[
    {
        "url":  "https://github.com/dotnet/runtime/issues/16827",
        "createdAt":  "2016-03-25T20:54:33Z",
        "number":  16827,
        "author":  "GSPP",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-04-29T15:54:22Z",
        "body":  "[Calling `Shutdown` on a `Socket` will cause it to become disconnected](https://github.com/dotnet/corefx/blob/master/src/System.Net.Sockets/src/System/Net/Sockets/Socket.cs#L4212) which is incorrect. This can cause, for example, `TcpClient.GetStream` to fail on a half-open socket.\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOMW8Bcw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIwMTQ5ODg2OA==",
                                           "createdAt":  "2016-03-25T20:59:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidsh",
                                           "body":  "What OS platform are you reproducing this bug?  Windows and/or *Nix?\n",
                                           "updatedAt":  "2016-03-25T20:59:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIwMTUwODIwNw==",
                                           "createdAt":  "2016-03-25T21:15:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "He\u0027s referring to code that\u0027s shared between them:\nhttps://github.com/dotnet/corefx/blob/master/src/System.Net.Sockets/src/System/Net/Sockets/Socket.cs#L4212\nand in the full framework:\nhttp://referencesource.microsoft.com/#System/net/System/Net/Sockets/Socket.cs,5681\n",
                                           "updatedAt":  "2016-03-25T21:15:31Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIwMTUyMDAzNQ==",
                                           "createdAt":  "2016-03-25T21:32:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidsh",
                                           "body":  "So, this is not a bug, but a request for a behavior change to how the current `Shutdown` method works on a `Socket`.  We would have to investigate that since it could break a lot of apps that depend on the current behavior.  it might be better long term to have another overload for `Shutdown` that has the different (new) behavior. That would require an API contract revision.\n",
                                           "updatedAt":  "2016-03-25T21:32:34Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIwMTUyNjI5Mw==",
                                           "createdAt":  "2016-03-25T21:42:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GSPP",
                                           "body":  "Some guy ran into this: http://stackoverflow.com/questions/36226535/half-closing-tcpclient I thought I\u0027d report it.\n\nI kind of doubt that someone depends on an exception being thrown here or on `Connected` returning false. This kind of problem is usually found during development because it seemingly breaks an otherwise working connection.\n\nAnd people shove their code around until they have worked around that bug (hopefully removing any `Connected` checks that they should not be doing anyway!). At least that\u0027s how most socket code arises judging by what my eyes have to see on Stack Overflow daily :)\n\nIndeed, the answer that was posted worked around the problem initially not realizing this is a bug. But people always notice so they don\u0027t depend on this behavior.\n",
                                           "updatedAt":  "2016-03-25T21:43:45Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIwMTUyOTEyNg==",
                                           "createdAt":  "2016-03-25T21:47:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GSPP",
                                           "body":  "Another question is whether `GetStream` should perform this check at all. Ideally, it would not and simply hand out the stream. The check does not accomplish anything since the condition can immediately become false right after checking. The check does not provide assurance. Rather, it provide a different and very rare non-deterministic failure mode for the same underlying cause. Also, this is a violation of separation of responsibilities. Again, I think nobody would depend on this behavior since a stream that is obtained through `GetStream` is usually being used right after that and a similar exception will occur.\n\nThe whole `GetStream` method is a design mistake. It should be an always working `Stream` property but this cannot be fixed now.\n",
                                           "updatedAt":  "2016-03-25T21:48:32Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIwMTUzNjcwMg==",
                                           "createdAt":  "2016-03-25T21:59:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidsh",
                                           "body":  "cc: @CIPop \n",
                                           "updatedAt":  "2016-03-25T21:59:06Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI0NDE4NjY3OA==",
                                           "createdAt":  "2016-09-01T19:31:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CIPop",
                                           "body":  "@GSPP thanks for reporting! \nAssigning to @himadrisarkar for triage / prioritization.\n",
                                           "updatedAt":  "2016-09-01T19:31:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI3ODc1MTQ1Mg==",
                                           "createdAt":  "2017-02-09T19:47:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "It looks like a reasonable thing to fix in .NET Core.\r\nWe will have to carefully review impact of the difference between platforms.\r\n\r\nQuestion: How painful it is today for customers? What is value? (number of customers)",
                                           "updatedAt":  "2019-09-10T21:28:31Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQxMjMyOTYwOQ==",
                                           "createdAt":  "2018-08-12T09:15:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GSPP",
                                           "body":  "Networking is a fundamental element of the .NET standard libraries. Especially with the world becoming more connected and distributed the core `Socket` API should be as reliable as possible. I\u0027d make the case to fix this. It does not seem like an expensive fix to take.",
                                           "updatedAt":  "2018-08-12T09:15:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTM1ODQ1MQ==",
                                           "createdAt":  "2021-04-29T15:54:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "It certainly seems weird that half-closing the socket sets it to disconnected, since it\u0027s *not* actually disconnected. Less clear to be if you shutdown both sides, since then you really are basically disconnected.\r\n\r\n\u003e Another question is whether GetStream should perform this check at all. Ideally, it would not and simply hand out the stream. The check does not accomplish anything since the condition can immediately become false right after checking. The check does not provide assurance. Rather, it provide a different and very rare non-deterministic failure mode for the same underlying cause. Also, this is a violation of separation of responsibilities. Again, I think nobody would depend on this behavior since a stream that is obtained through GetStream is usually being used right after that and a similar exception will occur.\r\n\r\nI agree with this. Seems like we should at least fix that part.",
                                           "updatedAt":  "2021-04-29T15:54:21Z"
                                       }
                                   ],
                         "totalCount":  10
                     },
        "title":  "Shutting down a Socket should not set it to disconnected",
        "labels":  [
                       "bug",
                       "area-System.Net.Sockets",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/17711",
        "createdAt":  "2016-06-27T15:04:41Z",
        "number":  17711,
        "author":  "GSPP",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCrOITg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "drewnoakes",
                                            "createdAt":  "2017-04-14T22:08:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "GSPP",
                                            "createdAt":  "2017-05-07T11:33:45Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "LHCGreg",
                                            "createdAt":  "2017-08-13T03:09:08Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ChristopherHaws",
                                            "createdAt":  "2018-04-24T17:41:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "felipepessoto",
                                            "createdAt":  "2018-11-07T01:44:19Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Thieum",
                                            "createdAt":  "2019-09-19T14:53:41Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "KrzysztofBranicki",
                                            "createdAt":  "2019-11-22T07:53:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "NN---",
                                            "createdAt":  "2019-11-24T16:49:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sgf",
                                            "createdAt":  "2020-08-04T05:12:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MaxDZ8",
                                            "createdAt":  "2021-01-17T15:33:34Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rdcm",
                                            "createdAt":  "2021-07-18T00:35:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Turnerj",
                                            "createdAt":  "2022-10-14T04:04:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "xsoheilalizadeh",
                                            "createdAt":  "2022-10-29T19:59:44Z"
                                        }
                                    ],
                          "totalCount":  13
                      },
        "updatedAt":  "2024-04-22T10:13:50Z",
        "body":  "Socket operations do not support timeouts sufficiently in the following cases:\n1. All async operations do not respect the configured timeout.\n2. `Connect` cannot be made to observe a timeout. I think there is no timeout for `Accept` either but that\u0027s usually an operation that is never supposed to time out.\n\nThe workarounds usually are quite nasty. For (1) people build their own (tedious and often flawed) timeouts. For (2) people often use an event plus an async IO. In case the timeout fires they close the socket. (This actually triggers [this unavoidable race condition resulting in an access violation!](https://github.com/dotnet/corefx/issues/5749#issuecomment-215597396))\n\nNote the amount of confusion that these problems cause: https://www.google.com/webhp?complete=1\u0026hl=en\u0026gws_rd=cr,ssl\u0026ei=#complete=1\u0026hl=en\u0026q=socket+beginreceive+timeout (I sometimes like to point to Google and Stack Overflow to show a nice sample of real-world user complaints. I have opened this ticket because I\u0027m repeatedly facing this issue as well.)\n\nI understand that the underlying Winsock (and now Linux) APIs make some of this hard. Since these issues are so widespread I believe it\u0027s worth the work to fix this at the managed code level (by implementing the timeouts and aborts in .NET code as opposed to making the native APIs do that).\n\nAs an open concern for (1) I see the question what happens to an IO that is cancelled at the managed level due to timeout or cancellation but still running at the native level. This can cause data to be discarded. The only clean way to solve this that I could find is to terminate the connection when a read or write ends up being cancelled. In my experience this matches perfectly with real world requirements. In case of a timeout usually the calling code backs out and just wants to shut everything down.\n\nTo summarize the ticket: Please add timeouts to all possibly blocking socket operations. Related ticket: [Allow the user to cancel anything at will (this is needed in addition to the timeout).](https://github.com/dotnet/corefx/issues/5749). Also related: [Add Task-based async methods which should take a `CancellationToken` _and_ observe the configured timeout.](https://github.com/dotnet/corefx/issues/9697)\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOWhX1Qg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIyODc5MjY0OQ==",
                                           "createdAt":  "2016-06-27T16:07:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GSPP",
                                           "body":  "I just found out that operating systems limit the _maximum_ timeout that is effectively supported. My Windows 7 uses at most 21 seconds and gives up. Web searches show that Linux has a different policy.\n\nTherefore, the connect timeout as per this ticket is to be understood as a maximum timeout. This needs to be documented should the feature be added.\n",
                                           "updatedAt":  "2016-06-27T16:07:06Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIyODgzNzkwNQ==",
                                           "createdAt":  "2016-06-27T18:45:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidsh",
                                           "body":  "cc: @CIPop @stephentoub \n",
                                           "updatedAt":  "2016-06-27T18:45:31Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI4MjEwMDI3MA==",
                                           "createdAt":  "2017-02-23T19:48:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "It may lead to new API proposal.\r\n\r\nNext steps:\r\n* Fully understand the ask above (it needs deeper reading),\r\n* Understand OS capabilities",
                                           "updatedAt":  "2017-02-23T19:48:52Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQxMjAwMTM2MQ==",
                                           "createdAt":  "2018-08-10T07:34:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "springy76",
                                           "body":  "Just my 2ct: When there will be finally a `CancellationToken` parameter, will this not automatically allow setting timeouts by using a self-cancelling `CancellationTokenSource` as such?:\r\n\r\n`new CancellationTokenSource(TimeSpan.FromSeconds(timeoutSeconds)).Token`\r\n\r\nIs this bad practice or problematic in other ways?",
                                           "updatedAt":  "2018-08-10T07:34:09Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQxMjMyODgwMA==",
                                           "createdAt":  "2018-08-12T08:58:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBctEWw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "MaxDZ8",
                                                                               "createdAt":  "2021-01-17T15:35:47Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "GSPP",
                                           "body":  "Once we have cancellation based on `CancellationToken` as proposed in the first ticket (https://github.com/dotnet/corefx/issues/5749 dd a clean way to cancel a long-running Socket operation (e.g. accept or connect)) implementing timeouts should be easier.\r\n\r\nThere is still a need to have timeouts directly supported. Pretty much any application needs to put a timeout on socket operations. I repeat here that all async operations do not respect any configured timeout at the moment.\r\n\r\nUnfortunately, there are already properties `int Socket.ReceiveTimeout` and `int Socket.SendTimeout`. They internally use `SetSocketOption` to make the OS implement the timeout. I read that sync socket IO is actually implemented in user mode around async kernel IO (on Windows). Then I assume that these timeouts are implemented there as well.\r\n\r\nFor compatibility reasons we cannot change the fact that async operations do not respect these properties. This means that we need a second way to specify a timeout.\r\n\r\nIt is also problematic, that these properties can only specify an integer number of seconds. Since we are touching these APIs anyway we should allow for more granular timeouts. In my opinion the framework should use `TimeSpan` for timeouts everywhere. But for consistency we might need use use `int milliseconds`. I\u0027m unsure about this. Below, I used `TimeSpan` to avoid units being ambiguous.\r\n\r\n`Shutdown` never blocks (https://docs.microsoft.com/en-us/windows/desktop/api/winsock/nf-winsock-shutdown) so there is no need to modify it.\r\n\r\n\u003chr\u003e\r\n\r\nAPI proposal:\r\n\r\nWe need these timeouts:\r\n\r\n* ReceiveTimeout\r\n* SendTimeout\r\n* ConnectTimeout\r\n* AcceptTimeout\r\n* DisconnectTimeout (also affects closing in my proposal)\r\n\r\nI propose adding these on an options object:\r\n\r\n```c#\r\nclass SocketTimeouts\r\n{ \r\n    public TimeSpan? ReceiveTimeout { get; set; }\r\n    public TimeSpan? SendTimeout { get; set; }\r\n    public TimeSpan? ConnectTimeout { get; set; }\r\n    public TimeSpan? AcceptTimeout { get; set; }\r\n    public TimeSpan? DiconnectTimeout { get; set; }\r\n}\r\n```\r\n\r\n`null` values are the default. In this case the behavior is exactly as before.\r\n\r\n`Socket` class:\r\n\r\n```c#\r\npublic SocketTimeouts Timeouts\r\n{\r\n get { return this.timeouts ?? (this.timeouts = new SocketTimeouts()); }\r\n set\r\n {\r\n  if (value == null) throw new ArgumentNullException();\r\n  this.timeouts = value;\r\n }\r\n}\r\n```\r\n\r\nThis object can be accessed and set as a whole as `Socket.Timeouts`. It is just a behaviorless DTO object. It is not owned by any socket so that this object can be allocated once by the application and reused. This makes this viable for low allocation scenarios.\r\n\r\nI would not touch `NetworkStream`, `TcpClient`, `TcpListener`, `UdpClient` and `UdpListener`. Timeouts can be set directly on the underlying socket.\r\n\r\nAlternatives:\r\n\r\n1. Add new timeout properties to `Socket` directly.\r\n2. Keep the existing `int` timeouts and add a property `bool UseTimeoutsForAsync` as a compatibility switch.\r\n3. Don\u0027t add properties but overloads on operations accepting `int` and `TimeSpan`. This does not work for receive and send, though, because specifying timeouts on each call to these functions is not realistic. Reads might exist inside of library code or happen through `NetworkStream`.",
                                           "updatedAt":  "2020-02-22T23:23:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQzMjY2NjM5MA==",
                                           "createdAt":  "2018-10-24T13:54:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GSPP",
                                           "body":  "Cancelling a `Connect` call by disposing the socket results in the following really scary message:\r\n\r\n\u003e An operation was attempted on something that is not a socket\r\n\r\nWith `SocketError.NotSocket`. This sounds like it might cause handle confusion problems destabilizing the entire process. If the `Socket` class had timeouts built-in this kind of nastiness would go away.\r\n",
                                           "updatedAt":  "2018-10-24T13:54:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5PbGHb",
                                           "createdAt":  "2022-11-30T17:26:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "triage: we should investigate option for `Connect`",
                                           "updatedAt":  "2022-11-30T17:26:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5aFBcm",
                                           "createdAt":  "2023-04-17T12:42:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mjanulaitis",
                                           "body":  "Wow this is still a bug in .Net 7.  I would have though MS would have removed the API in the .Net 7 release since it STILL doesn\u0027t work.  I just wasted my morning re-writing my blocking socket code to use the async methods only to find out it\u0027s busted after 7 years since the first report of it.  Ok I\u0027ll just delete the branch I wasted my morning creating.  I am specifically trying to shut down a TCP server that is stuck in an AcceptAsync.",
                                           "updatedAt":  "2023-04-17T12:42:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5aFKGl",
                                           "createdAt":  "2023-04-17T13:03:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e  I am specifically trying to shut down a TCP server that is stuck in an AcceptAsync.\r\n\r\nCan you share a repro? The cancellation token passed to AcceptAsync should enable it to be canceled. ",
                                           "updatedAt":  "2023-04-17T13:03:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5aFfVC",
                                           "createdAt":  "2023-04-17T13:48:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mjanulaitis",
                                           "body":  "@stephentoub I think possibly this has to do with me pressing Ctrl-C. I have a handler for the event then cancel the tasks, however currently it seems like the TPL just dumps tasks that are running rather than allowing the awaited methods to throw a cancellation event.  The debugger then hangs the app.  When I run without the debugger the process stops as expected.  I\u0027m still debugging now.",
                                           "updatedAt":  "2023-04-17T13:48:48Z"
                                       }
                                   ],
                         "totalCount":  10
                     },
        "title":  "Add reliable timeouts to socket operations",
        "labels":  [
                       "enhancement",
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/1476",
        "createdAt":  "2017-02-22T07:35:54Z",
        "number":  1476,
        "author":  "icylogic",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODC-3ZA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "JonHanna",
                                            "createdAt":  "2017-03-04T02:52:04Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Mygod",
                                            "createdAt":  "2017-05-11T16:31:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sgf",
                                            "createdAt":  "2018-10-22T06:43:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "enihcam",
                                            "createdAt":  "2018-12-07T10:50:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hexawyz",
                                            "createdAt":  "2019-04-23T18:55:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Exocomp",
                                            "createdAt":  "2019-07-18T03:59:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AndrewBoklashko",
                                            "createdAt":  "2020-03-15T14:08:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "neoayi",
                                            "createdAt":  "2021-03-12T05:16:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "GSPP",
                                            "createdAt":  "2022-01-20T13:14:21Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "shaan1337",
                                            "createdAt":  "2022-03-16T18:41:01Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "maximecaron",
                                            "createdAt":  "2022-09-06T21:26:19Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SergioLuis",
                                            "createdAt":  "2022-11-11T22:55:44Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "samsosa",
                                            "createdAt":  "2022-12-01T15:29:37Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "sgf",
                                            "createdAt":  "2023-03-10T20:21:52Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "alexkeh",
                                            "createdAt":  "2024-01-26T23:12:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "gkarabin",
                                            "createdAt":  "2024-06-06T02:38:31Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "alexkeh",
                                            "createdAt":  "2025-05-30T00:20:20Z"
                                        }
                                    ],
                          "totalCount":  17
                      },
        "updatedAt":  "2024-06-26T21:07:41Z",
        "body":  "## Proposal: TCP Fast Open\r\n\r\nTCP Fast Open is an extension for TCP to speed up the handshaking process in successive TCP connections. This feature has been available for OSX and Linux for years and was implemented on Windows by Anniversary Update. Users could check by `netsh`\r\n```\r\n\u003enetsh int tcp show global\r\nQuerying active state...\r\n\r\nTCP Global Parameters\r\n----------------------------------------------\r\n...\r\nTCP Fast Open                       : enabled\r\n```\r\nbut dotnet has not implemented this for System.Net yet.\r\n\r\n### Rational and Usage\r\n\r\nThis new API is important and powerful because when it is used with TLS False Start, we are down to 1-RTT from original 3-RTT for a successive TCP+TLS (HTTPS) connection, and furthermore, 0-RTT could be achieved by combining TFO and TLS 1.3.\r\n\r\nAnd it\u0027s easy to use: programmers only need to add a few lines to set an socket option and provide a buffer filled with data to send. Here\u0027s the usage:\r\n\r\n``` C#\r\nvar s = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\r\nvar e = new SocketAsyncEventArgs();\r\ns.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.FastOpen, true);\r\ne.SetBuffer(buffer, offset, length); \r\ns.ConnectAsync(e);\r\n```\r\n\r\nNote that  `buffer[offset]` ~ `buffer[offset+length-1]` might be (partially) sent together with SYN. It\u0027s up to the OS how to send.\r\n\r\nA typical usage is the TLS handshake. In successive connections, the client could send a SYN with TLS Client Hello.\r\n\r\nPlease check the \"Original Proposal\" for details.\r\n\r\n### Proposed API\r\n\r\n``` C#\r\nnamespace System.Net.Sockets\r\n{\r\n    // Defines socket option names for the \u003csee cref=\u0027System.Net.Sockets.Socket\u0027/\u003e class.\r\n    public enum SocketOptionName\r\n    {\r\n        // ...\r\n\r\n        #region SocketOptionLevel.Tcp\r\n        // ...\r\n        FastOpen = 15\r\n        #endregion\r\n\r\n    }\r\n}\r\n```\r\n\r\nThis enum value is 15 for Windows according to `ws2ipdef.h`.\r\n\r\n### Problems \u0026 Extra works\r\n\r\n- Implementation\r\n  In fact, adding just one line like the code above in [SocketOptionName.cs](https://github.com/dotnet/corefx/blob/bffef76f6af208e2042a2f27bc081ee908bb390b/src/System.Net.Sockets/src/System/Net/Sockets/SocketOptionName.cs) would work for Windows.\r\n  However, it might not work for Unix. Since dotnet simply pass the socket option to native API on Windows while the Unix Pal would check the value. For more information about the difference please check the relevant issue dotnet/corefx#14237 . To make this work for Unix we may need to modify [this part](https://github.com/dotnet/corefx/blob/master/src/Native/Unix/System.Native/pal_networking.cpp#L2103-L2113)\r\n\r\n- Compatibility\r\n  According to [MSDN](https://msdn.microsoft.com/en-us/library/windows/desktop/ms738596(v=vs.85).aspx), this option is available since Windows 10, 1607. Maybe we should generate a warning if this option is set on the older Windows platform\r\n\r\n- Other System.Net API\r\n  For API using sockets in its code such as WebClient or HttpClient, it could take advantage of this feature, especially for \"https://\" scheme.\r\n\r\n### Original Proposal\r\n\r\n#### TCP Fast Open on Windows\r\nWindows has introduced TCP Fast Open in the Anniversary Update serveral months ago. ([Announcing: New Transport Advancements in the Anniversary Update for Windows 10 and Windows Server 2016](https://blogs.technet.microsoft.com/networking/2016/07/18/announcing-new-transport-advancements-in-the-anniversary-update-for-windows-10-and-windows-server-2016/))\r\n\u003e TFO is one full Round Trip Time (RTT) faster than the standard TCP setup which requires a three way-handshake. This leads to latency savings and is very relevant to short web transfers over the Internet where the average latency is on the order of 40 msec.\r\n\r\n#### Native API for TCP Fast Open \r\nThis feature could be turned on using native Windows Socket 2 API: [IPPROTO_TCP Socket Options](https://msdn.microsoft.com/en-us/library/windows/desktop/ms738596(v=vs.85).aspx). But it has not been implemented in dotnet ([SocketOptionName.cs](https://github.com/dotnet/corefx/blob/bffef76f6af208e2042a2f27bc081ee908bb390b/src/System.Net.Sockets/src/System/Net/Sockets/SocketOptionName.cs)). \r\n\r\n#### dotnet API relating to TCP Fast Open\r\nAccording to the Native API Documentation, in addition to passing a new enum value to  the method `setSocketOption` which then calls the native `setsockopt`, we need to set up the buffer including the data to send during the initial connection:\r\n\u003eNote that to make use of fast opens, you should use ConnectEx to make the initial connection, and specify data in that function\u0027s lpSendBuffer parameter to be transferred during the handshake process. Some of the data in lpSendBuffer will be transferred under the Fast Open protocol.\r\n\r\nThe native method `ConnectEx` is called by  [`DoOperationConnect`](https://github.com/dotnet/corefx/blob/master/src/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncEventArgs.Windows.cs#L235) which is called by [`socket.ConnectAsync`](https://github.com/dotnet/corefx/blob/master/src/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncEventArgs.Windows.cs#L235) on Windows. And the buffer could be set as a property of SocketAsyncEventArgs.\r\n\r\n```C#\r\n//TFO is defined as 15 in ws2ipdef.h\r\nsocket.SetSocketOption(SocketOptionLevel.Tcp, (SocketOptionName)15, true);  \r\ne.SetBuffer(buffer, start, length);  //e is a SocketAsyncEventArgs\r\nsocket.ConnectAsync(e);\r\n```\r\n\r\n#### dotnet implementation\r\nThe most straightforward way to implement this feature is to add a new value to the SocketOptionName enum. But it enables this feature only on Windows. In this issue https://github.com/dotnet/corefx/issues/14237, it seems that members are interested in introducing a new cross-platform API for TCP options.\r\n\u003eIt would be nice if the Public API contained all of the possible socket options across Windows, Linux, and Darwin.\r\n\r\nPS. TCP Fast Open is natively supported on Linux and OSX. Here\u0027s how to use it on Linux: [TCP Fast Open: expediting web services](https://lwn.net/Articles/508865/)\r\n\r\nMore about TCP Fast Open:\r\n- [RFC7413](https://tools.ietf.org/html/rfc7413)\r\n- [Windows blog: Building a faster and more secure web with TCP Fast Open, TLS False Start, and TLS 1.3](https://blogs.windows.com/msedgedev/2016/06/15/building-a-faster-and-more-secure-web-with-tcp-fast-open-tls-false-start-and-tls-1-3/#0ODjLsVbVq2W3FyD.97)",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOgrDdag==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI4MzI2MDkwNg==",
                                           "createdAt":  "2017-03-01T06:57:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "I agree, we should do this.",
                                           "updatedAt":  "2017-03-01T06:57:34Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI4NDExNTY1NA==",
                                           "createdAt":  "2017-03-04T01:36:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Next step: We need [formal API proposal](https://github.com/dotnet/corefx/blob/master/Documentation/project-docs/api-review-process.md)",
                                           "updatedAt":  "2017-03-04T01:36:37Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI4NDEyMjgyMg==",
                                           "createdAt":  "2017-03-04T03:11:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "icylogic",
                                           "body":  "Glad you are interested in this API. I could follow the guideline to file a formal proposal so we can discuss details. Do I need to open a new issue like \"Proposal: TCP Fast Open\" or edit this issue?",
                                           "updatedAt":  "2017-03-04T03:11:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI4NDEyMzk3NQ==",
                                           "createdAt":  "2017-03-04T03:33:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Just edit this one. I often keep the original text in \"Original Proposal\" section or \"Details\" as GH doesn\u0027t version issue text.\r\nPing the issue whenever you update top post, summarizing the changes - it is easier to keep track of what happened.",
                                           "updatedAt":  "2017-03-04T03:33:43Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI4NDEzMTI2OA==",
                                           "createdAt":  "2017-03-04T06:15:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "icylogic",
                                           "body":  "Added a proposal including a short introduction, an example and some problems while leaving the original text unchanged in the section \"Original Proposal\"",
                                           "updatedAt":  "2017-03-04T06:15:53Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI4NDEzMjkxMg==",
                                           "createdAt":  "2017-03-04T06:54:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Sounds great, thank you!\r\n\r\nRe: Compatibility: What happens when you pass the flag on lower Windows version or Linux/OSX version which does not support it? Is it no op? Or failure?\r\n\r\n@geoffkizer @davidsh @CIPop @Priya91 any concerns/thumbs up? If I get 2 thumbs up, I can mark it as ready for API review on Tue.",
                                           "updatedAt":  "2017-03-04T06:54:52Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI4NDE4MTM5NA==",
                                           "createdAt":  "2017-03-04T21:14:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "I don\u0027t think we prevent you from passing arbitrary ints to SetSocketOption.  So something like this should work today:\r\n\r\n`            s.SetSocketOption(SocketOptionLevel.Tcp, (SocketOptionName)15, true);`",
                                           "updatedAt":  "2017-03-04T21:14:49Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI4NDE4MzMwMA==",
                                           "createdAt":  "2017-03-04T21:24:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "icylogic",
                                           "body":  "@geoffkizer Yes, it does work for Windows as I stated in the original proposal. So for Windows after Win10 1607, adding one line to the enum to formalize this API is enough. I\u0027m just not sure what will happen for Unix and Windows before 1607.",
                                           "updatedAt":  "2017-03-04T21:24:32Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI4NDE4NDE0MQ==",
                                           "createdAt":  "2017-03-04T21:31:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "My point is that we don\u0027t need to make any product change for users to do this today.\r\n\r\nIt might be nice to add the SocketOptionName for this, but that raises the question of whether and how we want to expose OS-specific socket options in SocketOptionName.",
                                           "updatedAt":  "2017-03-04T21:31:07Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI4NDE4NzE1Mw==",
                                           "createdAt":  "2017-03-04T21:58:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "icylogic",
                                           "body":  "OK, if we don\u0027t make any change, we can still use this feature on recent Windows. For programmers developing on other platforms which natively support TFO, they may need to wait for this issue https://github.com/dotnet/corefx/issues/14237#issuecomment-266035007 to be solved to use these socket options. It seems that corefx team is interested in introducing a new set of API.\r\nAnother issue is about other System.Net API, like WebClient or SslStream, which provide TLS connections and could obviously use this feature. If we don\u0027t want make any change to these API using this unexposed feature today, we could wait for TLS 1.3 to come out and make changes together.",
                                           "updatedAt":  "2017-03-04T21:58:10Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI4NDE4Nzk1Nw==",
                                           "createdAt":  "2017-03-04T22:03:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAHYlAg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "karelz",
                                                                               "createdAt":  "2017-03-05T02:26:15Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "I think we could certainly consider other APIs, e.g. some sort of way to enable this in a platform-neutral way.\r\n\r\nI\u0027m reacting to the \"Proposed API\" above, which proposes to add a Windows-specific enum value for FastOpen.  My point is that this is a convenience, not a necessity, since you can achieve the desired functionality by just passing (SocketOptionName)15.",
                                           "updatedAt":  "2017-03-04T22:03:36Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI4NDE4ODgxMQ==",
                                           "createdAt":  "2017-03-04T22:18:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "icylogic",
                                           "body":  "That makes sense. It\u0027s just the most direct way came to me but actually not a good way.\r\nMaybe we could expose some other APIs that does not take a platform-specific value and translate it in the PAL(Platform Adaptation Layer) like [this](https://github.com/dotnet/corefx/blob/master/src/Native/Unix/System.Native/pal_networking.cpp#L2103-L2113)",
                                           "updatedAt":  "2017-03-04T22:18:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI4NDU3ODk3OA==",
                                           "createdAt":  "2017-03-07T00:19:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "I think we should do two things:\r\n- Add the enum value and appropriately implement it on both Windows and Unix. I\u0027m not sure why the enum value is described as being specific to Windiws... on Unix we\u0027d translate it in the PAL into the right platform value as we do with all other options.\r\n- Add the ability to pass option names in a platform-specific way so that we have a workaround available in the future for other such options. While on Windows it would work to just cast the number to the enum, on Unix we go through a translation layer, so we\u0027d either misinterpret the value if it had an existing match in the enum, or we\u0027d throw for it if the value wasn\u0027t known, neither of which is right. We\u0027ve had a discussion of this in another issue, but I\u0027m on my phone and can\u0027t easily find it at the moment. Basically you want the ability to say \"pass this exact value to the OS, don\u0027t try to interpret/translate it\", and leave it up to the app to do the platform detection and determine the right value to use.",
                                           "updatedAt":  "2017-03-07T00:19:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI4NDU3OTgzMw==",
                                           "createdAt":  "2017-03-07T00:23:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "\u003e Add the enum value and appropriately implement it on both Windows and Unix. I\u0027m not sure why the enum value is described as being specific to Windiws... on Unix we\u0027d translate it in the PAL into the right platform value as we do with all other options.\r\n\r\nIs this something we want to continue to do, though?  I realize we did this for compat initially, but it seems like we could get into trouble here.  Would we be better off adding a \"bool FastOpen\" property on Socket, not unlike NoDelay?\r\n\r\n+1 to having a way to do platform-specific options names.\r\n",
                                           "updatedAt":  "2017-03-07T00:23:49Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI4NDU4MDQ5Mw==",
                                           "createdAt":  "2017-03-07T00:27:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e but it seems like we could get into trouble here\r\n\r\nCan you elaborate?",
                                           "updatedAt":  "2017-03-07T00:27:24Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI4NDU4MTk2OA==",
                                           "createdAt":  "2017-03-07T00:35:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCKxpiQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "GSPP",
                                                                               "createdAt":  "2022-01-20T13:17:47Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "Thinking about it more, I guess there\u0027s no actual trouble here; SetSocketOption is already essentially platform-agnostic and translated as appropriate for each platform. \r\n\r\nI guess the interesting question is: Is exposing stuff like this through SetSocketOptions the right API model?  We did this historically because it did in fact map directly to the Windows socket options.  Now that that\u0027s not true for Linux/etc, perhaps we should be moving towards a model where these things are exposed directly as properties.  At the very least, it might alleviate potential confusion around exactly what SetSocketOption does.",
                                           "updatedAt":  "2017-03-07T00:35:32Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI4NDU4MjUyMA==",
                                           "createdAt":  "2017-03-07T00:38:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "\u003e At the very least, it might alleviate potential confusion around exactly what SetSocketOption does.\r\n\r\nParticularly if we\u0027re adding something like \"SetRawSocketOption\" for platform-specific socket option acces.\r\n\r\nIt would be nice to say:\r\n(a) Platform-agnostic settings are exposed via easy to discover properties; they often map to socket options, but due to differences between platforms, we map these as appropriate\r\n(b) Platform-specific socket options are accessible through a new API(s); use at your own risk\r\n(c) SetSocketOptions is deprecated; use the properties from (a) instead\r\n\r\nThoughts?",
                                           "updatedAt":  "2017-03-07T00:38:53Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI4NDU5MDE3OA==",
                                           "createdAt":  "2017-03-07T01:20:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Achieving (c) would mean adding ~30 new members to Socket just for the existing named options, and then additional ones for additional names?\r\n\r\nFor (a), are there options that are relevant at multiple levels?  If so, those would need methods to take a level in addition to the value to set, along with a corresponding get method?\r\n\r\nI actually don\u0027t have a strong opinion about it, but the existing mechanism seems sufficient to me for the general case, and maps roughly to the APIs used on both Windows and Unix (get/setsockopt).  The idea of having all of the options available via the Get/SetSocketOption methods and then the most important ones for usability exposed individually as members makes some logical sense to me. My $.02.\r\n\r\nRegardless, SetRawSocketOption(int, ...) sounds good to me as the additional platform-specific-numerical-code-you-better-know-what-you\u0027re-doing-and-handle-platform-differences-yourself API.\r\n",
                                           "updatedAt":  "2017-03-07T01:20:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI4NDU5NTgxOA==",
                                           "createdAt":  "2017-03-07T01:51:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "Yeah, that does seem like a lot of new members.  \r\n\r\nThat said, I\u0027m not sure why it\u0027s better to expose these via an enum and a generic API.  Is it because the visibility of these things is reduced?  Does enum + generic API imply \"here be dragons\"?\r\n\r\nI realize that the value of doing this is low, given that we already have the enum and generic API.  We should add new stuff like FastOpen using the existing mechanism.  I\u0027m just trying to understand the principles here.",
                                           "updatedAt":  "2017-03-07T01:51:52Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI4NDYwNzE1NQ==",
                                           "createdAt":  "2017-03-07T03:00:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "icylogic",
                                           "body":  "\u003eWhile on Windows it would work to just cast the number to the enum, on Unix we go through a translation layer, so we\u0027d either misinterpret the value if it had an existing match in the enum, or we\u0027d throw for it if the value wasn\u0027t known, neither of which is right.  We\u0027ve had a discussion of this in another issue, but I\u0027m on my phone and can\u0027t easily find it at the moment.\r\n\r\n@stephentoub  Are you talking about [this issue](https://github.com/dotnet/corefx/issues/14237#issuecomment-265926068)? This is an example that we can\u0027t use some natively-supported socket options on Unix for now. Although we can do this on Windows.\r\n\r\nI\u0027ve mentioned this issue in the original proposal, since I\u0027m not sure whether the implementation of this feature should follow the current workaround. But I think it\u0027s the difference of underlying implementation that cause the different behavior of the same API.\r\n\r\nIf we want to achive two goals on both platforms: \r\n- Enable developers to use some \"unsafe\" native API with risks which they know they should take.\r\n- Provide safe-to-use public API which may miss some newest features but are guaranteed to be checked and will work if the check is passed.\r\n\r\nFor the first one,  SetRawSocketOption() for both Unix and Windows sounds good, and this method would work as what SetSocketOption does for Windows now: pass a raw value to native API.\r\n\r\nFor the second goal, SetSocketOption on Windows could be modified as: check the option value and generate `System.Net.Sockets.SocketException : Operation not supported` if needed,  just like what TCP_KEEPALIVE would encounter on Unix for now in the above issue. It just don\u0027t need the translation and call the SetRawSocketOption if the check is passed. By the way, this could also solve the compability issue of TCP_FASTOPEN on Windows before Win10 1607.\r\nI have to say that the second change would be a breaking change: If one used `SetSocketOption( some-raw-value-for-Windows-only )` for his code ( of course the code maybe only work for Windows), and this raw value is not included in the enum, this would generate an Exception.\r\nIf you think the second one is too aggressive, we could focus on SetRawSocketOption for now and I could draft this new proposal.",
                                           "updatedAt":  "2017-03-07T03:02:06Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI4NDYyMjMwNg==",
                                           "createdAt":  "2017-03-07T04:59:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "I can\u0027t tell... are we saying the same thing?  I\u0027m saying:\r\n- socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.FastOpen, true) does what you\u0027d expect: if sets the appropriate option on the underlying socket if supported, or throws an exception if it\u0027s not, as is the case with any other option you might try to set that may or may not be supported on a given OS.  How that happens in the code behind this is an implementation detail, and would just follow the established patterns in the codebase for how we do such things today.\r\n- socket.SetRawSocketOption is subject to the interpretation of the current OS, so you better call it with values specific to that OS, e.g. if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows) { socket.SetRawSocketOption(15, ...) } else if (RuntimeInformationIsOSPlatform(OSPlatform.Linux) { ... } else { ... } etc.",
                                           "updatedAt":  "2017-03-07T04:59:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI4NDYyOTE1NA==",
                                           "createdAt":  "2017-03-07T05:53:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "icylogic",
                                           "body":  "Sorry, I\u0027ve checked the source code again and found that although Windows PAL would not check the value before invoking native methods like Unix PAL, it will parse the error code returned from native API and throw exceptions. Then I have no questions about the original SetSocketOption.\r\n\r\nI agree that SetRawSocketOption should be used in this way. \r\n\r\nSo if we agree on adding SetRawSocketOption, I think the UNIX PAL may need to expose an API which does not check the option.\r\nIf my understanding is correct, we need either add a new method or modify this part:\r\n\r\n[SystemNative_SetSockOpt](https://github.com/dotnet/corefx/blob/master/src/Native/Unix/System.Native/pal_networking.cpp#L2211-L2269)\r\n```C#\r\nif (!TryGetPlatformSocketOption(socketOptionLevel, socketOptionName, optLevel, optName))\r\n// TryGetPlatformSocketOption checks options \r\n// and return false if it could not recognize them.\r\n{\r\n    return PAL_ENOTSUP;\r\n}\r\n```\r\nto something like\r\n```C#\r\nif ((!isRawSocketOption) \u0026\u0026 (!TryGetPlatformSocketOption(socketOptionLevel, socketOptionName, optLevel, optName)))\r\n// isRawSocketOption is a new parameter for SystemNative_SetSockOpt\r\n{\r\n    return PAL_ENOTSUP;\r\n}\r\n```\r\n\r\nAnd other corresponding changes in `SocketPal.Unix.cs` and `Socket.cs` (adding or overloading).\r\n",
                                           "updatedAt":  "2017-03-07T05:55:24Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI4NDcwNDY4OQ==",
                                           "createdAt":  "2017-03-07T12:10:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e So if we agree on adding SetRawSocketOption\r\n\r\nNew APIs need to follow the API review process outlined here:\r\nhttps://github.com/dotnet/corefx/blob/master/Documentation/project-docs/api-review-process.md\r\nA new issue should be opened for that.  I realize I may have caused confusion by raising it in this thread, but since it was related, I brought it up.  Now that we\u0027re on the same page, it\u0027d be good to have a separate issue for it and this issue can continue focusing on how to support TCP Fast Open in a cross-platform manner.\r\n\r\n\u003e I think the UNIX PAL may need to expose an API which does not check the option.\r\n\r\nCorrect.  But just to be clear, that\u0027s all implementation detail.  System.Native.so/dylib is all logically private to .NET Core, so adding new functions there is like adding a private member to a class; implementation detail that doesn\u0027t need to be discussed as part of public API design.",
                                           "updatedAt":  "2017-03-07T12:10:53Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4NTg5NjY3Nw==",
                                           "createdAt":  "2019-04-23T17:22:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "Added api request for SetRawSocketOption #865",
                                           "updatedAt":  "2020-05-05T23:10:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNzUyMTc0Mw==",
                                           "createdAt":  "2020-05-12T18:40:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "scalablecory",
                                           "body":  "The API as proposed seems reasonable to me. We will also need to update our Linux PAL to use `sendto` and MacOS PAL to use `connectx` when the caller supplies a buffer.",
                                           "updatedAt":  "2020-05-28T15:40:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyODczMzcxMg==",
                                           "createdAt":  "2020-05-14T16:06:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "scalablecory",
                                           "body":  "We should investigate usage in SocketsHttpHandler, at least TLS negotiation should get a boost. Need to find out how to plumb through SslStream.",
                                           "updatedAt":  "2020-05-14T16:06:48Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyODczNjAxOA==",
                                           "createdAt":  "2020-05-14T16:10:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "scalablecory",
                                           "body":  "Triage: I will look at OSX APIs to ensure it is something we can implement portably, then mark as ready for review.",
                                           "updatedAt":  "2020-05-14T16:10:55Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzOTAyNTI0Mg==",
                                           "createdAt":  "2020-06-04T18:22:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "terrajobst",
                                           "body":  "[Video](https://www.youtube.com/watch?v=H3obznO9_uo\u0026t=1h9m0s)\n\n* We need to decide wether we throw or whether we do a softwar fallback, but naming looks fine:\r\n\r\n```C#\r\nnamespace System.Net.Sockets\r\n{\r\n    public enum SocketOptionName\r\n    {\r\n        FastOpen = 15\r\n    }\r\n}\r\n```",
                                           "updatedAt":  "2020-06-04T19:07:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_YfGF",
                                           "createdAt":  "2022-03-09T21:21:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "deeprobin",
                                           "body":  "@terrajobst \r\n\r\nI think a software fallback would be useful.\r\nAs far as I know TCP_FASTOPEN is supported under Linux only from kernel version 3.6 on the client side and 3.7 on the server side. We should perhaps evaluate how to deal with features that do not work in older kernel versions elsewhere as a basis for decision making.\r\n\r\nHow this behaves under Windows I do not know just now.",
                                           "updatedAt":  "2022-03-09T21:21:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5F7NlI",
                                           "createdAt":  "2022-07-03T18:32:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sakno",
                                           "body":  "`SetRawSocketOption` is not enough. It seems like the socket at the client side must be configured properly. `sendto` requires to set `MSG_FASTOPEN`  flag when using with TFO. Thus, `SocketFlags` enum must be modified as well.",
                                           "updatedAt":  "2022-07-03T18:34:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5MroFI",
                                           "createdAt":  "2022-10-21T06:11:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "deeprobin",
                                           "body":  "\u003e `SetRawSocketOption` is not enough. It seems like the socket at the client side must be configured properly. `sendto` requires to set `MSG_FASTOPEN` flag when using with TFO. Thus, `SocketFlags` enum must be modified as well.\r\n\r\n@sakno\r\n\r\nI think that\u0027s a good point. This API needs a new review. Possibly with the following additional API:\r\n\r\n```cs\r\npublic partial enum SocketFlags {\r\n    FastOpen = 0x20000000, // or TcpFastOpenMessage?\r\n}\r\n```\r\n\r\n### libc Constant Reference: \r\n|constant|value|\r\n|-|-|\r\n|`TCP_FASTOPEN`|23|\r\n|`MSG_FASTOPEN`|0x20000000|\r\n\r\n---\r\n\r\nWe should also note that under Linux this may need to be explicitly enabled in `/proc/sys/net/ipv4/tcp_fastopen`.\r\nI do not know how we should proceed then in case it would not be enabled (due disabled in config / unsupported kernel version). Throw InvalidOperationException/NotSupportedException or just ignore it and not use TCP Fast Open?\r\n\r\n```sh\r\n# Disabled\r\necho \"0\"\u003e /proc/sys/net/ipv4/tcp_fastopen \r\n\r\n# Client-only\r\necho \"1\"\u003e /proc/sys/net/ipv4/tcp_fastopen \r\n\r\n# Server-only\r\necho \"2\"\u003e /proc/sys/net/ipv4/tcp_fastopen \r\n\r\n# full support\r\necho \"3\"\u003e /proc/sys/net/ipv4/tcp_fastopen \r\n```",
                                           "updatedAt":  "2022-10-21T06:11:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5PgDV3",
                                           "createdAt":  "2022-12-01T13:54:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "deeprobin",
                                           "body":  "pinging @karelz ",
                                           "updatedAt":  "2022-12-01T13:54:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5PgiiK",
                                           "createdAt":  "2022-12-01T15:21:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "@deeprobin is anything wrong with the usage proposed by the OP? The underlying Unix PAL (platform abstraction layer) could use a `sendto` syscall instead of `connect` in a transparent manner when `TcpFastOpen` is set and there is a buffer available on `SocketAsyncEventArgs`.\r\n\r\nUsing the managed `SendTo` / `ReceiveFrom` API-s directly comes with a big performance penalty today (see #30797), I wouldn\u0027t recommend it.",
                                           "updatedAt":  "2022-12-01T15:22:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5sMSBo",
                                           "createdAt":  "2023-11-16T19:14:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ScotMac",
                                           "body":  "So, what was the conclusion for this?\r\n\r\nThe SetSocketOption value pass-thru appears to work for turning on TFO. However, for the send/buffer, it appears that a new SocketFlag on the send was proposed, but not finalized?",
                                           "updatedAt":  "2023-11-16T19:14:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5sb0JG",
                                           "createdAt":  "2023-11-20T15:00:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "`MSG_FASTOPEN` is not cross-platform, so I would prefer looking for alternatives to the SocketFlag. For example, we could set `MSG_FASTOPEN` transparently, or use `TCP_FASTOPEN_CONNECT` (needs Linux 4.11+).\r\n\r\nSomeone needs to go and prototype this feature, ideally including it\u0027s usage by higher layers of the stack as https://github.com/dotnet/runtime/issues/1476#issuecomment-628733712 recommends.",
                                           "updatedAt":  "2023-11-20T15:00:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5tVgA5",
                                           "createdAt":  "2023-11-30T18:39:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ScotMac",
                                           "body":  "OK, so the MSG_FASTOPEN *also* works for the sendto? But only on certain platforms?  Can you provide the details please?",
                                           "updatedAt":  "2023-11-30T18:39:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5whUTp",
                                           "createdAt":  "2024-01-11T19:01:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ScotMac",
                                           "body":  "Can someone point me to how to use .NET to turn on TFO and send TFO data? Preferably in a platform independent manner. Is there some other issue that handles this?",
                                           "updatedAt":  "2024-01-11T19:01:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5xbLDB",
                                           "createdAt":  "2024-01-22T02:30:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ScotMac",
                                           "body":  "\u003e @deeprobin is anything wrong with the usage proposed by the OP? The underlying Unix PAL (platform abstraction layer) could use a `sendto` syscall instead of `connect` in a transparent manner when `TcpFastOpen` is set and there is a buffer available on `SocketAsyncEventArgs`.\r\n\u003e \r\n\u003e Using the managed `SendTo` / `ReceiveFrom` API-s directly comes with a big performance penalty today (see #30797), I wouldn\u0027t recommend it.\r\n\r\nThis seems to be a problem. ie, I don\u0027t believe you did the implementation the OP asked for, and the pass-thru implementation appears to have a big performance problem. Please look into doing the original proposal, where you handle the C native calls for sendto vs connect underneath the covers.",
                                           "updatedAt":  "2024-01-22T02:30:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5xkGpE",
                                           "createdAt":  "2024-01-23T04:52:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ScotMac",
                                           "body":  "OK, this is what i am doing, as a pass-thru to the C native API for SendTo (SetSockOpt does NOT appear to be needed):\r\n\r\nm_client.Client.SendTo(Encoding.ASCII.GetBytes(m_conOption.ConnectData), 0, m_conOption.ConnectData.Length, \r\n            (System.Net.Sockets.SocketFlags) 0x20000000, new IPEndPoint(addr, m_portNo));\r\n\r\nIs this the right approach?",
                                           "updatedAt":  "2024-01-23T04:52:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5xxuUO",
                                           "createdAt":  "2024-01-24T20:24:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ScotMac",
                                           "body":  "It appears that the \"pass-thru\" for the SendTo() is not supported (like it IS for the SetSockOpt(). When i try it, I get the following error:\r\n\r\n SE : System.Net.Sockets.SocketException (95): Operation not supported\r\n   at System.Net.Sockets.Socket.UpdateStatusAfterSocketErrorAndThrowException(SocketError error, String callerName)\r\n   at System.Net.Sockets.Socket.SendTo(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags, EndPoint remoteEP)\r\n   at OracleInternal.Network.TcpTransportAdapter.ConnectIterate()\r\n",
                                           "updatedAt":  "2024-01-24T20:33:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5xxv0e",
                                           "createdAt":  "2024-01-24T20:29:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ScotMac",
                                           "body":  "And from this issue:\r\n\r\nhttps://github.com/dotnet/runtime/issues/28706\r\n\r\nIt appears that Send/SendTo are  validating the flags, so no PASS-THRU flag is going to work.\r\n",
                                           "updatedAt":  "2024-01-24T20:29:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc54l-Uz",
                                           "createdAt":  "2024-03-27T16:30:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODcGEBA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "karelz",
                                                                               "createdAt":  "2024-03-27T16:36:35Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "While in #99490 we are planning to introduce this feature so customers can use it on their own risk, we must issue an important warning about its reliability:\r\n \r\nA non trivial percentage of middleboxes (routers, firewalls, proxies) in the open web will drop SYN packets containing TFO cookies. According to [this article](\r\nhttps://candrews.integralblue.com/2019/03/the-sad-story-of-tcp-fast-open), the ratio was 5% in 2019. This could lead to software bugs and failures that are very difficult to diagnose.\r\n \r\nWe consulted with the Windows networking team, and they confirmed that this concern is valid. It has prevented them from utilizing TFO as an enabled-by-default optimization in higher-level Windows components.\r\n \r\nIn practice, **TFO is only reliable in controlled networking environments**. This means that if an organization wants to optimize their solutions with TFO, they need full control over each firewall, router, and proxy on the network path between the client and the server. They need the rights and expertise to configure these middleboxes and they need to be committed to maintain the configuration. In my understanding this essentially excludes most cloud scenarios.\r\n \r\nAlso note that on Windows there is an aggressive TFO fallback mechanism that completely disables TFO globally until next restart when it detects problems with it. In my experiments I was never able to see a TFO cookie on a Windows system without first disabling this mechanism using `netsh int tcp set global fastopenfallback=disabled`. I assume there is a strong reason for the presence of this mechanism, and there is a risk that disabling it for one software may break other software on the same machine.",
                                           "updatedAt":  "2024-03-27T20:06:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc54l--2",
                                           "createdAt":  "2024-03-27T16:31:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODcGD_A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "karelz",
                                                                               "createdAt":  "2024-03-27T16:36:32Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "@ScotMac considering the problems described above, do you still find TFO useful for your scenario?",
                                           "updatedAt":  "2024-03-27T16:36:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc556qLp",
                                           "createdAt":  "2024-04-09T15:08:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "@ScotMac ping?",
                                           "updatedAt":  "2024-04-09T15:08:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc557B1V",
                                           "createdAt":  "2024-04-09T15:43:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "Note that the linked  https://github.com/dotnet/runtime/pull/99490 brings back the idea  @icylogic originally mentioned \r\n```c#\r\nvar s = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\r\nvar e = new SocketAsyncEventArgs();\r\ns.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.FastOpen, true);\r\ne.SetBuffer(buffer, offset, length); \r\ns.ConnectAsync(e);\r\n```\r\n\r\nThis fragment will now work across all platforms. On top of it, it adds the approved  `FastOpen` enum. When used in combination AND when TFO is actually enabled at OS level AND the TCP stack has proper cookies, part (or all of the provided) data will go it together with initial SYN. Otherwise it would just go out when TCP is established. \r\n\r\nWe don\u0027t plan to add more API at the moment but one can write simple extension. Perhaps something like \r\n```c#\r\ninternal static void Connect(this Socket socket, EndPoint ep, Memory\u003cbyte\u003e buffer, int timeout)\r\n{\r\n    var re = new ManualResetEventSlim();\r\n    var saea = new SocketAsyncEventArgs();\r\n    saea.SetBuffer(buffer);\r\n    saea.RemoteEndPoint = ep;\r\n    saea.Completed += (_, __) =\u003e re.Set();\r\n    if (!socket.ConnectAsync(saea))\r\n    {\r\n        re.Wait(timeout);\r\n    }\r\n}\r\n``` ",
                                           "updatedAt":  "2024-04-09T20:07:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc558sgV",
                                           "createdAt":  "2024-04-09T19:57:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODdmSXg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "karelz",
                                                                               "createdAt":  "2024-04-09T20:07:27Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "ScotMac",
                                           "body":  "We are discussing it internally. Thanks for the ping.",
                                           "updatedAt":  "2024-04-09T19:57:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56qcLV",
                                           "createdAt":  "2024-04-15T22:54:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ScotMac",
                                           "body":  "Based on the fact that we will have a good number of people using this within the cloud (not the public internet), we believe that 5% will not apply to us. And for a good number of those customers, the client will be on Linux.\r\n\r\nSo, yes, please continue w/ the implementation.",
                                           "updatedAt":  "2024-04-15T22:54:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6CsJGj",
                                           "createdAt":  "2024-06-26T20:53:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ScotMac",
                                           "body":  "@wfurt Hi Tomas, did your implementation make it into .NET 9 Preview 5? Is the new enum, specified here (SocketOptionName.FastOpen) implemented for your solution?",
                                           "updatedAt":  "2024-06-26T20:54:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6CsN1q",
                                           "createdAt":  "2024-06-26T21:07:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "no, it was submitted after the cutoff. It should be part of preview 6 - around Jul 9 . If you want to proceed on testing you can grab daily build: https://github.com/dotnet/sdk/blob/main/documentation/package-table.md",
                                           "updatedAt":  "2024-06-26T21:07:40Z"
                                       }
                                   ],
                         "totalCount":  49
                     },
        "title":  "TCP Fast Open implementation?",
        "labels":  [
                       "api-approved",
                       "area-System.Net.Sockets",
                       "os-windows",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/22225",
        "createdAt":  "2017-06-10T04:43:31Z",
        "number":  22225,
        "author":  "danmoseley",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-11-30T17:43:47Z",
        "body":  "## Types of failures\r\n\r\n```\r\nTimed out while waiting for connection\r\nExpected: True\r\nActual:   False\r\nat System.Net.Sockets.Tests.DualModeConnectAsync.DualModeConnectAsync_Static_DnsEndPointToHost_Helper(IPAddress listenOn, Boolean dualModeServer) in /root/corefx-1213655/src/System.Net.Sockets/tests/FunctionalTests/DualModeSocketTest.cs:line 610\r\n```\r\n\r\n## History of failures\r\n\r\nDay | Build | OS\r\n-- | -- | --\r\n2017/9/14 | 20170914.01 | OSX10.12\r\n2017/10/29 | 20171029.01 | OSX10.12\r\n2017/12/11 | 20171211.05 | Fedora25\r\n3/31 | 20180331.05 | OSX10.12\r\n\r\n\r\n# Original report\r\n\r\nhttps://ci.dot.net/job/dotnet_corefx/job/master/job/osx10.12_release_prtest/4505/consoleFull#18036880242d31e50d-1517-49fc-92b3-2ca637122019\r\n\r\n```     System.Net.Sockets.Tests.DualModeConnectAsync.DualModeConnectAsync_Static_DnsEndPointToHost_Helper(listenOn: 127.0.0.1, dualModeServer: False) [FAIL]\r\n19:07:03         Timed out while waiting for connection\r\n19:07:03         Expected: True\r\n19:07:03         Actual:   False\r\n19:07:03         Stack Trace:\r\n19:07:03   Using as the test runtime folder.\r\n19:07:03   ls: /cores: No such file or directory\r\n19:07:03   Running tests... Start time: 19:07:03\r\n19:07:03   Commands:\r\n19:07:03   python DumplingHelper.py install_dumpling\r\n19:07:03   __TIMESTAMP=`python DumplingHelper.py get_timestamp`\r\n19:07:03   chmod +x /Users/dotnet-bot/j/workspace/dotnet_corefx/master/osx10.12_release_prtest/bin/testhost/netcoreapp-OSX-Release-x64//dotnet\r\n19:07:03   /Users/dotnet-bot/j/workspace/dotnet_corefx/master/osx10.12_release_prtest/bin/testhost/netcoreapp-OSX-Release-x64//dotnet xunit.console.netcore.exe System.Text.Encoding.CodePages.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonosxtests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing\r\n19:07:03   python DumplingHelper.py collect_dump $\\ `pwd`  System.Text.Encoding.CodePages.Tests /Users/dotnet-bot/j/workspace/dotnet_corefx/master/osx10.12_release_prtest/bin/runtime/netcoreapp-OSX-Release-x64/,/Users/dotnet-bot/j/workspace/dotnet_corefx/master/osx10.12_release_prtest/bin/AnyOS.AnyCPU.Release/System.Text.Encoding.CodePages.Tests/netstandard/\r\n19:07:03   /Users/dotnet-bot/j/workspace/dotnet_corefx/master/osx10.12_release_prtest/bin/AnyOS.AnyCPU.Release/System.Text.Encoding.CodePages.Tests/netstandard /Users/dotnet-bot/j/workspace/dotnet_corefx/master/osx10.12_release_prtest/src/System.Text.Encoding.CodePages/tests\r\n19:07:03            /Users/dotnet-bot/j/workspace/dotnet_corefx/master/osx10.12_release_prtest/src/System.Net.Sockets/tests/FunctionalTests/DualModeSocketTest.cs(654,0): at System.Net.Sockets.Tests.DualModeConnectAsync.DualModeConnectAsync_Static_DnsEndPointToHost_Helper(IPAddress listenOn, Boolean dualModeServer)\r\n19:07:03      System.Net.Sockets.Tests.DualModeConnectionlessSendTo.SendToV4IPEndPointToV4Host_Success [FAIL]\r\n19:07:03         System.TimeoutException : The operation has timed out.\r\n19:07:03         Stack Trace:\r\n19:07:03            /Users/dotnet-bot/j/workspace/dotnet_corefx/master/osx10.12_release_prtest/src/System.Net.Sockets/tests/FunctionalTests/DualModeSocketTest.cs(1151,0): at System.Net.Sockets.Tests.DualModeConnectionlessSendTo.DualModeSendTo_IPEndPointToHost_Helper(IPAddress connectTo, IPAddress listenOn, Boolean dualModeServer, Boolean expectedToTimeout)\r\n19:07:03      System.Net.Sockets.Tests.DualModeConnectionlessBeginSendTo.BeginSendToV6IPEndPointToV6Host_Success [FAIL]\r\n19:07:03         System.TimeoutException : The operation has timed out.\r\n19:07:03         Stack Trace:\r\n19:07:03            /Users/dotnet-bot/j/workspace/dotnet_corefx/master/osx10.12_release_prtest/src/System.Net.Sockets/tests/FunctionalTests/DualModeSocketTest.cs(1252,0): at System.Net.Sockets.Tests.DualModeConnectionlessBeginSendTo.DualModeBeginSendTo_EndPointToHost_Helper(IPAddress connectTo, IPAddress listenOn, Boolean dualModeServer, Boolean expectedToTimeout)\r\n19:07:03   Using as the test runtime fold\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOT2yvWQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMyMzY3MjE0Mg==",
                                           "createdAt":  "2017-08-21T07:52:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KristinXie1",
                                           "body":  "failed again in CI: https://ci.dot.net/job/dotnet_corefx/job/master/job/outerloop_netcoreapp_win7_release/180/testReport/System.Net.Sockets.Tests/DualModeConnectAsync/DualModeConnectAsync_DnsEndPointToHost_Helper_listenOn____1__dualModeServer__False_/",
                                           "updatedAt":  "2017-08-21T07:52:04Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM1Njg1NDk3MA==",
                                           "createdAt":  "2018-01-11T07:57:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Sunny-pu",
                                           "body":  "failed again in CI:\r\nhttps://ci.dot.net/job/dotnet_corefx/job/master/job/outerloop_netcoreapp_windows_nt_release/271/testReport/System.Net.Sockets.Tests/DualModeConnectAsync/DualModeConnectAsync_DnsEndPointToHost_Helper_listenOn____1__dualModeServer__False_/",
                                           "updatedAt":  "2018-01-11T07:57:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQxMjY1OTQyOQ==",
                                           "createdAt":  "2018-08-13T20:50:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "This failed once in last four month (5/17) I\u0027m not sure if it is worth of keeping it open @karelz \r\n",
                                           "updatedAt":  "2018-08-13T20:50:34Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ1MjQ2NDMwOA==",
                                           "createdAt":  "2019-01-08T21:49:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "it did not fail in last three months. It seems like old intermittent infrastructure problem. ",
                                           "updatedAt":  "2019-01-08T21:49:36Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUxODgyODAxNg==",
                                           "createdAt":  "2019-08-06T20:19:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "Failed again, now flaky on UWP (or at least, failed once)\r\n```\r\n\r\nError message\r\nTimed out while waiting for connection\\r\\nExpected: True\\r\\nActual: False\r\n\r\nStack trace\r\n   at System.Net.Sockets.Tests.DualModeConnectAsync.DualModeConnectAsync_Static_DnsEndPointToHost_Helper(IPAddress listenOn, Boolean dualModeServer) in /_/src/System.Net.Sockets/tests/FunctionalTests/DualModeSocketTest.cs:line 613\r\n```",
                                           "updatedAt":  "2019-08-06T20:19:50Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyMTUwNDQwNQ==",
                                           "createdAt":  "2019-08-15T03:55:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ahsonkhan",
                                           "body":  "Failed again here https://github.com/dotnet/corefx/pull/40303 for `Windows Build UWP_CoreCLR_x64_Debug`:\r\nhttps://helix.dot.net/api/2019-06-17/jobs/21c7efa2-5a7f-49bf-9c9b-9f3d793613e3/workitems/System.Net.Sockets.Tests/console\r\n```text\r\nStarting:    System.Net.Sockets.Tests (parallel test collections = on, max threads = 2)\r\n    System.Net.Sockets.Tests.DualModeConnectAsync.DualModeConnectAsync_DnsEndPointToHost_Helper(listenOn: 127.0.0.1, dualModeServer: False) [FAIL]\r\n      Timed out while waiting for connection\r\n      Expected: True\r\n      Actual:   False\r\n      Stack Trace:\r\n        /_/src/System.Net.Sockets/tests/FunctionalTests/DualModeSocketTest.cs(588,0): at System.Net.Sockets.Tests.DualModeConnectAsync.DualModeConnectAsync_DnsEndPointToHost_Helper(IPAddress listenOn, Boolean dualModeServer)\r\n  Finished:    System.Net.Sockets.Tests\r\n```\r\n",
                                           "updatedAt":  "2019-08-15T03:55:49Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyMjgyMjA0NA==",
                                           "createdAt":  "2019-08-20T02:05:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AriNuer",
                                           "body":  "Test `System.Net.Sockets.Tests.DualModeConnectAsync.DualModeConnectAsync_Static_DnsEndPointToHost_Helper` failed again:\r\n```\r\n\r\nError message\r\nTimed out while waiting for connection\\r\\nExpected: True\\r\\nActual: False\r\n\r\nStack trace\r\n   at System.Net.Sockets.Tests.DualModeConnectAsync.DualModeConnectAsync_Static_DnsEndPointToHost_Helper(IPAddress listenOn, Boolean dualModeServer) in /_/src/System.Net.Sockets/tests/FunctionalTests/DualModeSocketTest.cs:line 613\r\n```\r\nDetails:\r\nhttps://dnceng.visualstudio.com/public/_build/results?buildId=316080\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=9143850\u0026resultId=148005\u0026paneView=debug",
                                           "updatedAt":  "2019-08-20T02:05:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyNzUyNDY2OA==",
                                           "createdAt":  "2019-09-03T16:01:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ViktorHofer",
                                           "body":  "Failed again but this time on netcoreapp: https://dnceng.visualstudio.com/public/_build/results?buildId=334906\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=9862974\u0026resultId=177921\u0026paneView=debug\r\n\r\nConfiguration: `netcoreapp-Windows_NT-Release-x86-Windows.10.Amd64.Client19H1.Open`\r\n\r\n```\r\nTimed out while waiting for connection\\r\\nExpected: True\\r\\nActual: False\r\n\r\n   at System.Net.Sockets.Tests.DualModeConnectAsync.DualModeConnectAsync_Static_DnsEndPointToHost_Helper(IPAddress listenOn, Boolean dualModeServer) in /_/src/System.Net.Sockets/tests/FunctionalTests/DualModeSocketTest.cs:line 614\r\n```",
                                           "updatedAt":  "2019-09-03T16:01:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUzMjg5NDcyMQ==",
                                           "createdAt":  "2019-09-18T22:42:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ViktorHofer",
                                           "body":  "Happened again: https://dnceng.visualstudio.com/public/_build/results?buildId=358741\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=10867932\u0026resultId=176327\u0026paneView=debug\r\n\r\n@davidsh any recommendation? seems to feel frequently enough to take a look.",
                                           "updatedAt":  "2019-09-18T22:42:53Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUzMjkwMDAyNw==",
                                           "createdAt":  "2019-09-18T23:05:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidsh",
                                           "body":  "@ViktorHofer \r\n\r\n\u003eHappened again: https://dnceng.visualstudio.com/public/_build/results?buildId=358741\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=10867932\u0026resultId=176327\u0026paneView=debug\r\n\r\nThis is a disabled-test.  How can it happen again?",
                                           "updatedAt":  "2019-09-18T23:05:52Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUzMjkwMzExNg==",
                                           "createdAt":  "2019-09-18T23:20:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "It is disabled on UWP but I\u0027m not sure if the run was. It seems like 32bit windows from brief look.",
                                           "updatedAt":  "2019-09-18T23:20:04Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUzMjkwMzMxMA==",
                                           "createdAt":  "2019-09-18T23:20:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidsh",
                                           "body":  "@wfurt Can you take a look?",
                                           "updatedAt":  "2019-09-18T23:20:58Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUzMjk4NzAzNA==",
                                           "createdAt":  "2019-09-19T06:29:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "I can check if I can reproduce it locally. If not, we will need some way how to re-create CI environment. ",
                                           "updatedAt":  "2019-09-19T06:29:13Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUzNTYxMzk2Nw==",
                                           "createdAt":  "2019-09-26T17:47:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ViktorHofer",
                                           "body":  "This happened again on `netcoreapp-Windows_NT-Release-x86-Windows.10.Amd64.Client19H1.Open`: https://dnceng.visualstudio.com/public/_build/results?buildId=367004\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=11106936\u0026paneView=debug\r\n\r\nCan somebody please take another look? RetryHelper / LoopbackServer might help here?",
                                           "updatedAt":  "2019-09-26T17:47:02Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUzNzA4OTQxMA==",
                                           "createdAt":  "2019-10-01T15:24:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ViktorHofer",
                                           "body":  "cc @davidsh @wfurt @eiriktsarpalis happened again in master: https://dnceng.visualstudio.com/public/_build/results?buildId=371143\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=11295054\u0026resultId=176777\u0026paneView=debug\r\n\r\nConfiguration: `netcoreapp-Windows_NT-Release-x86-Windows.10.Amd64.Client19H1.Open`\r\n\r\n```\r\nTimed out while waiting for connection\\r\\nExpected: True\\r\\nActual: False\r\n\r\n   at System.Net.Sockets.Tests.DualModeConnectAsync.DualModeConnectAsync_Static_DnsEndPointToHost_Helper(IPAddress listenOn, Boolean dualModeServer) in /_/src/System.Net.Sockets/tests/FunctionalTests/DualModeSocketTest.cs:line 614\r\n```",
                                           "updatedAt":  "2019-10-01T15:24:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU0MjI5MDU5Mw==",
                                           "createdAt":  "2019-10-15T16:12:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ViktorHofer",
                                           "body":  "Any idea why `DualModeConnectAsync_Static_DnsEndPointToHost_Helper` is timing out so often?",
                                           "updatedAt":  "2019-10-15T16:12:21Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU0MzI4NjY5NA==",
                                           "createdAt":  "2019-10-17T17:46:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidsh",
                                           "body":  "This issue was specific to the UAP implementation of the networking stack which had a different implementation for things like HTTP and WebSockets.\r\n\r\nAs of PR dotnet/corefx#41759, we no longer build the separate implementation for the UAP platform. So, this issue can\u0027t occur anymore with .NET 5 because we now will be using the same .NET Core implementation as on Windows, Linux, Mac.\r\n",
                                           "updatedAt":  "2019-10-17T17:46:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU0MzM2Mjg0MA==",
                                           "createdAt":  "2019-10-17T21:09:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ViktorHofer",
                                           "body":  "David this was failing on netcoreapp: https://dnceng.visualstudio.com/public/_build/results?buildId=390088\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=12095578\u0026resultId=178765\u0026paneView=debug",
                                           "updatedAt":  "2019-10-17T21:09:06Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU0MzM2Mzc5Ng==",
                                           "createdAt":  "2019-10-17T21:11:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidsh",
                                           "body":  "@wfurt Another test failure in Sockets to investigate.",
                                           "updatedAt":  "2019-10-17T21:11:56Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1MTg1NjkwMQ==",
                                           "createdAt":  "2021-06-01T06:28:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "VincentBu",
                                           "body":  "Similar test failed in [runtime-libraries-coreclr outerloop 20210531.3](https://dev.azure.com/dnceng/public/_build/results?buildId=1164140\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=35096686\u0026resultId=103025\u0026paneView=debug)\r\n\r\nFailed test:\r\n```\r\nnet6.0-Linux-Release-arm-CoreCLR_release-(Debian.9.Arm32.Open)Ubuntu.1804.ArmArch.Open@mcr.microsoft.com/dotnet-buildtools/prereqs:debian-9-helix-arm32v7-bfcd90a-20200121150037\r\n\r\n- System.Net.Sockets.Tests.DualModeConnectionlessReceiveFromAsync.ReceiveFromAsyncV6BoundToAnyV6_Success\r\n\r\n```\r\n\r\n**Error message:**\r\n```\r\nSystem.TimeoutException : The operation has timed out.\r\n\r\n\r\nStack trace\r\n   at System.Net.Sockets.Tests.DualModeConnectionlessReceiveFromAsync.ReceiveFromAsync_Helper(IPAddress listenOn, IPAddress connectTo, Boolean expectedToTimeout) in /_/src/libraries/System.Net.Sockets/tests/FunctionalTests/DualModeSocketTest.cs:line 1764\r\n   at System.Net.Sockets.Tests.DualModeConnectionlessReceiveFromAsync.ReceiveFromAsyncV6BoundToAnyV6_Success() in /_/src/libraries/System.Net.Sockets/tests/FunctionalTests/DualModeSocketTest.cs:line 1706\r\n```",
                                           "updatedAt":  "2021-06-01T06:28:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5PbK9Z",
                                           "createdAt":  "2022-11-30T17:43:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "triage: this is essentially dup of #1481. We should make DualMode  tests more reliable. ",
                                           "updatedAt":  "2022-11-30T17:43:46Z"
                                       }
                                   ],
                         "totalCount":  21
                     },
        "title":  "Test failure: System.Net.Sockets.Tests.DualModeConnectAsync / DualModeConnectAsync_Static_DnsEndPointToHost_Helper",
        "labels":  [
                       "area-System.Net.Sockets",
                       "disabled-test",
                       "test-bug",
                       "test-run-core"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/24340",
        "createdAt":  "2017-12-04T21:30:56Z",
        "number":  24340,
        "author":  "pepone",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-07-15T20:19:33Z",
        "body":  "setsockopt with IP_MULTICAST_IF value should be a struct in_addr\r\n\r\nSee\r\nhttps://github.com/dotnet/corefx/blob/9a563e12649a5f407d57605dc07a82637a22ef48/src/Native/Unix/System.Native/pal_networking.c#L2172\r\n\r\nThis is call from\r\nhttps://github.com/dotnet/corefx/blob/8f8b04afb41156aba5530992e3ed062d8bfad611/src/System.Net.Sockets/src/System/Net/Sockets/SocketPal.Unix.cs#L1135\r\n\r\nSo far seems to me we are just passing an interface index as an integer when linux setsockopt expects and in_addr struct\r\n\r\n[EDIT] Link the source code (don\u0027t reference master) by @karelz",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHORq8RdQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM0OTExMjcxOA==",
                                           "createdAt":  "2017-12-04T21:32:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidsh",
                                           "body":  "cc: @wfurt ",
                                           "updatedAt":  "2017-12-04T21:32:11Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM0OTE4ODkyMw==",
                                           "createdAt":  "2017-12-05T04:04:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "cc: @tmds",
                                           "updatedAt":  "2017-12-05T04:04:06Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM0OTIxNDg5MA==",
                                           "createdAt":  "2017-12-05T07:03:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "I\u0027m not sure I undersatnd this @pepone \r\n\r\nIf you look at the lines above:\r\n\r\n           else if (optionLevel == SocketOptionLevel.IP)\r\n            {\r\n                if (optionName == SocketOptionName.MulticastInterface)\r\n                {\r\n\r\n...\r\n                  err =Interop.Sys.SetIPv4MulticastOption(handle,Interop.Sys.MulticastOption.MULTICAST_IF, \u0026opt);\r\n\r\nThat seems correct. Rest simply assumes int value as a fallback. ",
                                           "updatedAt":  "2017-12-05T07:03:53Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM0OTIyNjU4Mw==",
                                           "createdAt":  "2017-12-05T08:05:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "`struct in_addr` is a 4 byte value that represents an IPv4 address. So `struct in_addr` and `int` have the same size.\r\nOn Windows and Unix, this int represents is the IP address of the interface.\r\nOn Windows, when the IP address is a 0.x.x.x then it is interpreted as an interface index.\r\nOn Unix, this is not the case. To specify an interface index, you need to use `ip_mreq`. This is not supported on Windows.\r\nThis case is detected in corefx code and converted to the `ip_mreq`:\r\n\r\nhttps://github.com/dotnet/corefx/blob/7caa95537499c06a96318403a7a87d8201c24de5/src/System.Net.Sockets/src/System/Net/Sockets/SocketPal.Unix.cs#L1117-L1130\r\n\r\nThe xplat way to set the multicast interface to an index is:\r\n```C#\r\nSetSocketOption(SocketOptionLevel.IP, SocketOptionName.MulticastInterface, IPAddress.HostToNetworkOrder(interfaceIndex))\r\n```",
                                           "updatedAt":  "2017-12-05T08:05:13Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM0OTIzMTc2MA==",
                                           "createdAt":  "2017-12-05T08:29:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pepone",
                                           "body":  "I see so far that doesn\u0027t seems to work with OS X, with interface index 1 (loopback), my test for this is quite similar to the one in corefx that is currently only run on Windows\r\n\r\n```c#\r\nusing System;\r\nusing System.Diagnostics;\r\nusing System.Text;\r\nusing System.Net;\r\nusing System.Net.Sockets;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace multicast\r\n{\r\n    class Program\r\n    {\r\n        // Create an Udp Socket and binds it to an available port\r\n        private static Socket CreateBoundUdpSocket(out int localPort)\r\n        {\r\n            Socket receiveSocket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);\r\n\r\n            // sending a message will bind the socket to an available port\r\n            string sendMessage = \"dummy message\";\r\n            int port = 54320;\r\n            IPAddress multicastAddress = IPAddress.Parse(\"239.255.1.1\");\r\n            receiveSocket.SendTo(Encoding.UTF8.GetBytes(sendMessage), new IPEndPoint(multicastAddress, port));\r\n\r\n            localPort = (receiveSocket.LocalEndPoint as IPEndPoint).Port;\r\n            Console.WriteLine(\"CreateBoundUdpSocket port: {0}\", localPort);\r\n            return receiveSocket;\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            Task.Run(async () =\u003e\r\n                    {\r\n                        try\r\n                        {\r\n                            int interfaceIndex = 1;\r\n                            IPAddress multicastAddress = IPAddress.Parse(\"239.255.1.1\");\r\n                            string message = \"hello\";\r\n                            int port;\r\n\r\n                            using (Socket receiveSocket = CreateBoundUdpSocket(out port),\r\n                                   sendSocket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp))\r\n                            {\r\n                                receiveSocket.ReceiveTimeout = 1000;\r\n                                receiveSocket.SetSocketOption(SocketOptionLevel.IP, SocketOptionName.AddMembership, new MulticastOption(multicastAddress, interfaceIndex));\r\n\r\n                                sendSocket.SetSocketOption(SocketOptionLevel.IP, SocketOptionName.MulticastInterface, IPAddress.HostToNetworkOrder(interfaceIndex));\r\n\r\n                                var receiveBuffer = new byte[1024];\r\n                                var receiveTask = receiveSocket.ReceiveAsync(new ArraySegment\u003cbyte\u003e(receiveBuffer), SocketFlags.None);\r\n\r\n                                sendSocket.SendTo(Encoding.UTF8.GetBytes(message), new IPEndPoint(multicastAddress, port));\r\n                                var cts = new CancellationTokenSource();\r\n                                if(await Task.WhenAny(receiveTask, Task.Delay(10000, cts.Token)) == receiveTask)\r\n                                {\r\n                                    cts.Cancel();\r\n                                    int bytesReceived = receiveTask.Result;\r\n                                    string receivedMessage = Encoding.UTF8.GetString(receiveBuffer, 0, bytesReceived);\r\n                                    if(receivedMessage.Equals(message))\r\n                                    {\r\n                                        Console.WriteLine(\"message received\");\r\n                                    }\r\n                                }\r\n                                else\r\n                                {\r\n                                    Console.WriteLine(\"Waiting for received data timed out\");\r\n                                }\r\n                            }\r\n                        }\r\n                        catch(Exception ex)\r\n                        {\r\n                            Console.WriteLine(ex);\r\n                        }\r\n                    }).Wait();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n[EDIT] Add syntax highlighting by @karelz",
                                           "updatedAt":  "2017-12-05T16:55:14Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM0OTIzMzA2MA==",
                                           "createdAt":  "2017-12-05T08:35:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "On my Linux machine:\r\n```\r\n/tmp/console$ dotnet run\r\nCreateBoundUdpSocket port: 49496\r\nmessage received\r\n```\r\nWhat do you get?",
                                           "updatedAt":  "2017-12-05T08:35:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM0OTIzMzQzMw==",
                                           "createdAt":  "2017-12-05T08:36:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pepone",
                                           "body":  "```$ cd multicast/\r\nair:multicast jose$ dotnet run\r\nCreateBoundUdpSocket port: 62594\r\nWaiting for received data timed out\r\n```",
                                           "updatedAt":  "2017-12-05T08:36:51Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM0OTIzODU3OQ==",
                                           "createdAt":  "2017-12-05T08:58:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "So the test doesn\u0027t fail when setting the socket option, nor does it fail when sending the packet.\r\nMaybe it gets eaten by the firewall.\r\nDoes the test work for interfaceIndex = 0? Is there a non-zero interfaceIndex that makes it work (e.g. default network interface)?",
                                           "updatedAt":  "2017-12-05T08:58:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM0OTI1MDUyMw==",
                                           "createdAt":  "2017-12-05T09:44:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pepone",
                                           "body":  "```\r\nWorks with 0 default\r\nTimeout with 1\r\n```\r\nOn same OS X machine have a C++ test using IP_MULTICAST_IF with in_addr 0x100007F (127.0.0.1) and it works \r\n\r\nand in this machine `NetworkInterface.LoopbackInterfaceIndex` is 1\r\n\r\n",
                                           "updatedAt":  "2017-12-05T09:44:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM0OTI1NTM3NA==",
                                           "createdAt":  "2017-12-05T10:02:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "\u003e On same OS X machine have a C++ test using IP_MULTICAST_IF with in_addr 0x100007F (127.0.0.1) and it works\r\n\r\nThat is specifying the multicast interface as an IP Address. The equivalent C# is:\r\n```\r\nsendSocket.SetSocketOption(SocketOptionLevel.IP, SocketOptionName.MulticastInterface, (int)IPAddress.Loopback.Address);\r\n```\r\n\r\nIs there a non-zero interfaceIndex (different from `1` loopback) that works? e.g. the default network interface?",
                                           "updatedAt":  "2017-12-05T10:02:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM0OTI2MzU3Mw==",
                                           "createdAt":  "2017-12-05T10:33:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pepone",
                                           "body":  "\u003eIs there a non-zero interfaceIndex (different from 1 loopback) that works? e.g. the default network interface?\r\n\r\nYes index 7 interface en0 works\r\n\r\nIt also works if I update the code to \r\n\r\n```\r\nreceiveSocket.SetSocketOption(SocketOptionLevel.IP, \r\n    SocketOptionName.AddMembership, \r\n    new MulticastOption(multicastAddress, IPAddress.Parse(\"127.0.0.1\")));\r\n\r\nsendSocket.SetSocketOption(SocketOptionLevel.IP, \r\n    SocketOptionName.MulticastInterface, \r\n    (int)IPAddress.Loopback.Address);\r\n```\r\n\r\nIsn\u0027t clear to me why this work and index 1 does not, aren\u0027t both cases essentially doing the same picking loopback interface to send the multicast requests?",
                                           "updatedAt":  "2017-12-05T10:33:49Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM0OTI3MDk1Ng==",
                                           "createdAt":  "2017-12-05T11:03:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "The difference between\r\n```\r\nSetSocketOption(SocketOptionLevel.IP, SocketOptionName.MulticastInterface, IPAddress.HostToNetworkOrder(1))\r\n```\r\nand\r\n```\r\nSetSocketOption(SocketOptionLevel.IP, SocketOptionName.MulticastInterface, (int)IPAddress.Loopback.Address);\r\n```\r\nis the latter is more strict. Perhaps the firewall comes into play here? Can you see how the test behaves when you turn off your firewall?",
                                           "updatedAt":  "2017-12-05T11:03:04Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM0OTI3Mjg0MA==",
                                           "createdAt":  "2017-12-05T11:10:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pepone",
                                           "body":  "Firewall is off with all this tests",
                                           "updatedAt":  "2017-12-05T11:10:44Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM0OTI4MDY3Nw==",
                                           "createdAt":  "2017-12-05T11:45:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "Looking back in history, it seems this has never worked on Mac Loopback: https://github.com/dotnet/corefx/pull/6523#issuecomment-194018529\r\n\r\n\u003e  The test passes on my Mac if I use a different interface index. Index 1 is \"loopback,\" as expected, but I only receive the packets if I send them from interface 4 (\"en0\").\r\n\r\nBased on what we learned, maybe you can update the title of the issue to `MulticastInterface set to loopback index does not work on OSX`?\r\n\r\nAs a workaround, we know that this does work:\r\n\r\n```\r\nSetSocketOption(SocketOptionLevel.IP, SocketOptionName.MulticastInterface, (int)IPAddress.Loopback.Address);\r\n```\r\n\r\nI can\u0027t debug this further (no mac).",
                                           "updatedAt":  "2017-12-05T11:45:29Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUzMDExMDk4OQ==",
                                           "createdAt":  "2019-09-10T20:42:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Next step: Try the code in C on Mac to see if we can make it work.",
                                           "updatedAt":  "2019-09-10T20:42:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GrxF1",
                                           "createdAt":  "2022-07-15T20:13:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MattYoung50",
                                           "body":  "Localhost does work for me following @pepone\u0027s last update. However if I want to make the receiver socket bind to a specific listener port, it does not work.\r\n\r\n```csharp\r\n// Create an Udp Socket and binds it to an available port\r\nprivate static Socket CreateBoundUdpSocket(out int localPort)\r\n{\r\n      Socket receiveSocket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);\r\n  \r\n      // sending a message will bind the socket to an available port\r\n      string sendMessage = \"dummy message\";\r\n      int port = 54320;\r\n      IPAddress multicastAddress = IPAddress.Parse(\"239.255.1.1\");\r\n  \r\n      receiveSocket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);\r\n      receiveSocket.Bind(new IPEndPoint(IPAddress.Parse(\"127.0.0.1\"), 51017));\r\n      //receiveSocket.SendTo(Encoding.UTF8.GetBytes(sendMessage), new IPEndPoint(multicastAddress, port));\r\n  \r\n      localPort = (receiveSocket.LocalEndPoint as IPEndPoint).Port;\r\n      Console.WriteLine(\"CreateBoundUdpSocket port: {0}\", localPort);\r\n      return receiveSocket;\r\n}\r\n```\r\n\r\n```bash\r\nmyoung-MC2:UdpSender myoung50$ dotnet run\r\nCreateBoundUdpSocket port: 51017\r\nWaiting for received data timed out\r\n```\r\n\r\nAny updates on this or suggestions to resolve this would be much appreciated. My application must bind and listen to a multicast group on a specific port.",
                                           "updatedAt":  "2022-07-15T20:19:33Z"
                                       }
                                   ],
                         "totalCount":  16
                     },
        "title":  "MulticastInterface set to loopback index does not work on OSX",
        "labels":  [
                       "bug",
                       "area-System.Net.Sockets",
                       "os-mac-os-x",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/26189",
        "createdAt":  "2018-05-16T17:15:32Z",
        "number":  26189,
        "author":  "rmkerr",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-11-07T13:59:07Z",
        "body":  "The recently added test ConcurrentSendReceive has failed in official runs with the following error 1-2 times a day for the last three days:\r\n```\r\nSystem.TimeoutException : WhenAllOrAnyFailed timed out after 10000\r\n   at System.Threading.Tasks.TaskTimeoutExtensions.WhenAllOrAnyFailed(Task[] tasks, Int32 millisecondsTimeout)\r\n   at System.Net.Sockets.Tests.UnixDomainSocketTest.ConcurrentSendReceive(Boolean forceNonBlocking) in E:\\A\\_work\\2\\s\\corefx\\src\\System.Net.Sockets\\tests\\FunctionalTests\\UnixDomainSocketTest.netcoreapp.cs:line 284\r\n--- End of stack trace from previous location where exception was thrown ---\r\n```\r\nThe failures occur for both the blocking and non-blocking case, and has occurred exclusively on the Windows.10.Amd64.ClientRS4 leg.\r\n\r\nI\u0027m not sure if that means Unix domain sockets are not enabled in RS4, if there is some config that needs to happen on that machine, or if there is a real bug here.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOksPbdA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM4OTcwMTA0Mg==",
                                           "createdAt":  "2018-05-16T23:51:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "@rmkerr, you said it\u0027s failing 1-2 times a day, but it\u0027s not clear to me: is that all of the RS4 runs, or are there runs where it succeeds and it\u0027s just failing sporadically?\r\n\r\n\u003e I\u0027m not sure if that means Unix domain sockets are not enabled in RS4\r\n\r\nRS4 is the first released version of Windows where they _are_ supported.",
                                           "updatedAt":  "2018-05-16T23:51:33Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM4OTkyNzIyNw==",
                                           "createdAt":  "2018-05-17T16:27:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rmkerr",
                                           "body":  "It\u0027s failing sporadically. The test has been run 24 times over the last four days, with six failures. It doesn\u0027t look like a configuration issue, since sometimes only one of the two cases will fail. ",
                                           "updatedAt":  "2018-05-17T16:27:07Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM4OTkyNzYwNw==",
                                           "createdAt":  "2018-05-17T16:28:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "And it\u0027s just that one test (ConcurrentSendReceive), right?  The others are all fine?",
                                           "updatedAt":  "2018-05-17T16:28:15Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM4OTkyODY1Nw==",
                                           "createdAt":  "2018-05-17T16:31:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "And you mentioned \"official runs\"... what about PRs?  It\u0027s an inner loop test, so it should be running now as part of every PR.  Has it failed there?",
                                           "updatedAt":  "2018-05-17T16:31:28Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM4OTkyODgxNw==",
                                           "createdAt":  "2018-05-17T16:31:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rmkerr",
                                           "body":  "Looking into it now. It looks like ConcurrentSendRecieveAsync has one failure on the 15th. I\u0027ll check PRs as well.",
                                           "updatedAt":  "2018-05-17T16:32:11Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM4OTkzMDEzMg==",
                                           "createdAt":  "2018-05-17T16:35:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "@sunilmut, are there any known issues in RS4 with having multiple threads issuing sends/recvs on the same unix domain socket at the same time?",
                                           "updatedAt":  "2018-05-17T16:35:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM4OTkzNjc4Nw==",
                                           "createdAt":  "2018-05-17T16:57:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rmkerr",
                                           "body":  "It looks like we\u0027re only running RS3 in PRs. So this test is always being skipped on PRs, and is only enabled on the official runs.",
                                           "updatedAt":  "2018-05-17T20:07:34Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5MjE0OTMzOA==",
                                           "createdAt":  "2018-05-25T18:53:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rmkerr",
                                           "body":  "@stephentoub I talked to Sunil about this -- there are not any known issues around multiple sends/receives. I\u0027ll try to see if I can reproduce this locally.",
                                           "updatedAt":  "2018-05-25T18:53:29Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ1MzU5MzM5MA==",
                                           "createdAt":  "2019-01-11T17:26:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "@rmkerr, is this still happening?",
                                           "updatedAt":  "2019-01-11T17:26:43Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ1NDA5MTg5Ng==",
                                           "createdAt":  "2019-01-14T17:34:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rmkerr",
                                           "body":  "My setup for checking in on the tests was just broken by the move away from ci.dot.net, so I\u0027m not sure. I\u0027ll try to get it running again today though.",
                                           "updatedAt":  "2019-01-14T17:34:09Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ1NDEwODc5Nw==",
                                           "createdAt":  "2019-01-14T18:25:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rmkerr",
                                           "body":  "Based on [this recent test run](https://dnceng.visualstudio.com/internal/_build/results?buildId=72013\u0026view=ms.vss-test-web.test-result-details), it looks like this is still happening.",
                                           "updatedAt":  "2019-01-14T18:25:13Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ3MDMyNTE0Mg==",
                                           "createdAt":  "2019-03-06T23:55:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "failed 20x in last 30 days in official runs.  all in Windows.10.Amd64.ClientRS4 queue.\r\n\r\n```\r\n   at System.Threading.Tasks.TaskTimeoutExtensions.WhenAllOrAnyFailed(Task[] tasks, Int32 millisecondsTimeout) in F:\\vsagent\\11\\s\\src\\Common\\tests\\System\\Threading\\Tasks\\TaskTimeoutExtensions.cs:line 69\r\n   at System.Net.Sockets.Tests.UnixDomainSocketTest.ConcurrentSendReceiveAsync() in F:\\vsagent\\11\\s\\src\\System.Net.Sockets\\tests\\FunctionalTests\\UnixDomainSocketTest.netcoreapp.cs:line 322\r\n--- End of stack trace from previous location where exception was thrown ---\r\n```",
                                           "updatedAt":  "2019-03-06T23:55:07Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4NjgxMTUwNQ==",
                                           "createdAt":  "2019-04-25T19:42:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "This seems specific to RS4. Another 26 failures in last 20 days.\r\n\r\nShould we disable this test on that OS? \r\nPerhaps push it to Feature? \r\nAny recommendation for instrumentation?\r\n\r\ncc: @davidsh  ",
                                           "updatedAt":  "2019-04-25T19:42:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4NjgxMTc5MQ==",
                                           "createdAt":  "2019-04-25T19:43:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e This seems specific to RS4.\r\n\r\nIs it running and passing on RS5?",
                                           "updatedAt":  "2019-04-25T19:43:13Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4NjgxMzg0NA==",
                                           "createdAt":  "2019-04-25T19:49:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidsh",
                                           "body":  "\u003eShould we disable this test on that OS?\r\nPerhaps push it to Feature?\r\nAny recommendation for instrumentation?\r\ncc: @davidsh \r\n\r\nThis is another case of asking ourselves are we adding value by testing this in CI with our .NET layer. I don\u0027t know which version of Windows 10 the UnixDomainSocket became operational. Maybe there are some bugs in it. We would have to ask the Windows TCP team.\r\n\r\nUnless we want to spend a lot of time investigating a Windows native feature, we should either disable this test on Windows or at least restrict it to RS5 and above. That would give us some test coverage on Windows and reduce the noise in our test results.",
                                           "updatedAt":  "2019-04-25T19:50:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4NjgyNjk4NQ==",
                                           "createdAt":  "2019-04-25T20:31:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "It seems like we only do RS5 for UWP. There is another Windows.10.Amd64.Core queue, but this test does not run there. So RS4 is only Windows platform where this test runs. I don\u0027t see any failures on Unix. ",
                                           "updatedAt":  "2019-04-25T20:31:24Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4NjgzOTg2OQ==",
                                           "createdAt":  "2019-04-25T21:12:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAnmBrA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "davidsh",
                                                                               "createdAt":  "2019-04-25T22:12:24Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "karelz",
                                           "body":  "If we don\u0027t believe this is .NET bug, I suggest to disable it on RS4 and below for now and move the issue to Future. Thoughts?",
                                           "updatedAt":  "2019-04-25T21:12:22Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ5MDYzMTQyOA==",
                                           "createdAt":  "2019-05-08T20:06:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "Got another failure on Window.\r\n\r\n```\r\n  System.Net.Sockets.Tests: [Long Running Test] \u0027System.Net.Sockets.Tests.UnixDomainSocketTest.Socket_SendReceiveAsync_PropagateToStream_Success\u0027, Elapsed: 00:12:15\r\n  System.Net.Sockets.Tests: [Long Running Test] \u0027System.Net.Sockets.Tests.UnixDomainSocketTest.Socket_SendReceiveAsync_PropagateToStream_Success\u0027, Elapsed: 00:14:15\r\n\r\n```\r\nhttps://mc.dot.net/#/user/dotnet-bot/pr~2Fdotnet~2Fcorefx~2Frefs~2Fpull~2F37505~2Fmerge/test~2Ffunctional~2Fcli~2F/20190508.15/workItem/System.Net.Sockets.Tests/wilogs",
                                           "updatedAt":  "2019-05-08T20:06:28Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyOTYxNzQ0NQ==",
                                           "createdAt":  "2019-09-09T18:54:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Next steps: Re-enable the test and disable it only for RS4.",
                                           "updatedAt":  "2019-09-09T18:54:06Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUzOTU4NTU1NQ==",
                                           "createdAt":  "2019-10-08T16:06:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ViktorHofer",
                                           "body":  "The test that was originally reported in the top post is still failing: https://dev.azure.com/dnceng/public/_build/results?buildId=381275\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=11789792\u0026resultId=174544\u0026paneView=debug\r\n\r\nConfiguration: `netcoreapp-Windows_NT-Debug-x64-Windows.10.Amd64.Client19H1.ES.Open`\r\n\r\n```\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.ConcurrentSendReceive\r\n\r\nSystem.TimeoutException : WhenAllOrAnyFailed timed out after 10000ms\r\n  at System.Threading.Tasks.TaskTimeoutExtensions.WhenAllOrAnyFailed(Task[] tasks, Int32 millisecondsTimeout) in /_/src/Common/tests/System/Threading/Tasks/TaskTimeoutExtensions.cs:line 75\r\n   at System.Net.Sockets.Tests.UnixDomainSocketTest.ConcurrentSendReceive(Boolean forceNonBlocking) in /_/src/System.Net.Sockets/tests/FunctionalTests/UnixDomainSocketTest.netcoreapp.cs:line 283\r\n--- End of stack trace from previous location ---\r\n```\r\n\r\n@stephentoub I see that you are tracking a different disabled test than the one reported initially.",
                                           "updatedAt":  "2019-10-08T16:06:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Sw9t0",
                                           "createdAt":  "2024-11-07T13:58:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MihaZupan",
                                           "body":  "Tests are disabled against this issue",
                                           "updatedAt":  "2024-11-07T13:58:56Z"
                                       }
                                   ],
                         "totalCount":  21
                     },
        "title":  "UnixDomainSocket test is timing out",
        "labels":  [
                       "area-System.Net.Sockets",
                       "disabled-test",
                       "os-windows",
                       "test-bug",
                       "test-run-core"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/26291",
        "createdAt":  "2018-05-27T18:19:42Z",
        "number":  26291,
        "author":  "Kaktusbot",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-06-12T20:36:36Z",
        "body":  "I was looking at sockets code, and one thing looked suspicious to me.\r\nI downloaded corefx repo and and tested some simple code with debugger.\r\n```C#\r\nList\u003cArraySegment\u003cbyte\u003e\u003e list = ... // Init List of ArraySegments with some bytes\r\nSocket socket = ... // Init Socket and connect to smth\r\n\r\n// Here BufferList of SocketAsyncEventArgs(cached as TaskSend) pins arrays of ArraySegments\r\nawait socket.SendAsync(list, SocketFlags.None); \r\n\r\n// Send single buffer as many times as you want, or just wait some time\r\n// It will not unpin BufferList from previous SendAsync, because it\u0027s SAEA cached as ValueTaskSend\r\nfor (int i = 0; i \u003c 1000000; i++)\r\n    await socket.SendAsync(new byte[] {...},  SocketFlags.None);\r\n\r\n// And here it is, only here with new multibuffer send \r\n// buffers from previous multibuffer send are unpinned with GCHandle.Free()\r\nawait socket.SendAsync(list, SocketFlags.None);\r\n```\r\nIf my program uses multibuffer send once and after that only uses singlebuffer sends then buffers from that first and single multibuffer send will be pinned as long as socket itself lives.\r\nI\u0027m understand that such a memory leak is unimportant and such use case somewhat absurd but I heard that pinning causes memory fragmentation.\r\nSo it bothers me and I think unpinning should occur after async operation is completed, not when next async operation is called.\r\nAm I right with my assumptions?\r\nShould I worry about them(fragmentation and leaks)?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOT2zM5w==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5MjM1MjU5OA==",
                                           "createdAt":  "2018-05-27T18:22:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Drawaes",
                                           "body":  "This is an optmisation. Often its the same buffer passed back again and again, this way you don\u0027t pay the pin/unpin every time. (But I could be wrong ;) )",
                                           "updatedAt":  "2018-05-27T18:22:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5MjM1MzcwNQ==",
                                           "createdAt":  "2018-05-27T18:40:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Kaktusbot",
                                           "body":  "\u003e This is an optmisation. Often its the same buffer passed back again and again, this way you don\u0027t pay the pin/unpin every time.\r\n\r\nIt sounded reasonable for me and I\u0027m almost calmed down but then I checked it with debugger.\r\nEven sending absolutely same List\u003cArraySegment\u003cbyte\u003e\u003e twice causes unpin and pin, it\u0027s only that GCHandles are not recreating.",
                                           "updatedAt":  "2018-05-27T18:40:45Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ1NjYwNTcwOQ==",
                                           "createdAt":  "2019-01-22T23:28:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "is there anything left on this or do we need another iteration? ",
                                           "updatedAt":  "2019-01-22T23:28:34Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ3MTY2OTEwNQ==",
                                           "createdAt":  "2019-03-11T18:41:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAqV3Ww==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kjkrum",
                                                                               "createdAt":  "2019-06-11T16:31:00Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "It does look like the implementation is the worst of both worlds.  Either it should pin and unpin as tightly as possible around the operation as it can, or it should retain the pinning in order to avoid pinning/unpinning for each operation, and only unpin when the next operation can\u0027t use the previous pinning.  But currently it appears to not unpin after the operation completes but then always unpin when starting the next operation, regardless of whether it could reuse the same pins.",
                                           "updatedAt":  "2019-03-11T18:41:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5PbMzn",
                                           "createdAt":  "2022-11-30T17:50:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "triage: we should look into it as the fix is probably pretty simple and we may improve perf. ",
                                           "updatedAt":  "2022-11-30T17:50:48Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "Socket SendAsync MutipleBuffers pinning.",
        "labels":  [
                       "enhancement",
                       "area-System.Net.Sockets",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/28157",
        "createdAt":  "2018-12-12T06:49:26Z",
        "number":  28157,
        "author":  "divman25",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC2P8jw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sgf",
                                            "createdAt":  "2018-12-26T01:39:02Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Pashahasband",
                                            "createdAt":  "2021-07-22T09:26:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kircat62",
                                            "createdAt":  "2021-07-22T09:28:20Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aorlov62",
                                            "createdAt":  "2021-07-22T12:33:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "IFoundTheLight",
                                            "createdAt":  "2021-08-07T17:43:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "shef",
                                            "createdAt":  "2021-08-14T20:47:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "docbrown",
                                            "createdAt":  "2022-01-06T21:48:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "vandycknick",
                                            "createdAt":  "2022-01-10T18:39:09Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "nlucas2",
                                            "createdAt":  "2022-04-01T18:27:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mnj",
                                            "createdAt":  "2022-06-03T21:57:50Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "TSRBerry",
                                            "createdAt":  "2022-08-15T15:23:31Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "liushouhuo",
                                            "createdAt":  "2023-03-14T11:57:43Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jdomnitz",
                                            "createdAt":  "2023-03-17T04:10:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kinnay",
                                            "createdAt":  "2023-09-02T15:08:54Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "y0ung3r",
                                            "createdAt":  "2024-03-02T06:08:43Z"
                                        }
                                    ],
                          "totalCount":  15
                      },
        "updatedAt":  "2024-04-05T06:30:30Z",
        "body":  "I am unable to use netlink connectors on Linux via dotnet and socket creation itself fails with \r\n\r\n\u003e Unhandled Exception: System.Net.Sockets.SocketException: Address family not supported by protocol\r\n\r\nI am trying to use linux netlink connectors to listen to process fork events directly from the OS. The C code would look something like this to create a socket and then use **sockaddr_nl** to send messages- \r\n`socket(PF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR)`\r\nOR\r\n```c\r\nint main() {\r\n    int sock = socket(16, SOCK_DGRAM, 11);\r\n    return 0;\r\n}\r\n```\r\nWhile the corresponding C# fails - \r\n```c#\r\nconst UInt16 NETLINK_CONNECTOR = 11;\r\nconst UInt16 PF_NETLINK = 16;\r\nSocket temp = new Socket((AddressFamily)PF_NETLINK, SocketType.Dgram, (ProtocolType)NETLINK_CONNECTOR);\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOeYlVMw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ0Njc3NDQ5MQ==",
                                           "createdAt":  "2018-12-12T22:51:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "cc @tmds @wfurt @eerhardt ",
                                           "updatedAt":  "2018-12-12T22:51:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ0Njc3NTIyNg==",
                                           "createdAt":  "2018-12-12T22:54:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "This will need API review. We talked about it when we talked about AF_PACKET. This one is also only Linux specific e.g. no windows, no other UNIXes.",
                                           "updatedAt":  "2018-12-12T23:20:12Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ0Njc4MTQzNg==",
                                           "createdAt":  "2018-12-12T23:19:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "I assume you meant related to dotnet/runtime#26416",
                                           "updatedAt":  "2018-12-12T23:19:58Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ0Njc4MjAzMg==",
                                           "createdAt":  "2018-12-12T23:22:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "yes, I should have added the link. In both cases we need to add enum to protocol list and do some testing on _all_ platforms. Since this would work only on Linux, we may do some extra documentation to make it clear. ",
                                           "updatedAt":  "2018-12-12T23:22:35Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2NTA4MTg5OQ==",
                                           "createdAt":  "2019-12-12T16:31:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Triage: Does not seem critical, but valuable.",
                                           "updatedAt":  "2019-12-12T16:31:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc40vFLt",
                                           "createdAt":  "2021-07-22T08:58:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Pashahasband",
                                           "body":  "Hello! When can we expect implementation?",
                                           "updatedAt":  "2021-07-22T08:58:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc40vHv7",
                                           "createdAt":  "2021-07-22T09:15:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "@Pashahasband there is no timeline set. Upvoting top post as you did is going to help us prioritize in future releases.",
                                           "updatedAt":  "2021-07-22T09:15:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc55XbKW",
                                           "createdAt":  "2024-04-04T04:46:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "xoofx",
                                           "body":  "Hey folks,\r\n\r\nIf I wanted to add support for this, what would it require? e.g Example:\r\n\r\n- `AddressFamily.NetLink` enum\r\n- `ProtocolType.NetLinkConnector` enum + document that it only works for Linux (I have other NetLink protocol types to add likely, will have to check)\r\n- Proper changes in `pal_networking` to convert to native type (back and forth)\r\n- Documentation\r\n\r\nShould I open an issue for API proposal? Consequently, I could create a PR for the changes, doesn\u0027t look difficult to bring.\r\n\r\nThoughts?",
                                           "updatedAt":  "2024-04-04T06:10:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc55hYYj",
                                           "createdAt":  "2024-04-05T03:36:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "the difficult part (IMHO) is the Netlink Enum(s) - AFAIK there is LOT of them. And the API review board is not too keen on platform specific functionality.  \r\nNow you can Create `Socket` from OS handle so there is trivial workaround IMHO. \r\n\r\nThe other part is that you may need more than just the socket ... but I may be wrong. Perhaps creating some stubs and demonstrate usage would be good next step @xoofx ",
                                           "updatedAt":  "2024-04-05T03:36:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc55iVUz",
                                           "createdAt":  "2024-04-05T06:30:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "xoofx",
                                           "body":  "\u003e the difficult part (IMHO) is the Netlink Enum(s) - AFAIK there is LOT of them. And the API review board is not too keen on platform specific functionality.\r\n\r\nI was looking at https://man7.org/linux/man-pages/man7/netlink.7.html and it is between 15-20 enum items. For the platform specific aspect, dunno, when I see that the existing ProtocolFamily has something like `Native ATM services protocol.`\r\n\r\n\u003e Now you can Create `Socket` from OS handle so there is trivial workaround IMHO.\r\n\r\nOh right, I thought that the underlying constructor was validating that the ProtocolType/AdressFamily are within accepted range, but it doesn\u0027t look like as it\u0027s just replacing with Unknown, but then that\u0027s fine.\r\n\r\n\u003e The other part is that you may need more than just the socket ... but I may be wrong. Perhaps creating some stubs and demonstrate usage would be good next step @xoofx\r\n\r\nProbably gonna try using the constructor taking an handle and will see how it goes.\r\n\r\nThanks\r\n",
                                           "updatedAt":  "2024-04-05T06:30:29Z"
                                       }
                                   ],
                         "totalCount":  10
                     },
        "title":  "Add AddressFamily netlink_connector on Sockets",
        "labels":  [
                       "api-suggestion",
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/28316",
        "createdAt":  "2019-01-04T15:02:01Z",
        "number":  28316,
        "author":  "sdb-dev",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-02-05T14:02:22Z",
        "body":  "**Issue:** \r\nSocket.BeginConnect throws a `Socket Exception (111): Connection Refused` when called with `IPAddress.Loopback` as the endpoint with no actively listening socket running on that port. This only occurs on a Linux operating system. On Windows, this method runs successfully even if there is nothing listening on the port. On Windows, the exception occurs on the `Socket.EndConnect` method instead.\r\n\r\n**Expected:** \r\n`Socket.BeginConnect` should run successfully, and `Socket.EndConnect` should instead throw the socket exception.\r\n\r\n**Steps to reproduce:**\r\n1) Create socket\r\n```c#\r\nvar socket = new Socket(IPAddress.Loopback.AddressFamily, SocketType.Stream, ProtocolType.Tcp);\r\n```\r\n2) Connect socket via Socket.BeginConnect.\r\n```c#\r\nsocket.BeginConnect(IPAddress.Loopback, OnEndConnect, null);\r\n```\r\n\r\n**Environment**\r\nLinux: Ubuntu 16.04.5 LTS\r\nWindows: Windows 1803\r\n.NET Core Version: 2.2.0\r\n\r\n**Stack Trace**\r\n```\r\nSystem.Net.Sockets.SocketException (111): Connection refused\r\n   at IAsyncResult System.Net.Sockets.Socket.BeginConnectEx(EndPoint remoteEP, bool flowContext, AsyncCallback callback, object state)\r\n   at IAsyncResult System.Net.Sockets.Socket.UnsafeBeginConnect(EndPoint remoteEP, AsyncCallback callback, object state, bool flowContext)\r\n   at IAsyncResult System.Net.Sockets.Socket.BeginConnect(EndPoint remoteEP, AsyncCallback callback, object state)\r\n```\r\n\r\n**Details:**\r\nBoth the linux environment and windows environment do not have any sockets listening on the given ports. On Windows, the connection refused occurs on EndConnect and not BeginConnect. The `IPAddress.Loopback` resolves to an IPv4 address and is using the `InterNetwork` address family.\r\n\r\nI am not sure if this is supposed to be the expected behaviour on Linux, but since it differs from Windows since there isn\u0027t much in the documentation regarding this specifically.\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOH5EeIQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ1MjQ5MTE2NQ==",
                                           "createdAt":  "2019-01-08T23:35:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "It seems like documentation suggests that socket exception _can_ happen. https://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.socket.beginconnect?view=netcore-2.2 I don\u0027t think we can really fix observed behavior as well as there simply may be timing race. ",
                                           "updatedAt":  "2019-01-08T23:35:53Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyOTYwNDEyOQ==",
                                           "createdAt":  "2019-09-09T18:20:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Triage: Reasonable to fix. Priority is not high.",
                                           "updatedAt":  "2019-09-09T18:20:37Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Socket.BeginConnect throws a connection refused on Linux instead of throwing it on Socket.EndConnect",
        "labels":  [
                       "documentation",
                       "area-System.Net.Sockets",
                       "os-linux",
                       "tenet-compatibility"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/131",
        "createdAt":  "2019-11-19T21:05:44Z",
        "number":  131,
        "author":  "safern",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-05-03T20:57:31Z",
        "body":  "We\u0027re disabling some System.Net.*.Tests assemblies when running on a checked runtime in: #261. However we should investigate what can we do to enable these tests there.\r\n\r\nI.e System.Net.Sockets.Tests would be a really would candidate for runtime testing and stress testing.\r\n\r\ncc: @BruceForstall @jkotas @stephentoub",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOqc1UDQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU1NTc3NjczOQ==",
                                           "createdAt":  "2019-11-20T00:19:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidsh",
                                           "body":  "@wfurt ",
                                           "updatedAt":  "2019-11-20T00:19:20Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU1NTg5ODE1NA==",
                                           "createdAt":  "2019-11-20T08:35:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ViktorHofer",
                                           "body":  "Do we know why especially the networking tests are so slow on a checked runtime?",
                                           "updatedAt":  "2019-11-20T08:35:56Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU1NjE3MjE2MA==",
                                           "createdAt":  "2019-11-20T17:54:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidsh",
                                           "body":  "What is a \"checked\" runtime? I know what Debug vs. Release is. How does \"checked\" related to that?",
                                           "updatedAt":  "2019-11-20T17:54:29Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU1NjE3Nzc4NA==",
                                           "createdAt":  "2019-11-20T17:59:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "BruceForstall",
                                           "body":  "Checked is the same as Debug (e.g., asserts enabled), but with the C++ compiler optimization enabled (so native code runs much faster).",
                                           "updatedAt":  "2019-11-20T17:59:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU1NjI0OTkwNQ==",
                                           "createdAt":  "2019-11-20T19:00:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOA4gLNQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "karelz",
                                                                               "createdAt":  "2020-01-07T20:52:42Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "wfurt",
                                           "body":  "It would be great to get more specific instructions how to know produce one and to know if test run is checked. I always assumed that checked would be slower than Debug but it seems like it may not. \r\nLot of networking code (product \u0026 tests) depends on timing. That is different from let say data structure tests. There are some constants for test and AFAIK we already adjusted some for ARM runs. We could possibly do that for checked builds if needed. But first we need to be able to reproduce it local and take a look.",
                                           "updatedAt":  "2019-11-20T19:00:09Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3MTc2NjM0MQ==",
                                           "createdAt":  "2020-01-07T20:53:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Any update on this? @BruceForstall @ViktorHofer @safern ",
                                           "updatedAt":  "2020-01-07T20:53:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3NDkyMTg2OA==",
                                           "createdAt":  "2020-01-16T00:29:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "safern",
                                           "body":  "Here is a Checked run, where this tests had to be killed because they were long running:\r\n\r\nhttps://helix.dot.net/api/2019-06-17/jobs/70eeb0e3-b877-4b51-a91b-2b5d8a69f8a8/workitems/System.Net.Mail.Functional.Tests/console",
                                           "updatedAt":  "2020-01-16T00:29:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3NDk5NDgwOA==",
                                           "createdAt":  "2020-01-16T05:50:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "console copy before link expires. I don\u0027t see any dump so this may be tricky. Also I noticed then when I\u0027m running tests with debug CLR it is super slow even on my dev box. \r\n```\r\nC:\\h\\w\\B22E09AD\\w\\A68A095C\\e\u003e\"C:\\h\\w\\B22E09AD\\p\\dotnet.exe\" exec --runtimeconfig System.Net.Mail.Functional.Tests.runtimeconfig.json --depsfile System.Net.Mail.Functional.Tests.deps.json xunit.console.dll System.Net.Mail.Functional.Tests.dll -xml testResults.xml -nologo -nocolor -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  \r\n  Discovering: System.Net.Mail.Functional.Tests (method display = ClassAndMethod, method display options = None)\r\n  Discovered:  System.Net.Mail.Functional.Tests (found 144 of 146 test cases)\r\n  Starting:    System.Net.Mail.Functional.Tests (parallel test collections = on, max threads = 2)\r\n   System.Net.Mail.Functional.Tests: [Long Running Test] \u0027System.Net.Mail.Tests.SmtpClientTest.TestCredentialsCopyInAsyncContext\u0027, Elapsed: 00:02:14\r\n   System.Net.Mail.Functional.Tests: [Long Running Test] \u0027System.Net.Mail.Tests.SmtpClientTest.TestCredentialsCopyInAsyncContext\u0027, Elapsed: 00:04:15\r\n   System.Net.Mail.Functional.Tests: [Long Running Test] \u0027System.Net.Mail.Tests.SmtpClientTest.TestCredentialsCopyInAsyncContext\u0027, Elapsed: 00:06:15\r\n   System.Net.Mail.Functional.Tests: [Long Running Test] \u0027System.Net.Mail.Tests.SmtpClientTest.TestCredentialsCopyInAsyncContext\u0027, Elapsed: 00:08:15\r\n   System.Net.Mail.Functional.Tests: [Long Running Test] \u0027System.Net.Mail.Tests.SmtpClientTest.TestCredentialsCopyInAsyncContext\u0027, Elapsed: 00:10:15\r\n   System.Net.Mail.Functional.Tests: [Long Running Test] \u0027System.Net.Mail.Tests.SmtpClientTest.TestCredentialsCopyInAsyncContext\u0027, Elapsed: 00:12:15\r\n   System.Net.Mail.Functional.Tests: [Long Running Test] \u0027System.Net.Mail.Tests.SmtpClientTest.TestCredentialsCopyInAsyncContext\u0027, Elapsed: 00:14:15\r\n```",
                                           "updatedAt":  "2020-01-16T05:50:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3NTAxMzI2MA==",
                                           "createdAt":  "2020-01-16T07:01:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "safern",
                                           "body":  "Don\u0027t run them against a debug CLR, because that is not optimized, you should run them against a checked CLR. \r\n\r\n`src\\coreclr\\build.cmd -checked \u0026\u0026 libraries.cmd /p:CoreCLRConfiguration=checked`\r\n\r\nIf you need it here is the testhost which was used for this job and contains a checked runtime:\r\nhttps://helixde107v0xdeko0k025g8.blob.core.windows.net/helix-job-515f0f7b-e695-4ee6-ac03-c600888962748843851101e463ebc/test-runtime-netcoreapp5.0-Windows_NT-Debug-x64.zip?sv=2018-03-28\u0026sr=c\u0026sig=Alo7OiJnlWnLBhPyRA8D2BDtKjmbjTiZg51IcVgk99o%3D\u0026se=2020-01-25T23%3A52%3A54Z\u0026sp=rl\r\n\r\nAnd here\u0027s the test payload\r\nhttps://helixde107v0xdeko0k025g8.blob.core.windows.net/helix-job-515f0f7b-e695-4ee6-ac03-c600888962748843851101e463ebc/System.Net.Mail.Functional.Tests.zip?sv=2018-03-28\u0026sr=c\u0026sig=Alo7OiJnlWnLBhPyRA8D2BDtKjmbjTiZg51IcVgk99o%3D\u0026se=2020-01-25T23%3A52%3A54Z\u0026sp=rl\r\n\r\n",
                                           "updatedAt":  "2020-01-16T07:01:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6SifwL",
                                           "createdAt":  "2024-11-06T01:23:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Due to lack of recent activity, this issue has been marked as a candidate for backlog cleanup.  It will be closed if no further activity occurs within 14 more days. Any new comment (by anyone, not necessarily the author) will undo this process.\n\nThis process is part of our [issue cleanup automation](https://github.com/dotnet/runtime/blob/main/docs/issue-cleanup.md).\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-11-06T01:23:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6pzVQN",
                                           "createdAt":  "2025-05-03T20:57:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MihaZupan",
                                           "body":  "Seeing the same timeout failure despite the test being disabled on non-release runtimes\nhttps://helixr1107v0xdcypoyl9e7f.blob.core.windows.net/dotnet-runtime-refs-pull-115234-merge-60c0a58a5d5d44bf9e/System.Net.Mail.Functional.Tests/1/console.f4ccdd97.log?helixlogtype=result\n\nhttps://github.com/dotnet/runtime/blob/d57b9d6ddf4bae97bf3f68be20f35dddbddf6558/src/libraries/System.Net.Mail/tests/Functional/SmtpClientAuthTest.cs#L21-L25\n\n```\nSystem.Net.Mail.Functional.Tests.dll -xml testResults.xml -nologo -nocolor -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing  \n  Discovering: System.Net.Mail.Functional.Tests (method display = ClassAndMethod, method display options = None)\n  Discovered:  System.Net.Mail.Functional.Tests (found 226 test cases)\n  Starting:    System.Net.Mail.Functional.Tests (parallel test collections = on [2 threads], stop on fail = off)\n   System.Net.Mail.Functional.Tests: [Long Running Test] \u0027System.Net.Mail.Tests.SmtpClientAuthTest_SendMailAsync.TestCredentialsCopyInAsyncContext\u0027, Elapsed: 00:03:20\n   System.Net.Mail.Functional.Tests: [Long Running Test] \u0027System.Net.Mail.Tests.SmtpClientAuthTest_SendMailAsync.TestCredentialsCopyInAsyncContext\u0027, Elapsed: 00:05:20\n   System.Net.Mail.Functional.Tests: [Long Running Test] \u0027System.Net.Mail.Tests.SmtpClientAuthTest_SendMailAsync.TestCredentialsCopyInAsyncContext\u0027, Elapsed: 00:07:20\n   System.Net.Mail.Functional.Tests: [Long Running Test] \u0027System.Net.Mail.Tests.SmtpClientAuthTest_SendMailAsync.TestCredentialsCopyInAsyncContext\u0027, Elapsed: 00:09:20\n   System.Net.Mail.Functional.Tests: [Long Running Test] \u0027System.Net.Mail.Tests.SmtpClientAuthTest_SendMailAsync.TestCredentialsCopyInAsyncContext\u0027, Elapsed: 00:11:20\n   System.Net.Mail.Functional.Tests: [Long Running Test] \u0027System.Net.Mail.Tests.SmtpClientAuthTest_SendMailAsync.TestCredentialsCopyInAsyncContext\u0027, Elapsed: 00:13:20\n\n...\n[EXECUTION TIMED OUT]\n```",
                                           "updatedAt":  "2025-05-03T20:57:30Z"
                                       }
                                   ],
                         "totalCount":  11
                     },
        "title":  "System.Net.*.Tests are unstable or slow/long-running on a S.P.CoreLib checked runtime",
        "labels":  [
                       "area-System.Net.Sockets",
                       "disabled-test",
                       "test-bug",
                       "test-run-core"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/753",
        "createdAt":  "2019-12-11T00:48:49Z",
        "number":  753,
        "author":  "lpereira",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODLl0Vg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "am11",
                                            "createdAt":  "2019-12-11T03:24:13Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "frevib",
                                            "createdAt":  "2020-01-20T07:05:58Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "xsoheilalizadeh",
                                            "createdAt":  "2020-05-09T09:13:21Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "haf",
                                            "createdAt":  "2020-06-17T15:19:58Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "viktor-svub",
                                            "createdAt":  "2020-06-23T07:15:46Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ArgTang",
                                            "createdAt":  "2020-08-15T09:51:41Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "paule96",
                                            "createdAt":  "2020-08-15T10:40:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jorangreef",
                                            "createdAt":  "2020-09-19T10:22:55Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ericsampson",
                                            "createdAt":  "2020-10-05T15:49:13Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ptrwis",
                                            "createdAt":  "2020-10-22T12:33:57Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dimaaan",
                                            "createdAt":  "2020-11-21T22:57:21Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "maknapp",
                                            "createdAt":  "2020-12-21T20:33:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hez2010",
                                            "createdAt":  "2021-02-19T10:18:51Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sumihiran",
                                            "createdAt":  "2021-03-24T02:08:08Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rducom",
                                            "createdAt":  "2021-04-14T23:19:55Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "imba-tjd",
                                            "createdAt":  "2021-06-07T13:15:02Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "codyebberson",
                                            "createdAt":  "2021-06-10T16:18:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "soooch",
                                            "createdAt":  "2021-08-02T17:34:50Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ydubernet",
                                            "createdAt":  "2021-08-20T08:14:17Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hheexx",
                                            "createdAt":  "2021-10-14T20:44:54Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "N0D4N",
                                            "createdAt":  "2022-01-31T10:34:06Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2022-03-09T01:44:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Cons-Cat",
                                            "createdAt":  "2022-03-25T21:11:51Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Const-me",
                                            "createdAt":  "2022-10-16T11:12:21Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "raftario",
                                            "createdAt":  "2022-11-28T20:14:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "tingliang0",
                                            "createdAt":  "2022-12-08T01:41:12Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "slang25",
                                            "createdAt":  "2022-12-12T06:11:46Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jgod",
                                            "createdAt":  "2023-04-12T23:45:36Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "avsorokin",
                                            "createdAt":  "2023-05-03T06:12:46Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Meai",
                                            "createdAt":  "2023-05-28T23:47:46Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "halter73",
                                            "createdAt":  "2023-06-12T22:53:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "compujuckel",
                                            "createdAt":  "2023-07-13T19:58:09Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Griboedow",
                                            "createdAt":  "2023-09-11T15:54:03Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "JayArrowz",
                                            "createdAt":  "2023-11-20T14:13:01Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "verdie-g",
                                            "createdAt":  "2024-02-18T16:07:16Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "alexandrehtrb",
                                            "createdAt":  "2024-02-22T13:45:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "issue-dispenser",
                                            "createdAt":  "2024-09-23T07:13:45Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "NN---",
                                            "createdAt":  "2024-10-02T05:49:09Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pantosha",
                                            "createdAt":  "2025-03-05T21:59:44Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "antoniofreire",
                                            "createdAt":  "2025-07-29T01:17:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ShreyasJejurkar",
                                            "createdAt":  "2025-08-18T05:12:33Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jmbryan4",
                                            "createdAt":  "2025-08-18T13:23:26Z"
                                        }
                                    ],
                          "totalCount":  42
                      },
        "updatedAt":  "2025-08-17T13:34:39Z",
        "body":  "[io_uring](https://kernel.dk/io_uring.pdf) is a new method to perform efficient I/O on Linux systems.  It provides a completion model (rather than a readiness model), similar to what IOCP on Windows provides, and unlike the standard  poll-like interfaces, it can be used to request I/O from regular files as well (and, unlike the old/broken AIO in Linux, it doesn\u0027t require files to be opened in O_DIRECT mode).\r\n\r\nIt is a recent development, but reports of it being used by servers are very promising, often yielding gains exceeding 2 or 4x in throughput.  [Here\u0027s a talk by its main author with details, including benchmarks](https://kernel-recipes.org/en/2019/talks/faster-io-through-io_uring/).\r\n\r\nIn addition to I/O (read/write/poll), it\u0027s also possible to handle connections (accept/connect) and a bunch of other things.\r\n\r\nIt should be possible to enable this and have both io_uring and epoll (as a fallback) in pal_networking.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOvmaKWA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2NDM2Mjc4OA==",
                                           "createdAt":  "2019-12-11T03:24:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "am11",
                                           "body":  "Going by the pdf, it seems that polled IO might be the most suited option for PAL networking, because it is efficient, closer to epoll implementation and does not require elevated privileges (like \u0027kernel side polling\u0027 option). Few questions:\r\n\r\n* should the implementation take dependency on liburing, or can it carry some boilerplate code and let go the liburing dependency (which comes from package managers); and instead make the kernel calls directly?\r\n* should it be added as a shim to support runtime check (like there are shims for libssl, libnuma,). this way the same portable linux build, when running on kernel version lower than 5.1, will switch to epoll?\r\n* in kernel v5.4, the implementation has [improved significantly](https://www.phoronix.com/scan.php?page=news_item\u0026px=Linux-5.4-IO-URING-Improvements), so should the PAL implementation take 5.4 as a baseline to switch from epoll to io_uring or keep 5.1 as baseline (where it was first implemented)?",
                                           "updatedAt":  "2019-12-11T10:26:52Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2NDYyMDc1Ng==",
                                           "createdAt":  "2019-12-11T16:21:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBQ6kEw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "am11",
                                                                               "createdAt":  "2019-12-11T17:08:55Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jorangreef",
                                                                               "createdAt":  "2020-09-19T10:24:12Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "lpereira",
                                           "body":  "I\u0027d say depend on liburing.  Doing stuff by hand is possible but we would be essentially replicating it inside the runtime; better to stick with something that\u0027s been debugged and tested already.   I don\u0027t know how much they care about API and ABI compatibility at this point, so using it as a shim might not be a good idea; maybe using a git submodule?\r\n\r\nAs for the minimum kernel requirement: for io_uring, we should support 5.4+ only, falling back to epoll on older kernel versions.  There were many improvements in the 5.5 series too, so eventually we might even bump the requirements if we end up taking the advantage of these features, just to simplify how we implement stuff -- for instance, async file I/O and not only sockets. (This kernel is still not common in most distributions but would be nice if the performance just appeared out of the blue after a kernel upgrade.)",
                                           "updatedAt":  "2019-12-11T16:21:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2NDYzNDkwOQ==",
                                           "createdAt":  "2019-12-11T16:53:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOA3DkAA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "lpereira",
                                                                               "createdAt":  "2019-12-11T17:48:14Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "damageboy",
                                           "body":  "Possible dupe of:\r\n\r\nhttps://github.com/dotnet/coreclr/issues/24441\r\n\r\nThis situation with the issues not yet ported is starting to generate noise...",
                                           "updatedAt":  "2019-12-11T16:53:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2NDY1OTM4MQ==",
                                           "createdAt":  "2019-12-11T17:53:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lpereira",
                                           "body":  "Indeed it\u0027s a dupe, @damageboy.  (I\u0027ll keep this issue open here as it might be easier to reference it and it\u0027s unlikely a lot of folks will keep a close eye on the coreclr repo after the consolidation.)",
                                           "updatedAt":  "2019-12-11T17:54:51Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2NDY2Mzk3Mg==",
                                           "createdAt":  "2019-12-11T18:03:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "damageboy",
                                           "body":  "@lpereira Aren\u0027t the issues moving? Has anything changed?",
                                           "updatedAt":  "2019-12-11T18:03:54Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2NDY4MTU4Mw==",
                                           "createdAt":  "2019-12-11T18:51:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lpereira",
                                           "body":  "\u003e @lpereira Aren\u0027t the issues moving? Has anything changed?\r\n\r\nThey\u0027re moving, but it should take a month or so.  I can close this one once the move is complete (can\u0027t easily mark as dupe in different repos.)",
                                           "updatedAt":  "2019-12-11T18:51:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2NDY5ODY5MA==",
                                           "createdAt":  "2019-12-11T19:35:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "am11",
                                           "body":  "\u003e It should be possible to enable this and have both io_uring and epoll (as a fallback) in pal_networking.\r\n\r\ni think `pal_networking`, coming from corefx, deserves a separate issue as there is a defined/finite surface area which is currently using `epoll` where io_uring can be incorporated. It can be tracked here.\r\n\r\ncoreclr issue is a broader discussion on how to make use of io_uring in variety of scenarios, which currently is done in coreclr\u0027s `pal` without using `epoll` and friends in kernel-agnostic manner, afaict.",
                                           "updatedAt":  "2019-12-11T19:35:21Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2NTU3Mjc3NA==",
                                           "createdAt":  "2019-12-13T19:17:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lpereira",
                                           "body":  "Another thing I think we can use io_uring -- maybe not right now, but we could contribute a patch to the Linux kernel -- is to implement WaitForMultipleObjectsEx() using futexes directly, and have a command in io_uring to perform operations in multiple futexes at the same time.\r\n",
                                           "updatedAt":  "2019-12-13T19:17:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3MzQ2NTMxOA==",
                                           "createdAt":  "2020-01-12T22:40:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "isilence",
                                           "body":  "\u003e Another thing I think we can use io_uring -- maybe not right now, but we could contribute a patch to the Linux kernel -- is to implement WaitForMultipleObjectsEx() using futexes directly, and have a command in io_uring to perform operations in multiple futexes at the same time.\r\n\r\n@lpereira, I\u0027m speculating, but would a new futex opcode with already implemented linked commands and timeouts suffice you?\r\nSomeone already mentioned supporting futex(2) axboe/liburing#39",
                                           "updatedAt":  "2020-01-12T22:40:14Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3NjAzMzE4OQ==",
                                           "createdAt":  "2020-01-19T18:36:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODthpLw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "ROCKET",
                                                                               "user":  "flcl42",
                                                                               "createdAt":  "2024-08-10T11:34:38Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "benaadams",
                                           "body":  "epoll bare minimum echo server \r\n```\r\n50 clients, running 512 bytes, 60 sec.\r\n\r\nSpeed: 189185 request/sec, 189185 response/sec\r\nRequests: 11351122\r\nResponses: 11351122\r\n```\r\nio_uring bare minimum echo server (Linux 5.4 needed, lower versions don\u0027t return the right amount of bytes read from `io_uring_prep_readv` in cqe-\u003eres.) https://github.com/frevib/io_uring-echo-server\r\n```\r\nBenchmarking: localhost:5555\r\n50 clients, running 512 bytes, 60 sec.\r\n\r\nSpeed: 368368 request/sec, 368368 response/sec\r\nRequests: 22102112\r\nResponses: 22102110\r\n```",
                                           "updatedAt":  "2020-01-20T06:13:47Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3NjA0MTA1Mw==",
                                           "createdAt":  "2020-01-19T20:03:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "isilence",
                                           "body":  "The difference looks good, even though it can do even better. E.g. `io_uring` allows registered buffers and fds, supports `IORING_OP_ACCEPT`, etc. (or get rid of callocs in the loop...)",
                                           "updatedAt":  "2020-01-19T20:05:52Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3NjA0OTQzNg==",
                                           "createdAt":  "2020-01-19T21:29:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOA5Z1Ow==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "fcantournet",
                                                                               "createdAt":  "2020-01-20T00:04:11Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "benaadams",
                                           "body":  "\r\n*edit* removed links as author has decided on  GPL v3.0",
                                           "updatedAt":  "2020-01-19T21:29:07Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3NjEyMzA2NQ==",
                                           "createdAt":  "2020-01-20T06:15:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOA5a0Pw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "benaadams",
                                                                               "createdAt":  "2020-01-20T06:24:16Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "benaadams",
                                                                               "createdAt":  "2020-01-20T06:33:26Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "nxrighthere",
                                                                               "createdAt":  "2020-01-20T07:34:02Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "frevib",
                                           "body":  "@benaadams changed it to MIT, sorry for the inconvenience. @isilence it definitely needs some optimizations and I think there are some tiny bugs. If you want/like/have time to issue a PR, I’m happy to merge.",
                                           "updatedAt":  "2020-01-20T06:15:13Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3NjEzMDAwNw==",
                                           "createdAt":  "2020-01-20T06:44:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBQ6kNQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jorangreef",
                                                                               "createdAt":  "2020-09-19T10:26:21Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "benaadams",
                                           "body":  "*edit* author changed to MIT so put link back https://github.com/frevib/io_uring-echo-server :)\r\n\r\nIt\u0027s a networking example using `liburing` which is LGPL so can be linked to (though not derived from for MIT; so don\u0027t look at the source for `liburing` in case we do our own implementation on `io_uring` which **must** be clean and not derived from LGPL). \r\n\r\nThough I don\u0027t know the dotnet policy on linking to LGPL and whether its allowed? /cc @jkotas \r\n\r\nThere\u0027s a very detailed document from the author of `liburing` @axboe who is also one of the authors of `io_uring` https://kernel.dk/io_uring.pdf on the motivation for `io_uring` and what it achieves, as well as how to use it (including considerations around memory barriers). \r\n\r\nThat then leads to the motivations for `liburing` and how to use that (it simplifies all the boilerplate setup and tear down for `io_uring` and handles all the memory barriers etc)\r\n\r\nTo quote\r\n\r\n\u003e With the inner details of the io_uring out of the way, you\u0027ll now be relieved to learn that there\u0027s a simpler way to do much of the above. The liburing library serves two purposes:\r\n\u003e * Remove the need for boiler plate code for setup of an io_uring instance.\r\n\u003e * Provide a simplified API for basic use cases.\r\n\r\nAlso a [LWN.net article](https://lwn.net/Articles/776703/) about `io_uring` ",
                                           "updatedAt":  "2020-01-20T06:44:18Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3NjE3MDkxNw==",
                                           "createdAt":  "2020-01-20T08:51:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOA5cOZA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2020-01-20T12:24:35Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "am11",
                                           "body":  "As noted above, I think at least for the usecase in `pal_networking.c` in this repository, where implementation is currently using epoll, does not require link to liburing (a convenience library). It is more work, yes, but IMO worth it for dotnet runtime. Taking a dependency on another runtime library comes with cost for packaging as well. For example, liburing is not readily available in Alpine Linux package and many other package management systems, see [Absent in repositories](https://repology.org/project/liburing/versions).",
                                           "updatedAt":  "2020-01-20T08:51:11Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3NjM2MjUzOA==",
                                           "createdAt":  "2020-01-20T17:07:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOA5faQQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "benaadams",
                                                                               "createdAt":  "2020-01-20T17:19:49Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "nxrighthere",
                                                                               "createdAt":  "2020-01-21T00:43:09Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "lpereira",
                                           "body":  "Notwithstanding library availability -- because we could use git submodules, for instance, and statically link with liburing -- there\u0027s a bigger issue: linking with LGPL would require us to also distribute `.o` files in addition to the binaries for .NET.\r\n\r\nSo I agree that it would be better to reimplement what liburing does; it\u0027s a thin wrapper around the kernel API.  It mostly reduces a lot of the boilerplate necessary to map the queues and provides a bunch of auxiliary functions and whatnot.\r\n\r\nIf we\u0027re unsure how to use the API, though, it\u0027s possible to read from other implementations; for instance, there\u0027s [a dual-licensed Apache 2/MIT library for Rust](https://github.com/quininer/io-uring) that could be used for studying purposes.",
                                           "updatedAt":  "2020-01-20T17:09:31Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3NjM2OTQwMg==",
                                           "createdAt":  "2020-01-20T17:26:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "Also the libuv PR for `io_uring` could be something to look at https://github.com/libuv/libuv/pull/2322 (libuv uses an joyent attribution licence); where they also state they can\u0027t look at the source for `liburing` as its LGPL https://github.com/libuv/libuv/pull/2322#issuecomment-500455185",
                                           "updatedAt":  "2020-01-20T17:26:43Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3NjM3MDgzOQ==",
                                           "createdAt":  "2020-01-20T17:30:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCTRHSg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "lpereira",
                                                                               "createdAt":  "2020-01-20T18:24:20Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "am11",
                                                                               "createdAt":  "2020-01-20T18:25:27Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "benaadams",
                                                                               "createdAt":  "2020-01-20T18:30:00Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "benaadams",
                                                                               "createdAt":  "2020-01-20T18:30:03Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "karelz",
                                                                               "createdAt":  "2020-01-21T16:36:53Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "svick",
                                                                               "createdAt":  "2020-01-23T18:03:54Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "jorangreef",
                                                                               "createdAt":  "2020-09-19T10:27:06Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ericsampson",
                                                                               "createdAt":  "2020-10-05T15:56:10Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "ydubernet",
                                                                               "createdAt":  "2021-08-20T08:20:54Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "pr8x",
                                                                               "createdAt":  "2022-03-16T17:44:55Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  10
                                                         },
                                           "author":  "axboe",
                                           "body":  "FWIW, I\u0027d be willing to change the liburing license to dual MIT/GPL. There\u0027s really nothing fancy in the library, it\u0027s mostly just helpers, and a simplified interface should the application wish to use that. But it\u0027d be a shame to have some of this code duplicated just because of licensing constraints.",
                                           "updatedAt":  "2020-01-20T17:30:54Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3NjM4NjMzMw==",
                                           "createdAt":  "2020-01-20T18:23:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lpereira",
                                           "body":  "@axboe  That would be appreciated; it would indeed help a lot with io_uring adoption, given that GPL family of licenses aren\u0027t, unfortunately (in my personal opinion), that popular these days.",
                                           "updatedAt":  "2020-01-20T22:01:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3NjQwNDg2Mg==",
                                           "createdAt":  "2020-01-20T19:31:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOA5hmww==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "benaadams",
                                                                               "createdAt":  "2020-01-20T19:47:57Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "benaadams",
                                                                               "createdAt":  "2020-01-20T19:48:03Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "lpereira",
                                                                               "createdAt":  "2020-01-20T20:05:07Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "am11",
                                                                               "createdAt":  "2020-01-21T03:42:20Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "adamsitnik",
                                                                               "createdAt":  "2020-01-21T10:54:12Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  5
                                                         },
                                           "author":  "axboe",
                                           "body":  "I like GPL for applications, and I still use it, but it makes less sense for libraries. And in particular for something like liburing, which isn\u0027t really a lot of smarts, it\u0027s mostly just setup and helper code. I\u0027m doing some due diligence by emailing folks that have more than a few commits in liburing, then I\u0027ll change it provided nobody objects (can\u0027t see why they would).",
                                           "updatedAt":  "2020-01-20T23:10:40Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3Njc1MDU0Ng==",
                                           "createdAt":  "2020-01-21T16:01:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCxENiA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "tkp1n",
                                                                               "createdAt":  "2020-01-21T20:27:03Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "lpereira",
                                                                               "createdAt":  "2020-01-23T15:07:31Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "bergwolf",
                                                                               "createdAt":  "2020-03-30T07:36:17Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "lbguilherme",
                                                                               "createdAt":  "2020-09-13T13:07:12Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "ericsampson",
                                                                               "createdAt":  "2020-10-05T15:56:24Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "ydubernet",
                                                                               "createdAt":  "2021-08-20T08:21:29Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "slang25",
                                                                               "createdAt":  "2022-12-12T06:14:15Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  7
                                                         },
                                           "author":  "axboe",
                                           "body":  "\u003e  I\u0027m doing some due diligence by emailing folks that have more than a few commits in liburing, then I\u0027ll change it provided nobody objects (can\u0027t see why they would).\r\n\r\nThis has now been done.",
                                           "updatedAt":  "2020-01-21T16:01:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3ODIzMjQzNA==",
                                           "createdAt":  "2020-01-24T17:50:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lpereira",
                                           "body":  "For the record, here\u0027s an ASP.NET transport by @tkp1n that reimplements liburing in C#: https://github.com/tkp1n/IoUring",
                                           "updatedAt":  "2020-01-24T17:50:44Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3ODI3MTQ3MQ==",
                                           "createdAt":  "2020-01-24T19:38:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "isilence",
                                           "body":  "\u003e @lpereira, I\u0027m speculating, but would a new futex opcode with already implemented linked commands and timeouts suffice you?\r\n\u003e Someone already mentioned supporting futex(2) [axboe/liburing#39](https://github.com/axboe/liburing/issues/39)\r\n\r\nGoing back to the ignored question... Guys, what\u0027s your use case and what would you need to integrate `io_uring`? Support for `futex(2)`? Something else?\r\n",
                                           "updatedAt":  "2020-01-24T19:38:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3ODMwNDc2MQ==",
                                           "createdAt":  "2020-01-24T21:14:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lpereira",
                                           "body":  "\u003e \u003e @lpereira, I\u0027m speculating, but would a new futex opcode with already implemented linked commands and timeouts suffice you?\r\n\u003e \u003e Someone already mentioned supporting futex(2) [axboe/liburing#39](https://github.com/axboe/liburing/issues/39)\r\n\u003e \r\n\u003e Going back to the ignored question... Guys, what\u0027s your use case and what would you need to integrate `io_uring`? Support for `futex(2)`? Something else?\r\n\r\nYeah, futex support for `io_uring` would be very welcome, especially if it had the `FUTEX_WAIT_MULTIPLE` command that was [proposed a while ago](https://lwn.net/Articles/794969/) (the use case is for Wine\u0027s implementation of `WaitForMultipleObjects()`, which is currently using polled `eventfd`s, but we also have an implementation in our PAL that could benefit from this.)\r\n",
                                           "updatedAt":  "2020-01-24T21:14:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3OTAwODg0OQ==",
                                           "createdAt":  "2020-01-27T23:39:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "isilence",
                                           "body":  "\u003e Yeah, futex support for `io_uring` would be very welcome, especially if it had the `FUTEX_WAIT_MULTIPLE` command that was [proposed a while ago](https://lwn.net/Articles/794969/) (the use case is for Wine\u0027s implementation of `WaitForMultipleObjects()`, which is currently using polled `eventfd`s, but we also have an implementation in our PAL that could benefit from this.)\r\n\r\nGreat, I\u0027ll try to take a look. I\u0027m concerned about not having fast-path in-userspace locking, but it should be any better than `eventfd + epoll`. I haven\u0027t seen FUTEX_WAIT_MULTIPLE, but will need it to be merged first.",
                                           "updatedAt":  "2020-01-27T23:39:55Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU4MTU4MzgzMQ==",
                                           "createdAt":  "2020-02-03T19:42:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lpereira",
                                           "body":  "This article about using `io_uring` in modern C++ (with coroutines et al) is a pretty good read and gives some API insights, too: https://cor3ntin.github.io/posts/iouring/",
                                           "updatedAt":  "2020-02-03T19:42:29Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU4MzI1MzY0NQ==",
                                           "createdAt":  "2020-02-07T06:30:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "lwn article [The rapid growth of io_uring](https://lwn.net/Articles/810414/) ",
                                           "updatedAt":  "2020-02-07T06:30:01Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU5MzQ0NDUxNw==",
                                           "createdAt":  "2020-03-02T15:00:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCW2Dow==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ReubenBond",
                                                                               "createdAt":  "2020-03-02T15:04:01Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "omariom",
                                                                               "createdAt":  "2020-03-02T18:31:06Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tibel",
                                                                               "createdAt":  "2020-03-21T09:57:14Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Leonardo-Ferreira",
                                                                               "createdAt":  "2020-05-04T23:48:29Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ArgTang",
                                                                               "createdAt":  "2020-08-15T09:55:14Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "PaulusParssinen",
                                                                               "createdAt":  "2022-04-07T17:06:00Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  6
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "A general update:\r\n\r\nAll prototyping is being done on https://github.com/tmds/Tmds.LinuxAsync, together with other experiments from #14304 . We hope to see some numbers soon. After that we can think about the productization of the changes.",
                                           "updatedAt":  "2020-03-02T15:50:50Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMzczMDU4MQ==",
                                           "createdAt":  "2020-10-05T16:07:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericsampson",
                                           "body":  "Is it possible to dupe-close one of these two issues, so that there is one main tracking issue?\r\nhttps://github.com/dotnet/runtime/issues/12650\r\n\r\n",
                                           "updatedAt":  "2020-10-05T16:07:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5mIU8r",
                                           "createdAt":  "2023-09-11T08:55:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEPgPgw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ReubenBond",
                                                                               "createdAt":  "2023-12-30T20:33:22Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "seungyongshim",
                                                                               "createdAt":  "2024-01-23T14:07:36Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hiyelbaz",
                                                                               "createdAt":  "2024-02-26T17:36:08Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "PaulusParssinen",
                                                                               "createdAt":  "2024-03-19T21:36:58Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "josephnhtam",
                                                                               "createdAt":  "2024-05-16T05:42:30Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "leo-costa",
                                                                               "createdAt":  "2024-07-07T08:50:21Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "nsentinel",
                                                                               "createdAt":  "2024-12-13T21:08:18Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "lvde0",
                                                                               "createdAt":  "2025-04-24T09:38:25Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  8
                                                         },
                                           "author":  "ShreyasJejurkar",
                                           "body":  "Hopefully this will be considered for 9.0",
                                           "updatedAt":  "2023-09-11T08:55:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc50_VzW",
                                           "createdAt":  "2024-02-25T00:00:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEPgPhA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Aragas",
                                                                               "createdAt":  "2024-02-25T13:42:35Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "omariom",
                                                                               "createdAt":  "2024-02-25T16:02:05Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "antonfirsov",
                                                                               "createdAt":  "2024-02-26T12:59:44Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hiyelbaz",
                                                                               "createdAt":  "2024-02-26T17:36:11Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ericsampson",
                                                                               "createdAt":  "2024-02-26T18:07:54Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "PaulusParssinen",
                                                                               "createdAt":  "2024-03-19T21:37:00Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "nsentinel",
                                                                               "createdAt":  "2024-12-13T21:08:12Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "lvde0",
                                                                               "createdAt":  "2025-04-24T09:38:26Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  8
                                                         },
                                           "author":  "ReubenBond",
                                           "body":  "Nice docs on io_uring for anyone interested in this: https://nick-black.com/dankwiki/index.php/Io_uring",
                                           "updatedAt":  "2024-02-25T00:00:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6-ZopY",
                                           "createdAt":  "2025-08-17T13:34:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Zetelias",
                                           "body":  "So is this going somewhere?",
                                           "updatedAt":  "2025-08-17T13:34:39Z"
                                       }
                                   ],
                         "totalCount":  32
                     },
        "title":  "Use io_uring instead of epoll when supported",
        "labels":  [
                       "enhancement",
                       "area-System.Net.Sockets",
                       "os-linux",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/932",
        "createdAt":  "2019-12-16T19:47:29Z",
        "number":  932,
        "author":  "webczat",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOA5XWUQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "tibel",
                                            "createdAt":  "2020-01-18T06:41:00Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-03-25T21:51:19Z",
        "body":  "Hello,\r\nI was wondering for some time: if unix sockets are supported directly by sockets api, how would I send unix file descriptors over them? It is a feature supported by every unix flavor, and pretty useful for example for implementing a dbus library, that comes to my mind first but it\u0027s not the only use case.\r\nMy question is, how would I do this with support for async/await? I am able to get a socket handle, so I could call sendmsg/recvmsg correctly, but I probably cannot attach to the io worker stuff in order to get non blocking notifications and implement SendFileDescriptorsAsync or something along the lines?\r\nAlso how would I go about implementing similar, more platform dependent features, like sending unix credentials or selinux context?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOT76fYA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2NjI5MDkxOQ==",
                                           "createdAt":  "2019-12-16T23:13:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "You still should be able to use poll/select to know that you can read something. \r\nQuestion is what you do with descriptor passed to your process? \r\nWe may be able to get https://github.com/dotnet/runtime/issues/862 but I don\u0027t know how would you for example use it with files. ",
                                           "updatedAt":  "2019-12-16T23:13:04Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2NjI5Mjc1Ng==",
                                           "createdAt":  "2019-12-16T23:18:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "webczat",
                                           "body":  "generally I believe FileStream accepts handles, don\u0027t remember if SafeFileHandle or UIntPtr, but it probably does. in the first case not sure if SafeFileHandle accepted UIntPtr, would have to check, but I believe it was possible. Othervise not sure how all that systemd activation support works in kestrel, when it gets a raw fd from systemd? it is actually file descriptor passing I believe.\r\nAs for using poll/select, I could do that, but all the rest of socket methods that do async operations integrate with io workers that already do poll/select/epoll. it would be duplicating functionality wouldn\u0027t it?",
                                           "updatedAt":  "2019-12-16T23:18:10Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2NjI5NTcyMA==",
                                           "createdAt":  "2019-12-16T23:27:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "Yes, it seems like `SafeFileHandle` can be created from IntPtr. As far as the second part, are you talking about function on socket used for passing or about processing once new descriptor is received? ",
                                           "updatedAt":  "2019-12-16T23:27:01Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2NjMxMjQ4MA==",
                                           "createdAt":  "2019-12-17T00:19:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "webczat",
                                           "body":  "I mean the function on socket used for passing. I have to call sendmsg instead of send or recvmsg instead of recv depending on the context. in case of async send/receive it would do select/poll/epoll on linux wouldn\u0027t it? and call actual send/recv after notification. If I implement my own handling like ReceiveDescriptorsAsync/SendDescriptorsAsync (let\u0027s assume such naming) then suddenly I have to call different functions on notification, and i have no way of hooking up to the whole io worker thing.",
                                           "updatedAt":  "2019-12-17T00:19:31Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2NjMxNDc0NA==",
                                           "createdAt":  "2019-12-17T00:26:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "yes, that is correct. Since there is no way how to pass descriptor to/from PAL, you will have to p/invoke native functions directly.  I would probably use dedicated socket to pass auxiliary data and I would not mix it with any other use. ",
                                           "updatedAt":  "2019-12-17T00:26:04Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2NjMxNzU5NQ==",
                                           "createdAt":  "2019-12-17T00:38:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "webczat",
                                           "body":  "note that that way you directly force-restrict any use of such features for protocols you don\u0027t control. nothing known to me uses sockets in such a way that they exist only to pass aux data. especially when this data is not a fd, but for example something like process info/user credentials. These data are, as said, aux, so they are being send with something else, for example with a dbus message, or whatever. Another example would be libvirt, the linux virtualization api, passing file descriptors to an open display when you try to connect to your vm\u0027s console locally. I am aware of the fact that I have to use native functions directly, the only problem with me is that I cannot hook that logic up to the io worker stuff, so I need to actually reimplement unix sockets just for this feature, or there is any other way that I don\u0027t know... or, I just ignore async and do all synchronous at least for fd passing.",
                                           "updatedAt":  "2019-12-17T00:38:33Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2NjM1ODQxNA==",
                                           "createdAt":  "2019-12-17T03:01:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "yes, you need to implement IO functions as what you want is not part of official API contract. \r\nHowever you can still implement it in asynchronous way and get it scheduled on thread pool.\r\nOnce you know you can read/write data, there really is not that much difference between sync/async method (as even Async can finish synchronously)  ",
                                           "updatedAt":  "2019-12-17T03:01:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2NjUyNjQyMQ==",
                                           "createdAt":  "2019-12-17T12:44:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "webczat",
                                           "body":  "won\u0027t it conflict with other async ops? also if I would like select/poll/epoll support I have problems as I have to reimplement that for fd passing...?\r\nIt would be useful to be able to attach to the io workers. It is already possible on windows because there is the mechanism of overlapped io and you have the ability to attach to this mechanism, but that is not possible here.",
                                           "updatedAt":  "2019-12-17T12:44:50Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU4OTE3MjQ1NA==",
                                           "createdAt":  "2020-02-20T16:37:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Triage: @antonfirsov please reconcile it with our DuplicateAndClose plans for Linux (related to #1760).\r\nExpected result: Clear plan/options to explore what we could / should do on Linux + decision of 5.0 vs. Future. Feel free to bring it back to triage (set untriaged label) when ready.",
                                           "updatedAt":  "2020-02-20T16:40:31Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg2NDk3MjIzMQ==",
                                           "createdAt":  "2021-06-21T11:54:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "webczat",
                                           "body":  "just wondering, if/until that is implemented, what is the expected course of action if I need this feature? I could invoke syscalls directly but async will never work. And there are potentially other similar things like sending credentials.",
                                           "updatedAt":  "2021-06-21T11:54:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Pvp9g",
                                           "createdAt":  "2022-12-05T18:16:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "triage: no resources in 8. We would need new API and we would need to check if there is any update on Windows side. ",
                                           "updatedAt":  "2022-12-05T18:16:45Z"
                                       }
                                   ],
                         "totalCount":  11
                     },
        "title":  "Sending file descriptors on unix sockets",
        "labels":  [
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/34473",
        "createdAt":  "2020-04-02T18:04:49Z",
        "number":  34473,
        "author":  "sakno",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-12-05T18:45:57Z",
        "body":  "`Socket.Disconnect(boolean)` method called on UDP socket behaves differently on different platforms. On Linux (Ubuntu 18.04.03 LTS) x64 it doesn\u0027t throw exception. On Windows 10 I get the following exception:\r\n```\r\nMessage: \r\n    System.Net.Sockets.SocketException : A request to send or receive data was disallowed because the socket is not connected and (when sending on a datagram socket using a sendto call) no address was supplied.\r\n  Stack Trace: \r\n    Socket.UpdateStatusAfterSocketErrorAndThrowException(SocketError error, String callerName)\r\n    Socket.Disconnect(Boolean reuseSocket)\r\n```\r\nProbably, behavior on Windows 10 is correct because UDP is connectionless protocol.\r\n\r\nVersion is .NET Core 3.1.201.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOT78_Yw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYwODAyNDMzNw==",
                                           "createdAt":  "2020-04-02T18:19:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sakno",
                                           "body":  "However, `Socket.Connect` works fine. It\u0027s strange because I can call `Connect` but unable to call `Disconnect`.",
                                           "updatedAt":  "2020-04-02T18:19:24Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNTM0ODQ5OQ==",
                                           "createdAt":  "2020-05-07T16:07:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Triage: It would be nice to have unified behavior across OS\u0027s. However, there may be difference in behavior of OS as #35048 demonstrates.\r\nIf it is possible and easy, we would take a fix.\r\n\r\n@sakno is it something you would be interested in contributing?",
                                           "updatedAt":  "2020-05-07T16:07:53Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNTM5MDA5MQ==",
                                           "createdAt":  "2020-05-07T17:23:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBDhIEg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "karelz",
                                                                               "createdAt":  "2020-05-07T17:55:58Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "sakno",
                                           "body":  "@karelz , probably yes, I can try. But I have 3 open PRs, it\u0027s not good to work in parallel on everything :smile: ",
                                           "updatedAt":  "2020-05-07T17:33:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Pvz9j",
                                           "createdAt":  "2022-12-05T18:45:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "triage: we should investigate if we _can_ make it consistent. We can possibly throw `PlatformNotSupportedException` and we can document the behavior. Currently low priority -\u003e leaving in Future. ",
                                           "updatedAt":  "2022-12-05T18:45:50Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Inconsistent behavior of Dgram Socket.Disconnect",
        "labels":  [
                       "enhancement",
                       "area-System.Net.Sockets",
                       "tenet-compatibility",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/34474",
        "createdAt":  "2020-04-02T18:15:56Z",
        "number":  34474,
        "author":  "sakno",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-06-07T11:29:22Z",
        "body":  "`Socket.SendToAsync(SocketAsyncEventArgs)` method has inconsistent behavior on different platforms if used for UDP socket for sending datagram to loopback address. On Linux (Ubuntu 18.04.03 LTS x64) it returns synchronously and `SocketAsyncEventArgs.SocketError` is `SocketError.ConnectionRefused`. On Windows 10 it returns synchronously but `SocketError` is `SocketError.Success`. ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOT7-2pA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNTM1MzE1MA==",
                                           "createdAt":  "2020-05-07T16:15:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "scalablecory",
                                           "body":  "It looks like Windows might have similar behavior if you set the `SIO_UDP_CONNRESET` option.",
                                           "updatedAt":  "2020-05-07T16:15:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNTM1NjUzOQ==",
                                           "createdAt":  "2020-05-07T16:21:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Triage:\r\n* We should not hide additional information we got on specific OS (Linux) and give it to the user if we can.\r\n* We may consider improving Windows to behave as Linux -- see https://github.com/dotnet/runtime/issues/34474#issuecomment-625353150 above\r\n* We should verify if the socket is still usable when we receive the error (if not we may want to fix it)\r\n* We may want to mention it in documentation that the calls might fail",
                                           "updatedAt":  "2020-05-07T16:21:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Pv7ak",
                                           "createdAt":  "2022-12-05T18:54:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "triage:  there was never guarantee about finishing synchronously or not. This is not part of the contract and it should be relayed on. We can investigate `SIO_UDP_CONNRESET` to make it more consistent but that may break others.\r\nLow priority for now. We should document it better to avoid surprises.",
                                           "updatedAt":  "2022-12-05T18:54:37Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Inconsistent behavior of Socket.SendToAsync(SocketAsyncEventArgs) ",
        "labels":  [
                       "documentation",
                       "area-System.Net.Sockets",
                       "tenet-compatibility",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/36170",
        "createdAt":  "2020-05-09T21:49:03Z",
        "number":  36170,
        "author":  "beniamin-airapetian",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-06-19T08:21:00Z",
        "body":  ".NET sockets have support of both IPv4 and IPv6 multicast. There are few multicast options in IP protocol and most of them are already supported by .NET, but there is no support of source specific multicast.\r\n\r\nAnother observation that current sockets implementation does not take advantage of using IP agnostic windows sockets APIs.\r\n\r\n## Rationale\r\nStreaming and communication services are very popular these days. IPv6 multicast is able to significantly improve this services in terms of performance, availability and usability. Also it opens a broad range of communication patterns between different devices in network. While native IPv6 adoption is only about 30% it is keep growing and eventually will cover every device.\r\n\r\nSource Specific Multicast (SSM) does not require complex address allocation or rendezvous point and works perfectly for things like streaming.\r\n\r\nIt still can be implemented using raw IPv6, but this approach requires an elevated permissions. Another option is to use new `Socket.SetRawSocketOption()` API proposed in #865, but it requires to pass socket option name as `int` and value as `ReadOnlySpan\u003cbyte\u003e`. On the other hand `Socket.SetRawSocketOption()` can be used to simplify implementation of API, since there will be no need to modify `System.Native/pal_networking.c` for Unix compatible systems.\r\n\r\n## Usage\r\nUsage can be close to what we have now with any source multicast.\r\n\r\nJoin source specific multicast group:\r\n```cs\r\nint interfaceIndex = 0;\r\nIPAddress groupIp = IPAddress.Parse(\"FF3E:0040:pppp:pppp:pppp:pppp:xxxx:xxxx\"); // Multicast group address (RFC 4607, RFC 3306)\r\nIPAddress sourceIp = IPAddress.Parse(\"xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx\");\r\n\r\nusing (Socket socket = new Socket(AddressFamily.InterNetworkV6, SocketType.Dgram, ProtocolType.Udp))\r\n{\r\n    var optionValue = new SourceMulticastOption(groupIp, sourceIp, interfaceIndex);\r\n    socket.SetSocketOption(SocketOptionLevel.IPv6, SocketOptionName.AddSourceMembership, optionValue);\r\n}\r\n```\r\nJoin any source multicast group using IP agnostic APIs:\r\n```cs\r\nint interfaceIndex = 0;\r\nIPAddress groupIp = IPAddress.Parse(\"FF3E:0040:pppp:pppp:pppp:pppp:xxxx:xxxx\"); // Multicast group address (RFC 4607, RFC 3306)\r\n\r\nusing (Socket socket = new Socket(AddressFamily.InterNetworkV6, SocketType.Dgram, ProtocolType.Udp))\r\n{\r\n    var optionValue = new IPv6MulticastOption(groupIp, interfaceIndex);\r\n    socket.SetSocketOption(SocketOptionLevel.IPv6, SocketOptionName.AddMembership, optionValue);\r\n}\r\n```\r\nFor IPv4 multicast usage is equivalent except:\r\n* Address family should be `AddressFamily.InterNetwork`;\r\n* Group and source addresses should be IPv4;\r\n* Socket option level has to be set to `SocketOptionLevel.IPv6`;\r\n\r\n## Proposed API\r\nNew option:\r\n```cs\r\npublic class SourceMulticastOption\r\n{\r\n    public IPAddress Group { get; }\r\n    public IPAddress Source { get; }\r\n    public long InterfaceIndex { get; }\r\n}\r\n```\r\nAdditional option names:\r\n```cs\r\npublic enum SocketOptionName\r\n{\r\n    ....\r\n    // Join all sources for a group. IP agnostic.\r\n    McastJoinGroup = 41,\r\n\r\n    // Drop all sources for a group. IP agnostic.\r\n    McastLeaveGroup = 42,\r\n\r\n    // Block IP group/source.\r\n    McastBlockSource = 43,\r\n\r\n    // Unblock IP group/source.\r\n    McastUnblockSource = 44,\r\n\r\n    // Join IP group/source.\r\n    McastJoinSourceGroup = 45,\r\n\r\n    // Leave IP group/source.\r\n    McastLeaveSourceGroup = 46,\r\n}\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOXywyQg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNjIzOTg5MA==",
                                           "createdAt":  "2020-05-09T21:49:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nNotify danmosemsft if you want to be subscribed.",
                                           "updatedAt":  "2020-05-09T21:49:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41VzpJ",
                                           "createdAt":  "2021-08-09T02:07:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kyanha",
                                           "body":  "With RFC 8815 deprecating any-source multicast for interdomain communication, I\u0027m currently writing extension methods to implement source-specific multicast. The way SocketAddress is written prevents efficient code from being written anywhere other than inside the System.Net.Sockets assembly. (Access to InternalSize and Buffer is needed to do block memory copies into SOCKADDR_STORAGE structures, while the only public interface to the same data is on a byte-by-byte this property.)\r\n\r\nAlso, implementing SOCKADDR_STORAGE in C# is questionable because AFAICT there\u0027s no way to force a given alignment for structure allocations on the heap. ws2ipdef.h (in the Windows SDK) makes it clear that SOCKADDR_STORAGE is intended to be aligned on a 64-bit boundary. As a result, I wrote this as unsafe code because of how that structure\u0027s alignment is guaranteed in the native code, and my perhaps-naive transliteration of this to C# doesn\u0027t allow for direct byte addressing of the memory occupied by the int64 which occupies the second 8 bytes.\r\n\r\nIf you want to see my first attempt at interim support (which relies on `setsockopt` and doesn\u0027t have final-state-based `WSAioctl` support), it can be found at https://github.com/kyanha/Kyanha.Net.Sockets.Extensions . It does use the Protocol Independent Multicast APIs.",
                                           "updatedAt":  "2021-08-10T04:16:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41WaFK",
                                           "createdAt":  "2021-08-09T09:11:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "Do operating systems nowadays have APIs for dynamically allocating a source-specific multicast address that is not already in use on the same host, as recommended in RFC 4607 section 4.3?  If they do, I hope the feature can be surfaced in .NET as well.  From RFC 6308 section 3.5, it appears that such APIs were not yet widely implemented ten years ago.",
                                           "updatedAt":  "2021-08-09T09:11:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41Y4Q3",
                                           "createdAt":  "2021-08-10T04:12:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kyanha",
                                           "body":  "\u003e Do operating systems nowadays have APIs for dynamically allocating a source-specific multicast address that is not already in use on the same host, as recommended in RFC 4607 section 4.3? If they do, I hope the feature can be surfaced in .NET as well. From RFC 6308 section 3.5, it appears that such APIs were not yet widely implemented ten years ago.\r\n\r\nI can\u0027t find information about such a facility on docs.microsoft.com. I can\u0027t find any information about any RFC 2771 implementation, either.\r\n\r\nMy best current recommendation would be to use a cryptographically-secure random number generator to generate the number of bits you need, and put them into the parts of the address where they need to be. In the case of IPv6, that would be a 1 in 2**31 chance of collision with any specific other source multicast group in use on the host. (If there exist more than one source multicast group already in use, the chances for collision increase accordingly.)",
                                           "updatedAt":  "2021-08-10T06:47:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5e5Oej",
                                           "createdAt":  "2023-06-14T22:13:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Simonl9l",
                                           "body":  "@scalablecory its been  while…any progress on this in the past year or two?\r\n\r\nthanks!",
                                           "updatedAt":  "2023-06-14T22:13:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5e6w3P",
                                           "createdAt":  "2023-06-15T06:49:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "unfortunately no @Simonl9l. This is unlikely to make 8.0. ",
                                           "updatedAt":  "2023-06-15T06:49:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5fI_t1",
                                           "createdAt":  "2023-06-18T16:09:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Simonl9l",
                                           "body":  "@wfurt thanks for the clarification.\r\n\r\nGiven some searching, it seems there may be a [workaround](https://stackoverflow.com/questions/5145804/how-to-join-source-specific-multicast-group-in-c-sharp-igmpv3) for this. If this is accurate, it\u0027s probably good to refer to this here in the proposal. ",
                                           "updatedAt":  "2023-06-18T16:09:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5fLDJC",
                                           "createdAt":  "2023-06-19T08:21:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "With [Socket.SetRawSocketOption](https://learn.microsoft.com/en-us/dotnet/api/system.net.sockets.socket.setrawsocketoption?view=net-7.0) you can do almost anything if you are willing to write platform specific code. ",
                                           "updatedAt":  "2023-06-19T08:21:00Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "Source specific multicast support for sockets",
        "labels":  [
                       "api-suggestion",
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/36951",
        "createdAt":  "2020-05-24T13:20:50Z",
        "number":  36951,
        "author":  "roji",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC7YnXg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Daniel-Svensson",
                                            "createdAt":  "2024-09-27T20:16:56Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-06-10T14:11:33Z",
        "body":  "As part of looking at multiplexing and perf for Linux, I did a quick benchmark of \"gather socket I/O\", i.e. writing multiple buffers to a socket in one go. This would open up some  interesting possibilities to further push perf (and also considerably simplify things for the design). Here are some quick results and observations:\r\n\r\n* Socket.SendPacketsAsync seems to be particularly bad on Linux, since... it doesn\u0027t actually write the buffers in one go, but rather [writes them one-by-one](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Net.Sockets/src/System/Net/Sockets/SocketPal.Unix.cs#L1825).\r\n* Socket.SendPacketsAsync also requires providing a list of [SendPacketsElement](https://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.sendpacketselement?view=netcore-3.1), which is an immutable reference type. That means that unless the buffers and offsets/counts are completely fixed, heap allocations are necessary for each write.\r\n* Socket.SendAsync with SocketAsyncEventArgs.BufferList is much better (\"only\" 3 times slower than regular single-buffer). However, each time SocketAsyncEventArgs.BufferList is set, [the whole array is copied internally](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncEventArgs.cs#L158) to avoid issues with subsequent changes. This again means that it\u0027s impossible to change the buffers/counts/offsets without triggering an expensive re-copying. Note that this re-copying is *not* done in the benchmark below, which reuses the same buffer list.\r\n* The parameters (NumBuffers/BufferSize) are currently set to a typical Npgsql muiltiplexing scenario for TE Fortunes, but can obviously be played with.\r\n\r\nIn other words, there\u0027s definitely work needed (and possibly new APIs) if these are to be useful in a high-perf scenario. Hopefully I didn\u0027t do miss anything or do any silliness in the benchmark, let me know.\r\n\r\nResults:\r\n\r\n``` ini\r\n\r\nBenchmarkDotNet=v0.12.0, OS=ubuntu 20.04\r\nIntel Xeon W-2133 CPU 3.60GHz, 1 CPU, 12 logical and 6 physical cores\r\n.NET Core SDK=5.0.100-preview.3.20216.6\r\n  [Host]     : .NET Core 3.1.1 (CoreCLR 4.700.19.60701, CoreFX 4.700.19.60801), X64 RyuJIT\r\n  DefaultJob : .NET Core 3.1.1 (CoreCLR 4.700.19.60701, CoreFX 4.700.19.60801), X64 RyuJIT\r\n\r\n\r\n```\r\n|                           Method | NumBuffers | BufferSize |      Mean |     Error |    StdDev |\r\n|--------------------------------- |----------- |----------- |----------:|----------:|----------:|\r\n|        NetworkStreamSingleBuffer |         25 |         36 |  1.198 us | 0.0114 us | 0.0106 us |\r\n| SocketAsyncEventArgsSingleBuffer |         25 |         36 |  1.145 us | 0.0110 us | 0.0092 us |\r\n|   SocketAsyncEventArgsBufferList |         25 |         36 |  3.616 us | 0.0158 us | 0.0132 us |\r\n|  SocketAsyncEventArgsSendPackets |         25 |         36 | 42.723 us | 0.2419 us | 0.2145 us |\r\n\r\n\u003cdetails\u003e\r\n\u003csummary\u003eBenchmark code\u003c/summary\u003e\r\n\r\n```c#\r\npublic class Program\r\n{\r\n    const int Port = 9595;\r\n    const string Address = \"127.0.0.1\";\r\n\r\n    DummyServer _server;\r\n    Socket _socket;\r\n    SocketAsyncEventArgs _args;\r\n    NetworkStream _networkStream;\r\n    ManualResetEventSlim _mre;\r\n    \r\n    [Params(25)]\r\n    public int NumBuffers { get; set; }\r\n\r\n    [Params(36)]\r\n    public int BufferSize { get; set; }\r\n\r\n    Memory\u003cbyte\u003e _singleBuffer;\r\n\r\n    public void SetupServerAndConnect()\r\n    {\r\n        _server = new DummyServer();\r\n        _server.Start();\r\n        _socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\r\n        _socket.Connect(new IPEndPoint(IPAddress.Parse(Address), Port));\r\n    }\r\n\r\n    [GlobalCleanup]\r\n    public async Task Cleanup()\r\n    {\r\n        _args?.Dispose();\r\n        _args = null;\r\n        _socket.Close();\r\n        _socket = null;\r\n        _networkStream = null;\r\n        await _server.FinishTask;\r\n    }\r\n\r\n    [GlobalSetup(Target = nameof(NetworkStreamSingleBuffer))]\r\n    public void SetupNetworkStreamSingleBuffer()\r\n    {\r\n        SetupServerAndConnect();\r\n        _networkStream = new NetworkStream(_socket, ownsSocket: false);\r\n        _singleBuffer = new byte[NumBuffers * BufferSize];\r\n    }\r\n    \r\n    [GlobalSetup(Target = nameof(SocketAsyncEventArgsSingleBuffer))]\r\n    public void SetupSocketAsyncEventArgsSingleBuffer()\r\n    {\r\n        SetupServerAndConnect();\r\n        _args = new SocketAsyncEventArgs();\r\n        _args.SetBuffer(new byte[NumBuffers * BufferSize]);\r\n        _mre = new ManualResetEventSlim();\r\n        _args.Completed += (s, e) =\u003e _mre.Set();\r\n    }\r\n\r\n    [GlobalSetup(Target = nameof(SocketAsyncEventArgsBufferList))]\r\n    public void SetupSocketAsyncEventArgsBufferList()\r\n    {\r\n        SetupServerAndConnect();\r\n        var bufferList = new List\u003cArraySegment\u003cbyte\u003e\u003e(NumBuffers);\r\n        for (var i = 0; i \u003c NumBuffers; i++)\r\n            bufferList.Add(new byte[BufferSize]);\r\n        _args = new SocketAsyncEventArgs\r\n        {\r\n            BufferList = bufferList\r\n        };\r\n        _mre = new ManualResetEventSlim();\r\n        _args.Completed += (s, e) =\u003e _mre.Set();\r\n    }\r\n\r\n    [GlobalSetup(Target = nameof(SocketAsyncEventArgsSendPackets))]\r\n    public void SetupSocketAsyncEventArgsSendPackets()\r\n    {\r\n        SetupServerAndConnect();\r\n        _args = new SocketAsyncEventArgs\r\n        {\r\n            SendPacketsElements = new SendPacketsElement[NumBuffers]\r\n        };\r\n        for (var i = 0; i \u003c NumBuffers; i++)\r\n            _args.SendPacketsElements[i] = new SendPacketsElement(new byte[BufferSize]);\r\n        _mre = new ManualResetEventSlim();\r\n        _args.Completed += (s, e) =\u003e _mre.Set();\r\n    }\r\n\r\n    [Benchmark]\r\n    public void NetworkStreamSingleBuffer()\r\n    {\r\n        var t = _networkStream.WriteAsync(_singleBuffer);\r\n        if (!t.IsCompletedSuccessfully)\r\n            throw new Exception(\"Non-synchronous completion\");\r\n    }\r\n    \r\n    [Benchmark]\r\n    public void SocketAsyncEventArgsSingleBuffer()\r\n    {\r\n        // Never completes asynchronously, but adding MRE and event handling because SendPacketsAsync needs it\r\n        _mre.Reset();\r\n        if (_socket.SendAsync(_args))\r\n            _mre.Wait();\r\n    }\r\n    \r\n    [Benchmark]\r\n    public void SocketAsyncEventArgsBufferList()\r\n    {\r\n        // Never completes asynchronously, but adding MRE and event handling because SendPacketsAsync needs it\r\n        _mre.Reset();\r\n        if (_socket.SendAsync(_args))\r\n            _mre.Wait();\r\n    }\r\n\r\n    [Benchmark]\r\n    public void SocketAsyncEventArgsSendPackets()\r\n    {\r\n        // Note: SendPacketsAsync seems to always returns true (non-synchronous completion)\r\n        _mre.Reset();\r\n        if (_socket.SendPacketsAsync(_args))\r\n            _mre.Wait();\r\n    }\r\n\r\n    static void Main() =\u003e BenchmarkRunner.Run\u003cProgram\u003e();\r\n    \r\n    class DummyServer\r\n    {\r\n        TcpListener _listener;\r\n        \r\n        public Task FinishTask { get; private set; }\r\n\r\n        public void Start()\r\n        {\r\n            _listener = new TcpListener(IPAddress.Parse(Address), Port);\r\n            _listener.Start();\r\n            FinishTask = Task.Run(Process);\r\n        }\r\n\r\n        void Process()\r\n        {\r\n            var client = _listener.AcceptTcpClient();\r\n            var buf = new byte[8192];\r\n            var stream = client.GetStream();\r\n            while (stream.Read(buf, 0, buf.Length) != 0)\r\n            {\r\n                // Do nothing with the data\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n/cc @stephentoub @davidfowl @ajcvickers ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOXkAaZg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzMzIzMDAzMA==",
                                           "createdAt":  "2020-05-24T13:20:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nNotify danmosemsft if you want to be subscribed.",
                                           "updatedAt":  "2020-05-24T13:20:56Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzMzIzMTUzMQ==",
                                           "createdAt":  "2020-05-24T13:31:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e the whole array is copied internally to avoid issues with subsequent changes. This again means that it\u0027s impossible to change the buffers/counts/offsets without triggering an expensive re-copying\r\n\r\nHow many buffers are you using such that this copy shows up in profiles as being \"expensive\"? This is copying the buffer references/bounds, not the contents of the buffers.",
                                           "updatedAt":  "2020-05-24T13:31:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzMzIzMjU2NA==",
                                           "createdAt":  "2020-05-24T13:40:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Socket.SendAsync with SocketAsyncEventArgs.BufferList is much better (\"only\" 3 times slower than regular single-buffer).\r\n\r\nFrom a quick look at the benchmark, you\u0027re always copying N bytes, and it\u0027s either all in one buffer or split across M buffers? All in one buffer is always going to be faster. The interesting thing to measure/compare is the overhead it takes to get M buffers into one buffer and sending that vs sending the M buffers sequentially vs sending them all at once.\r\n\r\nOr am I misunderstanding what\u0027s being demonstrated here?",
                                           "updatedAt":  "2020-05-24T16:40:47Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzMzIzNDI4Mw==",
                                           "createdAt":  "2020-05-24T13:52:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Socket.SendPacketsAsync seems to be particularly bad on Linux, since... it doesn\u0027t actually write the buffers in one go, but rather writes them one-by-one.\r\n\r\nThis could certainly be improved. The API that exists is closely tied to the Windows API it was originally wrapping, and supports \"packets\" that are either buffers or files. We need to maintain the relative ordering, and we use sendfile for the files. But the implementation could be changed to build up a list of adjacent buffers and send those in one shot. We\u0027d need to measure to see at what point the overhead of doing so is worthwhile.",
                                           "updatedAt":  "2020-05-24T13:52:29Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzMzI4MDY5OQ==",
                                           "createdAt":  "2020-05-24T19:16:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "roji",
                                           "body":  "I probably should have provided a bit more context here. In my current prototype, multiple producers encode directly into different segments of a single large buffer, which is then written and flushed; the disadvantage is that encoding is serialized, since lengths aren\u0027t necessarily known in advance, and management of multiple encoding producers would be quite complicated. The ideal situation is for each producer to encode on its own (pooled) buffer, which then gets written/flushed along with the others via a single gather I/O operation. Hence the baseline here was comparing to a single buffer write, without implying that the gather operation should be faster or equal to a one-buffer write.\r\n\r\nI\u0027ve updated the benchmark as suggested, parameterized different buffer numbers and sizes, and executed on both Linux and Windows (different machines though!).\r\n\r\n| Benchmark name | Description |\r\n|-------------------------|-----------------|\r\n| NetworkStreamSingleBuffer | Send a single large buffer\r\n| NetworkStreamMultipleBuffers | Send multiple buffers sequentially\r\n| NetworkStreamCopyMultipleBuffersIntoSingle | Copy multiple buffers into a single, large rented array, and send that\r\n| SocketAsyncEventArgsBufferList | Send multiple buffers in one go with the BufferList API\r\n| SocketAsyncEventArgsSendPackets | Send multiple buffers in one go with the SendPackets API\r\n\r\nAll tests send the same amount of bytes per method call. Full results are below, here are some observations:\r\n\r\n* BufferList allocates on Linux, but not on Windows\r\n* On Linux, copying multiple buffers is better than BufferList for smaller buffer sizes (100 \u003c N \u003c 1000), regardless of the number of buffers. On Windows, BufferList is (almost) always better than copying. This may suggest possible room for improvement in the BufferList implementation for Linux.\r\n* In some cases, NetworkStreamSingleBuffer performs better than SocketAsyncEventArgsBufferList. In these cases, it seems that NetworkStreamSingleBuffer allocates.\r\n* On Windows, SendPackets is much better than on Linux (as already mentioned), but still usually performs worse than BufferList (and also allocates), except with the bigger buffer sizes (1000 \u003c N \u003c 10000). The number of buffers doesn\u0027t seem to matter.\r\n* SendPackets can be tweaked via [SendPacketsFlags](https://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.socketasynceventargs.sendpacketsflags?view=netcore-3.1), though that looks like it\u0027s specific to the file sending mode of SendPackets, not to memory buffer (not sure).\r\n\r\n\u003cdetails\u003e\r\n\u003csummary\u003eLinux results\u003c/summary\u003e\r\n\r\n``` ini\r\n\r\nBenchmarkDotNet=v0.12.0, OS=ubuntu 20.04\r\nIntel Xeon W-2133 CPU 3.60GHz, 1 CPU, 12 logical and 6 physical cores\r\n.NET Core SDK=5.0.100-preview.3.20216.6\r\n  [Host]     : .NET Core 3.1.1 (CoreCLR 4.700.19.60701, CoreFX 4.700.19.60801), X64 RyuJIT\r\n  DefaultJob : .NET Core 3.1.1 (CoreCLR 4.700.19.60701, CoreFX 4.700.19.60801), X64 RyuJIT\r\n\r\n\r\n```\r\n|                                     Method | NumBuffers | BufferSize |       Mean |     Error |     StdDev |     Median |  Gen 0 | Gen 1 | Gen 2 | Allocated |\r\n|------------------------------------------- |----------- |----------- |-----------:|----------:|-----------:|-----------:|-------:|------:|------:|----------:|\r\n|                  **NetworkStreamSingleBuffer** |         **10** |         **10** |   **1.681 us** | **0.0333 us** |  **0.0356 us** |   **1.684 us** |      **-** |     **-** |     **-** |         **-** |\r\n|               NetworkStreamMultipleBuffers |         10 |         10 |  16.244 us | 0.3210 us |  0.3153 us |  16.119 us |      - |     - |     - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         10 |         10 |   1.683 us | 0.1376 us |  0.4058 us |   1.895 us |      - |     - |     - |         - |\r\n|             SocketAsyncEventArgsBufferList |         10 |         10 |   3.185 us | 0.0341 us |  0.0302 us |   3.179 us | 0.0648 |     - |     - |     288 B |\r\n|            SocketAsyncEventArgsSendPackets |         10 |         10 |  17.036 us | 0.1362 us |  0.1138 us |  17.038 us | 0.2136 |     - |     - |    1017 B |\r\n|                  **NetworkStreamSingleBuffer** |         **10** |        **100** |   **1.253 us** | **0.0029 us** |  **0.0026 us** |   **1.254 us** |      **-** |     **-** |     **-** |         **-** |\r\n|               NetworkStreamMultipleBuffers |         10 |        100 |  15.294 us | 0.8241 us |  2.4170 us |  16.354 us |      - |     - |     - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         10 |        100 |   1.430 us | 0.0084 us |  0.0074 us |   1.433 us |      - |     - |     - |         - |\r\n|             SocketAsyncEventArgsBufferList |         10 |        100 |   2.309 us | 0.0131 us |  0.0109 us |   2.311 us | 0.0648 |     - |     - |     288 B |\r\n|            SocketAsyncEventArgsSendPackets |         10 |        100 |  16.818 us | 0.7963 us |  2.2329 us |  17.794 us | 0.2136 |     - |     - |    1016 B |\r\n|                  **NetworkStreamSingleBuffer** |         **10** |       **1000** |   **3.098 us** | **0.0618 us** |  **0.0962 us** |   **3.076 us** |      **-** |     **-** |     **-** |         **-** |\r\n|               NetworkStreamMultipleBuffers |         10 |       1000 |  12.139 us | 0.0391 us |  0.0346 us |  12.131 us |      - |     - |     - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         10 |       1000 |   5.060 us | 0.0998 us |  0.1668 us |   5.131 us |      - |     - |     - |         - |\r\n|             SocketAsyncEventArgsBufferList |         10 |       1000 |   4.140 us | 0.0728 us |  0.0681 us |   4.143 us | 0.0610 |     - |     - |     288 B |\r\n|            SocketAsyncEventArgsSendPackets |         10 |       1000 |  13.068 us | 0.1886 us |  0.1672 us |  13.064 us | 0.2289 |     - |     - |    1016 B |\r\n|                  **NetworkStreamSingleBuffer** |         **10** |      **10000** |  **22.499 us** | **0.4488 us** |  **1.1094 us** |  **22.485 us** |      **-** |     **-** |     **-** |       **2 B** |\r\n|               NetworkStreamMultipleBuffers |         10 |      10000 |  31.141 us | 0.5615 us |  0.4689 us |  31.300 us |      - |     - |     - |       1 B |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         10 |      10000 |  30.042 us | 0.5942 us |  1.1448 us |  30.232 us |      - |     - |     - |         - |\r\n|             SocketAsyncEventArgsBufferList |         10 |      10000 |  22.884 us | 0.4510 us |  0.9415 us |  22.855 us | 0.0610 |     - |     - |     290 B |\r\n|            SocketAsyncEventArgsSendPackets |         10 |      10000 |  31.418 us | 0.6147 us |  1.0099 us |  31.234 us | 0.1831 |     - |     - |    1017 B |\r\n|                  **NetworkStreamSingleBuffer** |         **20** |         **10** |   **1.050 us** | **0.0326 us** |  **0.0931 us** |   **1.007 us** |      **-** |     **-** |     **-** |         **-** |\r\n|               NetworkStreamMultipleBuffers |         20 |         10 |  31.815 us | 0.2820 us |  0.2500 us |  31.795 us |      - |     - |     - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         20 |         10 |   1.656 us | 0.1561 us |  0.4602 us |   1.438 us |      - |     - |     - |         - |\r\n|             SocketAsyncEventArgsBufferList |         20 |         10 |   5.307 us | 0.1056 us |  0.2488 us |   5.320 us | 0.1221 |     - |     - |     528 B |\r\n|            SocketAsyncEventArgsSendPackets |         20 |         10 |  34.372 us | 0.3223 us |  0.3015 us |  34.268 us | 0.4272 |     - |     - |    1896 B |\r\n|                  **NetworkStreamSingleBuffer** |         **20** |        **100** |   **1.472 us** | **0.0066 us** |  **0.0058 us** |   **1.470 us** |      **-** |     **-** |     **-** |         **-** |\r\n|               NetworkStreamMultipleBuffers |         20 |        100 |  30.565 us | 1.8321 us |  5.4020 us |  33.213 us |      - |     - |     - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         20 |        100 |   1.706 us | 0.0068 us |  0.0063 us |   1.705 us |      - |     - |     - |         - |\r\n|             SocketAsyncEventArgsBufferList |         20 |        100 |   3.654 us | 0.0196 us |  0.0184 us |   3.659 us | 0.1221 |     - |     - |     528 B |\r\n|            SocketAsyncEventArgsSendPackets |         20 |        100 |  30.806 us | 2.0281 us |  5.9798 us |  34.251 us | 0.4272 |     - |     - |    1896 B |\r\n|                  **NetworkStreamSingleBuffer** |         **20** |       **1000** |   **5.134 us** | **0.1023 us** |  **0.2090 us** |   **5.130 us** |      **-** |     **-** |     **-** |         **-** |\r\n|               NetworkStreamMultipleBuffers |         20 |       1000 |  24.738 us | 0.4434 us |  0.4147 us |  24.732 us |      - |     - |     - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         20 |       1000 |   8.631 us | 0.1723 us |  0.2683 us |   8.573 us |      - |     - |     - |         - |\r\n|             SocketAsyncEventArgsBufferList |         20 |       1000 |   6.891 us | 0.1000 us |  0.0886 us |   6.848 us | 0.1221 |     - |     - |     528 B |\r\n|            SocketAsyncEventArgsSendPackets |         20 |       1000 |  25.447 us | 0.1552 us |  0.1376 us |  25.402 us | 0.4272 |     - |     - |    1896 B |\r\n|                  **NetworkStreamSingleBuffer** |         **20** |      **10000** |  **43.661 us** | **0.8650 us** |  **1.3210 us** |  **43.957 us** |      **-** |     **-** |     **-** |       **4 B** |\r\n|               NetworkStreamMultipleBuffers |         20 |      10000 |  60.014 us | 1.1742 us |  1.0984 us |  60.079 us |      - |     - |     - |       2 B |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         20 |      10000 |  54.904 us | 1.0826 us |  2.3071 us |  54.624 us |      - |     - |     - |       1 B |\r\n|             SocketAsyncEventArgsBufferList |         20 |      10000 |  41.990 us | 0.8255 us |  1.3093 us |  41.916 us | 0.1221 |     - |     - |     528 B |\r\n|            SocketAsyncEventArgsSendPackets |         20 |      10000 |  61.259 us | 1.4364 us |  1.4107 us |  61.050 us | 0.3662 |     - |     - |    1897 B |\r\n|                  **NetworkStreamSingleBuffer** |         **30** |         **10** |   **1.057 us** | **0.0144 us** |  **0.0113 us** |   **1.054 us** |      **-** |     **-** |     **-** |         **-** |\r\n|               NetworkStreamMultipleBuffers |         30 |         10 |  49.629 us | 0.9878 us |  1.2131 us |  49.217 us |      - |     - |     - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         30 |         10 |   1.409 us | 0.0282 us |  0.0602 us |   1.382 us |      - |     - |     - |         - |\r\n|             SocketAsyncEventArgsBufferList |         30 |         10 |   4.709 us | 0.3219 us |  0.9492 us |   4.342 us | 0.1755 |     - |     - |     768 B |\r\n|            SocketAsyncEventArgsSendPackets |         30 |         10 |  53.295 us | 1.0575 us |  1.7375 us |  52.644 us | 0.6104 |     - |     - |    2776 B |\r\n|                  **NetworkStreamSingleBuffer** |         **30** |        **100** |   **1.692 us** | **0.0064 us** |  **0.0057 us** |   **1.691 us** |      **-** |     **-** |     **-** |         **-** |\r\n|               NetworkStreamMultipleBuffers |         30 |        100 |  44.571 us | 3.0315 us |  8.9385 us |  49.222 us |      - |     - |     - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         30 |        100 |   2.195 us | 0.0305 us |  0.0286 us |   2.198 us |      - |     - |     - |         - |\r\n|             SocketAsyncEventArgsBufferList |         30 |        100 |   4.931 us | 0.0334 us |  0.0296 us |   4.940 us | 0.1755 |     - |     - |     768 B |\r\n|            SocketAsyncEventArgsSendPackets |         30 |        100 |  48.878 us | 1.9808 us |  5.8406 us |  51.348 us | 0.6104 |     - |     - |    2776 B |\r\n|                  **NetworkStreamSingleBuffer** |         **30** |       **1000** |   **6.896 us** | **0.1521 us** |  **0.2030 us** |   **6.852 us** |      **-** |     **-** |     **-** |         **-** |\r\n|               NetworkStreamMultipleBuffers |         30 |       1000 |  37.226 us | 0.3521 us |  0.3294 us |  37.185 us |      - |     - |     - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         30 |       1000 |   9.256 us | 0.1843 us |  0.4007 us |   9.240 us |      - |     - |     - |         - |\r\n|             SocketAsyncEventArgsBufferList |         30 |       1000 |   9.996 us | 0.1969 us |  0.3290 us |  10.015 us | 0.1678 |     - |     - |     768 B |\r\n|            SocketAsyncEventArgsSendPackets |         30 |       1000 |  37.859 us | 0.1902 us |  0.1485 us |  37.917 us | 0.6104 |     - |     - |    2776 B |\r\n|                  **NetworkStreamSingleBuffer** |         **30** |      **10000** |  **65.492 us** | **1.2892 us** |  **2.1892 us** |  **65.761 us** |      **-** |     **-** |     **-** |       **5 B** |\r\n|               NetworkStreamMultipleBuffers |         30 |      10000 |  89.947 us | 1.7124 us |  1.6818 us |  90.394 us |      - |     - |     - |       1 B |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         30 |      10000 | 106.631 us | 2.4397 us |  7.1554 us | 106.002 us |      - |     - |     - |       4 B |\r\n|             SocketAsyncEventArgsBufferList |         30 |      10000 |  61.315 us | 1.2136 us |  2.9771 us |  61.580 us | 0.1221 |     - |     - |     779 B |\r\n|            SocketAsyncEventArgsSendPackets |         30 |      10000 |  93.916 us | 1.8228 us |  1.8719 us |  93.266 us | 0.6104 |     - |     - |    2777 B |\r\n|                  **NetworkStreamSingleBuffer** |         **40** |         **10** |   **1.112 us** | **0.0171 us** |  **0.0151 us** |   **1.110 us** |      **-** |     **-** |     **-** |         **-** |\r\n|               NetworkStreamMultipleBuffers |         40 |         10 |  64.648 us | 1.0430 us |  0.9246 us |  64.515 us |      - |     - |     - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         40 |         10 |   1.589 us | 0.0434 us |  0.1266 us |   1.581 us |      - |     - |     - |         - |\r\n|             SocketAsyncEventArgsBufferList |         40 |         10 |   7.375 us | 0.0524 us |  0.0490 us |   7.367 us | 0.2289 |     - |     - |    1008 B |\r\n|            SocketAsyncEventArgsSendPackets |         40 |         10 |  67.361 us | 0.9693 us |  0.9067 us |  67.433 us | 0.7324 |     - |     - |    3656 B |\r\n|                  **NetworkStreamSingleBuffer** |         **40** |        **100** |   **1.818 us** | **0.0347 us** |  **0.0341 us** |   **1.815 us** |      **-** |     **-** |     **-** |         **-** |\r\n|               NetworkStreamMultipleBuffers |         40 |        100 |  60.379 us | 3.5290 us | 10.4052 us |  65.571 us |      - |     - |     - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         40 |        100 |   2.198 us | 0.0106 us |  0.0094 us |   2.201 us |      - |     - |     - |         - |\r\n|             SocketAsyncEventArgsBufferList |         40 |        100 |   6.228 us | 0.0207 us |  0.0184 us |   6.229 us | 0.2289 |     - |     - |    1008 B |\r\n|            SocketAsyncEventArgsSendPackets |         40 |        100 |  62.662 us | 3.1433 us |  9.2681 us |  67.246 us | 0.7935 |     - |     - |    3656 B |\r\n|                  **NetworkStreamSingleBuffer** |         **40** |       **1000** |   **9.133 us** | **0.1765 us** |  **0.2295 us** |   **9.068 us** |      **-** |     **-** |     **-** |         **-** |\r\n|               NetworkStreamMultipleBuffers |         40 |       1000 |  48.641 us | 0.4517 us |  0.4004 us |  48.591 us |      - |     - |     - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         40 |       1000 |  17.113 us | 0.3383 us |  0.5064 us |  17.107 us |      - |     - |     - |         - |\r\n|             SocketAsyncEventArgsBufferList |         40 |       1000 |  12.708 us | 0.2476 us |  0.2316 us |  12.670 us | 0.2289 |     - |     - |    1009 B |\r\n|            SocketAsyncEventArgsSendPackets |         40 |       1000 |  50.512 us | 0.1785 us |  0.1670 us |  50.471 us | 0.7935 |     - |     - |    3656 B |\r\n|                  **NetworkStreamSingleBuffer** |         **40** |      **10000** |  **88.075 us** | **1.7412 us** |  **3.0496 us** |  **88.145 us** |      **-** |     **-** |     **-** |       **7 B** |\r\n|               NetworkStreamMultipleBuffers |         40 |      10000 | 117.651 us | 2.2418 us |  2.4917 us | 117.356 us |      - |     - |     - |       1 B |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         40 |      10000 | 112.583 us | 2.7073 us |  7.9824 us | 111.997 us |      - |     - |     - |       4 B |\r\n|             SocketAsyncEventArgsBufferList |         40 |      10000 |  78.671 us | 1.7015 us |  5.0168 us |  78.457 us | 0.1221 |     - |     - |    1010 B |\r\n|            SocketAsyncEventArgsSendPackets |         40 |      10000 | 121.491 us | 2.3513 us |  2.8877 us | 121.659 us | 0.7324 |     - |     - |    3658 B |\r\n|                  **NetworkStreamSingleBuffer** |         **50** |         **10** |   **1.143 us** | **0.0224 us** |  **0.0343 us** |   **1.123 us** |      **-** |     **-** |     **-** |         **-** |\r\n|               NetworkStreamMultipleBuffers |         50 |         10 |  81.149 us | 0.7877 us |  0.7368 us |  81.007 us |      - |     - |     - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         50 |         10 |   1.573 us | 0.0314 us |  0.0875 us |   1.531 us |      - |     - |     - |         - |\r\n|             SocketAsyncEventArgsBufferList |         50 |         10 |   8.475 us | 0.1018 us |  0.0903 us |   8.460 us | 0.2747 |     - |     - |    1248 B |\r\n|            SocketAsyncEventArgsSendPackets |         50 |         10 |  83.192 us | 0.5231 us |  0.4893 us |  83.153 us | 0.9766 |     - |     - |    4536 B |\r\n|                  **NetworkStreamSingleBuffer** |         **50** |        **100** |   **1.982 us** | **0.0220 us** |  **0.0195 us** |   **1.990 us** |      **-** |     **-** |     **-** |         **-** |\r\n|               NetworkStreamMultipleBuffers |         50 |        100 |  75.753 us | 3.7625 us | 11.0939 us |  80.621 us |      - |     - |     - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         50 |        100 |   3.133 us | 0.0623 us |  0.0667 us |   3.098 us |      - |     - |     - |         - |\r\n|             SocketAsyncEventArgsBufferList |         50 |        100 |   7.461 us | 0.0346 us |  0.0307 us |   7.464 us | 0.2823 |     - |     - |    1248 B |\r\n|            SocketAsyncEventArgsSendPackets |         50 |        100 |  75.057 us | 5.5594 us | 16.3921 us |  84.178 us | 0.9766 |     - |     - |    4536 B |\r\n|                  **NetworkStreamSingleBuffer** |         **50** |       **1000** |  **10.730 us** | **0.2130 us** |  **0.2279 us** |  **10.659 us** |      **-** |     **-** |     **-** |         **-** |\r\n|               NetworkStreamMultipleBuffers |         50 |       1000 |  61.631 us | 0.6201 us |  0.5801 us |  61.501 us |      - |     - |     - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         50 |       1000 |  17.215 us | 0.3236 us |  0.4208 us |  17.232 us |      - |     - |     - |         - |\r\n|             SocketAsyncEventArgsBufferList |         50 |       1000 |  15.862 us | 0.3152 us |  0.4908 us |  15.870 us | 0.2747 |     - |     - |    1249 B |\r\n|            SocketAsyncEventArgsSendPackets |         50 |       1000 |  63.352 us | 0.2720 us |  0.2123 us |  63.364 us | 0.9766 |     - |     - |    4536 B |\r\n|                  **NetworkStreamSingleBuffer** |         **50** |      **10000** | **108.719 us** | **2.1416 us** |  **3.2054 us** | **108.736 us** |      **-** |     **-** |     **-** |      **12 B** |\r\n|               NetworkStreamMultipleBuffers |         50 |      10000 | 148.399 us | 3.2352 us |  4.4284 us | 148.460 us |      - |     - |     - |       2 B |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         50 |      10000 | 127.577 us | 2.5284 us |  6.4357 us | 128.348 us |      - |     - |     - |       1 B |\r\n|             SocketAsyncEventArgsBufferList |         50 |      10000 |  98.270 us | 2.0086 us |  5.8909 us |  97.926 us | 0.2441 |     - |     - |    1311 B |\r\n|            SocketAsyncEventArgsSendPackets |         50 |      10000 | 153.122 us | 3.0482 us |  4.1725 us | 153.159 us | 0.9766 |     - |     - |    4539 B |\r\n\u003c/details\u003e\r\n\r\n\u003cdetails\u003e\r\n\u003csummary\u003eWindows results\u003c/summary\u003e\r\n\r\n``` ini\r\n\r\nBenchmarkDotNet=v0.12.1, OS=Windows 10.0.18363.836 (1909/November2018Update/19H2)\r\nIntel Core i7-9750H CPU 2.60GHz, 1 CPU, 12 logical and 6 physical cores\r\n.NET Core SDK=3.1.300\r\n  [Host]     : .NET Core 3.1.4 (CoreCLR 4.700.20.20201, CoreFX 4.700.20.22101), X64 RyuJIT\r\n  DefaultJob : .NET Core 3.1.4 (CoreCLR 4.700.20.20201, CoreFX 4.700.20.22101), X64 RyuJIT\r\n\r\n\r\n```\r\n|                                     Method | NumBuffers | BufferSize |       Mean |      Error |     StdDev |     Median | Ratio | RatioSD |  Gen 0 | Gen 1 | Gen 2 | Allocated |\r\n|------------------------------------------- |----------- |----------- |-----------:|-----------:|-----------:|-----------:|------:|--------:|-------:|------:|------:|----------:|\r\n|                  **NetworkStreamSingleBuffer** |         **10** |         **10** |   **5.310 μs** |  **0.1059 μs** |  **0.1680 μs** |   **5.341 μs** |  **1.00** |    **0.00** |      **-** |     **-** |     **-** |         **-** |\r\n|               NetworkStreamMultipleBuffers |         10 |         10 |  51.103 μs |  0.3414 μs |  0.3026 μs |  51.090 μs |  9.76 |    0.50 |      - |     - |     - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         10 |         10 |   5.314 μs |  0.1062 μs |  0.1305 μs |   5.345 μs |  1.01 |    0.05 |      - |     - |     - |         - |\r\n|             SocketAsyncEventArgsBufferList |         10 |         10 |   5.134 μs |  0.0319 μs |  0.0299 μs |   5.144 μs |  0.98 |    0.05 |      - |     - |     - |         - |\r\n|            SocketAsyncEventArgsSendPackets |         10 |         10 |  13.156 μs |  0.0773 μs |  0.0685 μs |  13.159 μs |  2.51 |    0.13 | 0.0458 |     - |     - |     368 B |\r\n|                                            |            |            |            |            |            |            |       |         |        |       |       |           |\r\n|                  **NetworkStreamSingleBuffer** |         **10** |        **100** |   **5.251 μs** |  **0.1036 μs** |  **0.2162 μs** |   **5.269 μs** |  **1.00** |    **0.00** |      **-** |     **-** |     **-** |         **-** |\r\n|               NetworkStreamMultipleBuffers |         10 |        100 |  50.448 μs |  1.3837 μs |  4.0365 μs |  49.798 μs |  9.34 |    1.01 |      - |     - |     - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         10 |        100 |   6.132 μs |  0.1214 μs |  0.1661 μs |   6.097 μs |  1.18 |    0.11 |      - |     - |     - |         - |\r\n|             SocketAsyncEventArgsBufferList |         10 |        100 |   5.820 μs |  0.1155 μs |  0.2359 μs |   5.852 μs |  1.11 |    0.08 |      - |     - |     - |         - |\r\n|            SocketAsyncEventArgsSendPackets |         10 |        100 |  15.997 μs |  0.3178 μs |  0.5567 μs |  16.029 μs |  3.06 |    0.21 | 0.0458 |     - |     - |     368 B |\r\n|                                            |            |            |            |            |            |            |       |         |        |       |       |           |\r\n|                  **NetworkStreamSingleBuffer** |         **10** |       **1000** |   **5.611 μs** |  **0.1757 μs** |  **0.5180 μs** |   **5.629 μs** |  **1.00** |    **0.00** |      **-** |     **-** |     **-** |         **-** |\r\n|               NetworkStreamMultipleBuffers |         10 |       1000 |  55.607 μs |  2.0389 μs |  5.9152 μs |  56.986 μs | 10.00 |    1.40 |      - |     - |     - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         10 |       1000 |   7.039 μs |  0.3720 μs |  1.0852 μs |   6.500 μs |  1.27 |    0.25 |      - |     - |     - |       2 B |\r\n|             SocketAsyncEventArgsBufferList |         10 |       1000 |   5.623 μs |  0.2575 μs |  0.7592 μs |   5.927 μs |  1.01 |    0.18 |      - |     - |     - |         - |\r\n|            SocketAsyncEventArgsSendPackets |         10 |       1000 |  18.711 μs |  0.0710 μs |  0.0664 μs |  18.718 μs |  3.43 |    0.29 | 0.0305 |     - |     - |     368 B |\r\n|                                            |            |            |            |            |            |            |       |         |        |       |       |           |\r\n|                  **NetworkStreamSingleBuffer** |         **10** |      **10000** |  **35.910 μs** |  **1.2629 μs** |  **3.6437 μs** |  **36.673 μs** |  **1.00** |    **0.00** |      **-** |     **-** |     **-** |         **-** |\r\n|               NetworkStreamMultipleBuffers |         10 |      10000 |  58.625 μs |  1.8727 μs |  5.5218 μs |  60.418 μs |  1.66 |    0.32 |      - |     - |     - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         10 |      10000 |  49.577 μs |  0.7218 μs |  0.6752 μs |  49.608 μs |  1.70 |    0.50 |      - |     - |     - |      19 B |\r\n|             SocketAsyncEventArgsBufferList |         10 |      10000 |  37.742 μs |  0.7500 μs |  0.8637 μs |  37.910 μs |  1.22 |    0.33 |      - |     - |     - |         - |\r\n|            SocketAsyncEventArgsSendPackets |         10 |      10000 |  42.494 μs |  0.2339 μs |  0.2188 μs |  42.421 μs |  1.46 |    0.45 |      - |     - |     - |     368 B |\r\n|                                            |            |            |            |            |            |            |       |         |        |       |       |           |\r\n|                  **NetworkStreamSingleBuffer** |         **20** |         **10** |   **5.206 μs** |  **0.0296 μs** |  **0.0277 μs** |   **5.211 μs** |  **1.00** |    **0.00** |      **-** |     **-** |     **-** |         **-** |\r\n|               NetworkStreamMultipleBuffers |         20 |         10 |  98.887 μs |  1.3435 μs |  1.2567 μs |  99.441 μs | 18.99 |    0.27 |      - |     - |     - |       1 B |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         20 |         10 |   5.603 μs |  0.0231 μs |  0.0216 μs |   5.612 μs |  1.08 |    0.01 |      - |     - |     - |         - |\r\n|             SocketAsyncEventArgsBufferList |         20 |         10 |   5.382 μs |  0.0234 μs |  0.0219 μs |   5.382 μs |  1.03 |    0.01 |      - |     - |     - |         - |\r\n|            SocketAsyncEventArgsSendPackets |         20 |         10 |  14.400 μs |  0.0550 μs |  0.0514 μs |  14.413 μs |  2.77 |    0.02 | 0.1068 |     - |     - |     688 B |\r\n|                                            |            |            |            |            |            |            |       |         |        |       |       |           |\r\n|                  **NetworkStreamSingleBuffer** |         **20** |        **100** |   **5.536 μs** |  **0.0417 μs** |  **0.0391 μs** |   **5.543 μs** |  **1.00** |    **0.00** |      **-** |     **-** |     **-** |         **-** |\r\n|               NetworkStreamMultipleBuffers |         20 |        100 |  99.341 μs |  0.4334 μs |  0.3842 μs |  99.341 μs | 17.95 |    0.13 |      - |     - |     - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         20 |        100 |   5.732 μs |  0.0278 μs |  0.0247 μs |   5.729 μs |  1.04 |    0.01 |      - |     - |     - |         - |\r\n|             SocketAsyncEventArgsBufferList |         20 |        100 |   4.944 μs |  0.3061 μs |  0.9025 μs |   5.438 μs |  0.88 |    0.20 |      - |     - |     - |         - |\r\n|            SocketAsyncEventArgsSendPackets |         20 |        100 |  14.547 μs |  0.1657 μs |  0.1550 μs |  14.470 μs |  2.63 |    0.03 | 0.1068 |     - |     - |     688 B |\r\n|                                            |            |            |            |            |            |            |       |         |        |       |       |           |\r\n|                  **NetworkStreamSingleBuffer** |         **20** |       **1000** |   **8.988 μs** |  **0.1629 μs** |  **0.1444 μs** |   **9.036 μs** |  **1.00** |    **0.00** |      **-** |     **-** |     **-** |       **3 B** |\r\n|               NetworkStreamMultipleBuffers |         20 |       1000 | 101.225 μs |  4.5661 μs | 13.3915 μs | 104.686 μs | 10.39 |    3.04 |      - |     - |     - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         20 |       1000 |  12.872 μs |  0.2839 μs |  0.8326 μs |  12.392 μs |  1.59 |    0.04 |      - |     - |     - |       5 B |\r\n|             SocketAsyncEventArgsBufferList |         20 |       1000 |   7.942 μs |  0.1455 μs |  0.3037 μs |   7.842 μs |  0.92 |    0.03 |      - |     - |     - |         - |\r\n|            SocketAsyncEventArgsSendPackets |         20 |       1000 |  26.798 μs |  0.0947 μs |  0.0886 μs |  26.796 μs |  2.98 |    0.05 | 0.0916 |     - |     - |     688 B |\r\n|                                            |            |            |            |            |            |            |       |         |        |       |       |           |\r\n|                  **NetworkStreamSingleBuffer** |         **20** |      **10000** |  **66.829 μs** |  **1.3360 μs** |  **1.5904 μs** |  **66.775 μs** |  **1.00** |    **0.00** |      **-** |     **-** |     **-** |      **29 B** |\r\n|               NetworkStreamMultipleBuffers |         20 |      10000 |  89.588 μs |  1.1547 μs |  1.0236 μs |  89.430 μs |  1.33 |    0.04 |      - |     - |     - |      16 B |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         20 |      10000 | 100.458 μs |  1.2161 μs |  1.1376 μs | 100.783 μs |  1.50 |    0.04 |      - |     - |     - |      35 B |\r\n|             SocketAsyncEventArgsBufferList |         20 |      10000 |  73.214 μs |  1.0808 μs |  0.9026 μs |  72.933 μs |  1.09 |    0.03 |      - |     - |     - |         - |\r\n|            SocketAsyncEventArgsSendPackets |         20 |      10000 |  67.810 μs |  0.2853 μs |  0.2802 μs |  67.812 μs |  1.01 |    0.02 |      - |     - |     - |     688 B |\r\n|                                            |            |            |            |            |            |            |       |         |        |       |       |           |\r\n|                  **NetworkStreamSingleBuffer** |         **30** |         **10** |   **5.241 μs** |  **0.0344 μs** |  **0.0287 μs** |   **5.254 μs** |  **1.00** |    **0.00** |      **-** |     **-** |     **-** |         **-** |\r\n|               NetworkStreamMultipleBuffers |         30 |         10 | 154.837 μs |  0.4575 μs |  0.4056 μs | 154.853 μs | 29.54 |    0.19 |      - |     - |     - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         30 |         10 |   5.582 μs |  0.1117 μs |  0.3000 μs |   5.631 μs |  1.04 |    0.10 |      - |     - |     - |         - |\r\n|             SocketAsyncEventArgsBufferList |         30 |         10 |   5.343 μs |  0.0127 μs |  0.0106 μs |   5.340 μs |  1.02 |    0.01 |      - |     - |     - |         - |\r\n|            SocketAsyncEventArgsSendPackets |         30 |         10 |  15.146 μs |  0.0682 μs |  0.0638 μs |  15.144 μs |  2.89 |    0.02 | 0.1526 |     - |     - |    1008 B |\r\n|                                            |            |            |            |            |            |            |       |         |        |       |       |           |\r\n|                  **NetworkStreamSingleBuffer** |         **30** |        **100** |   **5.690 μs** |  **0.0501 μs** |  **0.0444 μs** |   **5.697 μs** |  **1.00** |    **0.00** |      **-** |     **-** |     **-** |         **-** |\r\n|               NetworkStreamMultipleBuffers |         30 |        100 | 144.650 μs |  4.5357 μs | 13.2309 μs | 147.184 μs | 24.71 |    4.49 |      - |     - |     - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         30 |        100 |   6.102 μs |  0.1082 μs |  0.1013 μs |   6.132 μs |  1.07 |    0.02 |      - |     - |     - |         - |\r\n|             SocketAsyncEventArgsBufferList |         30 |        100 |   5.841 μs |  0.0503 μs |  0.0470 μs |   5.828 μs |  1.03 |    0.01 |      - |     - |     - |         - |\r\n|            SocketAsyncEventArgsSendPackets |         30 |        100 |  15.770 μs |  0.0750 μs |  0.0702 μs |  15.782 μs |  2.77 |    0.02 | 0.1526 |     - |     - |    1008 B |\r\n|                                            |            |            |            |            |            |            |       |         |        |       |       |           |\r\n|                  **NetworkStreamSingleBuffer** |         **30** |       **1000** |  **11.514 μs** |  **0.1687 μs** |  **0.3168 μs** |  **11.399 μs** |  **1.00** |    **0.00** |      **-** |     **-** |     **-** |       **4 B** |\r\n|               NetworkStreamMultipleBuffers |         30 |       1000 | 152.884 μs |  0.7678 μs |  0.6412 μs | 152.861 μs | 13.05 |    0.25 |      - |     - |     - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         30 |       1000 |  12.394 μs |  0.2224 μs |  0.1971 μs |  12.401 μs |  1.06 |    0.03 |      - |     - |     - |       4 B |\r\n|             SocketAsyncEventArgsBufferList |         30 |       1000 |  12.721 μs |  0.2435 μs |  0.2605 μs |  12.720 μs |  1.09 |    0.04 |      - |     - |     - |         - |\r\n|            SocketAsyncEventArgsSendPackets |         30 |       1000 |  32.859 μs |  0.1714 μs |  0.1338 μs |  32.898 μs |  2.80 |    0.07 | 0.1221 |     - |     - |    1008 B |\r\n|                                            |            |            |            |            |            |            |       |         |        |       |       |           |\r\n|                  **NetworkStreamSingleBuffer** |         **30** |      **10000** |  **59.785 μs** |  **0.4962 μs** |  **0.3874 μs** |  **59.783 μs** |  **1.00** |    **0.00** |      **-** |     **-** |     **-** |         **-** |\r\n|               NetworkStreamMultipleBuffers |         30 |      10000 | 135.953 μs |  2.5654 μs |  2.1422 μs | 136.175 μs |  2.27 |    0.04 |      - |     - |     - |      22 B |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         30 |      10000 | 196.229 μs |  2.5452 μs |  2.2562 μs | 195.844 μs |  3.28 |    0.05 |      - |     - |     - |      80 B |\r\n|             SocketAsyncEventArgsBufferList |         30 |      10000 | 109.449 μs |  1.2758 μs |  1.1934 μs | 109.752 μs |  1.83 |    0.03 |      - |     - |     - |       1 B |\r\n|            SocketAsyncEventArgsSendPackets |         30 |      10000 |  92.665 μs |  0.5370 μs |  0.4484 μs |  92.772 μs |  1.55 |    0.01 |      - |     - |     - |    1008 B |\r\n|                                            |            |            |            |            |            |            |       |         |        |       |       |           |\r\n|                  **NetworkStreamSingleBuffer** |         **40** |         **10** |   **5.305 μs** |  **0.0299 μs** |  **0.0280 μs** |   **5.299 μs** |  **1.00** |    **0.00** |      **-** |     **-** |     **-** |         **-** |\r\n|               NetworkStreamMultipleBuffers |         40 |         10 | 203.825 μs |  3.9899 μs |  3.9186 μs | 204.747 μs | 38.39 |    0.71 |      - |     - |     - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         40 |         10 |   5.624 μs |  0.1411 μs |  0.4161 μs |   5.677 μs |  1.03 |    0.17 |      - |     - |     - |         - |\r\n|             SocketAsyncEventArgsBufferList |         40 |         10 |   5.645 μs |  0.0229 μs |  0.0203 μs |   5.647 μs |  1.06 |    0.01 |      - |     - |     - |         - |\r\n|            SocketAsyncEventArgsSendPackets |         40 |         10 |  16.056 μs |  0.1253 μs |  0.1172 μs |  16.052 μs |  3.03 |    0.03 | 0.1831 |     - |     - |    1328 B |\r\n|                                            |            |            |            |            |            |            |       |         |        |       |       |           |\r\n|                  **NetworkStreamSingleBuffer** |         **40** |        **100** |   **5.908 μs** |  **0.1028 μs** |  **0.0961 μs** |   **5.869 μs** |  **1.00** |    **0.00** |      **-** |     **-** |     **-** |         **-** |\r\n|               NetworkStreamMultipleBuffers |         40 |        100 | 203.884 μs |  0.4843 μs |  0.4293 μs | 203.878 μs | 34.47 |    0.59 |      - |     - |     - |       3 B |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         40 |        100 |   6.277 μs |  0.1031 μs |  0.0964 μs |   6.305 μs |  1.06 |    0.02 |      - |     - |     - |         - |\r\n|             SocketAsyncEventArgsBufferList |         40 |        100 |   6.028 μs |  0.0736 μs |  0.0615 μs |   6.040 μs |  1.02 |    0.02 |      - |     - |     - |         - |\r\n|            SocketAsyncEventArgsSendPackets |         40 |        100 |  16.904 μs |  0.0710 μs |  0.0664 μs |  16.907 μs |  2.86 |    0.05 | 0.1831 |     - |     - |    1328 B |\r\n|                                            |            |            |            |            |            |            |       |         |        |       |       |           |\r\n|                  **NetworkStreamSingleBuffer** |         **40** |       **1000** |  **16.576 μs** |  **0.3294 μs** |  **0.7764 μs** |  **16.299 μs** |  **1.00** |    **0.00** |      **-** |     **-** |     **-** |       **6 B** |\r\n|               NetworkStreamMultipleBuffers |         40 |       1000 | 206.927 μs |  4.0291 μs |  3.9571 μs | 207.926 μs | 11.67 |    0.34 |      - |     - |     - |       3 B |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         40 |       1000 |  17.132 μs |  0.2610 μs |  0.2442 μs |  17.132 μs |  0.97 |    0.02 |      - |     - |     - |         - |\r\n|             SocketAsyncEventArgsBufferList |         40 |       1000 |  14.682 μs |  0.2479 μs |  0.2198 μs |  14.719 μs |  0.83 |    0.02 |      - |     - |     - |         - |\r\n|            SocketAsyncEventArgsSendPackets |         40 |       1000 |  40.045 μs |  0.2153 μs |  0.1681 μs |  39.997 μs |  2.25 |    0.04 | 0.1831 |     - |     - |    1328 B |\r\n|                                            |            |            |            |            |            |            |       |         |        |       |       |           |\r\n|                  **NetworkStreamSingleBuffer** |         **40** |      **10000** | **141.411 μs** |  **2.7909 μs** |  **2.7410 μs** | **142.146 μs** |  **1.00** |    **0.00** |      **-** |     **-** |     **-** |      **41 B** |\r\n|               NetworkStreamMultipleBuffers |         40 |      10000 | 212.469 μs | 12.6034 μs | 37.1613 μs | 222.287 μs |  1.56 |    0.19 |      - |     - |     - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         40 |      10000 | 204.917 μs |  2.2431 μs |  1.9884 μs | 204.908 μs |  1.45 |    0.03 |      - |     - |     - |      78 B |\r\n|             SocketAsyncEventArgsBufferList |         40 |      10000 | 137.543 μs |  2.2148 μs |  2.0717 μs | 137.099 μs |  0.97 |    0.02 |      - |     - |     - |         - |\r\n|            SocketAsyncEventArgsSendPackets |         40 |      10000 | 104.034 μs |  0.7048 μs |  0.5885 μs | 103.974 μs |  0.74 |    0.02 | 0.1221 |     - |     - |    1329 B |\r\n|                                            |            |            |            |            |            |            |       |         |        |       |       |           |\r\n|                  **NetworkStreamSingleBuffer** |         **50** |         **10** |   **5.248 μs** |  **0.0277 μs** |  **0.0259 μs** |   **5.244 μs** |  **1.00** |    **0.00** |      **-** |     **-** |     **-** |         **-** |\r\n|               NetworkStreamMultipleBuffers |         50 |         10 | 253.654 μs |  1.4716 μs |  1.3046 μs | 253.975 μs | 48.29 |    0.30 |      - |     - |     - |       1 B |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         50 |         10 |   5.750 μs |  0.0385 μs |  0.0360 μs |   5.762 μs |  1.10 |    0.01 |      - |     - |     - |         - |\r\n|             SocketAsyncEventArgsBufferList |         50 |         10 |   5.653 μs |  0.0228 μs |  0.0178 μs |   5.656 μs |  1.08 |    0.01 |      - |     - |     - |         - |\r\n|            SocketAsyncEventArgsSendPackets |         50 |         10 |  16.939 μs |  0.0670 μs |  0.0627 μs |  16.939 μs |  3.23 |    0.02 | 0.2441 |     - |     - |    1648 B |\r\n|                                            |            |            |            |            |            |            |       |         |        |       |       |           |\r\n|                  **NetworkStreamSingleBuffer** |         **50** |        **100** |   **5.923 μs** |  **0.1172 μs** |  **0.1990 μs** |   **5.977 μs** |  **1.00** |    **0.00** |      **-** |     **-** |     **-** |         **-** |\r\n|               NetworkStreamMultipleBuffers |         50 |        100 | 248.751 μs |  0.7173 μs |  0.6710 μs | 248.575 μs | 42.65 |    2.45 |      - |     - |     - |       1 B |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         50 |        100 |   6.573 μs |  0.4767 μs |  1.3982 μs |   7.340 μs |  1.03 |    0.26 |      - |     - |     - |         - |\r\n|             SocketAsyncEventArgsBufferList |         50 |        100 |   6.298 μs |  0.1252 μs |  0.3298 μs |   6.358 μs |  1.06 |    0.07 |      - |     - |     - |         - |\r\n|            SocketAsyncEventArgsSendPackets |         50 |        100 |  17.908 μs |  0.1571 μs |  0.1470 μs |  17.928 μs |  3.07 |    0.18 | 0.2441 |     - |     - |    1648 B |\r\n|                                            |            |            |            |            |            |            |       |         |        |       |       |           |\r\n|                  **NetworkStreamSingleBuffer** |         **50** |       **1000** |  **20.506 μs** |  **0.3646 μs** |  **0.3232 μs** |  **20.465 μs** |  **1.00** |    **0.00** |      **-** |     **-** |     **-** |       **7 B** |\r\n|               NetworkStreamMultipleBuffers |         50 |       1000 | 261.622 μs |  9.5744 μs | 28.2304 μs | 268.357 μs | 12.56 |    1.50 |      - |     - |     - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         50 |       1000 |  18.869 μs |  0.3746 μs |  0.8607 μs |  18.623 μs |  0.98 |    0.02 |      - |     - |     - |         - |\r\n|             SocketAsyncEventArgsBufferList |         50 |       1000 |  20.282 μs |  0.4011 μs |  0.6003 μs |  20.119 μs |  1.01 |    0.03 |      - |     - |     - |         - |\r\n|            SocketAsyncEventArgsSendPackets |         50 |       1000 |  39.699 μs |  0.1201 μs |  0.1179 μs |  39.687 μs |  1.94 |    0.03 | 0.2441 |     - |     - |    1648 B |\r\n|                                            |            |            |            |            |            |            |       |         |        |       |       |           |\r\n|                  **NetworkStreamSingleBuffer** |         **50** |      **10000** | **177.767 μs** |  **3.5481 μs** |  **9.3471 μs** | **179.053 μs** |  **1.00** |    **0.00** |      **-** |     **-** |     **-** |         **-** |\r\n|               NetworkStreamMultipleBuffers |         50 |      10000 | 290.140 μs | 14.8617 μs | 43.8201 μs | 313.180 μs |  1.69 |    0.25 |      - |     - |     - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         50 |      10000 | 206.765 μs |  4.0923 μs |  6.3712 μs | 208.200 μs |  1.16 |    0.07 |      - |     - |     - |         - |\r\n|             SocketAsyncEventArgsBufferList |         50 |      10000 | 178.545 μs |  2.8085 μs |  2.3452 μs | 178.241 μs |  1.02 |    0.09 |      - |     - |     - |         - |\r\n|            SocketAsyncEventArgsSendPackets |         50 |      10000 | 150.540 μs |  0.9962 μs |  0.8831 μs | 150.545 μs |  0.86 |    0.08 | 0.2441 |     - |     - |    1649 B |\r\n\u003c/details\u003e\r\n\r\n\u003cdetails\u003e\r\n\u003csummary\u003eBenchmark code\u003c/summary\u003e\r\n\r\n```c#\r\n[MemoryDiagnoser]\r\npublic class Program\r\n{\r\n    const int Port = 9595;\r\n    const string Address = \"127.0.0.1\";\r\n\r\n    DummyServer _server;\r\n    Socket _socket;\r\n    SocketAsyncEventArgs _args;\r\n    NetworkStream _networkStream;\r\n    ManualResetEventSlim _mre;\r\n    \r\n    [Params(10, 20, 30, 40, 50)]\r\n    public int NumBuffers { get; set; }\r\n\r\n    [Params(10, 100, 1000, 10000)]\r\n    public int BufferSize { get; set; }\r\n\r\n    byte[][] _buffers;\r\n    List\u003cArraySegment\u003cbyte\u003e\u003e _bufferList;\r\n    Memory\u003cbyte\u003e _singleBuffer;\r\n\r\n    public void SetupServerAndConnect()\r\n    {\r\n        _server = new DummyServer();\r\n        _server.Start();\r\n        _socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\r\n        _socket.Connect(new IPEndPoint(IPAddress.Parse(Address), Port));\r\n    }\r\n\r\n    [GlobalCleanup]\r\n    public async Task Cleanup()\r\n    {\r\n        _args?.Dispose();\r\n        _args = null;\r\n        _socket.Close();\r\n        _socket = null;\r\n        _networkStream = null;\r\n        await _server.FinishTask;\r\n    }\r\n\r\n    [GlobalSetup(Target = nameof(NetworkStreamSingleBuffer))]\r\n    public void SetupNetworkStreamSingleBuffer()\r\n    {\r\n        SetupServerAndConnect();\r\n        _networkStream = new NetworkStream(_socket, ownsSocket: false);\r\n        _singleBuffer = new byte[NumBuffers * BufferSize];\r\n    }\r\n\r\n    [GlobalSetup(Target = nameof(NetworkStreamMultipleBuffers))]\r\n    public void SetupNetworkStreamMultipleBuffers()\r\n    {\r\n        SetupServerAndConnect();\r\n        _networkStream = new NetworkStream(_socket, ownsSocket: false);\r\n        _buffers = new byte[NumBuffers][];\r\n        for (var i = 0; i \u003c NumBuffers; i++)\r\n            _buffers[i] = new byte[BufferSize];\r\n    }\r\n\r\n    [GlobalSetup(Target = nameof(NetworkStreamCopyMultipleBuffersIntoSingle))]\r\n    public void SetupNetworkStreamCopyMultipleBuffersIntoSingle()\r\n    {\r\n        SetupServerAndConnect();\r\n        _networkStream = new NetworkStream(_socket, ownsSocket: false);\r\n        _buffers = new byte[NumBuffers][];\r\n        for (var i = 0; i \u003c NumBuffers; i++)\r\n            _buffers[i] = new byte[BufferSize];\r\n    }\r\n\r\n    [GlobalSetup(Target = nameof(SocketAsyncEventArgsBufferList))]\r\n    public void SetupSocketAsyncEventArgsBufferList()\r\n    {\r\n        SetupServerAndConnect();\r\n        var bufferList = new List\u003cArraySegment\u003cbyte\u003e\u003e(NumBuffers);\r\n        for (var i = 0; i \u003c NumBuffers; i++)\r\n            bufferList.Add(new byte[BufferSize]);\r\n        _args = new SocketAsyncEventArgs\r\n        {\r\n            BufferList = bufferList\r\n        };\r\n        _mre = new ManualResetEventSlim();\r\n        _args.Completed += (s, e) =\u003e _mre.Set();\r\n    }\r\n    \r\n    [GlobalSetup(Target = nameof(SocketAsyncEventArgsSendPackets))]\r\n    public void SetupSocketAsyncEventArgsSendPackets()\r\n    {\r\n        SetupServerAndConnect();\r\n        _args = new SocketAsyncEventArgs\r\n        {\r\n            SendPacketsElements = new SendPacketsElement[NumBuffers]\r\n        };\r\n        for (var i = 0; i \u003c NumBuffers; i++)\r\n            _args.SendPacketsElements[i] = new SendPacketsElement(new byte[BufferSize]);\r\n        _mre = new ManualResetEventSlim();\r\n        _args.Completed += (s, e) =\u003e _mre.Set();\r\n    }\r\n\r\n    [Benchmark(Baseline = true)]\r\n    public async Task NetworkStreamSingleBuffer()\r\n        =\u003e await _networkStream.WriteAsync(_singleBuffer);\r\n\r\n    [Benchmark]\r\n    public async Task NetworkStreamMultipleBuffers()\r\n    {\r\n        for (var i = 0; i \u003c NumBuffers; i++)\r\n            await _networkStream.WriteAsync(_buffers[i]);\r\n    }\r\n    \r\n    [Benchmark]\r\n    public async Task NetworkStreamCopyMultipleBuffersIntoSingle()\r\n    {\r\n        var singleBuffer = ArrayPool\u003cbyte\u003e.Shared.Rent(NumBuffers * BufferSize);\r\n        for (var i = 0; i \u003c NumBuffers; i++)\r\n            Buffer.BlockCopy(_buffers[i], 0, singleBuffer, i * BufferSize, BufferSize);\r\n        await _networkStream.WriteAsync(singleBuffer);\r\n        ArrayPool\u003cbyte\u003e.Shared.Return(singleBuffer);\r\n    }\r\n\r\n    [Benchmark]\r\n    public void SocketAsyncEventArgsBufferList()\r\n    {\r\n        _mre.Reset();\r\n        if (_socket.SendAsync(_args))\r\n            _mre.Wait();\r\n    }\r\n\r\n    [Benchmark]\r\n    public void SocketAsyncEventArgsSendPackets()\r\n    {\r\n        _mre.Reset();\r\n        if (_socket.SendPacketsAsync(_args))\r\n            _mre.Wait();\r\n    }\r\n\r\n    static void Main(string[] args)\r\n        =\u003e new BenchmarkSwitcher(typeof(Program).GetTypeInfo().Assembly).Run(args);\r\n    \r\n    class DummyServer\r\n    {\r\n        TcpListener _listener;\r\n        \r\n        public Task FinishTask { get; private set; }\r\n\r\n        public void Start()\r\n        {\r\n            _listener = new TcpListener(IPAddress.Parse(Address), Port);\r\n            _listener.Start();\r\n            FinishTask = Task.Run(Process);\r\n        }\r\n\r\n        void Process()\r\n        {\r\n            var client = _listener.AcceptTcpClient();\r\n            var buf = new byte[8192];\r\n            var stream = client.GetStream();\r\n            while (stream.Read(buf, 0, buf.Length) != 0)\r\n            {\r\n                // Do nothing with the data\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\u003c/details\u003e",
                                           "updatedAt":  "2020-05-24T19:27:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzMzI4ODc3MA==",
                                           "createdAt":  "2020-05-24T20:01:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "roji",
                                           "body":  "Just to be clear, this isn\u0027t urgent and I don\u0027t have any immediate pressing need for using this (though I may at some point).",
                                           "updatedAt":  "2020-05-24T20:01:21Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzMzUyNzA4Mw==",
                                           "createdAt":  "2020-05-25T11:31:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "`SocketAsyncEventArgsBufferList` is allocating:\r\n\r\nhttps://github.com/dotnet/runtime/blob/d0e22812943f358b438f1e379ccf99027d34789e/src/libraries/System.Net.Sockets/src/System/Net/Sockets/SocketPal.Unix.cs#L237-L238\r\n\r\nThe IOVector and GCHandles could be stackalloced (up to some bound).",
                                           "updatedAt":  "2020-05-25T11:37:08Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzMzUyOTQ1MA==",
                                           "createdAt":  "2020-05-25T11:38:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e The IOVector and GCHandles could be stackalloced (up to some bound).\r\n\r\nAs the Windows version of this does. Not sure why this one wasn\u0027t changed similarly.",
                                           "updatedAt":  "2020-05-25T11:38:10Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzMzUzNjA4NA==",
                                           "createdAt":  "2020-05-25T11:56:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBFTJww==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "roji",
                                                                               "createdAt":  "2020-05-25T11:57:46Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "stephentoub",
                                                                               "createdAt":  "2020-05-25T11:57:53Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "antoniofreire",
                                                                               "createdAt":  "2020-05-25T23:20:05Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "tmds",
                                           "body":  "@roji Linux defines `UIO_FASTIOV` to `8`. This means up to `8` iovs (`NumBuffers`) will be stackalloced in the kernel. It is an interesting nr to try in the benchmarks.\r\n\r\n\u003e As the Windows version of this does. Not sure why this one wasn\u0027t changed similarly.\r\n\r\n@stephentoub I will take a look at doing this for Unix too.",
                                           "updatedAt":  "2020-05-25T11:56:25Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNjcyNjY0MQ==",
                                           "createdAt":  "2021-03-25T13:18:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBo3sLw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "roji",
                                                                               "createdAt":  "2021-04-28T11:32:22Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "tmds",
                                           "body":  "\u003e The IOVector and GCHandles could be stackalloced (up to some bound).\r\n\r\nThis was implemented a while back in https://github.com/dotnet/runtime/pull/37583.\r\n\r\n@roji these are issues related to multi-buffer APIs: https://github.com/dotnet/runtime/issues/25344, and https://github.com/dotnet/runtime/issues/49941.",
                                           "updatedAt":  "2021-03-25T13:18:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Qq4X7",
                                           "createdAt":  "2022-12-15T17:10:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "triage: We should re-run the benchmarks to see where we are. Perhaps close it in favor of the linked issues.",
                                           "updatedAt":  "2022-12-15T17:10:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5eQBKw",
                                           "createdAt":  "2023-06-07T17:46:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "|                                     Method | NumBuffers | BufferSize |         Mean |       Error |      StdDev |       Median |   Gen0 | Allocated |\r\n|------------------------------------------- |----------- |----------- |-------------:|------------:|------------:|-------------:|-------:|----------:|\r\n|                  NetworkStreamSingleBuffer |         10 |         10 |   1,300.8 ns |    25.88 ns |    47.97 ns |   1,308.8 ns |      - |         - |\r\n|               NetworkStreamMultipleBuffers |         10 |         10 |  11,358.5 ns |   220.98 ns |   436.20 ns |  11,293.1 ns |      - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         10 |         10 |   1,515.2 ns |    29.90 ns |    40.93 ns |   1,528.8 ns |      - |         - |\r\n|             SocketAsyncEventArgsBufferList |         10 |         10 |   2,368.6 ns |    47.27 ns |   108.61 ns |   2,398.3 ns | 0.0343 |     288 B |\r\n|            SocketAsyncEventArgsSendPackets |         10 |         10 |  11,259.7 ns |   224.06 ns |   590.25 ns |  11,120.6 ns | 0.0305 |     296 B |\r\n|                  NetworkStreamSingleBuffer |         10 |        100 |   1,182.8 ns |    23.63 ns |    47.73 ns |   1,182.8 ns |      - |         - |\r\n|               NetworkStreamMultipleBuffers |         10 |        100 |  11,188.4 ns |   223.39 ns |   564.55 ns |  11,051.7 ns |      - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         10 |        100 |   1,255.0 ns |    24.96 ns |    55.82 ns |   1,246.7 ns |      - |         - |\r\n|             SocketAsyncEventArgsBufferList |         10 |        100 |   2,133.4 ns |    42.30 ns |   108.43 ns |   2,121.7 ns | 0.0343 |     288 B |\r\n|            SocketAsyncEventArgsSendPackets |         10 |        100 |  13,220.6 ns |   279.11 ns |   822.97 ns |  13,294.4 ns | 0.0305 |     296 B |\r\n|                  NetworkStreamSingleBuffer |         10 |       1000 |   2,780.3 ns |    55.27 ns |   151.31 ns |   2,859.5 ns |      - |         - |\r\n|               NetworkStreamMultipleBuffers |         10 |       1000 |  10,786.1 ns |   215.70 ns |   473.48 ns |  11,067.2 ns |      - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         10 |       1000 |   4,712.4 ns |    25.78 ns |    22.86 ns |   4,713.8 ns |      - |         - |\r\n|             SocketAsyncEventArgsBufferList |         10 |       1000 |   3,912.1 ns |    78.03 ns |   179.30 ns |   3,988.1 ns | 0.0305 |     288 B |\r\n|            SocketAsyncEventArgsSendPackets |         10 |       1000 |  11,830.6 ns |   230.69 ns |   226.57 ns |  11,830.2 ns | 0.0305 |     296 B |\r\n|                  NetworkStreamSingleBuffer |         10 |      10000 |  23,503.1 ns |   122.67 ns |   108.74 ns |  23,502.5 ns |      - |       3 B |\r\n|               NetworkStreamMultipleBuffers |         10 |      10000 |  29,316.7 ns |   348.88 ns |   309.28 ns |  29,355.6 ns |      - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         10 |      10000 |  31,601.7 ns |   365.07 ns |   323.63 ns |  31,665.7 ns |      - |       3 B |\r\n|             SocketAsyncEventArgsBufferList |         10 |      10000 |  23,663.5 ns |   441.11 ns |   452.99 ns |  23,491.0 ns | 0.0305 |     290 B |\r\n|            SocketAsyncEventArgsSendPackets |         10 |      10000 |  29,388.1 ns |   569.66 ns |   609.53 ns |  29,094.1 ns | 0.0305 |     296 B |\r\n|                  NetworkStreamSingleBuffer |         20 |         10 |     905.6 ns |     9.29 ns |     8.69 ns |     906.3 ns |      - |         - |\r\n|               NetworkStreamMultipleBuffers |         20 |         10 |  23,022.8 ns |   436.78 ns |   408.56 ns |  22,934.1 ns |      - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         20 |         10 |   1,051.0 ns |    20.90 ns |    56.14 ns |   1,078.2 ns |      - |         - |\r\n|             SocketAsyncEventArgsBufferList |         20 |         10 |   5,138.4 ns |   104.88 ns |   309.23 ns |   5,202.3 ns | 0.0610 |     528 B |\r\n|            SocketAsyncEventArgsSendPackets |         20 |         10 |  29,721.5 ns |   441.24 ns |   368.45 ns |  29,764.9 ns | 0.0305 |     456 B |\r\n|                  NetworkStreamSingleBuffer |         20 |        100 |   1,366.4 ns |     7.18 ns |     6.36 ns |   1,366.1 ns |      - |         - |\r\n|               NetworkStreamMultipleBuffers |         20 |        100 |  23,385.9 ns |   257.61 ns |   240.97 ns |  23,396.9 ns |      - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         20 |        100 |   1,769.5 ns |    52.88 ns |   155.08 ns |   1,724.6 ns |      - |         - |\r\n|             SocketAsyncEventArgsBufferList |         20 |        100 |   3,466.1 ns |    29.11 ns |    27.23 ns |   3,476.4 ns | 0.0610 |     528 B |\r\n|            SocketAsyncEventArgsSendPackets |         20 |        100 |  23,955.7 ns |   463.61 ns |   433.66 ns |  23,856.9 ns | 0.0305 |     456 B |\r\n|                  NetworkStreamSingleBuffer |         20 |       1000 |   4,538.2 ns |    89.98 ns |   159.94 ns |   4,593.3 ns |      - |         - |\r\n|               NetworkStreamMultipleBuffers |         20 |       1000 |  21,813.2 ns |   430.41 ns |   935.68 ns |  22,207.4 ns |      - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         20 |       1000 |   8,447.6 ns |   193.06 ns |   569.24 ns |   8,574.3 ns |      - |         - |\r\n|             SocketAsyncEventArgsBufferList |         20 |       1000 |   6,418.6 ns |    56.45 ns |    50.04 ns |   6,407.5 ns | 0.0610 |     528 B |\r\n|            SocketAsyncEventArgsSendPackets |         20 |       1000 |  23,295.8 ns |   249.54 ns |   233.42 ns |  23,224.6 ns | 0.0305 |     456 B |\r\n|                  NetworkStreamSingleBuffer |         20 |      10000 |  46,448.5 ns |   257.51 ns |   240.87 ns |  46,404.3 ns |      - |       7 B |\r\n|               NetworkStreamMultipleBuffers |         20 |      10000 |  56,630.3 ns | 1,129.14 ns | 2,639.33 ns |  57,081.9 ns |      - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         20 |      10000 |  60,458.0 ns |   263.37 ns |   233.47 ns |  60,452.0 ns |      - |       6 B |\r\n|             SocketAsyncEventArgsBufferList |         20 |      10000 |  45,904.8 ns |   914.16 ns | 1,220.38 ns |  46,380.7 ns | 0.0610 |     544 B |\r\n|            SocketAsyncEventArgsSendPackets |         20 |      10000 |  55,957.9 ns | 1,106.06 ns | 2,795.15 ns |  57,228.7 ns |      - |     456 B |\r\n|                  NetworkStreamSingleBuffer |         30 |         10 |     916.6 ns |    18.24 ns |    43.70 ns |     936.8 ns |      - |         - |\r\n|               NetworkStreamMultipleBuffers |         30 |         10 |  32,821.0 ns |   655.92 ns | 1,784.48 ns |  33,646.6 ns |      - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         30 |         10 |   1,268.2 ns |    25.34 ns |    63.10 ns |   1,300.5 ns |      - |         - |\r\n|             SocketAsyncEventArgsBufferList |         30 |         10 |   5,318.6 ns |   115.62 ns |   340.91 ns |   5,397.9 ns | 0.0916 |     768 B |\r\n|            SocketAsyncEventArgsSendPackets |         30 |         10 |  35,802.7 ns |   856.06 ns | 2,524.10 ns |  36,231.6 ns | 0.0610 |     616 B |\r\n|                  NetworkStreamSingleBuffer |         30 |        100 |   1,476.6 ns |    29.35 ns |    86.07 ns |   1,529.9 ns |      - |         - |\r\n|               NetworkStreamMultipleBuffers |         30 |        100 |  34,252.3 ns |   714.83 ns | 2,085.18 ns |  34,954.6 ns |      - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         30 |        100 |   2,198.4 ns |    18.21 ns |    17.03 ns |   2,197.5 ns |      - |         - |\r\n|             SocketAsyncEventArgsBufferList |         30 |        100 |   4,563.0 ns |    89.90 ns |   177.44 ns |   4,666.8 ns | 0.0916 |     768 B |\r\n|            SocketAsyncEventArgsSendPackets |         30 |        100 |  37,385.2 ns |   811.40 ns | 2,392.44 ns |  38,525.0 ns | 0.0610 |     616 B |\r\n|                  NetworkStreamSingleBuffer |         30 |       1000 |   6,759.4 ns |   132.26 ns |   197.96 ns |   6,852.4 ns |      - |       1 B |\r\n|               NetworkStreamMultipleBuffers |         30 |       1000 |  32,614.3 ns |   645.57 ns | 1,403.42 ns |  33,550.8 ns |      - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         30 |       1000 |   8,606.1 ns |   172.08 ns |   468.14 ns |   8,832.6 ns |      - |         - |\r\n|             SocketAsyncEventArgsBufferList |         30 |       1000 |   8,817.9 ns |   175.44 ns |   477.29 ns |   9,073.2 ns | 0.0916 |     768 B |\r\n|            SocketAsyncEventArgsSendPackets |         30 |       1000 |  32,953.5 ns |   658.02 ns | 1,485.25 ns |  33,830.3 ns | 0.0610 |     616 B |\r\n|                  NetworkStreamSingleBuffer |         30 |      10000 |  69,041.3 ns | 1,343.07 ns | 1,256.31 ns |  68,999.5 ns |      - |      10 B |\r\n|               NetworkStreamMultipleBuffers |         30 |      10000 |  83,282.6 ns | 1,648.63 ns | 4,457.17 ns |  85,570.1 ns |      - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         30 |      10000 | 120,654.0 ns | 2,328.24 ns | 2,771.60 ns | 121,729.5 ns |      - |      14 B |\r\n|             SocketAsyncEventArgsBufferList |         30 |      10000 |  69,344.8 ns | 1,332.32 ns | 1,534.30 ns |  69,678.4 ns |      - |     817 B |\r\n|            SocketAsyncEventArgsSendPackets |         30 |      10000 |  86,922.9 ns |   670.63 ns |   594.49 ns |  86,850.2 ns |      - |     616 B |\r\n|                  NetworkStreamSingleBuffer |         40 |         10 |     925.3 ns |    18.50 ns |    45.03 ns |     913.4 ns |      - |         - |\r\n|               NetworkStreamMultipleBuffers |         40 |         10 |  43,492.9 ns |   885.69 ns | 2,611.49 ns |  44,581.4 ns |      - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         40 |         10 |   1,271.4 ns |    25.39 ns |    65.98 ns |   1,238.7 ns |      - |         - |\r\n|             SocketAsyncEventArgsBufferList |         40 |         10 |   7,087.8 ns |   141.37 ns |   407.87 ns |   7,311.0 ns | 0.1144 |    1008 B |\r\n|            SocketAsyncEventArgsSendPackets |         40 |         10 |  44,058.9 ns |   900.92 ns | 2,656.37 ns |  45,376.8 ns | 0.0610 |     776 B |\r\n|                  NetworkStreamSingleBuffer |         40 |        100 |   1,601.5 ns |    36.48 ns |   107.56 ns |   1,649.5 ns |      - |         - |\r\n|               NetworkStreamMultipleBuffers |         40 |        100 |  44,597.8 ns | 1,005.22 ns | 2,963.92 ns |  44,909.9 ns |      - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         40 |        100 |   2,181.6 ns |    47.86 ns |   141.11 ns |   2,272.7 ns |      - |         - |\r\n|             SocketAsyncEventArgsBufferList |         40 |        100 |   5,432.5 ns |   108.48 ns |   302.41 ns |   5,342.2 ns | 0.1144 |    1008 B |\r\n|            SocketAsyncEventArgsSendPackets |         40 |        100 |  46,765.6 ns |   998.66 ns | 2,944.58 ns |  48,082.9 ns | 0.0610 |     776 B |\r\n|                  NetworkStreamSingleBuffer |         40 |       1000 |   8,783.9 ns |   172.09 ns |   318.98 ns |   8,972.3 ns |      - |       1 B |\r\n|               NetworkStreamMultipleBuffers |         40 |       1000 |  42,921.8 ns |   852.92 ns | 2,010.44 ns |  43,487.2 ns |      - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         40 |       1000 |  14,557.3 ns |   290.83 ns |   626.04 ns |  14,882.8 ns |      - |       1 B |\r\n|             SocketAsyncEventArgsBufferList |         40 |       1000 |  11,443.1 ns |   228.25 ns |   647.50 ns |  11,806.5 ns | 0.1068 |    1008 B |\r\n|            SocketAsyncEventArgsSendPackets |         40 |       1000 |  43,066.4 ns |   858.76 ns | 2,090.34 ns |  42,310.6 ns | 0.0610 |     776 B |\r\n|                  NetworkStreamSingleBuffer |         40 |      10000 |  89,434.8 ns | 1,781.39 ns | 2,773.41 ns |  90,329.0 ns |      - |      14 B |\r\n|               NetworkStreamMultipleBuffers |         40 |      10000 | 108,034.3 ns | 2,369.21 ns | 6,985.68 ns | 110,596.1 ns |      - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         40 |      10000 | 118,122.5 ns | 2,329.93 ns | 4,914.61 ns | 117,754.5 ns |      - |      13 B |\r\n|             SocketAsyncEventArgsBufferList |         40 |      10000 |  90,070.6 ns | 1,798.41 ns | 3,149.78 ns |  91,536.8 ns | 0.1221 |    1101 B |\r\n|            SocketAsyncEventArgsSendPackets |         40 |      10000 | 109,702.1 ns | 2,502.28 ns | 7,378.04 ns | 114,578.5 ns |      - |     776 B |\r\n|                  NetworkStreamSingleBuffer |         50 |         10 |     955.1 ns |    19.00 ns |    46.26 ns |     935.0 ns |      - |         - |\r\n|               NetworkStreamMultipleBuffers |         50 |         10 |  53,393.6 ns | 1,145.98 ns | 3,378.95 ns |  52,941.6 ns |      - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         50 |         10 |   1,336.4 ns |    20.25 ns |    20.79 ns |   1,331.0 ns |      - |         - |\r\n|             SocketAsyncEventArgsBufferList |         50 |         10 |   7,692.6 ns |   163.91 ns |   483.30 ns |   7,724.8 ns | 0.1450 |    1248 B |\r\n|            SocketAsyncEventArgsSendPackets |         50 |         10 |  57,095.9 ns | 1,260.05 ns | 3,715.27 ns |  55,610.3 ns | 0.0610 |     936 B |\r\n|                  NetworkStreamSingleBuffer |         50 |        100 |   1,634.0 ns |    35.03 ns |   103.30 ns |   1,605.5 ns |      - |         - |\r\n|               NetworkStreamMultipleBuffers |         50 |        100 |  54,188.3 ns | 1,182.35 ns | 3,486.19 ns |  53,357.2 ns |      - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         50 |        100 |   2,799.0 ns |    63.52 ns |   187.29 ns |   2,691.9 ns |      - |         - |\r\n|             SocketAsyncEventArgsBufferList |         50 |        100 |   6,541.6 ns |   130.53 ns |   339.26 ns |   6,447.0 ns | 0.1450 |    1248 B |\r\n|            SocketAsyncEventArgsSendPackets |         50 |        100 |  58,214.7 ns | 1,278.85 ns | 3,770.73 ns |  57,278.6 ns | 0.0610 |     936 B |\r\n|                  NetworkStreamSingleBuffer |         50 |       1000 |  11,031.2 ns |   218.45 ns |   455.98 ns |  11,104.9 ns |      - |       1 B |\r\n|               NetworkStreamMultipleBuffers |         50 |       1000 |  51,014.1 ns | 1,009.05 ns | 2,640.51 ns |  49,887.4 ns |      - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         50 |       1000 |  15,007.8 ns |   333.34 ns |   982.85 ns |  14,857.8 ns |      - |         - |\r\n|             SocketAsyncEventArgsBufferList |         50 |       1000 |  13,191.3 ns |   298.94 ns |   881.44 ns |  13,843.8 ns | 0.1373 |    1248 B |\r\n|            SocketAsyncEventArgsSendPackets |         50 |       1000 |  51,918.1 ns | 1,034.29 ns | 2,778.55 ns |  51,856.8 ns | 0.0610 |     936 B |\r\n|                  NetworkStreamSingleBuffer |         50 |      10000 | 110,541.3 ns | 2,192.01 ns | 3,280.90 ns | 110,214.5 ns |      - |      18 B |\r\n|               NetworkStreamMultipleBuffers |         50 |      10000 | 133,051.2 ns | 3,254.54 ns | 9,596.08 ns | 135,015.7 ns |      - |         - |\r\n| NetworkStreamCopyMultipleBuffersIntoSingle |         50 |      10000 | 117,460.3 ns | 2,329.36 ns | 4,140.44 ns | 115,984.9 ns |      - |      11 B |\r\n|             SocketAsyncEventArgsBufferList |         50 |      10000 | 112,479.8 ns | 2,226.99 ns | 3,659.00 ns | 111,858.5 ns | 0.1221 |    1421 B |\r\n|            SocketAsyncEventArgsSendPackets |         50 |      10000 | 133,664.5 ns | 3,133.41 ns | 9,238.92 ns | 139,065.3 ns |      - |     936 B |",
                                           "updatedAt":  "2023-06-07T17:46:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5eQBpm",
                                           "createdAt":  "2023-06-07T17:48:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "This is latest set with 8.0. But as far as I can tell the `StreamMultipleBuffers` does more work then `SingleBuffer` e.g. the tests are not quite in number of written bytes. ",
                                           "updatedAt":  "2023-06-07T17:48:31Z"
                                       }
                                   ],
                         "totalCount":  13
                     },
        "title":  "Performance of multi-buffer socket write APIs (scatter-gather)",
        "labels":  [
                       "api-suggestion",
                       "area-System.Net.Sockets",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/40207",
        "createdAt":  "2020-07-31T16:24:17Z",
        "number":  40207,
        "author":  "alnikola",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-12-15T17:14:09Z",
        "body":  "Current `SocketsTelemetry` implementation counts only bytes sent/received through various Socket\u0027s Send***/Receive*** methods taking byte array buffers. However, there is also SendFile method taking a file handler instead of a buffer that is not yet covered by the new telemetry.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOUKughA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY2NzIxMTQ2Mg==",
                                           "createdAt":  "2020-07-31T16:24:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in area-owners.md if you want to be subscribed.",
                                           "updatedAt":  "2020-07-31T16:24:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Qq6CE",
                                           "createdAt":  "2022-12-15T17:14:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "any thoughts on this @MihaZupan? ",
                                           "updatedAt":  "2022-12-15T17:14:09Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[Telemetry] Measure number of bytes transferred by Socket.SendFile",
        "labels":  [
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/40374",
        "createdAt":  "2020-08-05T11:33:57Z",
        "number":  40374,
        "author":  "antonfirsov",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-12-15T17:15:58Z",
        "body":  "This is a follow-up on https://github.com/dotnet/runtime/issues/32633#issuecomment-667192865.\r\n\r\nWindows has a built-in support for receiving bytes with `AcceptEx`, which can be utilized by `BeginAccept`/`EndAccept` overloads and `AcceptAsync(SocketAsyncEventArgs)`. \r\nSince such a socket operation does not exist on Unix, we throw `PlatformNotSupportedException` on those platforms. We may  consider emulating this feature instead.\r\n\r\nRelated: #1483",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOJ-JL-w==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY2OTE0MjAxMQ==",
                                           "createdAt":  "2020-08-05T11:33:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in area-owners.md if you want to be subscribed.",
                                           "updatedAt":  "2020-08-05T11:33:59Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Socket: AcceptAsync receiving first block not implemented on Unix",
        "labels":  [
                       "enhancement",
                       "area-System.Net.Sockets",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/42534",
        "createdAt":  "2020-09-21T16:33:36Z",
        "number":  42534,
        "author":  "stephentoub",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-12-15T17:18:47Z",
        "body":  "Separated out of https://github.com/dotnet/runtime/issues/41906\r\n\r\nOn Windows, the Socket.{Begin}SendFile API inherits the limitation of the Win32 TransmitFile function that constraints it to only being able to send int.MaxValue bytes; anything larger results in an error.  This is not a regression, but we should consider supporting this by manually partitioning as the TransmitFile docs suggest.  This already works on Linux and macOS.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOKX-efA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5NjIyOTUwMA==",
                                           "createdAt":  "2020-09-21T16:33:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in area-owners.md if you want to be subscribed.",
                                           "updatedAt":  "2020-09-21T16:33:38Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Consider removing Socket.SendFile 2GB limitation on Windows",
        "labels":  [
                       "area-System.Net.Sockets",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/43383",
        "createdAt":  "2020-10-14T03:44:04Z",
        "number":  43383,
        "author":  "geoffkizer",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-05-13T16:04:59Z",
        "body":  "The Socket class has a finalizer, but it shouldn\u0027t need to have one. It should be able to rely on the finalizer of SafeSocketHandle to handle finalization when necessary, now that the logic in SafeSocketHandle is reliable as of 5.0.\r\n\r\nHaving both of these objects be finalizable is problematic since we can\u0027t control the order in which their finalizers are called, and this may lead to unexpected behavior. It\u0027s also just unneeded overhead in the GC.\r\n\r\nI tested removing the finalizer, and everything works fine on Windows. However, on Linux the SafeSocketHandle is not properly collected. I believe this is because there\u0027s a reference to the SafeSocketHandle held (indirectly) by the SocketAsyncEngine dictionary. We probably need to make this a weak reference, or otherwise change the code so that the reference is not held.\r\n\r\n@antonfirsov @stephentoub @tmds @wfurt \r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOKtdwMQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwODEzNzQ3Mg==",
                                           "createdAt":  "2020-10-14T03:44:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in area-owners.md if you want to be subscribed.",
                                           "updatedAt":  "2020-10-14T03:44:06Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcxODc2MjAzMw==",
                                           "createdAt":  "2020-10-29T13:44:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "It would be nice if we can get rid of the finalizer on Socket. It is not causing any issues afaik.",
                                           "updatedAt":  "2020-10-29T13:44:21Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Remove Socket finalizer and ensure SafeSocketHandle finalization works correctly",
        "labels":  [
                       "enhancement",
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/43385",
        "createdAt":  "2020-10-14T03:57:09Z",
        "number":  43385,
        "author":  "geoffkizer",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-05-13T16:05:31Z",
        "body":  "When you Close a Socket, we cancel any pending IO on that Socket. Currently (and going back to .NET Framework days), if any pending IO operations are actually cancelled, the close changes from a graceful shutdown (FIN) to an abortive shutdown (RST). \r\n\r\nI am not sure why this behavior exists, but I think it is problematic and we should consider changing it so that we still perform a graceful shutdown in these cases.\r\n\r\nIt\u0027s fairly common for users to write a receive loop that continually pulls data from a socket. We do this in our HTTP2 implementation. Because of the above behavior, HTTP2 connections are typically going to be terminated with a RST instead of a FIN, which is not ideal.\r\n\r\nWhat\u0027s worse is that this behavior isn\u0027t deterministic in most cases in practice. Consider the receive loop from above -- most of the time it is waiting for data, and thus has a pending receive IO. But if you happen to call Close when the receive loop has completed a previous IO and hasn\u0027t yet issued the next IO, then you will not get an abortive close in this case. Similarly for the send side.\r\n\r\nUsers can force an abortive shutdown (RST) by calling Close(0) on the socket. If they don\u0027t do this, then presumably they want a graceful shutdown, and we should not override this, especially since we can\u0027t do it in a predictable/deterministic way.\r\n\r\n@antonfirsov @tmds @wfurt @stephentoub  ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOKwvgQg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwODE0MDc0Nw==",
                                           "createdAt":  "2020-10-14T03:57:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in area-owners.md if you want to be subscribed.",
                                           "updatedAt":  "2020-10-14T03:57:11Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwODE1NTk5Mg==",
                                           "createdAt":  "2020-10-14T04:55:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "scalablecory",
                                           "body":  "Do we have any composite operations in sockets right now? We would if we updated `SendFile` to transfer in 2GB increments.\r\n\r\nA graceful shutdown mid-op would be weird.",
                                           "updatedAt":  "2020-10-14T04:55:10Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwODE1NjQzMA==",
                                           "createdAt":  "2020-10-14T04:56:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "scalablecory",
                                           "body":  "Actually, I think for the same reason you\u0027d want cancel to be graceful during a read loop, you\u0027d want it to be abortive in a write loop. I don\u0027t know if there is a correct answer here...",
                                           "updatedAt":  "2020-10-14T04:56:52Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwODE1NzcyNw==",
                                           "createdAt":  "2020-10-14T05:01:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "Yeah, unfortunately, we cannot distinguish between pending reads and pending writes.\r\n\r\nThat said, the same timing issue exists with a write loop: if you happen to call Close while there is not actually an outstanding write, you won\u0027t get an abortive close.\r\n\r\nI think the ultimate answer is that the user needs to decide on graceful vs abortive themselves, based on the state of their app or whatever. The problem is, we\u0027re not letting them do this -- we are changing our behavior based on whether there\u0027s an outstanding IO at the moment or not.\r\n",
                                           "updatedAt":  "2020-10-14T05:01:51Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwODE1ODczNA==",
                                           "createdAt":  "2020-10-14T05:05:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "scalablecory",
                                           "body":  "I think `Close()`/`Dispose()` should be abortive if you haven\u0027t called `Shutdown()` -- very weird that you don\u0027t get an abortive close if there are no pending I/Os, are you sure? Sounds like a bug.",
                                           "updatedAt":  "2020-10-14T05:05:33Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwODE2MDUzOA==",
                                           "createdAt":  "2020-10-14T05:11:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "\u003e I think Close()/Dispose() should be abortive if you haven\u0027t called Shutdown() -- very weird that you don\u0027t get an abortive close if there are no pending I/Os, are you sure? Sounds like a bug.\r\n\r\nI just tested it to confirm, and it is graceful if there\u0027s no pending IO.\r\n\r\nThat said, if we did make Close/Dispose abortive if you haven\u0027t called Shutdown(), then at least that would be consistent and deterministic.",
                                           "updatedAt":  "2020-10-14T05:11:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwODE2MTIzNw==",
                                           "createdAt":  "2020-10-14T05:14:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "FWIW, NetworkStream calls Shutdown in its Dispose (actually InternalShutdown(), but the effect should be the same).",
                                           "updatedAt":  "2020-10-14T05:14:13Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwODE2OTU5Nw==",
                                           "createdAt":  "2020-10-14T05:40:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "scalablecory",
                                           "body":  "\u003e I think `Close()`/`Dispose()` should be abortive if you haven\u0027t called `Shutdown()` -- very weird that you don\u0027t get an abortive close if there are no pending I/Os, are you sure? Sounds like a bug.\r\n\r\nUgh, I forgot about linger. Yeah, we shouldn\u0027t do this (my suggestion) -- it is different from how normal BSD sockets work.\r\n",
                                           "updatedAt":  "2020-10-14T05:40:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwODU5NDMzNQ==",
                                           "createdAt":  "2020-10-14T18:51:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "This is what Unix generally does e.g. close() would flush gracefully all pending data. All the new weird code was added to mimic Windows. (and one would need special call if Reset is really desired)\r\nI think this would be breaking change but I would personally see it as improvement. ",
                                           "updatedAt":  "2020-10-14T18:51:33Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwODY1NjI2MQ==",
                                           "createdAt":  "2020-10-14T20:58:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "@scalablecory we also have some reliability, platform consistency, and code complexity problems around Dispose (see Geoff\u0027s email).\r\n\r\nIt looks like we can overcome these issues easily by altering the default behavior to be graceful.",
                                           "updatedAt":  "2020-10-14T20:58:09Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcxODc1MTU3Ng==",
                                           "createdAt":  "2020-10-29T13:27:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "\u003e What\u0027s worse is that this behavior isn\u0027t deterministic in most cases in practice. \r\n\r\nBecause it is nondeterministic, I also think it makes sense to make Close perform a FIN close even when there are out-standing operations.\r\n\r\nWhen the Socket gets closed by the finalizer, maybe we still want a RST close.",
                                           "updatedAt":  "2020-10-29T13:27:25Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyMjE5ODU5NA==",
                                           "createdAt":  "2020-11-05T07:32:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBV3iLg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "wfurt",
                                                                               "createdAt":  "2020-11-05T18:21:26Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "\u003e When the Socket gets closed by the finalizer, maybe we still want a RST close.\r\n\r\nAgreed, this seems like a case where RST definitely is the appropriate action.",
                                           "updatedAt":  "2020-11-05T07:32:52Z"
                                       }
                                   ],
                         "totalCount":  12
                     },
        "title":  "Consider changing socket close behavior to graceful shutdown when outstanding IO is cancelled",
        "labels":  [
                       "enhancement",
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/43935",
        "createdAt":  "2020-10-28T04:39:06Z",
        "number":  43935,
        "author":  "geoffkizer",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCu0BZw==",
                          "nodes":  [
                                        {
                                            "content":  "EYES",
                                            "user":  "MaxDZ8",
                                            "createdAt":  "2021-01-17T16:03:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sgf",
                                            "createdAt":  "2023-03-10T19:59:43Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2025-07-01T15:29:53Z",
        "body":  "We still have a few gaps in our Socket APIs where we are missing support for Task, Span/Memory, or CancellationToken.\r\n\r\nThis is a mega-issue to track all remaining work here for 6.0.\r\n\r\n### Async Socket APIs:\r\n\r\n- [x] AcceptAsync needs CancellationToken support -- implemented in https://github.com/dotnet/runtime/pull/53340\r\n\r\n```csharp\r\n\tpublic static ValueTask\u003cSocket\u003e AcceptAsync (this Socket socket, CancellationToken cancellationToken);\r\n\tpublic static ValueTask\u003cSocket\u003e AcceptAsync (this Socket socket, Socket acceptSocket, CancellationToken cancellationToken);\r\n```\r\n\r\n- [x] SendToAsync, ReceiveFromAsync, and ReceiveMessageFromAsync need Memory and CancellationToken support -- see #33418. (Note, this should probably wait until #41502 is completed.)\r\n\r\n```csharp\r\n\tpublic static ValueTask\u003cint\u003e SendToAsync(this Socket socket, ReadOnlyMemory\u003cbyte\u003e buffer, SocketFlags socketFlags, EndPoint remoteEP, CancellationToken cancellationToken = null);\r\n\tpublic static ValueTask\u003cSocketReceiveFromResult\u003e ReceiveFromAsync(this Socket socket, Memory\u003cbyte\u003e buffer, SocketFlags socketFlags, EndPoint remoteEP, CancellationToken cancellationToken = null);\r\n\tpublic static ValueTask\u003cSocketReceiveMessageFromResult\u003e ReceiveMessageFromAsync(this Socket socket, Memory\u003cbyte\u003e buffer, SocketFlags socketFlags, EndPoint remoteEP, CancellationToken cancellationToken = null);\r\n```\r\n\r\n- [x] Add Task-based SendFileAsync with Memory and CancellationToken support -- implemented in https://github.com/dotnet/runtime/pull/52208 and https://github.com/dotnet/runtime/pull/53062\r\n\r\n```csharp\r\n        public ValueTask SendFileAsync(string? fileName, CancellationToken cancellationToken = default);\r\n        public ValueTask SendFileAsync(string? fileName, ReadOnlyMemory\u003cbyte\u003e preBuffer, ReadOnlyMemory\u003cbyte\u003e postBuffer, TransmitFileOptions flags, CancellationToken cancellationToken = default);\r\n```\r\n\r\n- [x] Add Task-based DisconnectAsync -- implemented in https://github.com/dotnet/runtime/pull/51213\r\n\r\n```csharp\r\n        public static ValueTask DisconnectAsync(this Socket socket, bool reuseSocket, CancellationToken cancellationToken=default);\r\n```\r\n\r\n### Sync Socket APIs:\r\n\r\n- [x] SendTo, ReceiveFrom, ReceiveMessageFrom need Span support -- implemented in https://github.com/dotnet/runtime/pull/51956 and https://github.com/dotnet/runtime/pull/46285\r\n\r\n```csharp\r\n\tpublic int SendTo(ReadOnlySpan\u003cbyte\u003e buffer, EndPoint remoteEP);\r\n\tpublic int SendTo(ReadOnlySpan\u003cbyte\u003e buffer, SocketFlags socketFlags, EndPoint remoteEP);\r\n\tpublic int ReceiveFrom(Span\u003cbyte\u003e buffer, ref EndPoint remoteEP);\r\n\tpublic int ReceiveFrom(Span\u003cbyte\u003e buffer, SocketFlags socketFlags, ref EndPoint remoteEP);\r\n        public int ReceiveMessageFrom(Span\u003cbyte\u003e buffer, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);\r\n```\r\n\r\n- [x] SendFile needs Span support -- implemented in https://github.com/dotnet/runtime/pull/47230\r\n\r\n```csharp\r\n        public void SendFile(string fileName, ReadOnlySpan\u003cbyte\u003e preBuffer, ReadOnlySpan\u003cbyte\u003e postBuffer, TransmitFileOptions flags);\r\n```\r\n\r\n### Async TcpListener APIs:\r\n\r\n- [x] Accept async methods need CancellationToken support -- implemented in https://github.com/dotnet/runtime/pull/53340\r\n\r\n```csharp\r\n\tpublic ValueTask\u003cSocket\u003e AcceptSocketAsync (CancellationToken cancellationToken);\r\n\tpublic ValueTask\u003cTcpClient\u003e AcceptTcpClientAsync (CancellationToken cancellationToken);\r\n```\r\n\r\n### Async TcpClient APIs:\r\n\r\n- [x] Add missing ConnectAsync overloads -- implemented in https://github.com/dotnet/runtime/pull/44110\r\n\r\n```csharp\r\nnamespace System.Net.Sockets\r\n{\r\n    public class TcpClient : IDisposable\r\n    {\r\n        public Task ConnectAsync(IPEndPoint remoteEP);\r\n        public ValueTask ConnectAsync(IPEndPoint remoteEP, CancellationToken cancellationToken);\r\n    }\r\n}\r\n```\r\n\r\n### UdpClient APIs:\r\n\r\n- [ ] UdpClient Span, Memory, and CancellationToken support -- see https://github.com/dotnet/runtime/issues/864\r\n\r\n```csharp\r\npublic class UdpClient\r\n{\r\n    public int Send(ReadOnlySpan\u003cbyte\u003e datagram);\r\n    public int Send(ReadOnlySpan\u003cbyte\u003e datagram, IPEndPoint endPoint);\r\n    public int Send(ReadOnlySpan\u003cbyte\u003e datagram, string hostname, int port);\r\n    public ValueTask\u003cint\u003e SendAsync(ReadOnlyMemory\u003cbyte\u003e datagram, CancellationToken cancellationToken);\r\n    public ValueTask\u003cint\u003e SendAsync(ReadOnlyMemory\u003cbyte\u003e datagram, IPEndPoint endPoint, CancellationToken cancellationToken);\r\n    public ValueTask\u003cUdpReceiveResult\u003e ReceiveAsync(CancellationToken cancellationToken);\r\n}\r\n```\r\n\r\n### Related issues\r\n\r\n- [x] Move Task-based methods from SocketTaskExtensions to Socket -- see #43901 \r\n- [x] Memory support for SendPacketElements -- see #45267\r\n- [ ] Consider overloads for Task-based methods that remove #SocketFlags argument -- see #43934\r\n- [ ] Remove Socket finalizer and ensure SafeSocketHandle finalization works correctly -- see #43383\r\n- [ ] New APIs for zero-allocation connectionless sockets -- see #30797",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOUKvrYg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcxNzY5MDQzMw==",
                                           "createdAt":  "2020-10-28T04:39:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in area-owners.md if you want to be subscribed.",
                                           "updatedAt":  "2020-10-28T04:39:08Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcxODc1MDgxMA==",
                                           "createdAt":  "2020-10-29T13:26:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GSPP",
                                           "body":  "Is it common policy to not provide `CancellationToken` support for synchronous APIs? It seems just as useful to have it for sync as it is for async.",
                                           "updatedAt":  "2020-10-29T13:26:11Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcxODc2ODY3NA==",
                                           "createdAt":  "2020-10-29T13:54:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "@GSPP for sockets, it\u0027s not possible to implement reliable cancellation of synchronous calls in a cross-platform way. From https://github.com/dotnet/runtime/issues/42686#issuecomment-708937234:\r\n\r\n\u003e Note that POSIX does **not** specify a way to abort on-going synchronous calls. The implementation is relying on OS specifics which work well on Linux, and less well on some other OSes. For best cross-platform behaviour applications should avoid using `Dispose` to abort on-going operations.\r\n\r\n(#42686 is a typical issue around this problem)",
                                           "updatedAt":  "2020-10-29T13:54:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcxODg3OTMzMQ==",
                                           "createdAt":  "2020-10-29T16:44:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "In general we don\u0027t provide CancellationToken support for sync APIs.",
                                           "updatedAt":  "2020-10-29T16:44:07Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcxODkwMDcwNg==",
                                           "createdAt":  "2020-10-29T17:19:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Triage: The APIs should be approved in the spin offs, not in this issue - this one is just tracking all the work.\r\n\r\nNote: Some of the sub-issues are simple, so good for up-for-grabs.",
                                           "updatedAt":  "2020-10-29T17:19:50Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyMzA5OTE2NA==",
                                           "createdAt":  "2020-11-06T14:07:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "\u003e SendToAsync, ReceiveFromAsync, and ReceiveMessageFromAsync need Memory and CancellationToken support -- see #33148.\r\n\r\n@geoffkizer you meant #938 I guess.",
                                           "updatedAt":  "2020-11-06T14:07:47Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyNTA4OTQ0Nw==",
                                           "createdAt":  "2020-11-11T02:32:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "\u003e @geoffkizer you meant #938 I guess.\r\n\r\nActually, I meant #33418, but that links to #938 too. Thanks for catching, fixed now.",
                                           "updatedAt":  "2020-11-11T02:32:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Qq-ti",
                                           "createdAt":  "2022-12-15T17:23:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "triage: we should revisit what is missing and close the mega issue",
                                           "updatedAt":  "2022-12-15T17:23:24Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "Missing Socket APIs mega-issue",
        "labels":  [
                       "enhancement",
                       "area-System.Net.Sockets",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/43966",
        "createdAt":  "2020-10-28T19:09:47Z",
        "number":  43966,
        "author":  "geoffkizer",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-05-13T16:11:17Z",
        "body":  "Currently, for every send/receive operation, we always issue a syscall to see if we can perform the operation synchronously. If this fails (i.e. E_AGAIN), we enqueue the operation and wait for an epoll notification before trying again.\r\n\r\nWe can avoid this initial sync attempt for streaming protocols (i.e. TCP) in many cases by remembering whether the previous send/receive returned a partial response. That is, for receive, it didn\u0027t fill the entire buffer; for send, it didn\u0027t consume the entire buffer. In these cases we can know that the socket is now not ready and we need to wait for another epoll readiness notification. So on the next send/receive, we can detect that the socket is still not ready and skip the attempt to perform the operation synchronously.\r\n\r\nHere is the relevant passage from Linux epoll man:\r\n\r\n```\r\n       9.  Do I need to continuously read/write a file descriptor until\r\n       EAGAIN when using the EPOLLET flag (edge-triggered behavior)?\r\n\r\n       Receiving an event from epoll_wait(2) should suggest to you that\r\n       such file descriptor is ready for the requested I/O operation.\r\n       You must consider it ready until the next (nonblocking)\r\n       read/write yields EAGAIN.  When and how you will use the file\r\n       descriptor is entirely up to you.\r\n\r\n       For packet/token-oriented files (e.g., datagram socket, terminal\r\n       in canonical mode), the only way to detect the end of the\r\n       read/write I/O space is to continue to read/write until EAGAIN.\r\n\r\n       For stream-oriented files (e.g., pipe, FIFO, stream socket), the\r\n       condition that the read/write I/O space is exhausted can also be\r\n       detected by checking the amount of data read from / written to\r\n       the target file descriptor.  For example, if you call read(2) by\r\n       asking to read a certain amount of data and read(2) returns a\r\n       lower number of bytes, you can be sure of having exhausted the\r\n       read I/O space for the file descriptor.  The same is true when\r\n       writing using write(2).  (Avoid this latter technique if you can‐\r\n       not guarantee that the monitored file descriptor always refers to\r\n       a stream-oriented file.)\r\n```\r\n\r\n@adamsitnik prototyped this in #38747 and it showed a nice win -- 5% on TechEmpower JSON. So this definitely seems worth doing.\r\n\r\nIn #38747 we ran into some issues with handling EOF properly -- i.e. EPOLLHUP and/or EPOLLRDHUP. I think these are solvable -- see discussion on that issue. We didn\u0027t have time to chase this down for 5.0.\r\n\r\n@adamsitnik Any other thoughts/comments here?\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOKxFS0Q==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcxODE0ODkwOA==",
                                           "createdAt":  "2020-10-28T19:09:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in area-owners.md if you want to be subscribed.",
                                           "updatedAt":  "2020-10-28T19:09:49Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcxODczMjI4Ng==",
                                           "createdAt":  "2020-10-29T12:52:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "Though the man page says otherwise, I think receive may return with less bytes than the buffer size when there is a signal pending.",
                                           "updatedAt":  "2020-10-29T12:52:24Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyMjE5Nzc1NA==",
                                           "createdAt":  "2020-11-05T07:30:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "\u003e Though the man page says otherwise, I think receive may return with less bytes than the buffer size when there is a signal pending.\r\n\r\nIs there any way we can confirm or deny that?\r\n\r\nI\u0027ve seen references in other projects about leveraging this optimization. (Of course, I can\u0027t find them at the moment...)",
                                           "updatedAt":  "2020-11-05T07:30:51Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyMjU1NTYwMQ==",
                                           "createdAt":  "2020-11-05T18:23:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "I thin receive can receive less than asked for when more data is awailable  - but I would think that is rare case. If this is optimization, that can still work in our favor IMHO. ",
                                           "updatedAt":  "2020-11-05T18:23:29Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Linux sockets perf: Reduce syscalls by being smart about handling partial reads/writes",
        "labels":  [
                       "enhancement",
                       "area-System.Net.Sockets",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/43992",
        "createdAt":  "2020-10-28T22:41:47Z",
        "number":  43992,
        "author":  "geoffkizer",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-05-13T16:12:07Z",
        "body":  "SocketAsyncEngine uses _handleToContextMap to find the SocketAsyncContext associated with each epoll notification.\r\n\r\nWe should be able to replace this with a GCHandle and eliminate the dictionary lookup entirely. We would pass the GCHandle as the data param to epoll_ctl (i.e. TryChangeSocketEventRegistration) instead of the socket handle as we do now. When we receive an epoll notification, we\u0027d simply dereference the GCHandle, which is much cheaper than the dictionary lookup.\r\n\r\nI think the tricky part here is figuring out how to release the GCHandle when we are done with the socket and don\u0027t expect any more epoll notifications. I think we can wait for an EPOLLHUP notification and dispose the GCHandle then -- I believe this will guarantee we won\u0027t get any more epoll notifications for this socket. However, I think from previous experiments here that closing the socket fd will cause epoll notifications to stop, without generating an EPOLLHUP. I think we can deal with this by deferring the actual close until we receive EPOLLHUP, but we need to experiment here.\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOKtc3mQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcxODI0OTk2Mw==",
                                           "createdAt":  "2020-10-28T22:41:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in area-owners.md if you want to be subscribed.",
                                           "updatedAt":  "2020-10-28T22:41:49Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcxODcyOTM4Nw==",
                                           "createdAt":  "2020-10-29T12:46:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "@benaadams I think you suggested/tried this once.",
                                           "updatedAt":  "2020-10-29T12:46:24Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcxODc0NzU0NQ==",
                                           "createdAt":  "2020-10-29T13:20:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "Yes, had an issue with events coming through after the handle was freed, which are currently thrown away with the map lookup (as is no longer there) so that would need to be tightened up.",
                                           "updatedAt":  "2020-10-29T13:20:25Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Linux sockets perf: Replace _handleToContextMap dictionary with GCHandle ",
        "labels":  [
                       "enhancement",
                       "area-System.Net.Sockets",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/46600",
        "createdAt":  "2021-01-05T20:38:40Z",
        "number":  46600,
        "author":  "geoffkizer",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOBpXKZA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "gfoidl",
                                            "createdAt":  "2021-01-06T11:01:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "antonfirsov",
                                            "createdAt":  "2021-01-13T12:28:55Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pentp",
                                            "createdAt":  "2021-05-03T11:02:50Z"
                                        }
                                    ],
                          "totalCount":  3
                      },
        "updatedAt":  "2025-08-06T23:04:01Z",
        "body":  "Currently, if you call a sync Span-based Socket overload like `Socket.Receive(Span\u003cbyte\u003e buffer)`, and we end up going through the sync-over-async path in SocketAsyncContext, we will end up pinning the buffer when data is not immediately available from the socket.\r\n\r\nSee references to BufferPtrReceiveOperation and BufferPtrSendOperation in SocketAsyncContext.\r\n\r\nIn theory, this shouldn\u0027t be necessary. All sync operation handling happens on the original calling thread, so we can simply hold on to the Span there. The problem is that the structure of the code currently requires that we store this state on the Operation object, which means we need to pin the Span and treat it as a native pointer.\r\n\r\nWe should fix this. This would also allow us to remove the duplication of code that currently exists between the byte[] sync overloads and the Span sync overloads.\r\n\r\nMore generally, we shouldn\u0027t really need to store any operation-specific state on the Operation objects for sync operations; it can all live on the calling stack. This would likely simplify the code, and make these operations more efficient since we don\u0027t need to allocate an operation each time.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOvG_ppg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc1NDg4NTI3Ng==",
                                           "createdAt":  "2021-01-05T20:38:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nCurrently, if you call a sync Span-based Socket overload like `Socket.Receive(Span\u003cbyte\u003e buffer)`, and we end up going through the sync-over-async path in SocketAsyncContext, we will end up pinning the buffer when data is not immediately available from the socket.\r\n\r\nSee references to BufferPtrReceiveOperation and BufferPtrSendOperation in SocketAsyncContext.\r\n\r\nIn theory, this shouldn\u0027t be necessary. All sync operation handling happens on the original calling thread, so we can simply hold on to the Span there. The problem is that the structure of the code currently requires that we store this state on the Operation object, which means we need to pin the Span and treat it as a native pointer.\r\n\r\nWe should fix this. This would also allow us to remove the duplication of code that currently exists between the byte[] sync overloads and the Span sync overloads.\r\n\r\nMore generally, we shouldn\u0027t really need to store any operation-specific state on the Operation objects for sync operations; it can all live on the calling stack. This would likely simplify the code, and make these operations more efficient since we don\u0027t need to allocate an operation each time.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003egeoffkizer\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Net.Sockets`, `tenet-performance`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003eFuture\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-01-05T20:38:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3MDgyNzQxNg==",
                                           "createdAt":  "2021-02-01T12:40:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBe02lQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "geoffkizer",
                                                                               "createdAt":  "2021-02-04T07:11:01Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "We should also find new patterns of code sharing to consolidate sync method duplications in `Socket.cs`.\r\n\r\nFor example `Receive(byte[] ...)`, `Receive(Span\u003cbyte\u003e ...)` and `Receive(IList\u003cArraySegment\u003cbyte\u003e\u003e ...)` are mostly duplicates, and the `ReceiveMessageFrom` duplication introduced in #46285 is even worse.",
                                           "updatedAt":  "2021-02-01T12:40:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc68b-mm",
                                           "createdAt":  "2025-08-06T20:11:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Due to lack of recent activity, this issue has been marked as a candidate for backlog cleanup.  It will be closed if no further activity occurs within 14 more days. Any new comment (by anyone, not necessarily the author) will undo this process.\n\nThis process is part of our [issue cleanup automation](https://github.com/dotnet/runtime/blob/main/docs/issue-cleanup.md).\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-08-06T20:11:44Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "SocketAsyncContext should not need to pin Span buffers for sync APIs",
        "labels":  [
                       "enhancement",
                       "area-System.Net.Sockets",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/46785",
        "createdAt":  "2021-01-09T19:43:16Z",
        "number":  46785,
        "author":  "kyanha",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-07-18T16:45:58Z",
        "body":  "I am playing around with multicast UDP and I noticed that on Windows, the behavior of System.Net.Sockets.Socket.ReceiveMessageFrom does not appear to match the behavior documented for Winsock\u0027s recvfrom().  I am uncertain if this is a bug or if I\u0027m just looking in the wrong directions, so I\u0027d like to request support before I dig into it.\r\n\r\nSpecifically, when I ReceiveMessageFrom() into a buffer that\u0027s smaller than the data in the packet, Winsock says that recvfrom() should set an error of WSAEMSGSIZE.  As it stands right now, the buffer is filled with, but the IPPacketInformation.Address field is null on return.  The return value is the size of the buffer that has been filled.  There is apparently no way for me to figure out that it was truncated other than by the absence of the IPPacketInformation.Address field, and absolutely no way for me to figure out what the correct size should be.  (I use SocketOptions.Peek to try to get the necessary size, the way I would on Linux -- and on Linux, it works if I also provide |SocketOptions.Truncated, which makes the return value of ReceiveMessageFrom() be the size of the packet data I need to allocate.  This is not supported by Winsock, so I can\u0027t do it there.)\r\n\r\nTo be clear: the behavior I am seeing does not provide me any indication that the packet has been truncated, where I should be getting an error with the code System.Net.Sockets.SocketError.MessageSize.  Even if I do get SocketError.MessageSize, I am still uncertain where I should look for the necessary buffer size to receive the entire data.\r\n\r\nhttps://github.com/kyanha/MulticastTesting is a repo that shows this behavior.  Load it in Visual Studio and build it, set MulticastReceiver to be the active project and run it; then open a command prompt and run MulticastSender/bin/Debug/net-5.0/MulticastSender.exe.\r\n\r\nhttps://stackoverflow.com/questions/65591484/how-can-i-determine-the-size-of-a-udp-payload-in-windows is a stackoverflow question I asked about it.  I\u0027ve gotten comments from someone whose profile says they\u0027re a Microsoft Program Manager, but no actual answers to my question (other than to overallocate the receiving buffer).\r\n\r\nI also dabble in kernel programming (a filesystem filter driver), and improperly sized buffers offend the discipline I\u0027ve learned for that. Please don\u0027t tell me that I have to waste memory creating a 64KB buffer to handle incoming datagrams on the localhost interface before triple-buffering the packet data; I know the length has to be available somewhere, but I have no idea where.\r\n\r\n\u003c!--This is just a template - feel free to delete any and all of it and replace as appropriate.--\u003e\r\n\r\n### Configuration\r\n\r\ndotnet-5.0 on Windows 10 1909 x64. (I know the OS is mostly out of support, but I haven\u0027t yet diagnosed why it fails to upgrade).  This problem does not appear specific to this configuration.\r\n\r\n### Regression?\r\n\r\nDoes not work in .Net 4.7, either.\r\n\r\n### Other information\r\n\r\nThis probably doesn\u0027t have anything directly to do with this, but I was trying to figure out if there had been something potentially regarding incorrect error values, and I found some mismatches.  System.Net.Primitives contains System.Net.Sockets.SocketError, which contains constants based from decimal 10000 + offsets.  Interop.Unix contains Interop.Error, which contains many definitions which appear strongly related to the SocketError enum, but which are based from hexadecimal 0x10000 + offsets.  Since I\u0027ve gotten it to work on Linux but not Windows, I thought I\u0027d look into it, but this is very confusing and I really don\u0027t want to muck my repo up.\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOMhuQuw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc1NzM1NzMwMQ==",
                                           "createdAt":  "2021-01-09T19:43:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nI am playing around with multicast UDP and I noticed that on Windows, the behavior of System.Net.Sockets.Socket.ReceiveMessageFrom does not appear to match the behavior documented for Winsock\u0027s recvfrom().  I am uncertain if this is a bug or if I\u0027m just looking in the wrong directions, so I\u0027d like to request support before I dig into it.\r\n\r\nSpecifically, when I ReceiveMessageFrom() into a buffer that\u0027s smaller than the data in the packet, Winsock says that recvfrom() should set an error of WSAEMSGSIZE.  As it stands right now, the buffer is filled with, but the IPPacketInformation.Address field is null on return.  The return value is the size of the buffer that has been filled.  There is apparently no way for me to figure out that it was truncated other than by the absence of the IPPacketInformation.Address field, and absolutely no way for me to figure out what the correct size should be.  (I use SocketOptions.Peek to try to get the necessary size, the way I would on Linux -- and on Linux, it works if I also provide |SocketOptions.Truncated, which makes the return value of ReceiveMessageFrom() be the size of the packet data I need to allocate.  This is not supported by Winsock, so I can\u0027t do it there.)\r\n\r\nTo be clear: the behavior I am seeing does not provide me any indication that the packet has been truncated, where I should be getting an error with the code System.Net.Sockets.SocketError.MessageSize.  Even if I do get SocketError.MessageSize, I am still uncertain where I should look for the necessary buffer size to receive the entire data.\r\n\r\nhttps://github.com/kyanha/MulticastTesting is a repo that shows this behavior.  Load it in Visual Studio and build it, set MulticastReceiver to be the active project and run it; then open a command prompt and run MulticastSender/bin/Debug/net-5.0/MulticastSender.exe.\r\n\r\nhttps://stackoverflow.com/questions/65591484/how-can-i-determine-the-size-of-a-udp-payload-in-windows is a stackoverflow question I asked about it.  I\u0027ve gotten comments from someone whose profile says they\u0027re a Microsoft Program Manager, but no actual answers to my question (other than to overallocate the receiving buffer).\r\n\r\nI also dabble in kernel programming (a filesystem filter driver), and improperly sized buffers offend the discipline I\u0027ve learned for that. Please don\u0027t tell me that I have to waste memory creating a 64KB buffer to handle incoming datagrams on the localhost interface before triple-buffering the packet data; I know the length has to be available somewhere, but I have no idea where.\r\n\r\n\u003c!--This is just a template - feel free to delete any and all of it and replace as appropriate.--\u003e\r\n\r\n### Configuration\r\n\r\ndotnet-5.0 on Windows 10 1909 x64. (I know the OS is mostly out of support, but I haven\u0027t yet diagnosed why it fails to upgrade).  This problem does not appear specific to this configuration.\r\n\r\n### Regression?\r\n\r\nDoes not work in .Net 4.7, either.\r\n\r\n### Other information\r\n\r\nThis probably doesn\u0027t have anything directly to do with this, but I was trying to figure out if there had been something potentially regarding incorrect error values, and I found some mismatches.  System.Net.Primitives contains System.Net.Sockets.SocketError, which contains constants based from decimal 10000 + offsets.  Interop.Unix contains Interop.Error, which contains many definitions which appear strongly related to the SocketError enum, but which are based from hexadecimal 0x10000 + offsets.  Since I\u0027ve gotten it to work on Linux but not Windows, I thought I\u0027d look into it, but this is very confusing and I really don\u0027t want to muck my repo up.\r\n\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ekyanha\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Net.Sockets`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-01-09T19:43:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc2ODU1ODc2OA==",
                                           "createdAt":  "2021-01-27T20:32:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "I was able to reproduce this on Windows, however I\u0027m not sure if we can do anything, since we directly wrap the OS calls, and if there is no bug in the wrapper code, we just return whatever is returned by [`WSARecvMsg`](https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms741687(v=vs.85)).\r\n\r\nOn Linux both `ReceiveFrom` and `ReceiveMessageFrom` seem to succeed when the buffer is truncated. **Edit:** I assume this happens because the rest of the message is stored in the kernel receive buffer, and a subsequent `recv(msg)from` will succeed, although I\u0027m not confident in my knowledge here.",
                                           "updatedAt":  "2021-01-29T14:35:28Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc2OTg0MTM4MA==",
                                           "createdAt":  "2021-01-29T14:35:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "According to an ancient comment in our code, WSARecvMsg never returns `WSAEMSGSIZE` directly, data loss is only reported in the async completions:\r\n \r\nhttps://github.com/dotnet/runtime/blob/e9695b8e7840c37390ca58b821cfbeab178d1cc6/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs#L2501-L2504\r\n\r\n@kyanha you should use the asynchronous [ReceiveMessageFromAsync](https://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.socket.receivemessagefromasync?view=net-5.0) to detect data loss, or switch to `ReceiveMessage`.",
                                           "updatedAt":  "2021-01-29T14:35:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3MzQ1NjQ4NA==",
                                           "createdAt":  "2021-02-04T16:56:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Triage: There may be some ways we need to explore -- assigning to @antonfirsov. If not, we should doublecheck with winsock team, then close as by design.",
                                           "updatedAt":  "2021-02-04T16:56:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3NDM3NzQyMw==",
                                           "createdAt":  "2021-02-06T01:55:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kyanha",
                                           "body":  "What I want is for the Peek flag to do what it\u0027s documented to do and\nreturn the size the buffer needs to be. But apparently Winsock2 is the only\nAPI in Windows that doesn\u0027t have a \"query for the necessary buffer size\"\ncapability. And with IPv6 being able to split and reconstitute UDP packets,\nI have no actual way to ensure my buffers are big enough.\n\nI mean, if you\u0027re going to check with the Winsock team, could I ask you to\nmaybe ask them about that as well, and what they recommend I do to work\naround it? Please?\n\nCuz data loss is inevitable otherwise.\n\nOn Thu, Feb 4, 2021, 10:56 Karel Zikmund \u003cnotifications@github.com\u003e wrote:\n\n\u003e Triage: There may be some ways we need to explore -- assigning to\n\u003e @antonfirsov \u003chttps://github.com/antonfirsov\u003e. If not, we should\n\u003e doublecheck with winsock team, then close as by design.\n\u003e\n\u003e —\n\u003e You are receiving this because you were mentioned.\n\u003e Reply to this email directly, view it on GitHub\n\u003e \u003chttps://github.com/dotnet/runtime/issues/46785#issuecomment-773456484\u003e,\n\u003e or unsubscribe\n\u003e \u003chttps://github.com/notifications/unsubscribe-auth/AABMMFNLRJCB54QUWYCKANDS5LGVPANCNFSM4V32GG5A\u003e\n\u003e .\n\u003e\n",
                                           "updatedAt":  "2021-02-06T01:55:44Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc5MDc3OTk5OA==",
                                           "createdAt":  "2021-03-04T17:13:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ManickaP",
                                           "body":  "Triage: we should at least investigate for 6.0.",
                                           "updatedAt":  "2021-03-04T17:13:09Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg0MDY2NzMyMw==",
                                           "createdAt":  "2021-05-13T16:13:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Triage: Moving to Future. It is UDP, hitting only 1 customer. Would be nice to investigate, but does not seem to be critical for 6.0.",
                                           "updatedAt":  "2021-05-13T16:13:48Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "SocketError.MessageSize is not returned by Socket.ReceiveMessageFrom() when buffer too small",
        "labels":  [
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/46860",
        "createdAt":  "2021-01-12T16:58:31Z",
        "number":  46860,
        "author":  "antonfirsov",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-05-13T16:14:55Z",
        "body":  "After setting / using `SocketAsyncEventArgs.BufferList` we should be able to revert to single-buffer mode by calling:\r\n\r\n```C#\r\nsaea.BufferList = null;\r\nsaea.SetBuffer(...);\r\n```\r\n\r\nWhile working on UDP test harmonization, I discovered that this does not work with `ReceiveMessageFrom` on Linux. Haven\u0027t checked other Unixes.\r\n\r\nRepro:\r\n\r\n```C#\r\n[Fact]\r\npublic void ReceiveMessageFromIssue()\r\n{\r\n    using var receiver = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);\r\n    using var sender = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);\r\n    using var saea = new SocketAsyncEventArgs();\r\n    var completed = new ManualResetEventSlim();\r\n    saea.Completed += delegate { completed.Set(); };\r\n\r\n    receiver.Bind(new IPEndPoint(IPAddress.Loopback, 0));\r\n    sender.Bind(new IPEndPoint(IPAddress.Loopback, 0));\r\n    saea.RemoteEndPoint = new IPEndPoint(IPAddress.Any, 0);\r\n\r\n    // Commenting out the following line makes the issue disappear:\r\n    saea.BufferList = new List\u003cArraySegment\u003cbyte\u003e\u003e { new ArraySegment\u003cbyte\u003e(new byte[1]) };\r\n\r\n    saea.BufferList = null;\r\n    saea.SetBuffer(new byte[1024], 0, 1024);\r\n\r\n    sender.SendTo(new byte[1024], receiver.LocalEndPoint);\r\n    if (receiver.ReceiveMessageFromAsync(saea)) \r\n        Assert.True(completed.Wait(1000), \"Expected operation to complete within timeout\");\r\n\r\n    // Fails on Linux, works on Windows:\r\n    Assert.Equal(1024, saea.BytesTransferred);\r\n}\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOMhuScw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc1ODc5NzMwNg==",
                                           "createdAt":  "2021-01-12T16:58:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nAfter setting / using `SocketAsyncEventArgs.BufferList` we should be able to revert to single-buffer mode by calling:\r\n\r\n```C#\r\nsaea.BufferList = null;\r\nsaea.SetBuffer(...);\r\n```\r\n\r\nWhile working on UDP test harmonization, I discovered that this does not work with `ReceiveMessageFrom` on Linux. Haven\u0027t checked with other Unixes.\r\n\r\nRepro:\r\n\r\n```C#\r\n[Fact]\r\npublic void ReceiveMessageFromIssue()\r\n{\r\n    using var receiver = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);\r\n    using var sender = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);\r\n    using var saea = new SocketAsyncEventArgs();\r\n    var completed = new ManualResetEventSlim();\r\n    saea.Completed += delegate { completed.Set(); };\r\n\r\n    receiver.Bind(new IPEndPoint(IPAddress.Loopback, 0));\r\n    sender.Bind(new IPEndPoint(IPAddress.Loopback, 0));\r\n    saea.RemoteEndPoint = new IPEndPoint(IPAddress.Any, 0);\r\n\r\n    // Commenting out the following line makes the issue disappear:\r\n    saea.BufferList = new List\u003cArraySegment\u003cbyte\u003e\u003e { new ArraySegment\u003cbyte\u003e(new byte[1]) };\r\n\r\n    saea.BufferList = null;\r\n    saea.SetBuffer(new byte[1024], 0, 1024);\r\n\r\n    sender.SendTo(new byte[1024], receiver.LocalEndPoint);\r\n    if (receiver.ReceiveMessageFromAsync(saea)) \r\n        Assert.True(completed.Wait(1000), \"Expected operation to complete within timeout\");\r\n\r\n    // Fails on Linux, works on Windows:\r\n    Assert.Equal(1024, saea.BytesTransferred);\r\n}\r\n```\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eantonfirsov\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Net.Sockets`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-01-12T16:58:34Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc1ODg1MjcyNw==",
                                           "createdAt":  "2021-01-12T18:30:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "Good find, thanks.",
                                           "updatedAt":  "2021-01-12T18:30:55Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg0MDY2Nzc2Mw==",
                                           "createdAt":  "2021-05-13T16:14:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Triage: Corner case (unlikely for customers to hit it), fine to move to Future.",
                                           "updatedAt":  "2021-05-13T16:14:55Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "ReceiveMessageFrom does not work correctly on Linux after altering BufferList to a single buffer",
        "labels":  [
                       "bug",
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/47071",
        "createdAt":  "2021-01-16T01:26:06Z",
        "number":  47071,
        "author":  "davidfowl",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-08-18T13:06:34Z",
        "body":  "This [blog post](https://blog.cloudflare.com/sockmap-tcp-splicing-of-the-future/) outlines various techniques for proxying content from one socket to another and one such option is using the [splice(2)](https://man7.org/linux/man-pages/man2/splice.2.html) system call.\r\n\r\nWe could perform this optimization for example with `NetworkStream` in CopyToAsync if the target is a `NetworkStream` (and the sockets are TCP) (this is what go does in it\u0027s networking stack today).\r\n\r\ncc @geoffkizer ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOvG_pMg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc2MTI4NDcyNg==",
                                           "createdAt":  "2021-01-16T01:26:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThis [blog post](https://blog.cloudflare.com/sockmap-tcp-splicing-of-the-future/) outlines various techniques for proxying content from one socket to another and one such option is using the [splice(2)](https://man7.org/linux/man-pages/man2/splice.2.html) system call.\r\n\r\nWe could perform this optimization for example with `NetworkStream` in CopyToAsync if the target is a `NetworkStream` (and the sockets are TCP) (this is what go does in it\u0027s networking stack today).\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003edavidfowl\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Net`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-01-16T01:26:10Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc2MTU1NTExMA==",
                                           "createdAt":  "2021-01-16T12:22:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Certainly interesting to experiment with.\r\n\r\nMy understanding is splice doesn\u0027t actually work socket to socket,  but rather requires one of the ends to be a pipe.  That has a downside of requiring a pipe be created, and could be prohibitive for very small data,  but it also means potentially the approach could be generalized a bit more to allow integration with other stream types. In theory SocketsHttpHandler\u0027s response streams could participate, too, though with some care given content-length and chunk encoding; even so,  with splice taking a size,  it\u0027s theoretically feasible. \r\n\r\nIn practice,  I wonder how impactful it would actually be,  given the prevalence of TLS, the move to HTTP/2 and HTTP/3, etc.\r\n\r\nIf it actually proved impactful, it would be easier to employ if CopyToAsync took a max number of bytes to copy. Adding such an overload to Stream is possible,  but likely with a relatively expensive base implementation that would need to delegate to the existing overloads, and thus require creating a temporary Stream source that wrapped the original and capped the number of bytes that could be read. Most of our streams could override it,  though.",
                                           "updatedAt":  "2021-01-16T12:22:49Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc2MTU1NTIzNA==",
                                           "createdAt":  "2021-01-16T12:23:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThis [blog post](https://blog.cloudflare.com/sockmap-tcp-splicing-of-the-future/) outlines various techniques for proxying content from one socket to another and one such option is using the [splice(2)](https://man7.org/linux/man-pages/man2/splice.2.html) system call.\r\n\r\nWe could perform this optimization for example with `NetworkStream` in CopyToAsync if the target is a `NetworkStream` (and the sockets are TCP) (this is what go does in it\u0027s networking stack today).\r\n\r\ncc @geoffkizer \n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003edavidfowl\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Net.Sockets`, `tenet-performance`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003eFuture\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-01-16T12:23:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc2MzA0NDI3OA==",
                                           "createdAt":  "2021-01-19T18:42:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "\u003e it would be easier to employ if CopyToAsync took a max number of bytes to copy. Adding such an overload to Stream is possible, but likely with a relatively expensive base implementation that would need to delegate to the existing overloads\r\n\r\nMeaning, delegate to existing CopyTo overloads? It seems easier to delegate to Read/Write as the existing base CopyToAsync implementation does. ",
                                           "updatedAt":  "2021-01-19T18:42:14Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc2MzA0ODk5OA==",
                                           "createdAt":  "2021-01-19T18:50:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e It seems easier to delegate to Read/Write as the existing base CopyToAsync implementation does.\r\n\r\nAh, true.",
                                           "updatedAt":  "2021-01-19T18:50:31Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3MzQ2NTY4OQ==",
                                           "createdAt":  "2021-02-04T17:09:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "Triage: this would be only useful for HTTP 1.1 non-chunked, unencrypted requests. Worth investigating but doesn\u0027t seem high prio.\r\n\r\nIf it\u0027s important for YARP common traffic, we can bump priority.",
                                           "updatedAt":  "2021-02-04T17:09:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc68b-ky",
                                           "createdAt":  "2025-08-06T20:11:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Due to lack of recent activity, this issue has been marked as a candidate for backlog cleanup.  It will be closed if no further activity occurs within 14 more days. Any new comment (by anyone, not necessarily the author) will undo this process.\n\nThis process is part of our [issue cleanup automation](https://github.com/dotnet/runtime/blob/main/docs/issue-cleanup.md).\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-08-06T20:11:42Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "Consider using splice(2) to optimize NetworkStream.CopyToAsync",
        "labels":  [
                       "enhancement",
                       "area-System.Net.Sockets",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/47287",
        "createdAt":  "2021-01-21T19:58:22Z",
        "number":  47287,
        "author":  "geoffkizer",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-04-28T16:09:48Z",
        "body":  "If you put a socket into nonblocking mode (i.e. set Socket.Blocking=false) and then call synchronous SendFile, you get unexpected behavior.\r\n\r\nOn Windows, the call will block but will ultimately succeed.\r\n(EDIT: See my comment below for clarification.) _On Linux, you will likely end up with an EWOULDBLOCK result, but this isn\u0027t not reliable; sometimes the call will succeed, sometimes it will send partial data, etc._ \r\n\r\nSendFile is not intended to be used in nonblocking mode. If a user attempts this we should throw InvalidOperationException.\r\n\r\nMore details here: https://github.com/dotnet/runtime/pull/47230#pullrequestreview-572598591\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOMWDRwg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc2NDkwMDEzOA==",
                                           "createdAt":  "2021-01-21T19:58:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nIf you put a socket into nonblocking mode (i.e. set Socket.Blocking=false) and then call synchronous SendFile, you get unexpected behavior.\r\n\r\nOn Windows, the call will block but will ultimately succeed.\r\nOn Linux, you will likely end up with an EWOULDBLOCK result, but this isn\u0027t not reliable; sometimes the call will succeed, sometimes it will send partial data, etc. \r\n\r\nSendFile is not intended to be used in nonblocking mode. If a user attempts this we should throw InvalidOperationException.\r\n\r\nMore details here: https://github.com/dotnet/runtime/pull/47230#pullrequestreview-572598591\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003egeoffkizer\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Net.Sockets`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-01-21T19:58:24Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3MzQ3MzU4MA==",
                                           "createdAt":  "2021-02-04T17:21:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Triage: We should throw as suggested above. Should be fairly straightforward to do.",
                                           "updatedAt":  "2021-02-04T17:21:22Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3NDA0MDIxOA==",
                                           "createdAt":  "2021-02-05T13:42:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jaymin93",
                                           "body":  "Just to understand it better this bug fix would be checking for blocking =false in every synchronous method and throw in case of it is false need to throw invalid operation exception , is my understanding towards this bug is correct? ",
                                           "updatedAt":  "2021-02-05T13:43:31Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3NDA1Njk3NQ==",
                                           "createdAt":  "2021-02-05T14:13:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "\u003e On Linux, you will likely end up with an EWOULDBLOCK result, but this isn\u0027t not reliable; sometimes the call will succeed, sometimes it will send partial data, etc.\r\n\r\nOn Linux this should work.\r\n\r\n`sendfile` works the same as `sendmsg`: you need to call it again until everything was sent, and in case of `EAGAIN/EWOULDBLOCK` wait for `poll`.\r\n\r\n`TryCompleteSendFile` is missing some logic that calls it again on partial sends, like what we have in `TryCompleteSendTo`.",
                                           "updatedAt":  "2021-02-05T14:13:29Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3NDQwOTU4NQ==",
                                           "createdAt":  "2021-02-06T06:28:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "Yeah, my comment above is wrong/confusing.\r\n\r\nI should have said, on Linux, the kernel will buffer as much of the file as it can/wants to, and then tell you how much it sent, just like any other send operation. This will likely result in EWOULDBLOCK if you need to call sendfile multiple times, but that\u0027s not the real problem.\r\n\r\nThe problem is, Socket.SendFile doesn\u0027t return a value telling you how much it actually sent, like Socket.Send does. So there\u0027s no way for the user to know how much of the file was actually sent, which makes the API pretty useless.\r\n\r\nWe could in theory add a new method that returns the bytesSent. But there\u0027s no obvious way to make this work on Windows, since Windows doesn\u0027t seem to actually respect the non-blocking state of the socket for TransmitFile.\r\n\r\nI think the conclusion still stands: we should just fail Socket.SendFile when Socket.Blocking = false.",
                                           "updatedAt":  "2021-02-06T06:32:31Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3NDQxMDUzMw==",
                                           "createdAt":  "2021-02-06T06:39:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "\u003e TryCompleteSendFile is missing some logic that calls it again on partial sends, like what we have in TryCompleteSendTo.\r\n\r\nIn what case in particular? It looks like we are doing the retry logic in SocketAsyncContext. ",
                                           "updatedAt":  "2021-02-06T06:39:01Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3NDQxMDc3MQ==",
                                           "createdAt":  "2021-02-06T06:40:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "\u003e Just to understand it better this bug fix would be checking for blocking =false in every synchronous method and throw in case of it is false need to throw invalid operation exception , is my understanding towards this bug is correct?\r\n\r\nNo, this is specifically about SendFile.",
                                           "updatedAt":  "2021-02-06T06:40:09Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3NDQxMjEwOA==",
                                           "createdAt":  "2021-02-06T06:48:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jaymin93",
                                           "body":  "\u003e \u003e Just to understand it better this bug fix would be checking for blocking =false in every synchronous method and throw in case of it is false need to throw invalid operation exception , is my understanding towards this bug is correct?\r\n\u003e \r\n\u003e No, this is specifically about SendFile.\r\n\r\n\r\n\r\nok so i need to apply blocking =false check for specific method of send file and this will fix this bug , asking because i want to make pr , so before that i need to be clear about what actually case of bug fix, Thanks",
                                           "updatedAt":  "2021-02-06T06:48:44Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3NDQxMjY0NQ==",
                                           "createdAt":  "2021-02-06T06:51:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "SendFile in when Socket.Blocking = false.",
                                           "updatedAt":  "2021-02-06T06:51:02Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3NTk5NTU3NQ==",
                                           "createdAt":  "2021-02-09T14:50:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "\u003e In what case in particular? It looks like we are doing the retry logic in SocketAsyncContext.\r\n\r\nWe\u0027re not looping on partial sends like we do for `TryCompleteSendTo` until there is nothing more to be sent:\r\nhttps://github.com/dotnet/runtime/blob/4df29c9715659a7957ffeae8b79ba8b52d71ba02/src/libraries/System.Net.Sockets/src/System/Net/Sockets/SocketPal.Unix.cs#L883-L885",
                                           "updatedAt":  "2021-02-09T14:50:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3NjE4MDk5OA==",
                                           "createdAt":  "2021-02-09T19:23:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "We are looping in TryCompleteSendFile:\r\n\r\nhttps://github.com/dotnet/runtime/blob/4df29c9715659a7957ffeae8b79ba8b52d71ba02/src/libraries/System.Net.Sockets/src/System/Net/Sockets/SocketPal.Unix.cs#L935",
                                           "updatedAt":  "2021-02-09T19:23:44Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3NjIzNTk1Ng==",
                                           "createdAt":  "2021-02-09T20:51:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "Ah yes.\r\n\r\nIs there a test that occasionally fails on Linux that I can run?",
                                           "updatedAt":  "2021-02-09T20:51:37Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3NjI0MDY0Ng==",
                                           "createdAt":  "2021-02-09T20:59:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "I don\u0027t think there\u0027s an existing test, but there\u0027s discussion of what tests we should have here: https://github.com/dotnet/runtime/pull/47230#pullrequestreview-572598591\r\n\r\n@antonfirsov Did we add a (disabled) test for this?",
                                           "updatedAt":  "2021-02-09T20:59:32Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyODQyODczOA==",
                                           "createdAt":  "2021-04-28T12:50:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vijaya-lakshmi-venkatraman",
                                           "body":  "Hi,\r\nPlease check if my below summary of the required changes is right:\r\n\r\n- File : runtime/src/libraries/System.Net.Sockets/src/System/Net/Sockets/**SocketPal.Unix.cs**\r\n- Function : TryCompleteSendFile\r\n- Changes:\r\n```c#\r\ntry \r\n{\r\n     if(Socket.Binding == false)\r\n     {\r\n            sent = SendFile(socket, handle, ref offset, ref count, out errno);\r\n            bytesSent += sent;\r\n      }\r\n}\r\n```\r\n\r\n1. Is this right?\r\n2. Is it safe to assume that Socket.Binding is always available? I see that Socket.Binding is mentioned in one of the places \r\n```\r\ncase FIONBIO:\r\n                    // The Windows implementation explicitly throws this exception, so that all\r\n                    // changes to blocking/non-blocking are done via Socket.Blocking.\r\n                    throw new InvalidOperationException(SR.net_sockets_useblocking);\r\n``` ",
                                           "updatedAt":  "2021-04-28T16:09:48Z"
                                       }
                                   ],
                         "totalCount":  14
                     },
        "title":  "Socket.SendFile should fail if when Socket.Blocking = false",
        "labels":  [
                       "enhancement",
                       "area-System.Net.Sockets",
                       "good first issue",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/47714",
        "createdAt":  "2021-02-01T17:02:11Z",
        "number":  47714,
        "author":  "antonfirsov",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-05-13T16:17:53Z",
        "body":  "When the socket not bound, all sync and async variants of `ReceiveFrom` and `ReceiveMessageFrom` seem to throw `InvalidOperationException`. \r\n\r\n`SocketAsyncEventArg` overloads fail with `SocketError.InvalidArgument` instead. Furthermore: `ReceiveMessageFrom` hits an assertion failure, and on Unix `ReceiveFrom` does not fail at all.\r\n\r\nI\u0027m not sure if it\u0027s by design, or is it a something we want to change this for consistency.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOMhuaPQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3MTAwNTI0MA==",
                                           "createdAt":  "2021-02-01T17:02:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nWhen the socket not bound, all sync and async variants of `ReceiveFrom` and `ReceiveMessageFrom` seem to throw `InvalidOperationException`, except the `SocketAsyncEventArg` overloads, which throw `SocketException`. `ReceiveMessageFrom` also has a failing assertion in this case.\r\n\r\nWe may want to change this for consistency.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eantonfirsov\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Net.Sockets`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-02-01T17:02:15Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3MjE4MjQ2Ng==",
                                           "createdAt":  "2021-02-03T03:02:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "We should fix the assert at the very least.\r\n\r\n\u003e on Unix ReceiveFrom does not fail at all.\r\n\r\nWhat does it do, just never complete?\r\n\r\nI think we should just change the behavior here to throw `InvalidOperationException` for consistency. It\u0027s a usage error so changing the exception is not a big deal. And that would address the other weirdness here as well.\r\n",
                                           "updatedAt":  "2021-02-03T03:02:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3MjU5MjE4Ng==",
                                           "createdAt":  "2021-02-03T15:25:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "\u003e What does it do, just never complete?\r\n\r\nExactly.",
                                           "updatedAt":  "2021-02-03T15:25:40Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4MTQ5NDE1Ng==",
                                           "createdAt":  "2021-02-18T17:06:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ManickaP",
                                           "body":  "Triage: it makes more sense to throw in advance for protocols that require binding, we should fix for 6.0.",
                                           "updatedAt":  "2021-02-18T17:06:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg0MDY2OTc1Nw==",
                                           "createdAt":  "2021-05-13T16:17:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Triage: UDP corner case, fine to move to Future.",
                                           "updatedAt":  "2021-05-13T16:17:44Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "Unlike other variants, ReceiveFromAsync(saea) and ReceiveMessageFrom(saea) does not throw when socket is not bound",
        "labels":  [
                       "bug",
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/47772",
        "createdAt":  "2021-02-02T16:50:15Z",
        "number":  47772,
        "author":  "antonfirsov",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-01-25T17:24:37Z",
        "body":  "If the address family of the `remoteEP` argument does not match the socket\u0027s address family, variants of `Receive(Message)From` throw an `ArgumentException` thanks to this guard:\r\nhttps://github.com/dotnet/runtime/blob/4df29c9715659a7957ffeae8b79ba8b52d71ba02/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs#L1710-L1714\r\n\r\n`SendTo` has the same limitation, but we do not guard those methods, instead we let the underlying PAL to fail with a `SocketError.InvalidArgument`. We may want to change this behavior for consistency.\r\n\r\nAlso note that the `Recive(Message)From` exception is undocumented.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOMhubkg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3MTc4MDkyMA==",
                                           "createdAt":  "2021-02-02T16:50:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nIf the address family of the `remoteEP` argument does not match the socket\u0027s address family, variants of `Receive(Message)From` throw an `ArgumentException` thanks to this guard:\r\nhttps://github.com/dotnet/runtime/blob/4df29c9715659a7957ffeae8b79ba8b52d71ba02/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs#L1710-L1714\r\n\r\n`SendTo` has the same limitation, but we do not guard those methods, instead we let the underlying PAL to fail with a `SocketError.InvalidArgument`. We may want to change this behavior for consistency.\r\n\r\nAlso note that the `Recive(Message)From` exception is undocumented.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eantonfirsov\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Net.Sockets`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-02-02T16:50:20Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3MjE4NTc2MA==",
                                           "createdAt":  "2021-02-03T03:10:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBeubag==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "antonfirsov",
                                                                               "createdAt":  "2021-02-03T15:24:57Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "I agree, we should change for consistency. \r\n\r\nIn general it seems better to be throwing `ArgumentException` or similar in these cases, since it represents a usage error, as opposed to `SocketException` which could indicate a variety of different issues.",
                                           "updatedAt":  "2021-02-03T03:10:45Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4MTQ5NTA1Nw==",
                                           "createdAt":  "2021-02-18T17:07:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ManickaP",
                                           "body":  "Triage: we should fix for 6.0.",
                                           "updatedAt":  "2021-02-18T17:07:35Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg0MDY3MDA5OA==",
                                           "createdAt":  "2021-05-13T16:18:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Triage: UDP corner case, fine to move to Future.",
                                           "updatedAt":  "2021-05-13T16:18:17Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "SendTo*** and Receive(Message)From*** throw different exceptions when remoteEP AddressFamily does not match",
        "labels":  [
                       "bug",
                       "area-System.Net.Sockets",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/48477",
        "createdAt":  "2021-02-18T20:43:47Z",
        "number":  48477,
        "author":  "scalablecory",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-11-26T03:49:22Z",
        "body":  "## Background and Motivation\r\n\r\nWe already have (or [will likely have](https://github.com/dotnet/runtime/issues/33418), for UDP) a cancellable implementation of these methods, but they are not public. I propose making them public.\r\n\r\nThere are some scenarios where using SocketAsyncEventArgs will be more performant than the Task-based methods, but you must currently trade off cancellation support or get at the private methods via reflection. I\u0027d like to not depend on reflection anymore.\r\n\r\n## Proposed API\r\n\r\n```c#\r\nclass Socket\r\n{\r\n    // existing.\r\n    public bool SendAsync(SocketAsyncEventArgs e);\r\n    public bool ReceiveAsync(SocketAsyncEventArgs e);\r\n    public bool SendToAsync(SocketAsyncEventArgs e);\r\n    public bool SendPacketsAsync(SocketAsyncEventArgs e);\r\n    public bool ReceiveFromAsync(SocketAsyncEventArgs e);\r\n    public bool ReceiveMessageFromAsync(SocketAsyncEventArgs e);\r\n\r\n    // new.\r\n    public bool SendAsync(SocketAsyncEventArgs e, CancellationToken cancellationToken);\r\n    public bool ReceiveAsync(SocketAsyncEventArgs e, CancellationToken cancellationToken);\r\n    public bool SendToAsync(SocketAsyncEventArgs e, CancellationToken cancellationToken);\r\n    public bool SendPacketsAsync(SocketAsyncEventArgs e, CancellationToken cancellationToken);\r\n    public bool ReceiveFromAsync(SocketAsyncEventArgs e, CancellationToken cancellationToken);\r\n    public bool ReceiveMessageFromAsync(SocketAsyncEventArgs e, CancellationToken cancellationToken);\r\n}\r\n```\r\n\r\nCC @antonfirsov @geoffkizer ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOlKhvog==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4MTYyMjcwOQ==",
                                           "createdAt":  "2021-02-18T20:43:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n## Background and Motivation\r\n\r\nWe already have (or [will likely have](https://github.com/dotnet/runtime/issues/33418), for UDP) a cancellable implementation of these methods, but they are not public. I propose making them public.\r\n\r\nThere are some scenarios where using SocketAsyncEventArgs will be more performant than the Task-based methods, but you must currently trade off cancellation support or get at the private methods via reflection. I\u0027d like to not depend on reflection anymore.\r\n\r\n## Proposed API\r\n\r\n```c#\r\nclass Socket\r\n{\r\n    // existing.\r\n    public bool SendAsync(SocketAsyncEventArgs e);\r\n    public bool ReceiveAsync(SocketAsyncEventArgs e);\r\n    public bool SendToAsync(SocketAsyncEventArgs e);\r\n    public bool SendPacketsAsync(SocketAsyncEventArgs e);\r\n    public bool ReceiveFromAsync(SocketAsyncEventArgs e);\r\n    public bool ReceiveMessageFromAsync(SocketAsyncEventArgs e);\r\n\r\n    // new.\r\n    public bool SendAsync(SocketAsyncEventArgs e, CancellationToken cancellationToken);\r\n    public bool ReceiveAsync(SocketAsyncEventArgs e, CancellationToken cancellationToken);\r\n    public bool SendToAsync(SocketAsyncEventArgs e, CancellationToken cancellationToken);\r\n    public bool SendPacketsAsync(SocketAsyncEventArgs e, CancellationToken cancellationToken);\r\n    public bool ReceiveFromAsync(SocketAsyncEventArgs e, CancellationToken cancellationToken);\r\n    public bool ReceiveMessageFromAsync(SocketAsyncEventArgs e, CancellationToken cancellationToken);\r\n}\r\n```\r\n\r\nCC @antonfirsov @geoffkizer \n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003escalablecory\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Net.Sockets`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e6.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-02-18T20:43:50Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4MzMwOTU2OA==",
                                           "createdAt":  "2021-02-22T11:32:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBg3dAQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "stephentoub",
                                                                               "createdAt":  "2021-02-22T11:38:46Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "This is a weird API that deviates from typical async patterns, has a very strong hack-taste, and is unprecedented in the BCL. I\u0027m not sure if exposing stuff like this is a good tradeoff.\r\n\r\nCan\u0027t we instead introduce optimized `ValueTask` overloads for gathered reads/writes?",
                                           "updatedAt":  "2021-02-22T11:39:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4Mzk0NzU5Nw==",
                                           "createdAt":  "2021-02-23T06:37:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "scalablecory",
                                           "body":  "\u003e This is a weird API that deviates from typical async patterns, has a very strong hack-taste, and is unprecedented in the BCL. I\u0027m not sure if exposing stuff like this is a good tradeoff.\r\n\r\nI disagree re: API being unprecedented-- `CancellationToken` is the standard model of cancellation; if anything it makes them less weird to add support.\r\n\r\nAre you proposing that `SocketAsyncEventArgs` is dead and should be kept in maintenance mode going forward? I\u0027d be glad to see that, but we should open an issue to track migrating the features it exposes to the `ValueTask` overloads, and testing that those have equivalent perf.",
                                           "updatedAt":  "2021-02-23T06:37:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NDI0NjY3NQ==",
                                           "createdAt":  "2021-02-23T14:36:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "\u003e re: API being unprecedented -- `CancellationToken` is the standard model of cancellation\r\n\r\nI\u0027m talking about specific API models. `CancellationToken` is the standard, preferred way -- on `Task`-based methods. In your proposal you are mixing the EAP model with the Task-based model. I\u0027m not aware of existing similar API-s in the BCL.\r\n\r\n\u003e Are you proposing that `SocketAsyncEventArgs` is dead and should be kept in maintenance mode going forward?\r\n\r\nNo, but it has different patterns for cancellation (eg. [`CancelConnectAsync(e)`](https://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.socket.cancelconnectasync?view=net-5.0) which conforms to [this guideline](https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview)). We should either follow that pattern and add `Socket.CancelReadAsync(e)` + `CancelWriteAsync(e)`, or add new `ValueTask`-based overloads, but do not mix the two, even though it looks cheap to implement. \r\n\r\nMy understanding is that we are committed to prefer Task-based stuff over EAP, when it comes to adding new API-s. If I\u0027m not missing anything, the following addition should be sufficient to support the performance requirements of the \"Flexible HTTP\" stuff:\r\n\r\n```C#\r\npublic class Socket\r\n{\r\n    public ValueTask SendAsync(IReadOnlyList\u003cReadOnlyMemory\u003cbyte\u003e\u003e buffers, CancellationToken cancellationToken = default);\r\n    public ValueTask\u003cint\u003e ReceiveAsync(IReadOnlyList\u003cMemory\u003cbyte\u003e\u003e buffers, CancellationToken cancellationToken= default);\r\n}\r\n```\r\n\r\n",
                                           "updatedAt":  "2021-03-25T11:20:02Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NDM5MTE5OA==",
                                           "createdAt":  "2021-02-23T17:59:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "\u003e Are you proposing that SocketAsyncEventArgs is dead and should be kept in maintenance mode going forward? I\u0027d be glad to see that, but we should open an issue to track migrating the features it exposes to the ValueTask overloads, and testing that those have equivalent perf.\r\n\r\n\"Dead\" is probably a little too strong.\r\n\r\nI think the Task based APIs are our primary and preferred API, and our long-term goal should be to ensure that users never need to use SAEA instead of Task APIs due to missing features or perf. And yeah, that means we should (a) track issues re missing functionality in the Task APIs vs SAEA. and (b) do perf evaluation to ensure there\u0027s no perf gap here.\r\n\r\nThe main gap I\u0027m aware of today is scatter/gather support, but that\u0027s sort of tracked via the issue of whether/how to do scatter/gather in Stream and derived classes.\r\n\r\n",
                                           "updatedAt":  "2021-02-23T17:59:29Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NDQwMzk3Ng==",
                                           "createdAt":  "2021-02-23T18:14:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "\u003e The main gap I\u0027m aware of today is scatter/gather support, but that\u0027s sort of tracked via the issue of whether/how to do scatter/gather in Stream and derived classes.\r\n\r\nI assume you mean #25344. That does not include the missing async socket API-s (two methods from https://github.com/dotnet/runtime/issues/48477#issuecomment-784246675), and AFAIK there is no tracking issue for those.",
                                           "updatedAt":  "2021-02-23T18:14:44Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NDQxNDAwMg==",
                                           "createdAt":  "2021-02-23T18:25:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "\u003e I assume you mean #25344.\r\n\r\nYeah, that\u0027s what I meant.\r\n\r\n",
                                           "updatedAt":  "2021-02-23T18:25:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NDUwMDQyMA==",
                                           "createdAt":  "2021-02-23T20:46:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Triage:\r\n- Ideally move from SAEA to Task APIs long-term\r\n- We need to commit to not just Sockets, but also on Stream (not implement, but commit)\r\n- OK with perf concerns, but would be better to have real test comparing ValueTask and SAEA\r\n- We need API proposal",
                                           "updatedAt":  "2021-02-23T20:46:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4NDUwMjQwOA==",
                                           "createdAt":  "2021-02-23T20:50:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Idea: Create replacement issue to better capture the final intent.",
                                           "updatedAt":  "2021-02-23T20:50:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6UP23C",
                                           "createdAt":  "2024-11-20T02:18:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dhhoang",
                                           "body":  "Hi, is this issue still active?  \nI\u0027d love to have `Socket.CancelReadAsync(e)/CancelWriteAsync(e)` as I think it will be inline with the design of `SocketAsyncEventArgs`. In which case the `SocketError` code would be set to a specific code e.g. `Interrupted`.  \nMy use case for this is to time-out individual socket calls. Currently that can be done with the `socket.SendAsync(data, CancellationToken)` overload but it means there is a cancellation registration for every socket call which would likely reduce performance.  \n\nhttps://github.com/dotnet/runtime/blob/1e3544ec04e27538f3d38d274f7a65277f0d681f/src/libraries/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncEventArgs.Windows.cs#L195",
                                           "updatedAt":  "2024-11-20T02:18:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6UWKnx",
                                           "createdAt":  "2024-11-20T15:10:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "The overloads proposed here would not get rid of that CT registration, since we would be still passing the token. AFAIK most if not all CT based IO operations in .NET create a registration internally, but there several optimizations under the hood to make it as cheap as possible. Eg.  in socket PAL in the cases where the socket operation completes synchronously, `ProcessIOCPResult` won\u0027t be invoked and no registration happens.\n\n\u003e there is a cancellation registration for every socket call which would likely reduce performance\n\nIs it an assumption, or do you have data proving this?",
                                           "updatedAt":  "2024-11-20T15:10:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6UdjHS",
                                           "createdAt":  "2024-11-21T10:47:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dhhoang",
                                           "body":  "\u003e The overloads proposed here would not get rid of that CT registration, since we would be still passing the token. AFAIK most if not all CT based IO operations in .NET create a registration internally, but there several optimizations under the hood to make it as cheap as possible. Eg. in socket PAL in the cases where the socket operation completes synchronously, `ProcessIOCPResult` won\u0027t be invoked and no registration happens.\n\nI am not proposing overloads with `CancellationToken` as I don\u0027t think it makes sense to have them in `SocketAsyncEventArgs`. I think the `SocketAsyncEventArgs` methods are supposed to give us lower-level control on socket operations e.g. getting a `SocketError` . What I am proposing are `Socket.CancelXAsync(e)` (X might be send/recv/ etc.).   \nThe underlying implementation would be to cancel the operation at the native level, for example, calling `CancelIoEx` on Windows, and on Linux I think it\u0027s about ignoring the `epoll` event.  Essentially it\u0027d do the same action that\u0027s invoked when `CancellationToken` is triggered.\n\n\u003e Is it an assumption, or do you have data proving this?  \n\nI don\u0027t have any data, and I\u0027d be happy to create a benchmark to test this. My thinking is that `SendAsync(CancellationToken)` also uses SAEA, **plus** the CT registration, it would likely not be as efficient as using SAEA alone. For our use case we also expect a lot of pending read()/write().\n\n\n\n\n",
                                           "updatedAt":  "2024-11-21T10:47:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6UgdB3",
                                           "createdAt":  "2024-11-21T15:26:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD78KAA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "MihaZupan",
                                                                               "createdAt":  "2024-11-21T15:31:18Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "The standard way to achieve this would be to `Close`/`Dispose` the socket, which would cancel all pending IO. Of course this would terminate the TCP connection, but for most use-cases we\u0027ve seen this is acceptable or even desirable. Do you still need to be able receive from the socket after cancelling sends or vice-versa? Note that usually it\u0027s not safe to eg. issue a new read after a cancelled one from the application POV, since the status of the cancelled operation is undefined (buffer sent/partially sent/not sent).\n",
                                           "updatedAt":  "2024-11-21T15:26:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6UqG-i",
                                           "createdAt":  "2024-11-22T15:47:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dhhoang",
                                           "body":  "I\u0027ve managed to create a benchmark. This is just a basic test, a simplified echo server: https://github.com/dhhoang/dotnet-socket-cancellation  \nPlease have a look at the readme for some results. I think it shows `CancellationToken` methods are noticeably more expensive than SAEA.\n\u003e Do you still need to be able receive from the socket after cancelling sends or vice-versa\n\nYes, that is indeed our use case :) ",
                                           "updatedAt":  "2024-11-26T03:49:22Z"
                                       }
                                   ],
                         "totalCount":  14
                     },
        "title":  "Cancellable SocketAsyncEventArgs methods",
        "labels":  [
                       "api-suggestion",
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/49941",
        "createdAt":  "2021-03-20T17:45:32Z",
        "number":  49941,
        "author":  "davidfowl",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCuFcig==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aromaa",
                                            "createdAt":  "2021-03-20T22:12:52Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Seb-stian",
                                            "createdAt":  "2021-08-19T10:14:13Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SupinePandora43",
                                            "createdAt":  "2022-03-17T16:09:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "xsoheilalizadeh",
                                            "createdAt":  "2022-10-29T21:34:19Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "epeshk",
                                            "createdAt":  "2023-01-26T15:14:56Z"
                                        }
                                    ],
                          "totalCount":  5
                      },
        "updatedAt":  "2023-07-30T20:48:01Z",
        "body":  "## Background and Motivation\r\n\r\nDoing some profiling writing large payloads via Kestrel, about 1.2 % of the overall time is spent converting from `ReadOnlySequence\u003cbyte\u003e` to a `List\u003cArraySegment\u003cbyte\u003e\u003e` for the eventual call to the underlying socket API that takes an array of pointers to buffers. Most of the time is spent calling into [`MemoryMarshal.TryGetArray`](https://github.com/dotnet/runtime/blob/82ca681cbac89d813a3ce397e0c665e6c051ed67/src/libraries/System.Private.CoreLib/src/System/Runtime/InteropServices/MemoryMarshal.cs#L261) to get an `ArraySegment\u003cbyte\u003e`  from the `Memory\u003cbyte\u003e` most of which is a pointless conversion (which mostly defeats the purpose of use passing a pre-pinned memory handle to the networking stack).\r\n\r\n## Proposed API\r\n\r\n\r\n```diff\r\nnamespace System.Net.Sockets\r\n{\r\n    public class SocketAsyncEventArgs\r\n    {\r\n+    public IList\u003cReadOnlyMemory\u003cbyte\u003e\u003e? MemoryList { get; set; }\r\n    }\r\n}\r\n```\r\n\r\n## Usage Examples\r\n\r\n``` C#\r\nprivate void SetBufferList(in ReadOnlySequence\u003cbyte\u003e buffer)\r\n{\r\n    if (_bufferList == null)\r\n    {\r\n        _bufferList = new List\u003cReadOnlyMemory\u003cbyte\u003e\u003e();\r\n    }\r\n\r\n    foreach (ReadOnlyMemory\u003cbyte\u003e b in buffer)\r\n    {\r\n        _bufferList.Add(b);\r\n    }\r\n\r\n    // The act of setting this list, sets the buffers in the internal buffer list\r\n    MemoryList = _bufferList;\r\n}\r\n```\r\n\r\n## Risks\r\n\r\nMore ways of doing the same thing. When to choose MemoryList vs BufferList. Do they overwrite each other? etc.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYsfWHg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwMzQzMzAyNg==",
                                           "createdAt":  "2021-03-20T17:45:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @GrabYourPitchForks\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n## Background and Motivation\r\n\r\nDoing some profiling writing large payloads via Kestrel, about 1.2 % of the overall time is spent converting from `ReadOnlySequence\u003cbyte\u003e` to a `List\u003cArraySegment\u003cbyte\u003e\u003e` for the eventual call to the underlying socket API that takes an array of pointers to buffers. Most of the time is spent calling into [`MemoryMarshal.TryGetArray`](https://github.com/dotnet/runtime/blob/82ca681cbac89d813a3ce397e0c665e6c051ed67/src/libraries/System.Private.CoreLib/src/System/Runtime/InteropServices/MemoryMarshal.cs#L261) to get an `ArraySegment\u003cbyte\u003e`  from the `Memory\u003cbyte\u003e` most of which is a pointless conversion.\r\n\r\n## Proposed API\r\n\r\n\r\n```diff\r\nnamespace System.Net.Sockets\r\n{\r\n    public class SocketAsyncEventArgs\r\n    {\r\n+    public IList\u003cReadOnlyMemory\u003cbyte\u003e\u003e? MemoryList { get; set; }\r\n    }\r\n}\r\n```\r\n\r\n## Usage Examples\r\n\r\n``` C#\r\nprivate void SetBufferList(in ReadOnlySequence\u003cbyte\u003e buffer)\r\n{\r\n    if (_bufferList == null)\r\n    {\r\n        _bufferList = new List\u003cReadOnlyMemory\u003cbyte\u003e\u003e();\r\n    }\r\n\r\n    foreach (ReadOnlyMemory\u003cbyte\u003e b in buffer)\r\n    {\r\n        _bufferList.Add(b);\r\n    }\r\n\r\n    // The act of setting this list, sets the buffers in the internal buffer list\r\n    BufferList = _bufferList;\r\n}\r\n```\r\n\r\n## Risks\r\n\r\nMore ways of doing the same thing. When to choose MemoryList vs BufferList. Do they overwrite each other? etc.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003edavidfowl\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Memory`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-03-20T17:45:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNTA4MzM5Ng==",
                                           "createdAt":  "2021-03-23T17:19:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n## Background and Motivation\r\n\r\nDoing some profiling writing large payloads via Kestrel, about 1.2 % of the overall time is spent converting from `ReadOnlySequence\u003cbyte\u003e` to a `List\u003cArraySegment\u003cbyte\u003e\u003e` for the eventual call to the underlying socket API that takes an array of pointers to buffers. Most of the time is spent calling into [`MemoryMarshal.TryGetArray`](https://github.com/dotnet/runtime/blob/82ca681cbac89d813a3ce397e0c665e6c051ed67/src/libraries/System.Private.CoreLib/src/System/Runtime/InteropServices/MemoryMarshal.cs#L261) to get an `ArraySegment\u003cbyte\u003e`  from the `Memory\u003cbyte\u003e` most of which is a pointless conversion (which mostly defeats the purpose of use passing a pre-pinned memory handle to the networking stack).\r\n\r\n## Proposed API\r\n\r\n\r\n```diff\r\nnamespace System.Net.Sockets\r\n{\r\n    public class SocketAsyncEventArgs\r\n    {\r\n+    public IList\u003cReadOnlyMemory\u003cbyte\u003e\u003e? MemoryList { get; set; }\r\n    }\r\n}\r\n```\r\n\r\n## Usage Examples\r\n\r\n``` C#\r\nprivate void SetBufferList(in ReadOnlySequence\u003cbyte\u003e buffer)\r\n{\r\n    if (_bufferList == null)\r\n    {\r\n        _bufferList = new List\u003cReadOnlyMemory\u003cbyte\u003e\u003e();\r\n    }\r\n\r\n    foreach (ReadOnlyMemory\u003cbyte\u003e b in buffer)\r\n    {\r\n        _bufferList.Add(b);\r\n    }\r\n\r\n    // The act of setting this list, sets the buffers in the internal buffer list\r\n    MemoryList = _bufferList;\r\n}\r\n```\r\n\r\n## Risks\r\n\r\nMore ways of doing the same thing. When to choose MemoryList vs BufferList. Do they overwrite each other? etc.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003edavidfowl\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Net.Sockets`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-03-23T17:19:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNTA5NzQwNQ==",
                                           "createdAt":  "2021-03-23T17:39:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "I agree, this would be a good thing to do. Main difficulty is what you highlighted above:\r\n\r\n\u003e More ways of doing the same thing. When to choose MemoryList vs BufferList. Do they overwrite each other? etc.\r\n\r\nThe other consideration here is, we want this to work seamlessly with NetworkStream, so whatever way we choose to expose this in SAEA and other socket APIs will effectively commit us to the same approach in Stream etc. So we need to design this in concert with https://github.com/dotnet/runtime/issues/25344.\r\n\r\nAlso note, ReadOnlyMemory only covers send cases; presumably we want to support receive here as well. Which complicates things further.\r\n\r\n\r\n",
                                           "updatedAt":  "2021-03-23T17:39:10Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNTA5OTM0Ng==",
                                           "createdAt":  "2021-03-23T17:41:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "All that said: Can we improve the cost of MemoryMarshal.TryGetArray? That seems really high for what should be a very common operation.",
                                           "updatedAt":  "2021-03-23T17:41:45Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNTExNTY1Nw==",
                                           "createdAt":  "2021-03-23T18:04:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "BTW this all came up because I\u0027m looking at this https://github.com/dotnet/aspnetcore/issues/31110\r\n\r\n\u003e The other consideration here is, we want this to work seamlessly with NetworkStream, so whatever way we choose to expose this in SAEA and other socket APIs will effectively commit us to the same approach in Stream etc. So we need to design this in concert with #25344.\r\n\r\nAre you saying we should use the same types on both? I agree. I wouldn\u0027t gate one of the other but they can be designed together.\r\n\r\n\u003e Also note, ReadOnlyMemory only covers send cases; presumably we want to support receive here as well. Which complicates things further.\r\n\r\nGood point. I think multi-buffer sends are 90% and multi buffer receives are 10% (I pulled those numbers out of thin air btw).\r\n\r\n\u003e All that said: Can we improve the cost of MemoryMarshal.TryGetArray? That seems really high for what should be a very common operation.\r\n\r\nNo idea. @GrabYourPitchforks? The other issue is that Kestrel uses 4K buffers so we end up doing this lots of time doing these on individual 4K chunks.",
                                           "updatedAt":  "2021-03-23T18:04:40Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNTExNjE0OA==",
                                           "createdAt":  "2021-03-23T18:05:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "BTW there\u0027s a bunch of other overhead I hit as well. I filed the issue for the easy one so far. ",
                                           "updatedAt":  "2021-03-23T18:05:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNTEyMDk5NQ==",
                                           "createdAt":  "2021-03-23T18:12:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "\u003e Are you saying we should use the same types on both? I agree.\r\n\r\nYes. E.g. is it IList or IReadOnlyList? We need to use exactly the same types here across Socket/Stream or we could accidentally cause ourselves a lot of pain.\r\n\r\n\u003e I wouldn\u0027t gate one of the other but they can be designed together.\r\n\r\nYeah, we could choose to implement this in parts in different ways, we just need to feel confident that the design works in all cases.\r\n\r\n",
                                           "updatedAt":  "2021-03-23T18:12:28Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNTEyMTU0MA==",
                                           "createdAt":  "2021-03-23T18:13:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "\u003e BTW there\u0027s a bunch of other overhead I hit as well. \r\n\r\nPlease file it all :)",
                                           "updatedAt":  "2021-03-23T18:13:22Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNTE5OTYyNw==",
                                           "createdAt":  "2021-03-23T20:03:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBkxX8g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "halter73",
                                                                               "createdAt":  "2021-03-25T03:35:16Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "benaadams",
                                           "body":  "Or `ReadOnlySequence\u003cbyte\u003e` 🤔",
                                           "updatedAt":  "2021-03-23T20:03:37Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNTMzNTEyOQ==",
                                           "createdAt":  "2021-03-23T23:06:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBktYJQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "scalablecory",
                                                                               "createdAt":  "2021-03-24T17:22:09Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "The problem with ReadOnlySequence\\\u003cbyte\\\u003e is that we\u0027d end up forcing creation of a linked list.",
                                           "updatedAt":  "2021-03-23T23:06:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNTM0NjQ4Ng==",
                                           "createdAt":  "2021-03-23T23:25:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "\u003e The problem with ReadOnlySequence\u003cbyte\u003e is that we\u0027d end up forcing creation of a linked list.\r\n\r\nNot sure why? Change `_bufferListInternal` from `List\u003cArraySegment\u003cbyte\u003e\u003e` to  `List\u003cMemory\u003cbyte\u003e\u003e`\r\n\r\nhttps://github.com/dotnet/runtime/blob/1ee59da9f6104c611b137c9d14add04becefdf14/src/libraries/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncEventArgs.cs#L160-L168\r\n\r\nCan then enumerate the `IList\u003cArraySegment\u003cbyte\u003e\u003e` into it and enumerate the `ReadOnlySequence\u003cbyte\u003e` into it?",
                                           "updatedAt":  "2021-03-23T23:25:15Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNTM0ODMzNg==",
                                           "createdAt":  "2021-03-23T23:30:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "I meant to create the ReadOnlySequence in the first place.",
                                           "updatedAt":  "2021-03-23T23:30:06Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNTQ0MTg0NQ==",
                                           "createdAt":  "2021-03-24T02:46:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "\u003e I meant to create the ReadOnlySequence in the first place.\r\n\r\nTrue; but might already have one, like if you were forwarding upstream? (like your usage)\r\n```csharp\r\npublic async Task InvokeAsync(HttpContext context)\r\n{\r\n    var reader = context.Request.BodyReader;\r\n    var writer = _upstream.Output;\r\n    while (true)\r\n    {\r\n        var readResult = await reader.ReadAsync(default);\r\n        var buffer = readResult.Buffer;\r\n        var isCompleted = readResult.IsCompleted;\r\n\r\n        if (buffer.IsEmpty \u0026\u0026 isCompleted)\r\n        {\r\n            return;\r\n        }\r\n\r\n        await writer.WriteAsync(buffer);\r\n    }\r\n```\r\nMore mean your usage example could also be an api; and then don\u0027t need to create two Lists, since the first thing the `SocketAsyncEventArgs` does is copy the List to another List; so it would save one List creation and add sequence?\r\n```csharp\r\nprivate void SetBufferList(in ReadOnlySequence\u003cbyte\u003e buffer)\r\n{\r\n    if (_bufferListInternal == null)\r\n    {\r\n        _bufferListInternal = new List\u003cReadOnlyMemory\u003cbyte\u003e\u003e();\r\n    }\r\n    else\r\n    {\r\n        _bufferListInternal.Clear();\r\n    }\r\n\r\n    foreach (ReadOnlyMemory\u003cbyte\u003e b in buffer)\r\n    {\r\n        _bufferListInternal.Add(b);\r\n    }\r\n}\r\n```\r\n",
                                           "updatedAt":  "2021-03-24T02:46:45Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNTQ1ODgwNQ==",
                                           "createdAt":  "2021-03-24T03:27:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "I wouldn\u0027t mind adding directly to the buffer list. The setting API is jank and requires me to manage my own list. That would be a decent middleground ",
                                           "updatedAt":  "2021-03-24T03:27:58Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNjAxMDk4OA==",
                                           "createdAt":  "2021-03-24T17:19:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "scalablecory",
                                           "body":  "We need a receive variant too, as well as `Send()` and `Receive()` overloads.\r\n\r\n\u003e More mean your usage example could also be an api; and then don\u0027t need to create two Lists, since the first thing the `SocketAsyncEventArgs` does is copy the List to another List; so it would save one List creation and add sequence?\r\n\r\n@antonfirsov has ideas to make `Send()` and `Receive()` be the first-class APIs and have SAEA eventually wrap them. This will resolve this inefficiency by allowing direct translation to `WSABUF` with no in-between.",
                                           "updatedAt":  "2021-03-24T17:21:24Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNjAxNzI5MQ==",
                                           "createdAt":  "2021-03-24T17:26:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "scalablecory",
                                           "body":  "\u003e which mostly defeats the purpose of use passing a pre-pinned memory handle to the networking stack\r\n\r\nThis is interesting, because I\u0027d expect working with `ArraySegment` to actually be the most efficient here.\r\n\r\nWhat is the overhead of creating a GCHandle to a pre-pinned array? I\u0027d expect it to be close to a no-op. Maybe this is something that can be optimized.",
                                           "updatedAt":  "2021-03-24T17:26:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNjA2NzMxNA==",
                                           "createdAt":  "2021-03-24T18:42:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "Allocating a GCHandle isn\u0027t a noop, and we shouldn\u0027t be doing it. The stack should be re-written on top of `IList\u003cMemory\u003cbyte\u003e\u003e` instead of `ArraySegment\u003cbyte\u003e`, I\u0027m not sure why that would be contentious (I started messing with it in a local branch).",
                                           "updatedAt":  "2021-03-24T18:42:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNjMwNTMzMQ==",
                                           "createdAt":  "2021-03-25T02:03:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "scalablecory",
                                           "body":  "\u003e I\u0027m not sure why that would be contentious\r\n\r\nI\u0027m not proposing we use `ArraySegment`, I\u0027m just surprised it would be slower than `Memory`.",
                                           "updatedAt":  "2021-03-25T02:03:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNjMxMDU0MQ==",
                                           "createdAt":  "2021-03-25T02:17:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "The memory we create doesn\u0027t have a GC handle since it\u0027s using the pinned object heap. This code is allocating a GC handle for the underlying array when it doesn\u0027t need to. On top of that, we need to unpack the Memory back into an ArraySegment for each buffer in the linked list chain before setting the result on the SAEA. \r\n\r\nThere\u0027s all sorts of inefficiencies around multi-buffer sends, this is one of the lower hanging fruit 😄. ",
                                           "updatedAt":  "2021-03-25T02:17:04Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNjMzMTk5Mg==",
                                           "createdAt":  "2021-03-25T03:13:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBkyYgQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "scalablecory",
                                                                               "createdAt":  "2021-03-25T03:27:48Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "davidfowl",
                                                                               "createdAt":  "2021-03-25T07:17:35Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e\u003e What is the overhead of creating a GCHandle to a pre-pinned array? I\u0027d expect it to be close to a no-op. \r\n\r\n\u003e Allocating a GCHandle isn\u0027t a noop, and we shouldn\u0027t be doing it.\r\n\r\nYeah, it\u0027s not free, and it\u0027ll be more expensive the more contentious it is.  Creating a GCHandle entails synchronization (best case an interlocked, worst case a lock).  It doesn\u0027t really matter what the type of the handle is, nor whether the array is already pinned or not, it\u0027s the same appx operation and cost.  Below is an example, all serialized so no contention.\r\n\r\n| Method |                 type |     Mean |    Error |   StdDev |\r\n|------- |--------------------- |---------:|---------:|---------:|\r\n| Normal |               Normal | 30.88 ns | 0.144 ns | 0.135 ns |\r\n| Normal |               Pinned | 31.36 ns | 0.113 ns | 0.100 ns |\r\n| Normal |                 Weak | 31.53 ns | 0.528 ns | 0.441 ns |\r\n| Normal | WeakT(...)ction [21] | 33.69 ns | 0.151 ns | 0.118 ns |\r\n| Pinned |               Normal | 30.80 ns | 0.071 ns | 0.059 ns |\r\n| Pinned |               Pinned | 31.57 ns | 0.101 ns | 0.090 ns |\r\n| Pinned |                 Weak | 32.15 ns | 0.111 ns | 0.093 ns |\r\n| Pinned | WeakT(...)ction [21] | 33.50 ns | 0.121 ns | 0.107 ns |\r\n\r\n```C#\r\nprivate byte[] _normal = new byte[1024];\r\nprivate byte[] _pinned = GC.AllocateArray\u003cbyte\u003e(1024, pinned: true);\r\n\r\n[Benchmark]\r\n[Arguments(GCHandleType.Normal)]\r\n[Arguments(GCHandleType.Pinned)]\r\n[Arguments(GCHandleType.Weak)]\r\n[Arguments(GCHandleType.WeakTrackResurrection)]\r\npublic void Normal(GCHandleType type) =\u003e GCHandle.Alloc(_normal, type).Free();\r\n\r\n[Benchmark]\r\n[Arguments(GCHandleType.Normal)]\r\n[Arguments(GCHandleType.Pinned)]\r\n[Arguments(GCHandleType.Weak)]\r\n[Arguments(GCHandleType.WeakTrackResurrection)]\r\npublic void Pinned(GCHandleType type) =\u003e GCHandle.Alloc(_pinned, type).Free();\r\n```",
                                           "updatedAt":  "2021-03-25T03:15:25Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNjQyNDY4Mw==",
                                           "createdAt":  "2021-03-25T07:22:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "Right, we create the Memory with the [CreateFromPinnedArray](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.memorymarshal.createfrompinnedarray?view=net-5.0) to avoid GCHandle overhead and as it turns out, we only avoid it for single buffer writes. \r\n\r\nPS I\u0027m discovering these inefficiencies because I\u0027ve been looking at this https://github.com/dotnet/aspnetcore/issues/31110 and some other scenarios around reducing memory.",
                                           "updatedAt":  "2021-03-25T07:22:26Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNjY1MDgwMw==",
                                           "createdAt":  "2021-03-25T12:29:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBk3Wvg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "geoffkizer",
                                                                               "createdAt":  "2021-03-25T16:02:39Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "\u003e @antonfirsov has ideas to make `SendAsync()` and `Receive()` be the first-class APIs and have SAEA eventually wrap them.\r\n\r\nI didn\u0027t mean to wrap the `ValueTask` API-s by SAEA API-s. The idea is that the (cancellable) `ValueTask`  variants should be close-to-zero-overhead wrappers around the SAEA stuff, making them the primary choice for every developer who needs async, including Kestrel devs.\r\n\r\nI proposed those overloads in https://github.com/dotnet/runtime/issues/48477#issuecomment-784246675, copying them here for better visibility:\r\n```C#\r\npublic class Socket\r\n{\r\n    public ValueTask SendAsync(IReadOnlyList\u003cReadOnlyMemory\u003cbyte\u003e\u003e buffers, CancellationToken cancellationToken = default);\r\n    public ValueTask\u003cint\u003e ReceiveAsync(IReadOnlyList\u003cMemory\u003cbyte\u003e\u003e buffers, CancellationToken cancellationToken= default);\r\n}\r\n```\r\n\r\n@geoffkizer had a valid concern in a comment above:\r\n\r\n\u003e Also note, ReadOnlyMemory only covers send cases; presumably we want to support receive here as well. Which complicates things further.\r\n\r\nWith the `ValueTask` overloads we can avoid exploding the SAEA\u0027s public API further. (We can manage the lists as implementation details of Socket\u0027s internal SAEA.)\r\n\r\nTo provide better experience for callers with a ROS, we may also add a convenience overload for ROS, which wraps the `IList\u003cReadOnlyMemory\u003cbyte\u003e\u003e` variant by populating an internally cached list, which seems to be very easy to implement, and the overhead seems to be acceptable for me:\r\n\r\n```C#\r\n    public ValueTask SendAsync(ReadOnlySequence\u003cbyte\u003e buffers, CancellationToken cancellationToken = default);\r\n```\r\n\r\n@davidfowl would you be able to consume this stuff instead of SAEA? This would have some (but hopefully low) overhead, I think definitely much lower than the `TryGetArray` overhead you are mentioning, if we do it right.",
                                           "updatedAt":  "2021-03-25T12:39:01Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNjkxMTg2OA==",
                                           "createdAt":  "2021-03-25T15:04:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "\u003e @davidfowl would you be able to consume this stuff instead of SAEA? This would have some (but hopefully low) overhead, I think definitely much lower than the TryGetArray overhead you are mentioning, if we do it right.\n\nThat\u0027s nice but where do IOVectors and WsaBuf structs get stored? You can only stack alloc so many so in our case I\u0027d like to figure out how to reuse a cached set of these structs allocated on the heap once we exceed that limit.",
                                           "updatedAt":  "2021-03-25T15:04:21Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNzAwNzM1NA==",
                                           "createdAt":  "2021-03-25T16:03:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "\u003e With the ValueTask overloads we can avoid exploding the SAEA\u0027s public API further.\r\n\r\nYeah, I like this approach a lot. \r\n\r\nEdit to add: We already basically do this with CancellationToken support. It\u0027s exposed via Task APIs that wrap SAEA, but it\u0027s not exposed directly through SAEA APIs.",
                                           "updatedAt":  "2021-03-25T16:34:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNzAxNTM4OA==",
                                           "createdAt":  "2021-03-25T16:08:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "\u003e That\u0027s nice but where do IOVectors and WsaBuf structs get stored? You can only stack alloc so many so in our case I\u0027d like to figure out how to reuse a cached set of these structs allocated on the heap once we exceed that limit.\r\n\r\nWe can stack alloc a decent amount; I think we stack alloc up to 8 today -- @tmds would know for sure. And we could increase this (somewhat) if it makes a difference for real scenarios. \r\n\r\nBut regardless, we would still be using a cached SAEA instance under the covers, and that would reuse cached WSABUFs etc. It\u0027s just that we wouldn\u0027t expose Memory support on SAEA publicly, it would be an internal-only thing.\r\n\r\nIn other words I don\u0027t think there\u0027s an issue here.",
                                           "updatedAt":  "2021-03-25T16:08:32Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNzAyMjQxOA==",
                                           "createdAt":  "2021-03-25T16:12:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "\u003e But regardless, we would still be using a cached SAEA instance under the covers, and that would reuse cached WSABUFs etc. It\u0027s just that we wouldn\u0027t expose Memory support on SAEA publicly, it would be an internal-only thing.\r\n\r\nOK then I prefer this approach as well. I thought the goal was to avoid SAEA (which is something I want to do for reads BTW).",
                                           "updatedAt":  "2021-03-25T16:12:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNzAyMzk2MA==",
                                           "createdAt":  "2021-03-25T16:13:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBk3o_g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "antonfirsov",
                                                                               "createdAt":  "2021-03-25T16:27:12Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "\u003e I thought the goal was to avoid SAEA (which is something I want to do for reads BTW).\r\n\r\nWhy is that?",
                                           "updatedAt":  "2021-03-25T16:13:15Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNzAyOTQ2NA==",
                                           "createdAt":  "2021-03-25T16:16:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "BTW, how many buffers would you be using here typically?\r\n\r\nI would be careful about approaches that often require using a lot of buffers for scatter/gather -- e.g. \u003e4 to be conservative, or maybe \u003e8. I\u0027m not sure the kernels here do a great job in this case. ",
                                           "updatedAt":  "2021-03-25T16:16:15Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNzAzNDE0MA==",
                                           "createdAt":  "2021-03-25T16:18:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBk3tTw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "geoffkizer",
                                                                               "createdAt":  "2021-03-25T16:23:46Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "antonfirsov",
                                                                               "createdAt":  "2021-03-25T16:27:16Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "scalablecory",
                                                                               "createdAt":  "2021-03-25T16:32:47Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e I thought the goal was to avoid SAEA\r\n\r\nSAEA is an implementation detail for the socket methods, a detail we can change over time.  Right now it stores the kitchen sink: if we cache one for use in single-buffer ReadAsync calls, we\u0027re still paying for all the state associated with every other operation it can support.  My ideal over time is that we evolve to have some smaller internal data structure(s) per operation on top of which we can build both the socket operations and SAEA, which at that point would be purely legacy / for compat.  Waving my hands.",
                                           "updatedAt":  "2021-03-25T16:19:15Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNzA1MzMxMQ==",
                                           "createdAt":  "2021-03-25T16:31:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "\u003e BTW, how many buffers would you be using here typically?\r\n\u003e I would be careful about approaches that often require using a lot of buffers for scatter/gather -- e.g. \u003e4 to be conservative, or maybe \u003e8. I\u0027m not sure the kernels here do a great job in this case.\r\n\r\nWe use 4K buffers today so 8 buffers would be 32K. Large responses are sometimes more than this so it can get up there in the number of buffers (256 for 1MB). I\u0027m playing around with different buffer sizes and dynamic buffer sizes but that\u0027s not likely to be something that we commit anytime soon. Right now, I\u0027m trying to reduce the overhead at all of the layers as much as possible.\r\n\r\n\u003e SAEA is an implementation detail for the socket methods, a detail we can change over time. Right now it stores the kitchen sink: if we cache one for use in single-buffer ReadAsync calls, we\u0027re still paying for all the state associated with every other operation it can support. My ideal over time is that we evolve to have some smaller internal data structure(s) per operation on top of which we can build both the socket operations and SAEA, which at that point would be purely legacy / for compat. Waving my hands.\r\n\r\nYes, I know this, but we don\u0027t use the Task methods, they add overhead we don\u0027t need (and no I haven\u0027t measured 😄), but I don\u0027t see the value in adding overhead especially at the networking layer. We\u0027ll kinda do insane things here to avoid it. Right now, for ReadAsync we end up holding our derived `SocketAsyncEventArgs` in the state machine in a pending zero byte read and that\u0027s ~350 bytes per connection. I\u0027d like that to be as minimal as possible so I can pool the SAEA for reads as well, instead of having one per connection.",
                                           "updatedAt":  "2021-03-25T16:31:01Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNzA2NjAzMg==",
                                           "createdAt":  "2021-03-25T16:38:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBk4C4A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "antonfirsov",
                                                                               "createdAt":  "2021-03-25T17:01:53Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "\u003e I don\u0027t see the value in adding overhead especially at the networking layer.\r\n\r\nWhile it\u0027s true that the Task APIs are basically just wrappers over public SAEA today, that will likely change over time, as @stephentoub pointed out. The goal would be to reduce memory usage etc in the Task APIs in a way that is difficult to do via public SAEA. \r\n\r\nIn other words, in the future you\u0027ll probably want to use Task APIs anyway.",
                                           "updatedAt":  "2021-03-25T16:38:56Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNzEwMjU5Mg==",
                                           "createdAt":  "2021-03-25T17:02:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "It\u0027s fine to change them but right now the Task APIs don\u0027t let us control the scheduling which we care about (actually I\u0027d prefer that directly in the socket APIs themselves). But I\u0027m less concerned about sends than receives. We\u0027ve already changed the send side to pool SAEA so we have a very small number of those now, but receives mean we need one per connection. \r\n\r\nI\u0027d like to see how we achieve lower memory usage with the Task APIs directly, it\u0027d need to pool something across instances to get the same low footprint.",
                                           "updatedAt":  "2021-03-25T17:02:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNzEwODQ1Ng==",
                                           "createdAt":  "2021-03-25T17:06:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e right now the Task APIs don\u0027t let us control the scheduling which we care about\r\n\r\nWhat scheduling does SAEA support that the Socket APIs don\u0027t?",
                                           "updatedAt":  "2021-03-25T17:06:21Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNzEyNDMyNQ==",
                                           "createdAt":  "2021-03-25T17:16:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "On Unix we stackalloc up to 8 for this reason:\r\n\r\nhttps://github.com/dotnet/runtime/blob/400311b032fe5d05b49fb6a813e4a5a60604d8dd/src/libraries/System.Net.Sockets/src/System/Net/Sockets/SocketPal.Unix.cs#L21-L23",
                                           "updatedAt":  "2021-03-25T17:16:14Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNzEyNjMyMw==",
                                           "createdAt":  "2021-03-25T17:17:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "\u003e What scheduling does SAEA support that the Socket APIs don\u0027t?\r\n\r\nI misspoke, it isn\u0027t the scheduling, it\u0027s just the unnecessary overhead in our scenario:\r\n\r\n- The Task based APIs try to support concurrent operations and have lots of code to handle those cases (overlapping reads and writes).\r\n- We want to directly schedule our continuation but with the Task based APIs we need to wait for the await to yield before we thread hop again.",
                                           "updatedAt":  "2021-03-25T17:17:53Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwNzk2NjEyOA==",
                                           "createdAt":  "2021-03-26T06:14:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "To get this issue back on topic, because I\u0027d like to see a proposal that we all agree with:\r\n- I\u0027d like an API that doesn\u0027t regress the pooling we do today.\r\n- I\u0027d like an API that doesn\u0027t have hidden allocations in the name of usability.\r\n\r\nThe problem I have with the SendAsync API is that it will inevitably have to pool WSABufs/IOVectors over a certain size (8?). If those heap allocated arrays are rented from the array pool, I think that would be a big improvement. The next thing would be to pool PreAllocatedOverlapped on windows across different socket instances (PreallocatedOverlapped). \r\n\r\nI think if we did those, I would feel better about using the SendAsync overloads.",
                                           "updatedAt":  "2021-03-28T08:40:58Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwOTQwNDEyMQ==",
                                           "createdAt":  "2021-03-29T14:04:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "I wonder if it would make more sense to just allow you to reuse Socket instances, which would mean you\u0027d reuse the cached SAEAs and PreallocatedOverlapped and other things too.\r\n",
                                           "updatedAt":  "2021-03-29T14:04:37Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwOTY0NDMyNw==",
                                           "createdAt":  "2021-03-29T19:19:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "\u003e I wonder if it would make more sense to just allow you to reuse Socket instances, which would mean you\u0027d reuse the cached SAEAs and PreallocatedOverlapped and other things too.\r\n\r\nI guess this would mean designing new `Dispose` / `Close` API-s to which allow avoiding the disposal of cached SAEA-s, so `socket.AcceptAsync(System.Net.Sockets.Socket? acceptSocket)` can reuse them? This looks exposing implementation details, I think extending `SocketAsyncEventArgs` is still a (way much) lesser evil.",
                                           "updatedAt":  "2021-03-29T19:19:45Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyMzU2MjE0MQ==",
                                           "createdAt":  "2021-04-20T19:59:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Triage: We should keep discussing final design for post-6.0. It is reasonable for .NET 7.",
                                           "updatedAt":  "2021-04-20T19:59:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg2MzkyNDQ1MA==",
                                           "createdAt":  "2021-06-18T10:09:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC3yM4g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "olivier-spinelli",
                                                                               "createdAt":  "2023-03-14T11:10:16Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "pepone",
                                           "body":  "Would you consider using the same API already used for `QuicStream` \r\n\r\nhttps://github.com/dotnet/runtime/blob/01b7e73cd378145264a7cb7a09365b41ed42b240/src/libraries/System.Net.Quic/src/System/Net/Quic/QuicStream.cs#L98\r\n\r\nThis would make it simpler to support TCP and Quick with the same code.\r\n ",
                                           "updatedAt":  "2021-06-18T10:09:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iwOE_",
                                           "createdAt":  "2023-07-29T17:57:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "Now that we have in-line arrays I wonder if these should be span based APIs.",
                                           "updatedAt":  "2023-07-29T17:57:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iwOnq",
                                           "createdAt":  "2023-07-29T18:10:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Now that we have in-line arrays I wonder if these should be span based APIs.\r\n\r\nWhich specifically? Async and span don\u0027t mix well. ",
                                           "updatedAt":  "2023-07-29T18:10:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iw59x",
                                           "createdAt":  "2023-07-30T01:10:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "It wouldn’t work for SocketAsyncEventArgs but IIRC the underlying methods don’t need to pin the array passed in, They are usually copied. \r\n\r\nI know the lowest API we have is SAEA so this approach doesn’t flow through Socket.SendAsync in a clean way…",
                                           "updatedAt":  "2023-07-30T01:10:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iw-GA",
                                           "createdAt":  "2023-07-30T03:09:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e It wouldn’t work for SocketAsyncEventArgs but IIRC the underlying methods don’t need to pin the array passed in, They are usually copied.\r\n\u003e \r\n\u003e I know the lowest API we have is SAEA so this approach doesn’t flow through Socket.SendAsync in a clean way…\r\n\r\nI\u0027m still not understanding. Can you sketch what it is you\u0027re envisioning? If the operation can\u0027t complete immediately and fully, such that the operation needs to pend and try again later, the relevant data or buffers still needs to be available.\r\n\r\nDo you just mean an API like `SendAsync(ReadOnlySpan\u003cReadOnlyMemory\u003cbyte\u003e\u003e` and it would copy that span to its own possibly-pooled heap object? ",
                                           "updatedAt":  "2023-07-30T03:42:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ixziJ",
                                           "createdAt":  "2023-07-30T17:15:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "I was thinking about how we end up calling these APIs:\r\n- https://github.com/dotnet/runtime/blob/bd83e17052d3c09022bad1d91dca860ca6b27ab9/src/libraries/Common/src/Interop/Windows/WinSock/Interop.WSASend.cs#L24C8-L24C8\r\n- https://github.com/dotnet/runtime/blob/bd83e17052d3c09022bad1d91dca860ca6b27ab9/src/libraries/System.Net.Sockets/src/System/Net/Sockets/SocketPal.Unix.cs#L284\r\n\r\n\u003e I\u0027m still not understanding. Can you sketch what it is you\u0027re envisioning? If the operation can\u0027t complete immediately and fully, such that the operation needs to pend and try again later, the relevant data or buffers still needs to be available.\r\n\r\nThe buffers themselves are pinned for the lifetime of the async operation but the holder array just needs to be pinned for the length of the synchronous call.\r\n\r\n\u003e Do you just mean an API like SendAsync(ReadOnlySpan\u003cReadOnlyMemory\u003cbyte\u003e\u003e and it would copy that span to its own possibly-pooled heap object?\r\n\r\nYes exactly. We would flow this span all the way down to the OS API calls then translate it into the relevant Span\u003cWSABuffer/IOVector\u003e. \r\n\r\nThis doesn\u0027t gel with the current SAEA BufferList property, and I haven\u0027t thought through how to flow it from the user code down to the OS API.\r\n\r\nContrived example:\r\n\r\n```c#\r\nusing System.Net;\r\nusing System.Net.Sockets;\r\nusing System.Runtime.CompilerServices;\r\n\r\nvar socket = new Socket(SocketType.Stream, ProtocolType.Tcp);\r\nsocket.Bind(new IPEndPoint(IPAddress.Loopback, 5000));\r\nsocket.Listen();\r\n\r\nvar client = socket.Accept();\r\n\r\nvar buffers = new Buffers();\r\nbuffers[0] = GetHeaders();\r\nbuffers[1] = GetBody();\r\n\r\nawait client.SendAsync(buffers);\r\n\r\nReadOnlyMemory\u003cbyte\u003e GetHeaders() =\u003e default;\r\nReadOnlyMemory\u003cbyte\u003e GetBody() =\u003e default;\r\n\r\n[InlineArray(2)]\r\nstruct Buffers\r\n{\r\n    private ReadOnlyMemory\u003cbyte\u003e _buffers;\r\n}\r\n\r\nstatic class Extensions\r\n{\r\n    public static ValueTask\u003cint\u003e SendAsync(this Socket socket, ReadOnlySpan\u003cReadOnlyMemory\u003cbyte\u003e\u003e buffers) =\u003e default;\r\n}\r\n```",
                                           "updatedAt":  "2023-07-30T17:15:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ix0hg",
                                           "createdAt":  "2023-07-30T17:36:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e\u003e Do you just mean an API like SendAsync(ReadOnlySpan\u003cReadOnlyMemory\u003e and it would copy that span to its own possibly-pooled heap object?\r\n\r\n\u003e Yes exactly. We would flow this span all the way down to the OS API calls then translate it into the relevant Span\u003cWSABuffer/IOVector\u003e.\r\n\r\nJust to be extra clear, though, it\u0027s not just about pinning. The list of buffers needs to be available asynchronously from the current stack if the operation doesn\u0027t complete synchronously, which means copying it somewhere.",
                                           "updatedAt":  "2023-07-30T17:36:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ix2RZ",
                                           "createdAt":  "2023-07-30T18:14:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "\u003e Just to be extra clear, though, it\u0027s not just about pinning. The list of buffers needs to be available asynchronously from the current stack if the operation doesn\u0027t complete synchronously, which means copying it somewhere.\r\n\r\nAre you talking about the Linux case where we queue the operation? Or do you mean in both cases?",
                                           "updatedAt":  "2023-07-30T18:14:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ix2vc",
                                           "createdAt":  "2023-07-30T18:25:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Are you talking about the Linux case where we queue the operation?\r\n\r\nI\u0027m talking about the non-Windows case where if the native call on the non-blocking socket returns EAGAIN / EWOULDBLOCK, we wait on an epoll / kqueue and try again when notified that we can make forward progress with the operation.",
                                           "updatedAt":  "2023-07-30T18:25:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ix9Ye",
                                           "createdAt":  "2023-07-30T20:48:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "I see, yes that makes sense. It would force us to copy the array in that case.",
                                           "updatedAt":  "2023-07-30T20:48:01Z"
                                       }
                                   ],
                         "totalCount":  49
                     },
        "title":  "Support IList\u003cReadOnlyMemory\u003cbyte\u003e\u003e SocketAsyncEventArgs",
        "labels":  [
                       "api-suggestion",
                       "area-System.Net.Sockets",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/50568",
        "createdAt":  "2021-04-01T15:17:01Z",
        "number":  50568,
        "author":  "mdh1418",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-08-08T04:37:50Z",
        "body":  "Several tests from System.Net.Sockets.Tests fail on Android\r\n\r\nSystem.Net.Sockets.Tests.dll   Failed: 10\r\n```\r\nSystem.Net.Sockets.Tests.SendReceive_SpanSync.TcpReceiveSendGetsCanceledByDispose(receiveOrSend: True, ipv6Server: False, dualModeClient: True)\r\nSystem.Net.Sockets.Tests.SendReceive_SpanSync.TcpReceiveSendGetsCanceledByDispose(receiveOrSend: True, ipv6Server: True, dualModeClient: False)\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.UnixDomainSocketEndPoint_UsingAbstractSocketAddressOnUnsupported_Throws\r\nSystem.Net.Sockets.Tests.SendReceive_SyncForceNonBlocking.TcpReceiveSendGetsCanceledByDispose(receiveOrSend: True, ipv6Server: False, dualModeClient: True)\r\nSystem.Net.Sockets.Tests.SendReceive_SyncForceNonBlocking.TcpReceiveSendGetsCanceledByDispose(receiveOrSend: True, ipv6Server: True, dualModeClient: False)\r\nSystem.Net.Sockets.Tests.OSSupportTest.IOControl_SIOCATMARK_Unix_Success\r\nSystem.Net.Sockets.Tests.SendReceive_Sync.TcpReceiveSendGetsCanceledByDispose(receiveOrSend: True, ipv6Server: False, dualModeClient: True)\r\nSystem.Net.Sockets.Tests.SendReceive_Sync.TcpReceiveSendGetsCanceledByDispose(receiveOrSend: True, ipv6Server: True, dualModeClient: False)\r\nSystem.Net.Sockets.Tests.SendReceive_SpanSyncForceNonBlocking.TcpReceiveSendGetsCanceledByDispose(receiveOrSend: True, ipv6Server: False, dualModeClient: True)\r\nSystem.Net.Sockets.Tests.SendReceive_SpanSyncForceNonBlocking.TcpReceiveSendGetsCanceledByDispose(receiveOrSend: True, ipv6Server: True, dualModeClient: False)\r\n```\r\n\r\nUpdated based on local run as of 349d8113bab",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOSFNc5w==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxMTk3ODg3OQ==",
                                           "createdAt":  "2021-04-01T15:17:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nSeveral tests from System.Net.Sockets.Tests fail on Android\r\n\r\n- [ ] System.Net.Sockets.Tests.SendReceive_SyncForceNonBlocking.TcpReceiveSendGetsCanceledByDispose(receiveOrSend: True, ipv6Server: False, dualModeClient: True)\r\n- [ ] System.Net.Sockets.Tests.SendReceive_SyncForceNonBlocking.TcpReceiveSendGetsCanceledByDispose(receiveOrSend: True, ipv6Server: True, dualModeClient: False)\r\n- [ ] System.Net.Sockets.Tests.UnixDomainSocketTest.UnixDomainSocketEndPoint_UsingAbstractSocketAddressOnUnsupported_Throws\r\n- [ ] System.Net.Sockets.Tests.OSSupportTest.IOControl_SIOCATMARK_Unix_Success\r\n- [ ] System.Net.Sockets.Tests.SendReceive_SpanSyncForceNonBlocking.TcpReceiveSendGetsCanceledByDispose(receiveOrSend: True, ipv6Server: False, dualModeClient: True)\r\n- [ ] System.Net.Sockets.Tests.SendReceive_SpanSyncForceNonBlocking.TcpReceiveSendGetsCanceledByDispose(receiveOrSend: True, ipv6Server: True, dualModeClient: False)\r\n- [ ] System.Net.Sockets.Tests.SendReceive_SpanSync.TcpReceiveSendGetsCanceledByDispose(receiveOrSend: True, ipv6Server: False, dualModeClient: True)\r\n- [ ] System.Net.Sockets.Tests.SendReceive_SpanSync.TcpReceiveSendGetsCanceledByDispose(receiveOrSend: True, ipv6Server: True, dualModeClient: False)\r\n- [ ] System.Net.Sockets.Tests.SendReceive_Sync.TcpReceiveSendGetsCanceledByDispose(receiveOrSend: True, ipv6Server: False, dualModeClient: True)\r\n- [ ] System.Net.Sockets.Tests.SendReceive_Sync.TcpReceiveSendGetsCanceledByDispose(receiveOrSend: True, ipv6Server: True, dualModeClient: False)\r\n- [ ] System.Net.Sockets.Tests.SocketOptionNameTest.GetSetRawSocketOption_Roundtrips(family: InterNetwork)\r\n- [ ] System.Net.Sockets.Tests.SocketOptionNameTest.GetSetRawSocketOption_Roundtrips(family: InterNetworkV6)\r\n- [ ] System.Net.Sockets.Tests.DualModeAcceptAsync.AcceptAsyncV4BoundToAnyV4_Success\r\n- [ ] System.Net.Sockets.Tests.DualModeAcceptAsync.AcceptAsyncV4BoundToSpecificV4_Success\r\n- [ ] System.Net.Sockets.Tests.DualModeAcceptAsync.AcceptAsyncV4BoundToAnyV6_Success\r\n- [ ] System.Net.Sockets.Tests.DualModeAcceptAsync.AcceptAsyncV6BoundToSpecificV6_Success\r\n- [ ] System.Net.Sockets.Tests.DualModeConnectAsync.ConnectAsyncV4IPEndPointToV4Host_Success\r\n- [ ] System.Net.Sockets.Tests.DualModeConnectAsync.ConnectAsyncV6IPEndPointToV6Host_Success\r\n- [ ] System.Net.Sockets.Tests.DualModeConnectAsync.ConnectAsyncV6IPEndPointToV4Host_Fails\r\n- [ ] System.Net.Sockets.Tests.DualModeConnectAsync.ConnectAsyncV4IPEndPointToDualHost_Success\r\n- [ ] System.Net.Sockets.Tests.DualModeConnectAsync.ConnectAsyncV4IPEndPointToV6Host_Fails\r\n- [ ] System.Net.Sockets.Tests.DualModeConnectAsync.ConnectAsyncV6IPEndPointToDualHost_Success\r\n- [ ] System.Net.Sockets.Tests.IPPacketInformationTest.Equals_NonDefaultValue_Success\r\n- [ ] System.Net.Sockets.Tests.IPPacketInformationTest.GetHashCode_NonDefaultValue_Succes\r\n\r\nBased on CI runs from https://github.com/dotnet/runtime/pull/50095\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003emdh1418\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Net.Sockets`, `os-android`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e6.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-04-01T15:17:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc402p9a",
                                           "createdAt":  "2021-07-26T14:16:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "@mdh1418 :\r\n\r\nIt looks like these tests have been mass-disabled in #50800. Is there any log / stack trace from the time before? (Can\u0027t find on kusto). Some of them might be caused by a problem described in #1481.\r\n\r\nIs this something you still plan to investigate for 6.0? If not shouldn\u0027t we move it out to 7.0?",
                                           "updatedAt":  "2021-07-26T14:19:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc405zJo",
                                           "createdAt":  "2021-07-27T14:35:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mdh1418",
                                           "body":  "@antonfirsov I don\u0027t think I have the log/stack trace from before.\r\n\r\nI just reran the tests, and out of the original 26, only 12 still fail now based off of 34094b305d4 and I updated the description accordingly.\r\n\r\nThe following is the failure log/stack trace from my local run.\r\n\r\n```\r\nSystem.Net.Sockets.Tests.dll   Failed: 12\r\n\r\nTest collection for System.Net.Sockets.Tests.SendReceive_SpanSync\r\nSystem.Net.Sockets.Tests.SendReceive_SpanSync.TcpReceiveSendGetsCanceledByDispose(receiveOrSend: True, ipv6Server: False, dualModeClient: True)\r\n    System.AggregateException : One or more errors occurred. (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null))\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\r\nSystem.Net.Sockets.Tests.SendReceive_SpanSync.TcpReceiveSendGetsCanceledByDispose(receiveOrSend: True, ipv6Server: True, dualModeClient: False)\r\n    System.AggregateException : One or more errors occurred. (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null))\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\r\n\r\nTest collection for System.Net.Sockets.Tests.UnixDomainSocketTest\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.UnixDomainSocketEndPoint_UsingAbstractSocketAddressOnUnsupported_Throws\r\n    Assert.Throws() Failure\\nExpected: typeof(System.Net.Sockets.SocketException)\\nActual:   (No exception was thrown)\r\n\r\nTest collection for System.Net.Sockets.Tests.SendReceive_SyncForceNonBlocking\r\nSystem.Net.Sockets.Tests.SendReceive_SyncForceNonBlocking.TcpReceiveSendGetsCanceledByDispose(receiveOrSend: True, ipv6Server: False, dualModeClient: True)\r\n    System.AggregateException : One or more errors occurred. (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null))\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\r\nSystem.Net.Sockets.Tests.SendReceive_SyncForceNonBlocking.TcpReceiveSendGetsCanceledByDispose(receiveOrSend: True, ipv6Server: True, dualModeClient: False)\r\n    System.AggregateException : One or more errors occurred. (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null))\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\r\n\r\nTest collection for System.Net.Sockets.Tests.OSSupportTest\r\nSystem.Net.Sockets.Tests.OSSupportTest.IOControl_SIOCATMARK_Unix_Success\r\n    System.Net.Sockets.SocketException : Permission denied\r\n\r\nTest collection for System.Net.Sockets.Tests.SocketOptionNameTest\r\nSystem.Net.Sockets.Tests.SocketOptionNameTest.GetSetRawSocketOption_Roundtrips(family: InterNetwork)\r\n    Microsoft.DotNet.XUnitExtensions.SkipTestException : Unknown platform\r\nSystem.Net.Sockets.Tests.SocketOptionNameTest.GetSetRawSocketOption_Roundtrips(family: InterNetworkV6)\r\n    Microsoft.DotNet.XUnitExtensions.SkipTestException : Unknown platform\r\n\r\nTest collection for System.Net.Sockets.Tests.SendReceive_Sync\r\nSystem.Net.Sockets.Tests.SendReceive_Sync.TcpReceiveSendGetsCanceledByDispose(receiveOrSend: True, ipv6Server: False, dualModeClient: True)\r\n    System.AggregateException : One or more errors occurred. (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null))\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\r\nSystem.Net.Sockets.Tests.SendReceive_Sync.TcpReceiveSendGetsCanceledByDispose(receiveOrSend: True, ipv6Server: True, dualModeClient: False)\r\n    System.AggregateException : One or more errors occurred. (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null))\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\r\n\r\nTest collection for System.Net.Sockets.Tests.SendReceive_SpanSyncForceNonBlocking\r\nSystem.Net.Sockets.Tests.SendReceive_SpanSyncForceNonBlocking.TcpReceiveSendGetsCanceledByDispose(receiveOrSend: True, ipv6Server: False, dualModeClient: True)\r\n    System.AggregateException : One or more errors occurred. (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null))\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\r\nSystem.Net.Sockets.Tests.SendReceive_SpanSyncForceNonBlocking.TcpReceiveSendGetsCanceledByDispose(receiveOrSend: True, ipv6Server: True, dualModeClient: False)\r\n    System.AggregateException : One or more errors occurred. (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)) (Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null))\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\\n---- Assert.Equal() Failure\\nExpected: ConnectionReset\\nActual:   (null)\r\n",
                                           "updatedAt":  "2021-07-27T14:35:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HnkuV",
                                           "createdAt":  "2022-08-01T18:26:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "directhex",
                                           "body":  "This isn\u0027t really any better today than a year ago. How many of these are cases where Android _should_ be passing, vs. cases where the OS means the test can never pass? e.g. SIOCATMARK is explicitly disabled on Android (https://android.googlesource.com/platform/system/sepolicy/+/master/public/domain.te)",
                                           "updatedAt":  "2022-08-01T18:26:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5IU1zn",
                                           "createdAt":  "2022-08-12T18:54:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "SamMonoRT",
                                           "body":  "moving to 8.0.0",
                                           "updatedAt":  "2022-08-12T18:54:27Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "System.Net.Sockets.Tests fails on Android",
        "labels":  [
                       "area-System.Net.Sockets",
                       "disabled-test",
                       "os-android"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/52124",
        "createdAt":  "2021-04-30T18:11:34Z",
        "number":  52124,
        "author":  "mdh1418",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-07-25T19:01:54Z",
        "body":  "System.Net.Sockets.Tests.dll   Failed: 70\r\nPNSE\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_Sync.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveFrom_CancellableTask.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_MemoryArrayTask.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveFrom_MemoryArrayTask.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_SpanSyncForceNonBlocking.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_Task.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_Apm.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_MemoryNativeTask.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveFrom_SpanSync.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_SpanSync.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_Eap.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveFrom_Apm.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveFrom_SpanSyncForceNonBlocking.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveFrom_Task.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveFrom_Eap.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveFrom_SyncForceNonBlocking.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_SyncForceNonBlocking.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_CancellableTask.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveFrom_Sync.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveFrom_MemoryNativeTask.ReceiveSent_TCP_Success(ipv6: True)\r\nFAIL\r\nSystem.Net.Sockets.Tests.SendReceive_Eap.SendRecv_NoBuffering_Success\r\nSystem.Net.Sockets.Tests.SendReceive_Sync.UdpReceiveGetsCanceledByDispose(address: 127.0.0.1)\r\nSystem.Net.Sockets.Tests.SendReceive_Sync.UdpReceiveGetsCanceledByDispose(address: ::1)\r\nSystem.Net.Sockets.Tests.SendReceive_Sync.UdpReceiveGetsCanceledByDispose(address: ::ffff:127.0.0.1)\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_BasicPropertiesPropagate_Success(addressFamily: InterNetworkV6, socketType: Stream, protocolType: Tcp)\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_BasicPropertiesPropagate_Success(addressFamily: Unix, socketType: Stream, protocolType: Unspecified)\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_BasicPropertiesPropagate_Success(addressFamily: InterNetwork, socketType: Dgram, protocolType: Udp)\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_BasicPropertiesPropagate_Success(addressFamily: InterNetworkV6, socketType: Dgram, protocolType: Udp)\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_BasicPropertiesPropagate_Success(addressFamily: InterNetwork, socketType: Stream, protocolType: Tcp)\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_Listening_Success(shareSafeHandle: False)\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_Listening_Success(shareSafeHandle: True)\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_Tcp_SendReceive_Success(addressFamily: InterNetwork, socketType: Stream, protocolType: Tcp)\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_Tcp_SendReceive_Success(addressFamily: InterNetworkV6, socketType: Stream, protocolType: Tcp)\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_SocketPair_Success\r\nSystem.Net.Sockets.Tests.SendReceive_MemoryArrayTask.SendRecv_NoBuffering_Success\r\nSystem.Net.Sockets.Tests.SocketOptionNameTest.GetSetRawSocketOption_Roundtrips(family: InterNetwork)\r\nSystem.Net.Sockets.Tests.SocketOptionNameTest.GetSetRawSocketOption_Roundtrips(family: InterNetworkV6)\r\nSystem.Net.Sockets.Tests.SocketOptionNameTest.MulticastInterface_Set_IPv6_AnyInterface_Succeeds\r\nSystem.Net.Sockets.Tests.SocketOptionNameTest.Get_AcceptConnection_Succeeds\r\nSystem.Net.Sockets.Tests.SelectTest.Select_Error_OneReadyAtATime\r\nSystem.Net.Sockets.Tests.SelectTest.Select_ReadError_NoneReady_ManySockets\r\nSystem.Net.Sockets.Tests.SelectTest.Poll_ReadReady_LongTimeouts(microsecondsTimeout: -1)\r\nSystem.Net.Sockets.Tests.SelectTest.Poll_ReadReady_LongTimeouts(microsecondsTimeout: 30000000)\r\nSystem.Net.Sockets.Tests.DualModeBeginConnectToIPAddress.BeginConnectV6IPAddressToV6Host_Success\r\nSystem.Net.Sockets.Tests.DualModeBeginConnectToIPAddress.BeginConnectV6IPAddressToDualHost_Success\r\nSystem.Net.Sockets.Tests.DualModeBeginConnectToIPAddress.BeginConnectV4IPAddressToV4Host_Success\r\nSystem.Net.Sockets.Tests.DualModeBeginConnectToIPAddress.BeginConnectV4IPAddressToDualHost_Success\r\nSystem.Net.Sockets.Tests.TcpListenerTest.Accept_AcceptsPendingSocketOrClient(mode: 0)\r\nSystem.Net.Sockets.Tests.TcpListenerTest.Accept_AcceptsPendingSocketOrClient(mode: 1)\r\nSystem.Net.Sockets.Tests.TcpListenerTest.Accept_AcceptsPendingSocketOrClient(mode: 2)\r\nSystem.Net.Sockets.Tests.UdpClientTest.DontFragment_Roundtrips\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_ConnectAsyncUnixDomainSocketEndPoint_Success\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_SendReceiveAsync_PropagateToStream_Success(iterations: 500, writeBufferSize: 18, readBufferSize: 21)\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_SendReceiveAsync_PropagateToStream_Success(iterations: 500, writeBufferSize: 21, readBufferSize: 18)\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_SendReceiveAsync_PropagateToStream_Success(iterations: 5000, writeBufferSize: 1, readBufferSize: 1)\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_SendReceiveAsync_PropagateToStream_Success(iterations: 5, writeBufferSize: 128000, readBufferSize: 64000)\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_SendReceive_Success\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.ConcurrentSendReceive(forceNonBlocking: False)\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.ConcurrentSendReceive(forceNonBlocking: True)\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.UnixDomainSocketEndPoint_RemoteEndPointEqualsBindAddress(abstractAddress: False)\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_ConnectAsyncUnixDomainSocketEndPoint_NotServer\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_SendReceive_Clone_Success\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.ConcurrentSendReceiveAsync\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_SendReceiveAsync_Success\r\nSystem.Net.Sockets.Tests.SendReceive_MemoryNativeTask.SendRecv_NoBuffering_Success\r\nSystem.Net.Sockets.Tests.SendReceive_Apm.SendRecv_NoBuffering_Success\r\nSystem.Net.Sockets.Tests.SendReceive_Task.SendRecv_NoBuffering_Success\r\nSystem.Net.Sockets.Tests.SendReceive_SpanSync.UdpReceiveGetsCanceledByDispose(address: 127.0.0.1)\r\nSystem.Net.Sockets.Tests.SendReceive_SpanSync.UdpReceiveGetsCanceledByDispose(address: ::1)\r\nSystem.Net.Sockets.Tests.SendReceive_SpanSync.UdpReceiveGetsCanceledByDispose(address: ::ffff:127.0.0.1)\r\n\r\nHangs on\r\nReceiveMessageFrom.cs - ClosedDuringOperation_Throws_ObjectDisposedExceptionOrSocketException\r\nReceiveFrom.cs - ClosedDuringOperation_Throws_ObjectDisposedExceptionOrSocketException\r\nExecutionContextFlowTest.cs -  APM_ExecutionContextFlowsAcrossBeginSendFileOperation\r\n```\r\nSystem.Net.Sockets.Tests.dll   Failed: 70\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveMessageFrom_Sync\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_Sync.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveFrom_CancellableTask\r\nSystem.Net.Sockets.Tests.ReceiveFrom_CancellableTask.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.SendReceive_Eap\r\nSystem.Net.Sockets.Tests.SendReceive_Eap.SendRecv_NoBuffering_Success\r\n    System.Net.Sockets.SocketException : Invalid argument\r\n\r\nTest collection for System.Net.Sockets.Tests.SendReceive_Sync\r\nSystem.Net.Sockets.Tests.SendReceive_Sync.UdpReceiveGetsCanceledByDispose(address: 127.0.0.1)\r\n    System.TimeoutException : The operation has timed out.\r\nSystem.Net.Sockets.Tests.SendReceive_Sync.UdpReceiveGetsCanceledByDispose(address: ::1)\r\n    System.TimeoutException : The operation has timed out.\r\nSystem.Net.Sockets.Tests.SendReceive_Sync.UdpReceiveGetsCanceledByDispose(address: ::ffff:127.0.0.1)\r\n    System.TimeoutException : The operation has timed out.\r\n\r\nTest collection for System.Net.Sockets.Tests.CreateSocket\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_BasicPropertiesPropagate_Success(addressFamily: InterNetworkV6, socketType: Stream, protocolType: Tcp)\r\n    Assert.Equal() Failure\\nExpected: InterNetworkV6\\nActual:   Unknown\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_BasicPropertiesPropagate_Success(addressFamily: Unix, socketType: Stream, protocolType: Unspecified)\r\n    Assert.Equal() Failure\\nExpected: Unix\\nActual:   Unknown\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_BasicPropertiesPropagate_Success(addressFamily: InterNetwork, socketType: Dgram, protocolType: Udp)\r\n    Assert.Equal() Failure\\nExpected: InterNetwork\\nActual:   Unknown\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_BasicPropertiesPropagate_Success(addressFamily: InterNetworkV6, socketType: Dgram, protocolType: Udp)\r\n    Assert.Equal() Failure\\nExpected: InterNetworkV6\\nActual:   Unknown\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_BasicPropertiesPropagate_Success(addressFamily: InterNetwork, socketType: Stream, protocolType: Tcp)\r\n    Assert.Equal() Failure\\nExpected: InterNetwork\\nActual:   Unknown\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_Listening_Success(shareSafeHandle: False)\r\n    Assert.Throws() Failure\\nExpected: typeof(System.InvalidOperationException)\\nActual:   typeof(System.Net.Internals.SocketExceptionFactory+ExtendedSocketException): Operation not supported 127.0.0.1:0\\n---- System.Net.Internals.SocketExceptionFactory+ExtendedSocketException : Operation not supported 127.0.0.1:0\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_Listening_Success(shareSafeHandle: True)\r\n    Assert.Throws() Failure\\nExpected: typeof(System.InvalidOperationException)\\nActual:   typeof(System.Net.Internals.SocketExceptionFactory+ExtendedSocketException): Operation not supported 127.0.0.1:0\\n---- System.Net.Internals.SocketExceptionFactory+ExtendedSocketException : Operation not supported 127.0.0.1:0\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_Tcp_SendReceive_Success(addressFamily: InterNetwork, socketType: Stream, protocolType: Tcp)\r\n    Assert.True() Failure\\nExpected: True\\nActual:   False\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_Tcp_SendReceive_Success(addressFamily: InterNetworkV6, socketType: Stream, protocolType: Tcp)\r\n    Assert.True() Failure\\nExpected: True\\nActual:   False\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_SocketPair_Success\r\n    Assert.True() Failure\\nExpected: True\\nActual:   False\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveMessageFrom_MemoryArrayTask\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_MemoryArrayTask.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveFrom_MemoryArrayTask\r\nSystem.Net.Sockets.Tests.ReceiveFrom_MemoryArrayTask.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveMessageFrom_SpanSyncForceNonBlocking\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_SpanSyncForceNonBlocking.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveMessageFrom_Task\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_Task.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveMessageFrom_Apm\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_Apm.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveMessageFrom_MemoryNativeTask\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_MemoryNativeTask.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveFrom_SpanSync\r\nSystem.Net.Sockets.Tests.ReceiveFrom_SpanSync.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.SendReceive_MemoryArrayTask\r\nSystem.Net.Sockets.Tests.SendReceive_MemoryArrayTask.SendRecv_NoBuffering_Success\r\n    System.Net.Sockets.SocketException : Invalid argument\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveMessageFrom_SpanSync\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_SpanSync.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveMessageFrom_Eap\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_Eap.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveFrom_Apm\r\nSystem.Net.Sockets.Tests.ReceiveFrom_Apm.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.SocketOptionNameTest\r\nSystem.Net.Sockets.Tests.SocketOptionNameTest.GetSetRawSocketOption_Roundtrips(family: InterNetwork)\r\n    Microsoft.DotNet.XUnitExtensions.SkipTestException : Unknown platform\r\nSystem.Net.Sockets.Tests.SocketOptionNameTest.GetSetRawSocketOption_Roundtrips(family: InterNetworkV6)\r\n    Microsoft.DotNet.XUnitExtensions.SkipTestException : Unknown platform\r\nSystem.Net.Sockets.Tests.SocketOptionNameTest.MulticastInterface_Set_IPv6_AnyInterface_Succeeds\r\n    System.Net.Sockets.SocketException : No route to host\r\nSystem.Net.Sockets.Tests.SocketOptionNameTest.Get_AcceptConnection_Succeeds\r\n    System.Net.Sockets.SocketException : Protocol not available\r\n\r\nTest collection for System.Net.Sockets.Tests.SelectTest\r\nSystem.Net.Sockets.Tests.SelectTest.Select_Error_OneReadyAtATime\r\n    Assert.Equal() Failure\\nExpected: 1\\nActual:   0\r\nSystem.Net.Sockets.Tests.SelectTest.Select_ReadError_NoneReady_ManySockets\r\n    System.Net.Sockets.SocketException : Too many open files in system\r\nSystem.Net.Sockets.Tests.SelectTest.Poll_ReadReady_LongTimeouts(microsecondsTimeout: -1)\r\n    System.Net.Sockets.SocketException : Too many open files in system\r\nSystem.Net.Sockets.Tests.SelectTest.Poll_ReadReady_LongTimeouts(microsecondsTimeout: 30000000)\r\n    System.Net.Sockets.SocketException : Too many open files in system\r\n\r\nTest collection for System.Net.Sockets.Tests.DualModeBeginConnectToIPAddress\r\nSystem.Net.Sockets.Tests.DualModeBeginConnectToIPAddress.BeginConnectV6IPAddressToV6Host_Success\r\n    System.Net.Sockets.SocketException : Too many open files in system\r\nSystem.Net.Sockets.Tests.DualModeBeginConnectToIPAddress.BeginConnectV6IPAddressToDualHost_Success\r\n    System.Net.Sockets.SocketException : Too many open files in system\r\nSystem.Net.Sockets.Tests.DualModeBeginConnectToIPAddress.BeginConnectV4IPAddressToV4Host_Success\r\n    System.Net.Sockets.SocketException : Too many open files in system\r\nSystem.Net.Sockets.Tests.DualModeBeginConnectToIPAddress.BeginConnectV4IPAddressToDualHost_Success\r\n    System.Net.Sockets.SocketException : Too many open files in system\r\n\r\nTest collection for System.Net.Sockets.Tests.TcpListenerTest\r\nSystem.Net.Sockets.Tests.TcpListenerTest.Accept_AcceptsPendingSocketOrClient(mode: 0)\r\n    System.Net.Sockets.SocketException : Too many open files in system\r\nSystem.Net.Sockets.Tests.TcpListenerTest.Accept_AcceptsPendingSocketOrClient(mode: 1)\r\n    System.Net.Sockets.SocketException : Too many open files in system\r\nSystem.Net.Sockets.Tests.TcpListenerTest.Accept_AcceptsPendingSocketOrClient(mode: 2)\r\n    System.Net.Sockets.SocketException : Too many open files in system\r\n\r\nTest collection for System.Net.Sockets.Tests.UdpClientTest\r\nSystem.Net.Sockets.Tests.UdpClientTest.DontFragment_Roundtrips\r\n    System.Net.Sockets.SocketException : Operation not supported\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveFrom_SpanSyncForceNonBlocking\r\nSystem.Net.Sockets.Tests.ReceiveFrom_SpanSyncForceNonBlocking.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.UnixDomainSocketTest\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_ConnectAsyncUnixDomainSocketEndPoint_Success\r\n    System.ArgumentOutOfRangeException : The path \u0027/Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/n142pcgf.yhxAAAAAAAAAAAAAAAAAAAAA\u0027 is of an invalid length for use with domain sockets on this platform.  The length must be between 1 and 104 characters, inclusive. (Parameter \u0027path\u0027)\\nActual value was /Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/n142pcgf.yhxAAAAAAAAAAAAAAAAAAAAA.\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_SendReceiveAsync_PropagateToStream_Success(iterations: 500, writeBufferSize: 18, readBufferSize: 21)\r\n    System.ArgumentOutOfRangeException : The path \u0027/Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/i31xer4y.t3yAAAAAAAAAAAAAAAAAAAAA\u0027 is of an invalid length for use with domain sockets on this platform.  The length must be between 1 and 104 characters, inclusive. (Parameter \u0027path\u0027)\\nActual value was /Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/i31xer4y.t3yAAAAAAAAAAAAAAAAAAAAA.\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_SendReceiveAsync_PropagateToStream_Success(iterations: 500, writeBufferSize: 21, readBufferSize: 18)\r\n    System.ArgumentOutOfRangeException : The path \u0027/Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/vfxmclar.52qAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0027 is of an invalid length for use with domain sockets on this platform.  The length must be between 1 and 104 characters, inclusive. (Parameter \u0027path\u0027)\\nActual value was /Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/vfxmclar.52qAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_SendReceiveAsync_PropagateToStream_Success(iterations: 5000, writeBufferSize: 1, readBufferSize: 1)\r\n    System.ArgumentOutOfRangeException : The path \u0027/Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/5opzwyhl.y2sAAAAAAAAAAAAAA\u0027 is of an invalid length for use with domain sockets on this platform.  The length must be between 1 and 104 characters, inclusive. (Parameter \u0027path\u0027)\\nActual value was /Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/5opzwyhl.y2sAAAAAAAAAAAAAA.\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_SendReceiveAsync_PropagateToStream_Success(iterations: 5, writeBufferSize: 128000, readBufferSize: 64000)\r\n    System.ArgumentOutOfRangeException : The path \u0027/Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/n2fypzci.crkAAAAAAAAAAAAAAAAAAA\u0027 is of an invalid length for use with domain sockets on this platform.  The length must be between 1 and 104 characters, inclusive. (Parameter \u0027path\u0027)\\nActual value was /Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/n2fypzci.crkAAAAAAAAAAAAAAAAAAA.\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_SendReceive_Success\r\n    System.ArgumentOutOfRangeException : The path \u0027/Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/2zan0xuw.c33AAAAAAAAAAAAAAAAAAAAAAAAA\u0027 is of an invalid length for use with domain sockets on this platform.  The length must be between 1 and 104 characters, inclusive. (Parameter \u0027path\u0027)\\nActual value was /Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/2zan0xuw.c33AAAAAAAAAAAAAAAAAAAAAAAAA.\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.ConcurrentSendReceive(forceNonBlocking: False)\r\n    System.ArgumentOutOfRangeException : The path \u0027/Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/r2juhb2t.ontAAAAAAAAAAAAAAAA\u0027 is of an invalid length for use with domain sockets on this platform.  The length must be between 1 and 104 characters, inclusive. (Parameter \u0027path\u0027)\\nActual value was /Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/r2juhb2t.ontAAAAAAAAAAAAAAAA.\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.ConcurrentSendReceive(forceNonBlocking: True)\r\n    System.ArgumentOutOfRangeException : The path \u0027/Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/zzjxremm.vd5AAAAAAA\u0027 is of an invalid length for use with domain sockets on this platform.  The length must be between 1 and 104 characters, inclusive. (Parameter \u0027path\u0027)\\nActual value was /Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/zzjxremm.vd5AAAAAAA.\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.UnixDomainSocketEndPoint_RemoteEndPointEqualsBindAddress(abstractAddress: False)\r\n    System.ArgumentOutOfRangeException : The path \u0027/Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/rco2lyco.guvAAAAAAAAA\u0027 is of an invalid length for use with domain sockets on this platform.  The length must be between 1 and 104 characters, inclusive. (Parameter \u0027path\u0027)\\nActual value was /Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/rco2lyco.guvAAAAAAAAA.\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_ConnectAsyncUnixDomainSocketEndPoint_NotServer\r\n    System.ArgumentOutOfRangeException : The path \u0027/Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/t12qvpze.spaAAAAA\u0027 is of an invalid length for use with domain sockets on this platform.  The length must be between 1 and 104 characters, inclusive. (Parameter \u0027path\u0027)\\nActual value was /Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/t12qvpze.spaAAAAA.\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_SendReceive_Clone_Success\r\n    System.ArgumentOutOfRangeException : The path \u0027/Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/dyumux35.53aAA\u0027 is of an invalid length for use with domain sockets on this platform.  The length must be between 1 and 104 characters, inclusive. (Parameter \u0027path\u0027)\\nActual value was /Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/dyumux35.53aAA.\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.ConcurrentSendReceiveAsync\r\n    System.ArgumentOutOfRangeException : The path \u0027/Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/3qtc3vik.ooiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0027 is of an invalid length for use with domain sockets on this platform.  The length must be between 1 and 104 characters, inclusive. (Parameter \u0027path\u0027)\\nActual value was /Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/3qtc3vik.ooiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_SendReceiveAsync_Success\r\n    System.ArgumentOutOfRangeException : The path \u0027/Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/xtfwlc33.nz3AAAAAAAAAAAAAAAAAAAAAA\u0027 is of an invalid length for use with domain sockets on this platform.  The length must be between 1 and 104 characters, inclusive. (Parameter \u0027path\u0027)\\nActual value was /Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/xtfwlc33.nz3AAAAAAAAAAAAAAAAAAAAAA.\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveFrom_Task\r\nSystem.Net.Sockets.Tests.ReceiveFrom_Task.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveFrom_Eap\r\nSystem.Net.Sockets.Tests.ReceiveFrom_Eap.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveFrom_SyncForceNonBlocking\r\nSystem.Net.Sockets.Tests.ReceiveFrom_SyncForceNonBlocking.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveMessageFrom_SyncForceNonBlocking\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_SyncForceNonBlocking.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveMessageFrom_CancellableTask\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_CancellableTask.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.SendReceive_MemoryNativeTask\r\nSystem.Net.Sockets.Tests.SendReceive_MemoryNativeTask.SendRecv_NoBuffering_Success\r\n    System.Net.Sockets.SocketException : Invalid argument\r\n\r\nTest collection for System.Net.Sockets.Tests.SendReceive_Apm\r\nSystem.Net.Sockets.Tests.SendReceive_Apm.SendRecv_NoBuffering_Success\r\n    System.Net.Sockets.SocketException : Invalid argument\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveFrom_Sync\r\nSystem.Net.Sockets.Tests.ReceiveFrom_Sync.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.SendReceive_Task\r\nSystem.Net.Sockets.Tests.SendReceive_Task.SendRecv_NoBuffering_Success\r\n    System.Net.Sockets.SocketException : Invalid argument\r\n\r\nTest collection for System.Net.Sockets.Tests.SendReceive_SpanSync\r\nSystem.Net.Sockets.Tests.SendReceive_SpanSync.UdpReceiveGetsCanceledByDispose(address: 127.0.0.1)\r\n    System.TimeoutException : The operation has timed out.\r\nSystem.Net.Sockets.Tests.SendReceive_SpanSync.UdpReceiveGetsCanceledByDispose(address: ::1)\r\n    System.TimeoutException : The operation has timed out.\r\nSystem.Net.Sockets.Tests.SendReceive_SpanSync.UdpReceiveGetsCanceledByDispose(address: ::ffff:127.0.0.1)\r\n    System.TimeoutException : The operation has timed out.\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveFrom_MemoryNativeTask\r\nSystem.Net.Sockets.Tests.ReceiveFrom_MemoryNativeTask.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHORzJ1xg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgzMDI3MTk3OA==",
                                           "createdAt":  "2021-04-30T18:11:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nSystem.Net.Sockets.Tests.dll   Failed: 70\r\nPNSE\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_Sync.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveFrom_CancellableTask.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_MemoryArrayTask.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveFrom_MemoryArrayTask.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_SpanSyncForceNonBlocking.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_Task.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_Apm.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_MemoryNativeTask.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveFrom_SpanSync.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_SpanSync.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_Eap.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveFrom_Apm.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveFrom_SpanSyncForceNonBlocking.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveFrom_Task.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveFrom_Eap.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveFrom_SyncForceNonBlocking.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_SyncForceNonBlocking.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_CancellableTask.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveFrom_Sync.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveFrom_MemoryNativeTask.ReceiveSent_TCP_Success(ipv6: True)\r\nFAIL\r\nSystem.Net.Sockets.Tests.SendReceive_Eap.SendRecv_NoBuffering_Success\r\nSystem.Net.Sockets.Tests.SendReceive_Sync.UdpReceiveGetsCanceledByDispose(address: 127.0.0.1)\r\nSystem.Net.Sockets.Tests.SendReceive_Sync.UdpReceiveGetsCanceledByDispose(address: ::1)\r\nSystem.Net.Sockets.Tests.SendReceive_Sync.UdpReceiveGetsCanceledByDispose(address: ::ffff:127.0.0.1)\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_BasicPropertiesPropagate_Success(addressFamily: InterNetworkV6, socketType: Stream, protocolType: Tcp)\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_BasicPropertiesPropagate_Success(addressFamily: Unix, socketType: Stream, protocolType: Unspecified)\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_BasicPropertiesPropagate_Success(addressFamily: InterNetwork, socketType: Dgram, protocolType: Udp)\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_BasicPropertiesPropagate_Success(addressFamily: InterNetworkV6, socketType: Dgram, protocolType: Udp)\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_BasicPropertiesPropagate_Success(addressFamily: InterNetwork, socketType: Stream, protocolType: Tcp)\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_Listening_Success(shareSafeHandle: False)\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_Listening_Success(shareSafeHandle: True)\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_Tcp_SendReceive_Success(addressFamily: InterNetwork, socketType: Stream, protocolType: Tcp)\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_Tcp_SendReceive_Success(addressFamily: InterNetworkV6, socketType: Stream, protocolType: Tcp)\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_SocketPair_Success\r\nSystem.Net.Sockets.Tests.SendReceive_MemoryArrayTask.SendRecv_NoBuffering_Success\r\nSystem.Net.Sockets.Tests.SocketOptionNameTest.GetSetRawSocketOption_Roundtrips(family: InterNetwork)\r\nSystem.Net.Sockets.Tests.SocketOptionNameTest.GetSetRawSocketOption_Roundtrips(family: InterNetworkV6)\r\nSystem.Net.Sockets.Tests.SocketOptionNameTest.MulticastInterface_Set_IPv6_AnyInterface_Succeeds\r\nSystem.Net.Sockets.Tests.SocketOptionNameTest.Get_AcceptConnection_Succeeds\r\nSystem.Net.Sockets.Tests.SelectTest.Select_Error_OneReadyAtATime\r\nSystem.Net.Sockets.Tests.SelectTest.Select_ReadError_NoneReady_ManySockets\r\nSystem.Net.Sockets.Tests.SelectTest.Poll_ReadReady_LongTimeouts(microsecondsTimeout: -1)\r\nSystem.Net.Sockets.Tests.SelectTest.Poll_ReadReady_LongTimeouts(microsecondsTimeout: 30000000)\r\nSystem.Net.Sockets.Tests.DualModeBeginConnectToIPAddress.BeginConnectV6IPAddressToV6Host_Success\r\nSystem.Net.Sockets.Tests.DualModeBeginConnectToIPAddress.BeginConnectV6IPAddressToDualHost_Success\r\nSystem.Net.Sockets.Tests.DualModeBeginConnectToIPAddress.BeginConnectV4IPAddressToV4Host_Success\r\nSystem.Net.Sockets.Tests.DualModeBeginConnectToIPAddress.BeginConnectV4IPAddressToDualHost_Success\r\nSystem.Net.Sockets.Tests.TcpListenerTest.Accept_AcceptsPendingSocketOrClient(mode: 0)\r\nSystem.Net.Sockets.Tests.TcpListenerTest.Accept_AcceptsPendingSocketOrClient(mode: 1)\r\nSystem.Net.Sockets.Tests.TcpListenerTest.Accept_AcceptsPendingSocketOrClient(mode: 2)\r\nSystem.Net.Sockets.Tests.UdpClientTest.DontFragment_Roundtrips\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_ConnectAsyncUnixDomainSocketEndPoint_Success\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_SendReceiveAsync_PropagateToStream_Success(iterations: 500, writeBufferSize: 18, readBufferSize: 21)\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_SendReceiveAsync_PropagateToStream_Success(iterations: 500, writeBufferSize: 21, readBufferSize: 18)\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_SendReceiveAsync_PropagateToStream_Success(iterations: 5000, writeBufferSize: 1, readBufferSize: 1)\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_SendReceiveAsync_PropagateToStream_Success(iterations: 5, writeBufferSize: 128000, readBufferSize: 64000)\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_SendReceive_Success\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.ConcurrentSendReceive(forceNonBlocking: False)\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.ConcurrentSendReceive(forceNonBlocking: True)\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.UnixDomainSocketEndPoint_RemoteEndPointEqualsBindAddress(abstractAddress: False)\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_ConnectAsyncUnixDomainSocketEndPoint_NotServer\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_SendReceive_Clone_Success\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.ConcurrentSendReceiveAsync\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_SendReceiveAsync_Success\r\nSystem.Net.Sockets.Tests.SendReceive_MemoryNativeTask.SendRecv_NoBuffering_Success\r\nSystem.Net.Sockets.Tests.SendReceive_Apm.SendRecv_NoBuffering_Success\r\nSystem.Net.Sockets.Tests.SendReceive_Task.SendRecv_NoBuffering_Success\r\nSystem.Net.Sockets.Tests.SendReceive_SpanSync.UdpReceiveGetsCanceledByDispose(address: 127.0.0.1)\r\nSystem.Net.Sockets.Tests.SendReceive_SpanSync.UdpReceiveGetsCanceledByDispose(address: ::1)\r\nSystem.Net.Sockets.Tests.SendReceive_SpanSync.UdpReceiveGetsCanceledByDispose(address: ::ffff:127.0.0.1)\r\n\r\n```\r\nSystem.Net.Sockets.Tests.dll   Failed: 70\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveMessageFrom_Sync\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_Sync.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveFrom_CancellableTask\r\nSystem.Net.Sockets.Tests.ReceiveFrom_CancellableTask.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.SendReceive_Eap\r\nSystem.Net.Sockets.Tests.SendReceive_Eap.SendRecv_NoBuffering_Success\r\n    System.Net.Sockets.SocketException : Invalid argument\r\n\r\nTest collection for System.Net.Sockets.Tests.SendReceive_Sync\r\nSystem.Net.Sockets.Tests.SendReceive_Sync.UdpReceiveGetsCanceledByDispose(address: 127.0.0.1)\r\n    System.TimeoutException : The operation has timed out.\r\nSystem.Net.Sockets.Tests.SendReceive_Sync.UdpReceiveGetsCanceledByDispose(address: ::1)\r\n    System.TimeoutException : The operation has timed out.\r\nSystem.Net.Sockets.Tests.SendReceive_Sync.UdpReceiveGetsCanceledByDispose(address: ::ffff:127.0.0.1)\r\n    System.TimeoutException : The operation has timed out.\r\n\r\nTest collection for System.Net.Sockets.Tests.CreateSocket\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_BasicPropertiesPropagate_Success(addressFamily: InterNetworkV6, socketType: Stream, protocolType: Tcp)\r\n    Assert.Equal() Failure\\nExpected: InterNetworkV6\\nActual:   Unknown\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_BasicPropertiesPropagate_Success(addressFamily: Unix, socketType: Stream, protocolType: Unspecified)\r\n    Assert.Equal() Failure\\nExpected: Unix\\nActual:   Unknown\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_BasicPropertiesPropagate_Success(addressFamily: InterNetwork, socketType: Dgram, protocolType: Udp)\r\n    Assert.Equal() Failure\\nExpected: InterNetwork\\nActual:   Unknown\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_BasicPropertiesPropagate_Success(addressFamily: InterNetworkV6, socketType: Dgram, protocolType: Udp)\r\n    Assert.Equal() Failure\\nExpected: InterNetworkV6\\nActual:   Unknown\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_BasicPropertiesPropagate_Success(addressFamily: InterNetwork, socketType: Stream, protocolType: Tcp)\r\n    Assert.Equal() Failure\\nExpected: InterNetwork\\nActual:   Unknown\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_Listening_Success(shareSafeHandle: False)\r\n    Assert.Throws() Failure\\nExpected: typeof(System.InvalidOperationException)\\nActual:   typeof(System.Net.Internals.SocketExceptionFactory+ExtendedSocketException): Operation not supported 127.0.0.1:0\\n---- System.Net.Internals.SocketExceptionFactory+ExtendedSocketException : Operation not supported 127.0.0.1:0\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_Listening_Success(shareSafeHandle: True)\r\n    Assert.Throws() Failure\\nExpected: typeof(System.InvalidOperationException)\\nActual:   typeof(System.Net.Internals.SocketExceptionFactory+ExtendedSocketException): Operation not supported 127.0.0.1:0\\n---- System.Net.Internals.SocketExceptionFactory+ExtendedSocketException : Operation not supported 127.0.0.1:0\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_Tcp_SendReceive_Success(addressFamily: InterNetwork, socketType: Stream, protocolType: Tcp)\r\n    Assert.True() Failure\\nExpected: True\\nActual:   False\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_Tcp_SendReceive_Success(addressFamily: InterNetworkV6, socketType: Stream, protocolType: Tcp)\r\n    Assert.True() Failure\\nExpected: True\\nActual:   False\r\nSystem.Net.Sockets.Tests.CreateSocket.Ctor_SafeHandle_SocketPair_Success\r\n    Assert.True() Failure\\nExpected: True\\nActual:   False\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveMessageFrom_MemoryArrayTask\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_MemoryArrayTask.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveFrom_MemoryArrayTask\r\nSystem.Net.Sockets.Tests.ReceiveFrom_MemoryArrayTask.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveMessageFrom_SpanSyncForceNonBlocking\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_SpanSyncForceNonBlocking.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveMessageFrom_Task\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_Task.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveMessageFrom_Apm\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_Apm.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveMessageFrom_MemoryNativeTask\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_MemoryNativeTask.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveFrom_SpanSync\r\nSystem.Net.Sockets.Tests.ReceiveFrom_SpanSync.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.SendReceive_MemoryArrayTask\r\nSystem.Net.Sockets.Tests.SendReceive_MemoryArrayTask.SendRecv_NoBuffering_Success\r\n    System.Net.Sockets.SocketException : Invalid argument\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveMessageFrom_SpanSync\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_SpanSync.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveMessageFrom_Eap\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_Eap.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveFrom_Apm\r\nSystem.Net.Sockets.Tests.ReceiveFrom_Apm.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.SocketOptionNameTest\r\nSystem.Net.Sockets.Tests.SocketOptionNameTest.GetSetRawSocketOption_Roundtrips(family: InterNetwork)\r\n    Microsoft.DotNet.XUnitExtensions.SkipTestException : Unknown platform\r\nSystem.Net.Sockets.Tests.SocketOptionNameTest.GetSetRawSocketOption_Roundtrips(family: InterNetworkV6)\r\n    Microsoft.DotNet.XUnitExtensions.SkipTestException : Unknown platform\r\nSystem.Net.Sockets.Tests.SocketOptionNameTest.MulticastInterface_Set_IPv6_AnyInterface_Succeeds\r\n    System.Net.Sockets.SocketException : No route to host\r\nSystem.Net.Sockets.Tests.SocketOptionNameTest.Get_AcceptConnection_Succeeds\r\n    System.Net.Sockets.SocketException : Protocol not available\r\n\r\nTest collection for System.Net.Sockets.Tests.SelectTest\r\nSystem.Net.Sockets.Tests.SelectTest.Select_Error_OneReadyAtATime\r\n    Assert.Equal() Failure\\nExpected: 1\\nActual:   0\r\nSystem.Net.Sockets.Tests.SelectTest.Select_ReadError_NoneReady_ManySockets\r\n    System.Net.Sockets.SocketException : Too many open files in system\r\nSystem.Net.Sockets.Tests.SelectTest.Poll_ReadReady_LongTimeouts(microsecondsTimeout: -1)\r\n    System.Net.Sockets.SocketException : Too many open files in system\r\nSystem.Net.Sockets.Tests.SelectTest.Poll_ReadReady_LongTimeouts(microsecondsTimeout: 30000000)\r\n    System.Net.Sockets.SocketException : Too many open files in system\r\n\r\nTest collection for System.Net.Sockets.Tests.DualModeBeginConnectToIPAddress\r\nSystem.Net.Sockets.Tests.DualModeBeginConnectToIPAddress.BeginConnectV6IPAddressToV6Host_Success\r\n    System.Net.Sockets.SocketException : Too many open files in system\r\nSystem.Net.Sockets.Tests.DualModeBeginConnectToIPAddress.BeginConnectV6IPAddressToDualHost_Success\r\n    System.Net.Sockets.SocketException : Too many open files in system\r\nSystem.Net.Sockets.Tests.DualModeBeginConnectToIPAddress.BeginConnectV4IPAddressToV4Host_Success\r\n    System.Net.Sockets.SocketException : Too many open files in system\r\nSystem.Net.Sockets.Tests.DualModeBeginConnectToIPAddress.BeginConnectV4IPAddressToDualHost_Success\r\n    System.Net.Sockets.SocketException : Too many open files in system\r\n\r\nTest collection for System.Net.Sockets.Tests.TcpListenerTest\r\nSystem.Net.Sockets.Tests.TcpListenerTest.Accept_AcceptsPendingSocketOrClient(mode: 0)\r\n    System.Net.Sockets.SocketException : Too many open files in system\r\nSystem.Net.Sockets.Tests.TcpListenerTest.Accept_AcceptsPendingSocketOrClient(mode: 1)\r\n    System.Net.Sockets.SocketException : Too many open files in system\r\nSystem.Net.Sockets.Tests.TcpListenerTest.Accept_AcceptsPendingSocketOrClient(mode: 2)\r\n    System.Net.Sockets.SocketException : Too many open files in system\r\n\r\nTest collection for System.Net.Sockets.Tests.UdpClientTest\r\nSystem.Net.Sockets.Tests.UdpClientTest.DontFragment_Roundtrips\r\n    System.Net.Sockets.SocketException : Operation not supported\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveFrom_SpanSyncForceNonBlocking\r\nSystem.Net.Sockets.Tests.ReceiveFrom_SpanSyncForceNonBlocking.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.UnixDomainSocketTest\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_ConnectAsyncUnixDomainSocketEndPoint_Success\r\n    System.ArgumentOutOfRangeException : The path \u0027/Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/n142pcgf.yhxAAAAAAAAAAAAAAAAAAAAA\u0027 is of an invalid length for use with domain sockets on this platform.  The length must be between 1 and 104 characters, inclusive. (Parameter \u0027path\u0027)\\nActual value was /Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/n142pcgf.yhxAAAAAAAAAAAAAAAAAAAAA.\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_SendReceiveAsync_PropagateToStream_Success(iterations: 500, writeBufferSize: 18, readBufferSize: 21)\r\n    System.ArgumentOutOfRangeException : The path \u0027/Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/i31xer4y.t3yAAAAAAAAAAAAAAAAAAAAA\u0027 is of an invalid length for use with domain sockets on this platform.  The length must be between 1 and 104 characters, inclusive. (Parameter \u0027path\u0027)\\nActual value was /Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/i31xer4y.t3yAAAAAAAAAAAAAAAAAAAAA.\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_SendReceiveAsync_PropagateToStream_Success(iterations: 500, writeBufferSize: 21, readBufferSize: 18)\r\n    System.ArgumentOutOfRangeException : The path \u0027/Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/vfxmclar.52qAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0027 is of an invalid length for use with domain sockets on this platform.  The length must be between 1 and 104 characters, inclusive. (Parameter \u0027path\u0027)\\nActual value was /Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/vfxmclar.52qAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_SendReceiveAsync_PropagateToStream_Success(iterations: 5000, writeBufferSize: 1, readBufferSize: 1)\r\n    System.ArgumentOutOfRangeException : The path \u0027/Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/5opzwyhl.y2sAAAAAAAAAAAAAA\u0027 is of an invalid length for use with domain sockets on this platform.  The length must be between 1 and 104 characters, inclusive. (Parameter \u0027path\u0027)\\nActual value was /Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/5opzwyhl.y2sAAAAAAAAAAAAAA.\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_SendReceiveAsync_PropagateToStream_Success(iterations: 5, writeBufferSize: 128000, readBufferSize: 64000)\r\n    System.ArgumentOutOfRangeException : The path \u0027/Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/n2fypzci.crkAAAAAAAAAAAAAAAAAAA\u0027 is of an invalid length for use with domain sockets on this platform.  The length must be between 1 and 104 characters, inclusive. (Parameter \u0027path\u0027)\\nActual value was /Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/n2fypzci.crkAAAAAAAAAAAAAAAAAAA.\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_SendReceive_Success\r\n    System.ArgumentOutOfRangeException : The path \u0027/Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/2zan0xuw.c33AAAAAAAAAAAAAAAAAAAAAAAAA\u0027 is of an invalid length for use with domain sockets on this platform.  The length must be between 1 and 104 characters, inclusive. (Parameter \u0027path\u0027)\\nActual value was /Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/2zan0xuw.c33AAAAAAAAAAAAAAAAAAAAAAAAA.\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.ConcurrentSendReceive(forceNonBlocking: False)\r\n    System.ArgumentOutOfRangeException : The path \u0027/Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/r2juhb2t.ontAAAAAAAAAAAAAAAA\u0027 is of an invalid length for use with domain sockets on this platform.  The length must be between 1 and 104 characters, inclusive. (Parameter \u0027path\u0027)\\nActual value was /Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/r2juhb2t.ontAAAAAAAAAAAAAAAA.\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.ConcurrentSendReceive(forceNonBlocking: True)\r\n    System.ArgumentOutOfRangeException : The path \u0027/Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/zzjxremm.vd5AAAAAAA\u0027 is of an invalid length for use with domain sockets on this platform.  The length must be between 1 and 104 characters, inclusive. (Parameter \u0027path\u0027)\\nActual value was /Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/zzjxremm.vd5AAAAAAA.\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.UnixDomainSocketEndPoint_RemoteEndPointEqualsBindAddress(abstractAddress: False)\r\n    System.ArgumentOutOfRangeException : The path \u0027/Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/rco2lyco.guvAAAAAAAAA\u0027 is of an invalid length for use with domain sockets on this platform.  The length must be between 1 and 104 characters, inclusive. (Parameter \u0027path\u0027)\\nActual value was /Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/rco2lyco.guvAAAAAAAAA.\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_ConnectAsyncUnixDomainSocketEndPoint_NotServer\r\n    System.ArgumentOutOfRangeException : The path \u0027/Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/t12qvpze.spaAAAAA\u0027 is of an invalid length for use with domain sockets on this platform.  The length must be between 1 and 104 characters, inclusive. (Parameter \u0027path\u0027)\\nActual value was /Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/t12qvpze.spaAAAAA.\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_SendReceive_Clone_Success\r\n    System.ArgumentOutOfRangeException : The path \u0027/Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/dyumux35.53aAA\u0027 is of an invalid length for use with domain sockets on this platform.  The length must be between 1 and 104 characters, inclusive. (Parameter \u0027path\u0027)\\nActual value was /Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/dyumux35.53aAA.\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.ConcurrentSendReceiveAsync\r\n    System.ArgumentOutOfRangeException : The path \u0027/Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/3qtc3vik.ooiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0027 is of an invalid length for use with domain sockets on this platform.  The length must be between 1 and 104 characters, inclusive. (Parameter \u0027path\u0027)\\nActual value was /Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/3qtc3vik.ooiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.\r\nSystem.Net.Sockets.Tests.UnixDomainSocketTest.Socket_SendReceiveAsync_Success\r\n    System.ArgumentOutOfRangeException : The path \u0027/Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/xtfwlc33.nz3AAAAAAAAAAAAAAAAAAAAAA\u0027 is of an invalid length for use with domain sockets on this platform.  The length must be between 1 and 104 characters, inclusive. (Parameter \u0027path\u0027)\\nActual value was /Users/mdhwang/Library/Developer/CoreSimulator/Devices/71D00C72-A1BD-4EF7-87EA-B22842EC1650/data/Containers/Data/Application/B3760577-6193-4B31-9EA5-797B36B6C215/tmp/xtfwlc33.nz3AAAAAAAAAAAAAAAAAAAAAA.\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveFrom_Task\r\nSystem.Net.Sockets.Tests.ReceiveFrom_Task.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveFrom_Eap\r\nSystem.Net.Sockets.Tests.ReceiveFrom_Eap.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveFrom_SyncForceNonBlocking\r\nSystem.Net.Sockets.Tests.ReceiveFrom_SyncForceNonBlocking.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveMessageFrom_SyncForceNonBlocking\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_SyncForceNonBlocking.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveMessageFrom_CancellableTask\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_CancellableTask.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.SendReceive_MemoryNativeTask\r\nSystem.Net.Sockets.Tests.SendReceive_MemoryNativeTask.SendRecv_NoBuffering_Success\r\n    System.Net.Sockets.SocketException : Invalid argument\r\n\r\nTest collection for System.Net.Sockets.Tests.SendReceive_Apm\r\nSystem.Net.Sockets.Tests.SendReceive_Apm.SendRecv_NoBuffering_Success\r\n    System.Net.Sockets.SocketException : Invalid argument\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveFrom_Sync\r\nSystem.Net.Sockets.Tests.ReceiveFrom_Sync.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n\r\nTest collection for System.Net.Sockets.Tests.SendReceive_Task\r\nSystem.Net.Sockets.Tests.SendReceive_Task.SendRecv_NoBuffering_Success\r\n    System.Net.Sockets.SocketException : Invalid argument\r\n\r\nTest collection for System.Net.Sockets.Tests.SendReceive_SpanSync\r\nSystem.Net.Sockets.Tests.SendReceive_SpanSync.UdpReceiveGetsCanceledByDispose(address: 127.0.0.1)\r\n    System.TimeoutException : The operation has timed out.\r\nSystem.Net.Sockets.Tests.SendReceive_SpanSync.UdpReceiveGetsCanceledByDispose(address: ::1)\r\n    System.TimeoutException : The operation has timed out.\r\nSystem.Net.Sockets.Tests.SendReceive_SpanSync.UdpReceiveGetsCanceledByDispose(address: ::ffff:127.0.0.1)\r\n    System.TimeoutException : The operation has timed out.\r\n\r\nTest collection for System.Net.Sockets.Tests.ReceiveFrom_MemoryNativeTask\r\nSystem.Net.Sockets.Tests.ReceiveFrom_MemoryNativeTask.ReceiveSent_TCP_Success(ipv6: True)\r\n    System.PlatformNotSupportedException : This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.\r\n```\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003emdh1418\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Net.Sockets`, `os-ios`, `os-tvos`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e6.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-04-30T18:11:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgzMTc3NjM2NQ==",
                                           "createdAt":  "2021-05-04T08:38:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBpkLrA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "mdh1418",
                                                                               "createdAt":  "2021-05-04T18:35:34Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "karelz",
                                           "body":  "@mdh1418 please remove the \u0027untriaged\u0027 label when you set milestones, so that it does not pop up on queries to triage. Thanks!",
                                           "updatedAt":  "2021-05-04T08:38:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GrWAE",
                                           "createdAt":  "2022-07-15T17:49:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jtschuster",
                                           "body":  "Test failed in a rolling runtime-extra-platforms build: https://runfo.azurewebsites.net/view/build/?number=1869899\r\n",
                                           "updatedAt":  "2022-07-15T17:49:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HMnXG",
                                           "createdAt":  "2022-07-25T19:01:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mdh1418",
                                           "body":  "Update:\r\n\r\nThe tests that were listed as failing because of PSNE are now passing \r\n\r\n```\r\nPNSE\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_Sync.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveFrom_CancellableTask.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_MemoryArrayTask.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveFrom_MemoryArrayTask.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_SpanSyncForceNonBlocking.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_Task.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_Apm.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_MemoryNativeTask.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveFrom_SpanSync.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_SpanSync.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_Eap.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveFrom_Apm.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveFrom_SpanSyncForceNonBlocking.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveFrom_Task.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveFrom_Eap.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveFrom_SyncForceNonBlocking.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_SyncForceNonBlocking.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveMessageFrom_CancellableTask.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveFrom_Sync.ReceiveSent_TCP_Success(ipv6: True)\r\nSystem.Net.Sockets.Tests.ReceiveFrom_MemoryNativeTask.ReceiveSent_TCP_Success(ipv6: True)\r\n```\r\n\r\nDisabling the ActiveIssues leads to 49 failing tests\r\nhttps://gist.github.com/mdh1418/d3470d1bf4629f8f4724b25bd723264a\r\n\r\nPlus, these still cause the app to hang\r\nReceiveMessageFrom.cs - ClosedDuringOperation_Throws_ObjectDisposedExceptionOrSocketException\r\nReceiveFrom.cs - ClosedDuringOperation_Throws_ObjectDisposedExceptionOrSocketException\r\nExecutionContextFlowTest.cs -  APM_ExecutionContextFlowsAcrossBeginSendFileOperation",
                                           "updatedAt":  "2022-07-25T19:01:54Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "[iOS][tvOS] System.Net.Sockets.Tests fails and hangs on iOS tvOS",
        "labels":  [
                       "area-System.Net.Sockets",
                       "os-ios",
                       "os-tvos"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/53767",
        "createdAt":  "2021-06-05T12:39:39Z",
        "number":  53767,
        "author":  "clairernovotny",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOBy8-WA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SpencerBurgess",
                                            "createdAt":  "2021-07-19T05:21:58Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2024-08-05T11:09:11Z",
        "body":  "mDNS, and anything else that needs multicast on iOS, no longer works with XCode 12.5. See the discussion here:\r\nhttps://github.com/novotnyllc/Zeroconf/issues/195#issuecomment-841508002\r\n\r\n@rcinge has a working theory:\r\n\r\n\u003e After thinking about this, this is my guess/story about what is going on:\r\n\r\n\u003e The reason this issue appeared with Xcode 12.5 is that the new multicast restriction policy is implemented in Apple-shipped library code (the NWConnectionGroup API), and an updated version of that library would ship with the new Xcode. Likewise, the library wrappers for all system calls would also ship with the new release of Xcode.\r\n\r\n\u003e The core bit: there\u0027s some undocumented socket option or system call argument that signals to the macOS kernel that multicast traffic is allowed on this specific socket. The NWConnectionGroup API knows this secret and will enable multicast traffic on a socket if: (1) the desired mDNS protocols and description are coded in Info.plist (2) the protocols specified do not violate Apple\u0027s restrictions (3) the device user consents to allow the app to examine network traffic. Finally, as results from the multicast query are returned by the Receive() system call, the NWConnectionGroup API then gets to filter the data it returns to the caller.\r\n\r\n\u003e The legacy BSD Sockets system call wrappers also know the secret. Before Xcode 12.5, they would enable multicast traffic unconditionally, but starting with Xcode 12.5, they don\u0027t enable any multicast traffic.\r\n\r\n\u003e Final bit: In the macOS kernel, when the network receive system call is executed, if the secret option has been set and the user consent flag is set, all is well. If the secret option is not set, the kernel looks for the multicast entitlement; if the entitlement exists, the receive call proceeds (legacy mode), otherwise it returns the \"No route to host\" error.\r\n\r\n\u003e Apple denied my request for the multicast entitlement because it gives away the keys to the kingdom: the BSD Socket API is basically a set of kernel system calls-- it\u0027s just too low level for all the policy enforcement. Since I am still developing my app, their logic of \"well, use this API instead\" is sound.\r\n\r\n\u003e If the story is true, to make Zeroconf function again on iOS requires code that calls the NWConnectionGroup API.\u0027\r\n\r\nAs the Zeroconf library uses the `UdpClient` APIs, it seems like the runtime might need to be updated to use the `NWConnectionGroup` APIs.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOhztTIQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NTIzNDcwMg==",
                                           "createdAt":  "2021-06-05T12:39:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-06-05T12:39:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NTIzNDg2Nw==",
                                           "createdAt":  "2021-06-05T12:41:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\r\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\r\n\u003cdetails\u003e\r\n\u003csummary\u003eIssue Details\u003c/summary\u003e\r\n\u003chr /\u003e\r\n\r\nmDNS, and anything else that needs multicast on iOS, no longer works with XCode 12.5. See the discussion here:\r\nhttps://github.com/novotnyllc/Zeroconf/issues/195#issuecomment-841508002\r\n\r\n@rcinge has a working theory:\r\n\r\n\u003e After thinking about this, this is my guess/story about what is going on:\r\n\r\n\u003e The reason this issue appeared with Xcode 12.5 is that the new multicast restriction policy is implemented in Apple-shipped library code (the NWConnectionGroup API), and an updated version of that library would ship with the new Xcode. Likewise, the library wrappers for all system calls would also ship with the new release of Xcode.\r\n\r\n\u003e The core bit: there\u0027s some undocumented socket option or system call argument that signals to the macOS kernel that multicast traffic is allowed on this specific socket. The NWConnectionGroup API knows this secret and will enable multicast traffic on a socket if: (1) the desired mDNS protocols and description are coded in Info.plist (2) the protocols specified do not violate Apple\u0027s restrictions (3) the device user consents to allow the app to examine network traffic. Finally, as results from the multicast query are returned by the Receive() system call, the NWConnectionGroup API then gets to filter the data it returns to the caller.\r\n\r\n\u003e The legacy BSD Sockets system call wrappers also know the secret. Before Xcode 12.5, they would enable multicast traffic unconditionally, but starting with Xcode 12.5, they don\u0027t enable any multicast traffic.\r\n\r\n\u003e Final bit: In the macOS kernel, when the network receive system call is executed, if the secret option has been set and the user consent flag is set, all is well. If the secret option is not set, the kernel looks for the multicast entitlement; if the entitlement exists, the receive call proceeds (legacy mode), otherwise it returns the \"No route to host\" error.\r\n\r\n\u003e Apple denied my request for the multicast entitlement because it gives away the keys to the kingdom: the BSD Socket API is basically a set of kernel system calls-- it\u0027s just too low level for all the policy enforcement. Since I am still developing my app, their logic of \"well, use this API instead\" is sound.\r\n\r\n\u003e If the story is true, to make Zeroconf function again on iOS requires code that calls the NWConnectionGroup API.\u0027\r\n\r\nAs the Zeroconf library uses the `UdpClient` APIs, it seems like the runtime might need to be updated to use the `NWConnectionGroup` APIs.\r\n\r\n\u003ctable\u003e\r\n  \u003ctr\u003e\r\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\r\n    \u003ctd\u003eclairernovotny\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n  \u003ctr\u003e\r\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\r\n    \u003ctd\u003e-\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n  \u003ctr\u003e\r\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\r\n    \u003ctd\u003e\r\n\r\n`area-System.Net.Sockets`, `untriaged`\r\n\r\n\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n  \u003ctr\u003e\r\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\r\n    \u003ctd\u003e-\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n\u003c/table\u003e\r\n\u003c/details\u003e",
                                           "updatedAt":  "2021-06-05T12:42:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg2NDk0MzE4NA==",
                                           "createdAt":  "2021-06-21T11:04:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "clairernovotny",
                                           "body":  "Ping, can anyone please take a look? This is a regression and is breaking apps.",
                                           "updatedAt":  "2021-06-21T11:04:28Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg2NDk0ODE0Mw==",
                                           "createdAt":  "2021-06-21T11:11:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "@marek-safar ping?",
                                           "updatedAt":  "2021-06-21T11:11:54Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg2NDk1NjczNA==",
                                           "createdAt":  "2021-06-21T11:25:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "marek-safar",
                                           "body":  "@steveisok please have a look. Although I\u0027d not classify this as regression.",
                                           "updatedAt":  "2021-06-21T11:25:29Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg2NDk1OTM4Mw==",
                                           "createdAt":  "2021-06-21T11:29:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBvfDeQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "mduchev",
                                                                               "createdAt":  "2021-06-21T11:40:33Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "clairernovotny",
                                           "body":  "It was working for years until iOS changed something recently and it stopped. That\u0027s a regression to me, even if we didn\u0027t cause it.",
                                           "updatedAt":  "2021-06-21T11:30:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41QJD5",
                                           "createdAt":  "2021-08-05T12:36:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOB1QK6A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "neicureuil",
                                                                               "createdAt":  "2021-08-05T14:30:49Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "clairernovotny",
                                           "body":  "Any progress here?",
                                           "updatedAt":  "2021-08-05T12:36:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41dRl2",
                                           "createdAt":  "2021-08-11T14:17:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveisok",
                                           "body":  "No progress yet.  If we do make this fix, it\u0027ll likely need to be made during the RC period. ",
                                           "updatedAt":  "2021-08-11T14:17:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41sSkM",
                                           "createdAt":  "2021-08-18T04:26:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveisok",
                                           "body":  "I\u0027m going to set the milestone to 7, but I am still considering this for 6 and may change it back.  ",
                                           "updatedAt":  "2021-08-18T04:26:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49aFsx",
                                           "createdAt":  "2022-02-04T18:36:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "clairernovotny",
                                           "body":  "Hi folks, just looking for an update on this?",
                                           "updatedAt":  "2022-02-04T18:36:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49aJ-C",
                                           "createdAt":  "2022-02-04T19:01:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveisok",
                                           "body":  "@clairernovotny it\u0027s in our backlog, but at this point I do not know if it\u0027ll make it when MAUI goes GA.  ",
                                           "updatedAt":  "2022-02-04T19:01:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49aKNx",
                                           "createdAt":  "2022-02-04T19:02:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "clairernovotny",
                                           "body":  "Have we independently confirmed the issue, that multicast is not working today on iOS with the latest SDK\u0027s?",
                                           "updatedAt":  "2022-02-04T19:02:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49aM__",
                                           "createdAt":  "2022-02-04T19:18:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveisok",
                                           "body":  "No, I don\u0027t believe so. We\u0027ll verify and if necessary, fix when the issue gets picked up.",
                                           "updatedAt":  "2022-02-04T19:18:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4-AWPi",
                                           "createdAt":  "2022-02-15T13:32:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danardelean",
                                           "body":  "8 months and nobody took a look at it yet and yes still doesn\u0027t work with the new version of XCode",
                                           "updatedAt":  "2022-02-15T13:32:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5EPxAO",
                                           "createdAt":  "2022-06-02T15:14:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "@steveisok @simonrozsival do you still plan to take a look at this for 7.0?",
                                           "updatedAt":  "2022-06-02T15:14:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ITo4s",
                                           "createdAt":  "2022-08-12T13:25:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "directhex",
                                           "body":  "@antonfirsov short version: no, it\u0027s exceedingly unlikely to happen for 7.0 given the number of issues we have left to handle, the amount of work it looks like rewriting System.Net.Sockets for iOS will involve, and the number of weeks left for handling issues.\r\n\r\nI\u0027ve done some quick scoping, and Simon did a deeper exercise before me. It\u0027s not clear it\u0027s even _feasible_ for us to implement UdpClient over top of NWConnectionGroup - better to use the high level Bonjour APIs directly, at an app level.\r\n\r\nI know it\u0027s not what anyone wants to hear, but I\u0027m going to retarget this for 8.0. That\u0027s not a commitment to implementing it for 8.0, more an acknowledgement that it\u0027s just not going to happen for 7.0",
                                           "updatedAt":  "2022-08-12T13:25:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6HO1Mh",
                                           "createdAt":  "2024-08-05T11:09:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Tapanila",
                                           "body":  "Any plans to look into this?",
                                           "updatedAt":  "2024-08-05T11:09:10Z"
                                       }
                                   ],
                         "totalCount":  17
                     },
        "title":  "Multicast doesn\u0027t work with XCode 12.5 and higher on iOS",
        "labels":  [
                       "enhancement",
                       "area-System.Net.Sockets",
                       "os-ios"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/54418",
        "createdAt":  "2021-06-18T15:29:43Z",
        "number":  54418,
        "author":  "mdh1418",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-01-25T17:40:20Z",
        "body":  "System.Net.Sockets.Tests.ReceiveFrom_Apm.BeginReceiveFrom_RemoteEpIsReturnedWhenCompletedSynchronously\r\n```\r\nAssert.Equal() Failure\r\nExpected: 127.0.0.1:60450\r\nActual:   0.0.0.0:0\r\n```\r\n\r\nhttps://dev.azure.com/dnceng/public/_build/results?buildId=1193974\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=35822972\u0026resultId=117044\u0026paneView=dotnet-dnceng.dnceng-build-release-tasks.helix-test-information-tab\r\n\r\n```\r\n\u003ctest name=\"System.Net.Sockets.Tests.ReceiveFrom_Apm.BeginReceiveFrom_RemoteEpIsReturnedWhenCompletedSynchronously\" type=\"System.Net.Sockets.Tests.ReceiveFrom_Apm\" method=\"BeginReceiveFrom_RemoteEpIsReturnedWhenCompletedSynchronously\" time=\"0.0025662\" result=\"Fail\"\u003e\r\n        \u003coutput\u003e\u003c![CDATA[Completed synchronously, updated endpoint.\r\n]]\u003e\u003c/output\u003e\r\n        \u003cfailure exception-type=\"Xunit.Sdk.EqualException\"\u003e\r\n          \u003cmessage\u003e\u003c![CDATA[Assert.Equal() Failure\\nExpected: 127.0.0.1:60450\\nActual:   0.0.0.0:0]]\u003e\u003c/message\u003e\r\n          \u003cstack-trace\u003e\u003c![CDATA[   at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)]]\u003e\u003c/stack-trace\u003e\r\n        \u003c/failure\u003e\r\n      \u003c/test\u003e\r\n```\r\n\r\nI was not able to reproduce locally.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHONNpljw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg2NDExOTI0Mw==",
                                           "createdAt":  "2021-06-18T15:29:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nSystem.Net.Sockets.Tests.ReceiveFrom_Apm.BeginReceiveFrom_RemoteEpIsReturnedWhenCompletedSynchronously\r\n```\r\nAssert.Equal() Failure\r\nExpected: 127.0.0.1:60450\r\nActual:   0.0.0.0:0\r\n```\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003emdh1418\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Net.Sockets`, `os-maccatalyst`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e6.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-06-18T15:29:47Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg2NDQ3MjA4Mg==",
                                           "createdAt":  "2021-06-19T22:37:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "filipnavara",
                                           "body":  "This could very well be related to the dual mode sockets like the ping tests were. It will likely only fail on IPv6 network.",
                                           "updatedAt":  "2021-06-19T22:37:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg2NDQ3MzU4NQ==",
                                           "createdAt":  "2021-06-19T22:58:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBvZKhA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "filipnavara",
                                                                               "createdAt":  "2021-06-20T05:50:01Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "[`CreateSocket()` returns an IPV4 socket by default](https://github.com/dotnet/runtime/blob/5297337e5b7db9feef81f612f3d4e70128c7fa55/src/libraries/System.Net.Sockets/tests/FunctionalTests/ReceiveFrom.cs#L16), which is [not being overriden](https://github.com/dotnet/runtime/blob/5297337e5b7db9feef81f612f3d4e70128c7fa55/src/libraries/System.Net.Sockets/tests/FunctionalTests/ReceiveFrom.cs#L317-L319) in the reported test, so it doesn\u0027t look like a dual mode issue. Might be a timing-critical issue in the underlying OS stack, since we just propagate whatever we get from `recvfrom`.",
                                           "updatedAt":  "2021-06-19T22:58:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc402mWP",
                                           "createdAt":  "2021-07-26T13:59:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBz3FOQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "mdh1418",
                                                                               "createdAt":  "2021-07-26T14:19:05Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "This is a new test introduced in #47781, which only fails on Mac Catalyst. The test validates a marginal feature in the legacy APM API. I would not categorize it as a regression and don\u0027t see the importance for 6.0. The observed behavior is likely a platform issue anyways.\r\n\r\nMoving to 7.0, will disable the test on Mac Catalyst for cleaner CI.",
                                           "updatedAt":  "2021-07-26T14:03:05Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "[MacCatalyst] System.Net.Sockets Loopback test fails x64 and arm64",
        "labels":  [
                       "area-System.Net.Sockets",
                       "disabled-test",
                       "runtime-mono",
                       "os-maccatalyst"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/56828",
        "createdAt":  "2021-08-04T10:11:59Z",
        "number":  56828,
        "author":  "qmfrederik",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCxJcQQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "scalablecory",
                                            "createdAt":  "2021-09-29T18:39:18Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MatthiasJentsch",
                                            "createdAt":  "2023-07-06T14:10:20Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2023-09-06T09:26:39Z",
        "body":  "### Background and motivation\r\n\r\nBoth Windows and Linux support connecting to Bluetooth devices using sockets:\r\n\r\n- On Linux, you create a socket with `AF_BLUETOOTH` and `BTPROTO_L2CAP`, `BTPROTO_RFCOMM`,  `BTPROTO_SCO` or `BTPROTO_HCI` to connect to devices over Bluetooth. See [bluetooth.h](https://github.com/torvalds/linux/blob/master/include/net/bluetooth/bluetooth.h) for more details\r\n- On Windows, you create a socket with `AF_BTH` and `BTHPROTO_RFCOMM`, see [Bluetooth and socket](https://docs.microsoft.com/en-us/windows/win32/bluetooth/bluetooth-and-socket)\r\n\r\nI believe macOS uses a higher-level API and doesn\u0027t expose Bluetooth sockets as such.\r\n\r\nSimilar to #28636, this API proposal suggests adding the `Bluetooth` `AddressFamily` and the corresponding `ProtocolType` values to enable programmers to use .NET to connect to Bluetooth sockets.\r\n\r\nRequests for (basic) support for Bluetooth came up before: see #20379, https://github.com/dotnet/runtime/issues/862#issuecomment-416965420.\r\n\r\nPython also has support for Bluetooth sockets. See https://docs.python.org/3.4/library/socket.html.\r\n\r\n### API Proposal\r\n\r\n```diff\r\n namespace System.Net.Sockets\r\n {\r\n     public enum AddressFamily\r\n     {\r\n+        Bluetooth = 33,\r\n     }\r\n     public enum ProtocolType\r\n     {\r\n+        L2Cap, /* Logical link control and adaptation protocol */\r\n+        RFComm, /* Radio frequency communication */\r\n+        Hci, /* Host Controller Interface */\r\n+        Sco, /* Synchronous Connection-Oriented */\r\n     }\r\n// A single BluetoothEndPoint class could be used for L2Cap, RFComm and SCO\r\n+    public sealed class BluetoothEndPoint : EndPoint\r\n+    {\r\n+        public L2CapEndPoint(ReadOnlySpan\u003cbyte\u003e macAddress, int port);\r\n+    }\r\n+    public enum HciChannel\r\n+    {\r\n+        Raw,\r\n+        User,\r\n+        Monitor,\r\n+        Control,\r\n+        Logging\r\n+    }\r\n// HCI endpoints are a bit different, they are not used to connect to remote devices over Bluetooth but\r\n// rather provide endpoints to interact with the Bluetooth controller in the local host.\r\n+    public sealed class HciEndPoint : EndPoint\r\n+   {\r\n+        public HciEndPoint(ReadOnlySpan\u003cbyte\u003e adapter, HciChannel channel);\r\n+   }\r\n }\r\n\r\n```     \r\n\r\n\r\n### API Usage\r\n\r\n#### Set up a L2Cap server which listens on a local Bluetooth adapter:\r\n\r\n```C#\r\nvar adapter = new byte[] { /* MAC address of a local bluetooth adapter */};\r\nvar socket = new Socket(AddressFamily.Bluetooth, SocketType.Seqpacket, ProtocolType.L2Cap);\r\nsocket.Bind(new BluetoothEndPoint(adapter, 0x13));\r\nvar client = await socket.AcceptAsync();\r\n```\r\n\r\n#### Connect to the Bluetooth management socket\r\n\r\n```c#\r\nvar socket = new Socket(AddressFamily.Bluetooth, SocketType.Raw, ProtocolType.Hci);\r\nsocket.Bind(new HciEndPoint(Array.Empty\u003cbyte\u003e(), HciChannel.Control);\r\n```\r\n\r\n### Risks\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOZc3Zwg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc41MwoT",
                                           "createdAt":  "2021-08-04T10:12:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nBoth Windows and Linux support connecting to Bluetooth devices using sockets:\r\n\r\n- On Linux, you create a socket with `AF_BLUETOOTH` and `BTPROTO_L2CAP`, `BTPROTO_RFCOMM`,  `BTPROTO_SCO` or `BTPROTO_HCI` to connect to devices over Bluetooth. See [bluetooth.h](https://github.com/torvalds/linux/blob/master/include/net/bluetooth/bluetooth.h) for more details\r\n- On Windows, you create a socket with `AF_BTH` and `BTHPROTO_RFCOMM`, see [Bluetooth and socket](https://docs.microsoft.com/en-us/windows/win32/bluetooth/bluetooth-and-socket)\r\n\r\nI believe macOS uses a higher-level API and doesn\u0027t expose Bluetooth sockets as such.\r\n\r\nSimilar to #28636, this API proposal suggests adding the `Bluetooth` `AddressFamily` and the corresponding `ProtocolType` values to enable programmers to use .NET to connect to Bluetooth sockets.\r\n\r\nRequests for (basic) support for Bluetooth came up before: see #20379, https://github.com/dotnet/runtime/issues/862#issuecomment-416965420.\r\n\r\nPython also has support for Bluetooth sockets. See https://docs.python.org/3.4/library/socket.html.\n\n### API Proposal\n\n```C#\r\n namespace System.Net.Sockets\r\n {\r\n     public enum AddressFamily\r\n     {\r\n+        Bluetooth = 33,\r\n     }\r\n     public enum ProtocolType\r\n     {\r\n+        L2Cap, /* Logical link control and adaptation protocol */\r\n+        RFComm, /* Radio frequency communication */\r\n+        Hci, /* Host Controller Interface */\r\n+        Sco, /* Synchronous Connection-Oriented */\r\n     }\r\n }\r\n\r\n```     \r\n\n\n### API Usage\n\n```C#\r\nvar socket = new Socket(AddressFamily.Bluetooth, SocketType.Seqpacket, ProtoclType.L2Cap);\r\nvar client = socket.AcceptAsync();\r\n```\r\n\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eqmfrederik\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Net.Sockets`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-08-04T10:12:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41QuU0",
                                           "createdAt":  "2021-08-05T16:02:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ManickaP",
                                           "body":  "Triage: this is non-trivial work . It\u0027s not just adding new enum values but also making it work with the OS of choice.",
                                           "updatedAt":  "2021-08-05T16:02:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43dXX6",
                                           "createdAt":  "2021-09-29T18:40:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "scalablecory",
                                           "body":  "Does .NET MAUI have Bluetooth APIs that would make sense for you?",
                                           "updatedAt":  "2021-09-29T18:40:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43gcIe",
                                           "createdAt":  "2021-09-30T11:51:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "qmfrederik",
                                           "body":  "@scalablecory I haven\u0027t found any. What I\u0027ve seen so far seems to be focused on Bluetooth LE on iOS/Android.\r\n\r\nMy use case is to set up a L2Cap server with which Bluetooth devices can interface, on Linux. This involves setting up a L2Cap socket listener.\r\n\r\nThe main limitation I\u0027m hitting is that the .NET Socket/SocketListener classes don\u0027t support `AddressFamily.Bluetooth` / `ProtocolType.L2Cap`. The workaround is to P/Invoke into libc. That involves duplicating a lot of the code which already exists in .net, unfortunately.\r\n\r\nPS: @ManickaP \u0027s comment about this being non-trivial work may refer to a full-fledged Bluetooth API; that\u0027s not what I\u0027m asking/proposing. Having support for Bluetooth sockets would be sufficient.",
                                           "updatedAt":  "2021-09-30T11:51:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5gyLDW",
                                           "createdAt":  "2023-07-06T14:16:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MatthiasJentsch",
                                           "body":  "@qmfrederik Did you found a workaround via P/Invoke? I\u0027d like to use a .NET Bluetooth socket connection with Linux.",
                                           "updatedAt":  "2023-07-06T14:16:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5khNMM",
                                           "createdAt":  "2023-08-21T14:19:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "peterfoot",
                                           "body":  "By P/Invoking into libc functions it is possible to overcome this limitation. However it does involve a lot of reinventing the wheel (https://inthehand.com/2023/08/21/reinventing-the-wheel-again-bluetooth-on-linux/)\r\nI\u0027m working on finishing this implementation - this adds Linux Bluetooth Sockets to the existing support for Windows, Android and iOS (External Accessory devices only). I also have a binding library for IOBluetooth on macOS which needs updating to .NET 6.0. I don\u0027t think that Microsoft should add Bluetooth support to .NET because it requires a number of other APIs and structures, however the Socket class on Linux shouldn\u0027t limit what address families are used - it should just pass values to the native API and return the correct exception types as required as it does on Windows.",
                                           "updatedAt":  "2023-08-21T14:19:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5lvwsm",
                                           "createdAt":  "2023-09-05T17:25:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "embeddedmz",
                                           "body":  "Hi @peterfoot \r\n\r\nOn Windows, If I don\u0027t specify the type of the OS in the C# project parameters I get an exception when creating a Bluetooth client (closed Issue https://github.com/inthehand/32feet/issues/332).\r\n\r\nWhen I run the program on Linux I get the same exception but there\u0027s no Linux option in the OS type combo box.\r\n\r\nCan you help me to use the Bluetooth RFComm in a C# program under Ubuntu ? I need to provide a Stream object to my API that sends/receives data. I found this article https://people.csail.mit.edu/albert/bluez-intro/x502.html which contains a C code but this last depends on libbluetooth",
                                           "updatedAt":  "2023-09-05T17:25:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5lzdnC",
                                           "createdAt":  "2023-09-06T09:26:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "peterfoot",
                                           "body":  "@embeddedmz I\u0027ve started a discussion for this as it is off topic for this dotnet runtime issue - https://github.com/inthehand/32feet/discussions/342\r\n",
                                           "updatedAt":  "2023-09-06T09:26:39Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "[API Proposal]: Add AddressFamily.Bluetooth, ProtocolType.L2Cap, .RFComm, .Hci and .Sco",
        "labels":  [
                       "api-suggestion",
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/58327",
        "createdAt":  "2021-08-29T14:57:59Z",
        "number":  58327,
        "author":  "fbrosseau",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODBNI9w==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Wraith2",
                                            "createdAt":  "2021-08-29T18:27:41Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "shirhatti",
                                            "createdAt":  "2021-08-30T16:32:51Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "nick-beer",
                                            "createdAt":  "2023-09-12T16:30:32Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "0xfeeddeadbeef",
                                            "createdAt":  "2025-04-15T01:15:32Z"
                                        }
                                    ],
                          "totalCount":  4
                      },
        "updatedAt":  "2023-06-13T07:07:46Z",
        "body":  "### Description\r\n\r\nHello,\r\n\r\nUnix SocketPal prevents managed code from creating AF_VSOCK (and any other new and/or non-standard AF\u0027s). This is unfortunate, because at the managed level, everything is there to extend for new address families: You write your EndPoint-derived implementation properly, and then it gets serialized to a SocketAddress, and that gets passed down to `socket` for the platform, and everything works. That is the case for Windows, where dotnet does not attempt to do anything with the parameters - if WinSock is happy with it, it works.\r\n\r\nIn Linux, SocketPal needs to do some translations, likely because some of the basic values do not match between their original Windows constants and the standard Linux ones. In its current form, the code there bails out entirely if anything is unknown: \r\n\r\nhttps://github.com/dotnet/runtime/blob/cffaa78235ea93d5e3eeb56956579df503e11250/src/libraries/Native/Unix/System.Native/pal_networking.c#L2461-L2487\r\n\r\nMy exact use case is for AF_VSOCK. In this specific case, I guess the simplest fix would be to add AF_VSOCK to `TryConvertAddressFamilyPalToPlatform`. However, should Linux SocketPal allow for arbitrary unknown AFs, like Windows does? That\u0027s a larger change, and that can come with complications if the values keep diverging over time between Linux and Windows.\r\n\r\n### Regression\r\n\r\nNo, pal_networking.c blame looks old over there.\r\n\r\n### Workaround\r\n\r\nPinvoke `socket()`, `connect()` / `bind()` / ... (basically anything that deals with EndPoint classes), and then `new Socket(new SafeSocketHandle((IntPtr)sock, true));` to leverage the actual Socket/IO benefits provided by .net. \r\n\r\nThis workaround has multiple drawbacks - the current managed code in Socket gets all confused and assumes that the socket has Connected=false, due to the code only handling IPv4/IPv6/Unix in the SafeHandle constructor. Having Connected=false prevents it from using NetworkStream, for example. Then, if a Stream interface is required, the workaround is to instead use a FileStream over the sockfd.  This is really not ideal : )\r\n\r\n@antonfirsov \r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOXrFAiQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc42HAVH",
                                           "createdAt":  "2021-08-29T14:58:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\n\r\nHello,\r\n\r\nUnix SocketPal prevents managed code from creating AF_VSOCK (and any other new and/or non-standard AF\u0027s). This is unfortunate, because at the managed level, everything is there to extend for new address families: You write your EndPoint-derived implementation properly, and then it gets serialized to a SocketAddress, and that gets passed down to `socket` for the platform, and everything works. That is the case for Windows, where dotnet does not attempt to do anything with the parameters - if WinSock is happy with it, it works.\r\n\r\nIn Linux, SocketPal needs to do some translations, likely because some of the basic values do not match between their original Windows constants and the standard Linux ones. In its current form, the code there bails out entirely if anything is unknown: \r\n\r\nhttps://github.com/dotnet/runtime/blob/cffaa78235ea93d5e3eeb56956579df503e11250/src/libraries/Native/Unix/System.Native/pal_networking.c#L2461-L2487\r\n\r\nMy exact use case is for AF_VSOCK. In this specific case, I guess the simplest fix would be to add AF_VSOCK to `TryConvertAddressFamilyPalToPlatform`. However, should Linux SocketPal allow for arbitrary unknown AFs, like Windows does? That\u0027s a larger change, and that can come with complications if the values keep diverging over time between Linux and Windows.\r\n\r\n### Regression\r\n\r\nNo, pal_networking.c blame looks old over there.\r\n\r\n### Workaround\r\n\r\nPinvoke `socket()`, `connect()` / `bind()` / ... (basically anything that deals with EndPoint classes), and then `new Socket(new SafeSocketHandle((IntPtr)sock, true));` to leverage the actual Socket/IO benefits provided by .net.\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003efbrosseau\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Net.Sockets`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-08-29T14:58:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42Jd3d",
                                           "createdAt":  "2021-08-30T15:43:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "\u003e I guess the simplest fix would be to add AF_VSOCK to TryConvertAddressFamilyPalToPlatform\r\n\r\nFor that we also need a managed `AddressFamily` entry for `AF_VSOCK`. If VSOCK is an important use case for you, I recommend to file an API proposal adding that specific address family. Assuming we accept the proposal, to me it looks like an up-for-grabs candidate.\r\n\r\n\u003e  the current managed code in Socket gets all confused and assumes that the socket has Connected=false, due to the code only handling IPv4/IPv6/Unix in the SafeHandle constructor.\r\n\r\nIf understand it correctly, this is due to a condition check before we call `getpeername` on the socket handle:\r\nhttps://github.com/dotnet/runtime/blob/e0e7bfce6c0841bb659810cd80bce87e4cf7329b/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs#L179-L186\r\n\r\nI\u0027m wondering what would happen if we just removed this criteria to unblock scenarios dealing with connected sockets of arbitrary address families? `_remoteEndPoint` would remain unassigned in case of arbitrary address families, but send/receive operations should still work. @geoffkizer @tmds thoughts?",
                                           "updatedAt":  "2021-08-30T15:43:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42JeqR",
                                           "createdAt":  "2021-08-30T15:47:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "cc @shirhatti ",
                                           "updatedAt":  "2021-08-30T15:47:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42Je02",
                                           "createdAt":  "2021-08-30T15:48:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "fbrosseau",
                                           "body":  "\u003e For that we also need a managed AddressFamily entry for AF_VSOCK. If VSOCK is an important use case for you, I recommend to file an API proposal adding that specific address family. Assuming we accept the proposal, to me it looks like an up-for-grabs candidate.\r\n\r\nFrom a framework perspective I guess this makes the most sense, but I was hoping this issue could be handled 100% internally at the PAL level so that it is easier to pass. I can submit an API proposal in parallel. At that point, would it only be the AddressFamily entry, or would it be AddressFamily + EndPoint impl? And AF_VSOCK only, or AF_HYPERV as well? Note that AF_HYPERV is not a problem, unlike VSOCK, because on Windows it is possible to write a fully functional EndPoint implementation and AF_HYPERV works completely in managed. But providing the implementation would add convenience.\r\n\r\nWhat I mean by handling it internally at the PAL is that could it be changed so that unknown values flow through to the native calls instead of early-returning an error? Right now it strictly enforces well-known values to guard against invalid parameters and sizes, but the native call would already return an adequate error if it does not like the parameters.\r\n\r\n\u003e If understand it correctly, this is due to a condition check before we call getpeername on the socket handle:\r\n\r\nYes. My understanding of that code is that relaxing those conditions would work.",
                                           "updatedAt":  "2021-08-30T15:54:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42Jh-2",
                                           "createdAt":  "2021-08-30T16:04:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "\u003e  or would it be AddressFamily + EndPoint impl\r\n\r\nIn #28636 (https://github.com/dotnet/corefx/pull/37315) we shipped a few new address families without EndPoint implementations so it\u0027s probably not necessary, meaning that the minimal API would just focus on unblocking users instead of delivering a full solution. /cc @wfurt \r\n\r\n\u003e or AF_HYPERV as well\r\n\r\nTo me it sounds reasonable to file a shared proposal for these two.",
                                           "updatedAt":  "2021-08-30T16:04:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42JknV",
                                           "createdAt":  "2021-08-30T16:17:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "I did some work on Netlink and It was working for me - at least the small part I was using. Supporting completely new protocols blindly is not trivial. As you noticed there are fragments in the socket code making certain assumptions. Ability to create Socket from handle was added to solve also some other use cases. Creating Socket from RAW AddressFamily was discussed but rejected as it may have still have some other lingering issue. For one, it may still have issue not knowing if socket is or is not Connected. Existing code is guessing and perhaps that may be improved. Alternatively we may pass that information to the constructor. \r\n\r\nCan you share your code @fbrosseau primarily the endpoint, creation and example oof what is not working? \r\n\r\n\r\n",
                                           "updatedAt":  "2021-08-30T16:17:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42JnEp",
                                           "createdAt":  "2021-08-30T16:27:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "fbrosseau",
                                           "body":  "\u003e I did some work on Netlink and It was working for me \r\n\r\nIn Linux? Windows PAL allows for arbitrary AFs, but not Linux.\r\n\r\n\u003e Can you share your code @fbrosseau primarily the endpoint, creation and example oof what is not working?\r\n\r\n```\r\nnew Socket((AddressFamily)40, SocketType.Stream, 0);\r\n\r\n--\u003e\r\nUnhandled exception. System.Net.Sockets.SocketException (97): Address family not supported by protocol\r\n   at System.Net.Sockets.Socket..ctor(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType)\r\n   at AfHyperV.Program.Main(String[] args)\r\n```\r\n\r\n```\r\nnew SocketAddress((AddressFamily)40, 32);\r\n\r\n--\u003e\r\n\r\nUnhandled exception. System.PlatformNotSupportedException: Operation is not supported on this platform.\r\n   at System.Net.SocketAddressPal.ThrowOnFailure(Error err)\r\n   at System.Net.SocketAddressPal.SetAddressFamily(Byte[] buffer, AddressFamily family)\r\n   at System.Net.SocketAddress..ctor(AddressFamily family, Int32 size)\r\n   at AfHyperV.Program.Main(String[] args) \r\n```\r\n\r\nAnything that touches the AddressFamily throws. I can share a full example of what would be a correct VSockEndPoint implementation, but basically every step is a blocker :)\r\n\r\nNote that these errors are generated by the Unix PAL itself, not the OS. The OS would accept these parameters happily. See the part of pal_networking.c that I linked in OP",
                                           "updatedAt":  "2021-08-30T16:33:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42JoWJ",
                                           "createdAt":  "2021-08-30T16:33:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "Yes, on Linux. Windows does not have Netlink. And this is not what I meant. I know casting number to AddressFamily will not work.  It is about creating handle you self, creating Socket from it and using your EndPoint for Bind(). ",
                                           "updatedAt":  "2021-08-30T16:33:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42Joko",
                                           "createdAt":  "2021-08-30T16:34:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "fbrosseau",
                                           "body":  "Ah sorry! Yes, well managed Socket.Bind/.Connect is a no-go due to the SocketAddress constructor throwing, and I do not think there is any possible way to implement EndPoint.Serialize without it. So that step too must be done through PInvoke. But then due to the defensive code in the Socket constructor that takes a handle, _rightEndPoint is never considered if the AF is not IPv4/IPv6/Unix.",
                                           "updatedAt":  "2021-08-30T16:39:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42J5HY",
                                           "createdAt":  "2021-08-30T18:01:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "Take a look at https://github.com/dotnet/runtime/issues/26416. It has example of managed `Bind` with custom AddressFamily. I think the sequence should be: \r\n1) create handle with P/Invoke. \r\n2) Create Socket from it. \r\n3) Use Socket.Bind if needed.  \r\n\r\nThis should all work AFAIK.\r\nLooking back, I don\u0027t think I ever tried `Connect` since neither CAN nor Netlink is stream oriented. If `Bind` works but `Connect`  does not it I think that would be something we can look into. \r\nI can probably also find my old Netlink prototype. It did not do `Connect` but it was using `SendTo` as far as I remember. ",
                                           "updatedAt":  "2021-08-30T18:01:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42J6jW",
                                           "createdAt":  "2021-08-30T18:09:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "fbrosseau",
                                           "body":  "LLEndpoint uses `new SocketAddress(AddressFamily.Packet, 20);` which has first-class support in TryConvertAddressFamilyPalToPlatform and hence it works, but anything outside of the hardcoded values will return false from there and throw once back in managed.",
                                           "updatedAt":  "2021-08-30T18:11:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42J-Y7",
                                           "createdAt":  "2021-08-30T18:31:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "Than look at https://github.com/dotnet/runtime/blob/ebc0f05ebc3bb8854dceaf791486b4aa49739e80/src/libraries/System.Net.Sockets/tests/FunctionalTests/CreateSocketTests.cs#L584\r\n\r\nOriginal addition of Netlink was reverted (e.g. there is neither PAL nor enum) but that test can still dump routing table. \r\nI think the trick that makes it work is here:\r\nhttps://github.com/dotnet/runtime/blob/ebc0f05ebc3bb8854dceaf791486b4aa49739e80/src/libraries/System.Net.Sockets/tests/FunctionalTests/CreateSocketTests.cs#L519-L520\r\n\r\nNetlink is one example were even if we added `AddressFamily` use of it was still problematic. \r\nThat was my story of adding support for unknown/arbitrary protocols. ",
                                           "updatedAt":  "2021-08-30T18:31:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42KGk6",
                                           "createdAt":  "2021-08-30T19:17:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "fbrosseau",
                                           "body":  "Ah yes interesting, I didn\u0027t realize SocketAddress could be fuzzed into changing the AF byte, this goes against both the docs and the code comments, so I did not expect this to be a supported scenario.\r\n\r\nhttps://github.com/dotnet/runtime/blob/9671726c0a79d5f4cab320b32da1cd4463a0d1be/src/libraries/Common/src/System/Net/SocketAddress.cs#L55-L59\r\n\r\nThen yes if that\u0027s supported that works, that removes the need for quite a bit of PInvoke, except the initial `socket()` call.",
                                           "updatedAt":  "2021-08-30T19:17:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42KJYh",
                                           "createdAt":  "2021-08-30T19:33:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "It would be probably cleaner if you can use `AddressFamily.Unknown` as base but that will probably fail as that does not really represent any OS protocol. One challenge with supporting unknown protocols is lack of uses case and difficulty with writing tests. If you can get something working we can perhaps take that it as feedback and make improvements for future @fbrosseau. Trouble with `Netlink` was fact that it also needed specific `ProtocolType` and there are many and user can possibly also register and create one dynamically. Perhaps we can look at it again in 7.0 and make process of adding new protocols easier. \r\n\r\n",
                                           "updatedAt":  "2021-08-30T19:33:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42KJ5R",
                                           "createdAt":  "2021-08-30T19:36:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "fbrosseau",
                                           "body":  "AFAIK VSock is mainstream enough now and it also supports \"loopback\" that does not require having any actual VM in the system, so this is probably a good testable candidate AF.",
                                           "updatedAt":  "2021-08-30T19:36:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42KLIU",
                                           "createdAt":  "2021-08-30T19:43:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "Yah, you can argue that about `Netlink` as well. Part of the trouble is that .NET in not particularly well setup to handle platform specific features e.g. works only on Linux. ",
                                           "updatedAt":  "2021-08-30T19:43:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42LvpR",
                                           "createdAt":  "2021-08-31T09:08:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "\u003e Part of the trouble is that .NET in not particularly well setup to handle platform specific features e.g. works only on Linux.\r\n\r\nThat\u0027s true, but we already have similar address families (eg. AF_PACKET), so I don\u0027t see an issue adding more of them. We should just point out in the docs, that the given enum value is platform-specific.\r\n\r\nI think this is a good candidate to be a community-driven feature, my recommendation is still to \r\n- Go and approve #58378\r\n- See if @fbrosseau or someone else can PR a working implementation with usability proven in functional tests. If yes, that\u0027s great, if we discover an issue in the meanwhile, we just drop the proposal.\r\n\r\nIndependently, we should also evaluate if we can improve the support of using arbitrary AddressFamilies / ProtocolTypes through P/Invoke and custom endpoints. I think we can provide limited support for advanced users without adding new API-s or implementing high impact changes like the eliminating strict PAL \"mappability\" criterias entirely, by doing just 2 things: \r\n1. Relax the criteria only in `SocketAddress(AddressFamily)` constructor to actually enable the use of EndPoints with custom address families.\r\n2. Remove the `_rightEndPoint != null` check in `Socket(SafeSocketHandle)` as mentioned in my https://github.com/dotnet/runtime/issues/58327#issuecomment-908451293 so connected sockets created in unmanaged code act like they are actually connected.",
                                           "updatedAt":  "2021-08-31T09:15:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42MD_7",
                                           "createdAt":  "2021-08-31T11:03:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "fbrosseau",
                                           "body":  "Sure I could look into that.\r\n\r\n\u003e Points 1 \u0026 2\r\n\r\nCould the TryConvertAddressFamilyPalToPlatform condition be relaxed in SystemNative_Socket too? The code already does not do anything with the result other than passing it to `socket()`, so if SystemNative_Socket did not return with error on TryConvertAddressFamilyPalToPlatform=false, even that would no longer require PInvoke. AFAICT with those changes + this one, zero PInvoke would then be required for anything to have a functioning custom AF.",
                                           "updatedAt":  "2021-08-31T11:04:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42MJH5",
                                           "createdAt":  "2021-08-31T11:33:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "\u003e Could the TryConvertAddressFamilyPalToPlatform condition be relaxed in SystemNative_Socket too?\r\n\r\nYou want to use `AddressFamily` to pass in raw values. For values that match defined address families, the PAL has no way of knowing whether it should convert them or treat them as raw.\r\n\r\nWe need some API addition that indicates whether the values are raw ones. These could be some overload that accepts ints, similar to `SetRawSocketOption` vs `SetSocketOption`.\r\n\r\n\u003e Remove the _rightEndPoint != null\r\n\r\n`_rightEndPoint` is the way `Socket` tracks the type of `EndPoint` it should use. For unknown address families, a user may want to specify this. Or maybe we want to add a `RawEndPoint` that exposes the raw address data.\r\n\r\nAPI could be something in this direction:\r\n\r\n```cs\r\nconst int AF_VSOCK = 40;\r\nconst int SOCK_STREAM = 1;\r\nusing var socket = new Socket(AF_VSOCK, SOCK_STREAM, 0, new MyVSockEndPoint());\r\n```",
                                           "updatedAt":  "2021-08-31T11:33:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42MUJh",
                                           "createdAt":  "2021-08-31T12:37:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "fbrosseau",
                                           "body":  "\u003e You want to use AddressFamily to pass in raw values. For values that match defined address families, the PAL has no way of knowing whether it should convert them or treat them as raw.\r\n\r\nI am not sure I can see the concrete problem - the already existing special-cases (Packet, CAN) already have synthetic values on purpose to not clash with anything standard. So that part is fine. Then, for the normal stuff (IPv4 etc), the values are universal. For the AF values that do differ between platforms (VSock and HyperV are examples), the OS would already tell if the values are good or bad.\r\n\r\n\u003e API could be something in this direction:\r\n\r\nFirst argument would be redundant with the endpoint argument since the AF value is already part of the EndPoint contract. I am also not sure if having an endpoint at `socket()`-time would make sense for all families. Also would that be the remote or local endpoint? Their final values are often unknown until after `bind`-time, or even lazier at `connect`-time with port-sharing options, for example.",
                                           "updatedAt":  "2021-08-31T12:41:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42MUzl",
                                           "createdAt":  "2021-08-31T12:41:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "@tmds API addition is a very deep rabbit hole, the scope seems to be much bigger here than with `SetRawSocketOption`. It\u0027s not enough to just expose `Socket(int, int, int, ???)` stuff, for consistency we also need to consider a bunch of other additions like `EndPoint.RawAddressFamily` or `Socket.RawAddressFamily`. I\u0027m  skeptical if we can reach consensus and get the funding for such changes in 7.0.0. This is why I\u0027m suggesting to evaluate minor changes which may be just enough to unblock users.\r\n\r\n\u003e `_rightEndPoint` is the way `Socket` tracks the type of `EndPoint` it should use. \r\n\r\n`_rightEndPoint` seems to be unused with connected `Send`/`Receive`. In `SendTo` the `remoteEp` parameter is mandatory, in `ReceiveFrom`, we may expect the user to pass `remoteEP` when used with arbitrary address families. ",
                                           "updatedAt":  "2021-08-31T12:42:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42MWsw",
                                           "createdAt":  "2021-08-31T12:52:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "\u003e Then, for the normal stuff (IPv4 etc), the values are universal.\r\n\r\nThere is no standard that specifies these values are the same cross-platform.\r\n\r\n\u003e API addition is a very deep rabbit hole\r\n\r\nThe problem that needs to be solved is distinguish raw values from defined enum values.\r\n\r\n\u003e for consistency we also need to consider a bunch of other additions like EndPoint.RawAddressFamily or Socket.RawAddressFamily\r\n\r\nThese enums have an `Unknown` value which could be used instead of adding new APIs.\r\n\r\n\u003e _rightEndPoint seems to be unused with connected Send/Receive. In SendTo the remoteEp parameter is mandatory, in ReceiveFrom, we may expect the user to pass remoteEP when used with arbitrary address families.\r\n\r\nYes, only specific operations require `_rightEndPoint`. The options are: a. not support them, b. allow the user to specify his own `EndPoint` type, or c. introduce a `RawEndPoint` type.",
                                           "updatedAt":  "2021-08-31T12:52:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42MYpg",
                                           "createdAt":  "2021-08-31T13:03:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "\u003e These enums have an `Unknown` value which could be used instead of adding new APIs.\r\n\r\nSounds reasonable to me, but wondering if anyone would push back on that.\r\n\r\n\u003e b. allow the user to specify his own `EndPoint` type\r\n\r\nI think this is something we should be capable to support with the current API-s. (`Connect()`, `SendTo()`, `ReceiveFrom()` can be used to specify a custom `EndPoint` type.) The only API hole is seems to be around connected socket creation from a handle. We can add `Socket(SafeSocketHandle handle, EndPoint remoteEp)` to deal with this.",
                                           "updatedAt":  "2021-08-31T13:03:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42U8sR",
                                           "createdAt":  "2021-09-02T09:40:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "\u003e The only API hole is seems to be around connected socket creation from a handle. We can add Socket(SafeSocketHandle handle, EndPoint remoteEp) to deal with this.\r\n\r\nIf we don\u0027t add a constructor to `Socket`/`SafeSocketHandle` that accepts raw values, the user will need to P/Invoke.\r\n\r\n```cs\r\nconst int AF_VSOCK = 40;\r\nconst int SOCK_STREAM = 1;\r\nconst int SOCK_CLOEXEC = 0x80000;\r\n\r\n[DllImport(\"libc\", SetLastError = true)]\r\npublic static extern int socket(int domain, int type, int protocol);\r\n\r\nint fd = socket(AF_VSOCK, SOCK_STREAM | SOCK_CLOEXEC, 0); // TODO: handle fd == -1\r\nusing var socket = new Socket(new SafeSocketHandle((IntPtr)fd, true), new MyVSockEndPoint());\r\n```",
                                           "updatedAt":  "2021-09-02T09:40:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42VL7h",
                                           "createdAt":  "2021-09-02T10:43:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "\u003e If we don\u0027t add a constructor to `Socket`/`SafeSocketHandle` that accepts raw values, the user will need to P/Invoke.\r\n\r\nWhich might be acceptable for advanced scenarios. Again, I\u0027m not super optimistic about our ability finalizing API proposals around the socket area, mostly because it has lower priority in comparison to other hot topics. (See our [backlog of stale suggestions](https://github.com/dotnet/runtime/issues?q=is%3Aissue+is%3Aopen+label%3Aarea-System.Net.Sockets+label%3Aapi-suggestion)). I may give it a try though :)\r\n\r\n\u003e \u003e for consistency we also need to consider a bunch of other additions like EndPoint.RawAddressFamily or Socket.RawAddressFamily\r\n\r\n\u003e These enums have an `Unknown` value which could be used instead of adding new APIs.\r\n\r\nThis would mean that the raw address family and socket/protocol type is settable, but not queryable. This is quite atypical for BCL API-s, and likely not what we want there, meaning that we need to expose properties which is where the rabbit hole begins ...\r\n\r\nRegarding the code sample in https://github.com/dotnet/runtime/issues/58327#issuecomment-911461137: I meant the `Socket(SafeSocketHandle handle, EndPoint remoteEp)` constructor to create `Socket` instances which are already connected using unmanaged `connect` or `accept`. `Socket(handle)` should be sufficient to create, bind and connect the socket via managed API-s, assigning `_rightEndPoint` when necessary. The only thing we need to do here is to find a way to relax the `AddressFamily` validation in the `SocketAddress` constructor.",
                                           "updatedAt":  "2021-09-02T10:43:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42WbHr",
                                           "createdAt":  "2021-09-02T16:14:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Triage: Similar to https://github.com/dotnet/runtime/issues/58378#issuecomment-911847247 -- there may be dragons, let\u0027s find out more first.",
                                           "updatedAt":  "2021-09-02T16:14:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5EPu9-",
                                           "createdAt":  "2022-06-02T15:07:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "Triage: not critical for 7.0, pushing to future for now.",
                                           "updatedAt":  "2022-06-02T15:07:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5brou3",
                                           "createdAt":  "2023-05-08T10:48:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "crozone",
                                           "body":  "\u003e Ah yes interesting, I didn\u0027t realize SocketAddress could be fuzzed into changing the AF byte, this goes against both the docs and the code comments, so I did not expect this to be a supported scenario.\r\n\u003e \r\n\u003e https://github.com/dotnet/runtime/blob/9671726c0a79d5f4cab320b32da1cd4463a0d1be/src/libraries/Common/src/System/Net/SocketAddress.cs#L55-L59\r\n\u003e \r\n\u003e Then yes if that\u0027s supported that works, that removes the need for quite a bit of PInvoke, except the initial `socket()` call.\r\n\r\nI noticed this myself when implementing a `SocketCanEndPoint : EndPoint` to allow binding to a SocketCAN socket on Linux. I didn\u0027t end up needing to set the first two bytes since `AddressFamily.ControllerAreaNetwork` is actually correctly translated into `CAN_AF` by `TryConvertAddressFamilyPalToPlatform`, but it is very weird that the comment explicitly says those bytes are read-only, and yet they\u0027re clearly not. Is it a bug?",
                                           "updatedAt":  "2023-05-08T10:48:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5cNIfZ",
                                           "createdAt":  "2023-05-14T16:58:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "This may be officially relaxed as part of #30797. I don\u0027t if it would be useful but it would provide ability to send/receive without need for `SocketCanEndPoint`. ",
                                           "updatedAt":  "2023-05-14T16:58:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5erTPB",
                                           "createdAt":  "2023-06-13T02:10:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "crozone",
                                           "body":  "\u003e This may be officially relaxed as part of #30797. I don\u0027t if it would be useful but it would provide ability to send/receive without need for `SocketCanEndPoint`.\r\n\r\nIn the SocketCAN usecase, the `SocketCanEndPoint` is only used to bind the socket to the CAN interface with `.Bind()`, but not after that. This means that the performance impact isn\u0027t as serious as needing to pass it into every `SendTo()` or `ReceiveFrom()`, but there\u0027s still an annoying extra copy through the `EndPoint` indirection.\r\n\r\nIs there any scope in that ticket for also making `Bind()` accept a `sockaddr` in the same way? Maybe even a `BindRaw()` that bypasses the `SocketFamily` Pal translation stuff, since the first two bytes are the address family.\r\n\r\nSocketCAN code for reference: https://github.com/crozone/SocketCanNet/blob/main/SocketCanNet/CanSocketEndPoint.cs\r\n\r\nhttps://github.com/crozone/SocketCanNet/blob/f33ff5ca0d4a72d463d5373884134002b678fdf1/SocketCanNet/SocketExtensions.cs#L98-L107",
                                           "updatedAt":  "2023-06-13T02:10:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5esUCJ",
                                           "createdAt":  "2023-06-13T07:07:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "there is no plan for `Bind(SocketAddress)` at the moment. That is simple function and p/invoke would be trivial IMHO. (unlike ReceiveFromAsync  where there is lot of internal complexity and platform differences)  ",
                                           "updatedAt":  "2023-06-13T07:07:46Z"
                                       }
                                   ],
                         "totalCount":  31
                     },
        "title":  "Cannot create AF_VSOCK Sockets due to overly strict SocketPal",
        "labels":  [
                       "enhancement",
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/58378",
        "createdAt":  "2021-08-30T16:15:14Z",
        "number":  58378,
        "author":  "fbrosseau",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-07-31T13:59:46Z",
        "body":  "### Background and motivation\r\n\r\nProposal for AddressFamily.Vsock and AddressFamily.HyperV. I am not sure about the best letter casing for Vsock.\r\n\r\n```csharp\r\nnamespace System.Net.Sockets\r\n{\r\n    public enum AddressFamily\r\n    {\r\n+       Vsock = 40,\r\n+       HyperV = 34,\r\n    }\r\n} \r\n```\r\n\r\nAs discussed in #58327, this current API proposal is only for the enums. EndPoint implementations for VSock and HyperV can be done in user code. This follows previous examples of API additions where only AddressFamily enum values were added and the rest is up to the users.\r\n\r\nThis proposal (at least the VSock part) unblocks the AF_VSOCK scenario, because right now the Unix SocketPAL refuses unknown AF values outright.\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYtmmfQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc42JkPX",
                                           "createdAt":  "2021-08-30T16:15:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-08-30T16:15:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42Jkjw",
                                           "createdAt":  "2021-08-30T16:16:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\r\n\r\nProposal for AddressFamily.Vsock and AddressFamily.HyperV. I am not sure about the best letter casing for Vsock.\r\n\r\n```csharp\r\nnamespace System.Net.Sockets\r\n{\r\n    public enum AddressFamily\r\n    {\r\n+       Vsock = 40,\r\n+       HyperV = 34,\r\n    }\r\n} \r\n```\r\n\r\nAs discussed in #58327, this current API proposal is only for the enums. EndPoint implementations for VSock and HyperV can be done in user code. This follows previous examples of API additions where only AddressFamily enum values were added and the rest is up to the users.\r\n\r\nThis proposal (at least the VSock part) unblocks the AF_VSOCK scenario, because right now the Unix SocketPAL refuses unknown AF values outright.\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003efbrosseau\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Net.Sockets`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-08-30T16:16:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42Jtjv",
                                           "createdAt":  "2021-08-30T17:03:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Wraith2",
                                           "body":  "If the unix pal allows you to pass through your own address family you don\u0027t need an enumerated value defined here to use the hyper-v socket. These options are niche enough that I\u0027m not sure they need their own names. I have a working hyper-v endpoint in windows so I think the unblocking on unix is all that is needed.",
                                           "updatedAt":  "2021-08-30T17:03:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42JySb",
                                           "createdAt":  "2021-08-30T17:27:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "fbrosseau",
                                           "body":  "Yes indeed HyperV is not required to have working hyper-v sockets, it was suggested in the other issue that we add it anyway just as convenience, but if folks prefer to reduce the scope of this proposal that\u0027s fine either way.",
                                           "updatedAt":  "2021-08-30T17:27:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42Wa9P",
                                           "createdAt":  "2021-09-02T16:14:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Triage: In principle ok, but we have tried similar thing with netlink and failed -- @wfurt to link where we had to back it out. There were also conflicts with other AddressFamilies.\r\nLet\u0027s not repeat similar mistakes when we take this.\r\n\r\nWe would like to see prototype first, before we bring it to API review. We expect that API review will be easy, if we are convinced we can implement it in a way we will not regret later.",
                                           "updatedAt":  "2021-09-02T16:14:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42WbXi",
                                           "createdAt":  "2021-09-02T16:16:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Wraith2",
                                           "body":  "Prototype of which part?",
                                           "updatedAt":  "2021-09-02T16:16:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42Wb6h",
                                           "createdAt":  "2021-09-02T16:18:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "@Wraith2 Vsock, since HyperV is just a trivial convenience API.",
                                           "updatedAt":  "2021-09-02T16:18:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42WcYr",
                                           "createdAt":  "2021-09-02T16:21:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Wraith2",
                                           "body":  "Ah, the bit I don\u0027t already have working. 😞 ",
                                           "updatedAt":  "2021-09-02T16:21:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42WdMf",
                                           "createdAt":  "2021-09-02T16:25:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "@Wraith2 if you can link or copy here working code for HyperV, that would be also helpful for that part.",
                                           "updatedAt":  "2021-09-02T16:25:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42WzS2",
                                           "createdAt":  "2021-09-02T18:26:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Wraith2",
                                           "body":  "https://github.com/Wraith2/HyperVSockets it\u0027s enough to get a server process on the hyperv host and a client from a child within it connected using JsonRpc over a stream. There\u0027s windows specific stuff in there for looking up the client vitualmachine id which you\u0027ll have to provide an alternative for on linux but otherwise it should work if you can get the socket plumbed together.",
                                           "updatedAt":  "2021-09-02T18:26:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc45dxZc",
                                           "createdAt":  "2021-11-09T12:26:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "arontsang",
                                           "body":  "It would be interesting to keep any API changes open for other AddressFamily types.\r\n\r\nI would really like to see support for XDP especially since we have memory/span. It would be very interesting to see what kind of raw packet performance we can get on dotnet.",
                                           "updatedAt":  "2021-11-09T12:26:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc45d5SC",
                                           "createdAt":  "2021-11-09T13:11:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "@arontsang do you have a particular application in mind for XDP, or is it just general interest?\r\n\r\nNote that our datagram sockets suffer from heavy allocations even with UDP -- #30797. I don\u0027t see the point of introducing support for a high-perf protocol, without solving that problem first.",
                                           "updatedAt":  "2021-11-09T13:11:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc45lEhL",
                                           "createdAt":  "2021-11-11T06:13:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "arontsang",
                                           "body":  "@antonfirsov Just thought it would be fun. Although XDP would require us to design a datagram socket that works with buffer pools.",
                                           "updatedAt":  "2021-11-11T06:13:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5EPubi",
                                           "createdAt":  "2022-06-02T15:04:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "Triage: moving this to future, since we don\u0027t believe we have the capacity to push through an API review on time for 7.0.",
                                           "updatedAt":  "2022-06-02T15:04:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5i2U0h",
                                           "createdAt":  "2023-07-31T13:46:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mawelsh",
                                           "body":  "This probably didn\u0027t make it into 8, either.  Getting support for the address families would do a lot to get a product I work on out of having to rely on other tunnels (Socat/HVC) to ride VSOCK.  We\u0027re currently evaluating future feature development for additional services that will be coordinated over VSOCK via GRPC. Relying less on outside services would be ideal.",
                                           "updatedAt":  "2023-07-31T13:46:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5i2aZ9",
                                           "createdAt":  "2023-07-31T13:59:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "@mawelsh you can instantiate a `Socket` from an existing `SafeSocketHandle` which you can you can create with P/Invoke, see https://github.com/dotnet/runtime/issues/58327#issuecomment-911461137. Does this workaround work for you?",
                                           "updatedAt":  "2023-07-31T13:59:45Z"
                                       }
                                   ],
                         "totalCount":  16
                     },
        "title":  "[API Proposal]: AddressFamily.Vsock, AddressFamily.HyperV",
        "labels":  [
                       "api-suggestion",
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/58689",
        "createdAt":  "2021-09-05T05:32:35Z",
        "number":  58689,
        "author":  "jasonpugsley",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-09-14T20:02:17Z",
        "body":  "I have PR #58688 that is needed for FreeBSD to be able to set permissions on a unix domain socket for an eventpipe.\r\n\r\nFreeBSD is the same as APPLE where you cannot set the permissions on a socket file descriptor using `fchmod()`, something that can be done with Linux.\r\n\r\nThe current alternative method sets the `umask()` before calling `socket()` and `bind()` and then resets it after.\r\n\r\nWhat I would like to suggest as a possibly cleaner implementation is to set the permission on the socket file after the call to `bind()` but before the call to `listen()`.\r\n\r\nI have tested this on FreeBSD 12.2 and MacOS 11.5.2 and it should be _safe_ because a client that tries to `connect()` to the socket file before the server has called `listen()` will fail with `ECONNREFUSED`. If there is something I\u0027ve missed that still makes this unsafe please tell me.\r\n\r\nCurrent server pseudo code\r\n```\r\n    orig = umask(~(S_IRUSR | S_IWUSR))\r\n    s = socket()\r\n    bind(s, path)\r\n    umask(orig)\r\n    listen(s)\r\n```\r\n\r\nProposed server pseudo code\r\n```\r\n    s = socket()\r\n    bind(s, path)\r\n    chmod(path, (S_IRUSR | S_IWUSR))\r\n    listen(s)\r\n```\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHONs4Igw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc42h9Y5",
                                           "createdAt":  "2021-09-08T03:08:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jasonpugsley",
                                           "body":  "I tested this on Linux as well (Ubuntu 20.04) and it also returns ECONNREFUSED for a client trying to connect to a server socket that isn\u0027t yet in listen() state. So it seems at least MacOS/FreeBSD/Linux could use the bind()/chmod()/listen() sequence.\r\nThe create method could be simplified in\r\nsrc/coreclr/debug/debug-pal/unix/diagnosticsipc.cpp as\r\n\r\n```cpp\r\nIpcStream::DiagnosticsIpc *IpcStream::DiagnosticsIpc::Create(const char *const pIpcName, ConnectionMode mode, ErrorCallback callback)\r\n{\r\n    sockaddr_un serverAddress{};\r\n    serverAddress.sun_family = AF_UNIX;\r\n\r\n    if (pIpcName != nullptr)\r\n    {\r\n        int chars = snprintf(serverAddress.sun_path, sizeof(serverAddress.sun_path), \"%s\", pIpcName);\r\n        _ASSERTE(chars \u003e 0 \u0026\u0026 (unsigned int)chars \u003c sizeof(serverAddress.sun_path));\r\n    }\r\n    else\r\n    {\r\n        // generate the default socket name in TMP Path\r\n        const ProcessDescriptor pd = ProcessDescriptor::FromCurrentProcess();\r\n        PAL_GetTransportName(\r\n            sizeof(serverAddress.sun_path),\r\n            serverAddress.sun_path,\r\n            \"dotnet-diagnostic\",\r\n            pd.m_Pid,\r\n            pd.m_ApplicationGroupId,\r\n            \"socket\");\r\n    }\r\n\r\n    if (mode == ConnectionMode::CONNECT)\r\n        return new IpcStream::DiagnosticsIpc(-1, \u0026serverAddress, ConnectionMode::CONNECT);\r\n\r\n    const int serverSocket = ::socket(AF_UNIX, SOCK_STREAM, 0);\r\n    if (serverSocket == -1)\r\n    {\r\n        if (callback != nullptr)\r\n            callback(strerror(errno), errno);\r\n        _ASSERTE(!\"Failed to create diagnostics IPC socket.\");\r\n        return nullptr;\r\n    }\r\n\r\n    const int fSuccessBind = ::bind(serverSocket, (sockaddr *)\u0026serverAddress, sizeof(serverAddress));\r\n    if (fSuccessBind == -1)\r\n    {\r\n        if (callback != nullptr)\r\n            callback(strerror(errno), errno);\r\n        _ASSERTE(fSuccessBind != -1);\r\n\r\n        const int fSuccessClose = ::close(serverSocket);\r\n        _ASSERTE(fSuccessClose != -1);\r\n\r\n        return nullptr;\r\n    }\r\n\r\n    if (chmod(pIpcName, S_IRUSR | S_IWUSR) == -1)\r\n    {\r\n        if (callback != nullptr)\r\n            callback(strerror(errno), errno);\r\n        _ASSERTE(!\"Failed to set permissions on diagnostics IPC socket.\");\r\n        const int fSuccessClose = ::close(serverSocket);\r\n        _ASSERTE(fSuccessClose != -1);\r\n        return nullptr;\r\n    }\r\n\r\n    return new IpcStream::DiagnosticsIpc(serverSocket, \u0026serverAddress, mode);\r\n}\r\n```\r\nBut I still need someone else to weigh in on this to ensure it\u0027s no less secure than the existing method. Is there any additional benefit in setting the permission on the socket fd on Linux?",
                                           "updatedAt":  "2021-09-10T09:40:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42zgiD",
                                           "createdAt":  "2021-09-14T20:02:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Triage: Might impact also non-FreeBSD OSs. But didn\u0027t come up yet.",
                                           "updatedAt":  "2021-09-14T20:02:17Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Setting permissions on eventpipe AF_UNIX socket file for MacOS/FreeBSD/Linux",
        "labels":  [
                       "enhancement",
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/59157",
        "createdAt":  "2021-09-15T13:50:59Z",
        "number":  59157,
        "author":  "Rodrigo-Andrade",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCzPLzg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pentp",
                                            "createdAt":  "2023-10-12T13:31:09Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2023-10-07T16:57:48Z",
        "body":  "I have being using this with great results for more than a year now, any plans for making this more \"official\"?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOaGnijQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc421qh0",
                                           "createdAt":  "2021-09-15T13:51:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-09-15T13:51:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc422lSZ",
                                           "createdAt":  "2021-09-15T18:37:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOB6f3ig==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "karelz",
                                                                               "createdAt":  "2021-09-15T19:23:23Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e I have being using this with great results\r\n\r\nCan you share more details?",
                                           "updatedAt":  "2021-09-15T18:37:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc422lTx",
                                           "createdAt":  "2021-09-15T18:37:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nI have being using this with great results for more than a year now, any plans for making this more \"official\"?\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eRodrigo-Andrade\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Net.Sockets`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-09-15T18:37:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc428nAW",
                                           "createdAt":  "2021-09-17T14:48:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Rodrigo-Andrade",
                                           "body":  "\u003e Can you share more details?\r\n\r\nI talked a bit about that here:\r\nhttps://github.com/dotnet/runtime/issues/44449\r\n\r\nBut long story short: since the change of how sockets queue work in linux, my app had some performance regressions.\r\nAfter enabling both flags, app performance doubled by avoiding queuing work in the threadpool. \r\n\r\n",
                                           "updatedAt":  "2021-09-17T14:48:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc429rHA",
                                           "createdAt":  "2021-09-17T23:47:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "halter73",
                                           "body":  "At least for `UnsafePreferInlineScheduling` in Kestrel, the concern is this could cause worse performance and possibly even deadlocks given blocking code. I assume there are similar concerns for `DOTNET_SYSTEM_NET_SOCKETS_INLINE_COMPLETIONS`.\r\n\r\nKestrel defaults to `AllowSynchronousIO` being false, but that just prevents calls to `HttpContext.Request.Body.Read(...)` and not `HttpContext.Request.Body.ReadAsync(...).Result` and other similar patterns. Even blocking on something like a database transaction or an outgoing HTTP request from a request handler could be a big problem if Kestrel\u0027s Socket transport doesn\u0027t dispatch to the thread pool.",
                                           "updatedAt":  "2021-09-17T23:47:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42_SDd",
                                           "createdAt":  "2021-09-19T23:56:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODJcbsg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pentp",
                                                                               "createdAt":  "2023-10-12T13:31:03Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "Rodrigo-Andrade",
                                           "body":  "Yes, and i had this problem (deadlocks), that actually led to improvements as some code paths were silently blocking.\r\nBut i am not proposing it to be the default, just that it is a legitimate option, right now it\u0027s my understanding that it\u0027s just experimental and can be pulled at any moment. ",
                                           "updatedAt":  "2021-09-19T23:56:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc44cvUL",
                                           "createdAt":  "2021-10-19T19:55:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Triage: Currently we do not have plans to productize it, but we want to do more investigation in 7.0 + collect feedback from users who use, so we will keep it open.",
                                           "updatedAt":  "2021-10-19T19:55:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5oaeKN",
                                           "createdAt":  "2023-10-07T16:57:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ShreyasJejurkar",
                                           "body":  "Please consider making this option as supported instead of experiment if not on by default. ",
                                           "updatedAt":  "2023-10-07T16:57:48Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "DOTNET_SYSTEM_NET_SOCKETS_INLINE_COMPLETIONS and UnsafePreferInlineScheduling Support",
        "labels":  [
                       "enhancement",
                       "area-System.Net.Sockets",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/63115",
        "createdAt":  "2021-12-24T05:58:51Z",
        "number":  63115,
        "author":  "geoffkizer",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC8lgzw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "GSPP",
                                            "createdAt":  "2022-01-20T10:57:34Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "u7pro",
                                            "createdAt":  "2024-11-12T14:02:58Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2022-01-19T12:48:11Z",
        "body":  "Every TCP server accept loop works like this:\r\n(1) Create and start the listener\r\n(2) Loop, accepting TCP connections and dispatching them, typically by spawning a thread pool work item\r\n(3) Close the listener to stop accepting new connections (typically done from a separate thread, since the thread running the accept loop is busy waiting for connections to arrive)\r\n\r\nUnfortunately, the behavior when you close the listener is today really ugly. It varies based on whether you do a sync or async accept, and whether you use TcpListener or Socket directly. Additionally, given the way accept loops are typically implemented, there is a race that results in a different exception if the close happens while an accept is pending vs happening after one accept completes but we haven\u0027t looped around to issue the next accept yet.\r\n\r\nIf you happen to stop the listener while the accept is pending, you will get a `SocketException`. For sync accept, you\u0027ll get SocketError=Interrupted. For async accept, you\u0027ll get SocketError=OperationAborted. (This is on Windows, but I believe the Linux behavior was implemented to match Windows.) I believe this is due to differences in sync/async handling in the underlying WinSock APIs, but this doesn\u0027t really help our users. \r\n\r\nAlso note that it\u0027s not correct to assume that any `SocketException` from accept is because the listener was closed -- other error conditions may cause different SocketExceptions. Instead, you have to explicitly check for the correct SocketError as listed above, depending on whether you do a sync or async accept.\r\n\r\nIf you lose the race and stop the listener while an accept is not pending, you will get `ObjectDisposedException` for Socket and `InvalidOperationException` for `TcpListener` (with the unhelpful message \"You must call the Start() method before calling this method.\"), for both sync and async accept. Since your dispatch logic is usually very short, you\u0027ll only rarely lose the race and see these exceptions, which may manifest to users as a rare and hard to diagnose exception.\r\n\r\nClosing the listener is a standard thing to do and shouldn\u0027t result in an exception from accept -- and especially shouldn\u0027t result in four different exceptions you need to check for.\r\n\r\nIdeally, Accept would have a way to return without exception but indicate that the listener was closed. Perhaps something like:\r\n\r\n```csharp\r\npublic class Socket\r\n{\r\n    public Socket? TryAccept();\r\n}\r\n```\r\n\r\nwhere returning null indicates that the listener was closed. Similarly for async and TcpListener methods.\r\n\r\nAlternatively, we could change the behavior of the existing accept methods to at least be consistent in the exceptions they throw when the listener is closed, and not be subject to the race described above. Throwing ObjectDisposedException in all cases seems reasonable. Note however that TcpListener doesn\u0027t implement IDisposable, so it\u0027s a bit weird to throw ObjectDisposedException there -- an alternative would be to throw InvalidOperationException for TcpListener, since that matches the behavior today when you lose the race. In theory, well-written apps should be handling these exceptions (ODE for Socket, IOE for TcpListener) today anyway, but in practice it seems likely that some are not, so changing the exception behavior here may break some apps -- though also lead to fixing the apps to work properly in all cases.\r\n\r\nRelated: https://github.com/dotnet/runtime/issues/63114\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOPJWMzg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc47pQOJ",
                                           "createdAt":  "2021-12-24T05:58:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nEvery TCP server accept loop works like this:\r\n(1) Create and start the listener\r\n(2) Loop, accepting TCP connections and dispatching them, typically by spawning a thread pool work item\r\n(3) Close the listener to stop accepting new connections (typically done from a separate thread, since the thread running the accept loop is busy waiting for connections to arrive)\r\n\r\nUnfortunately, the behavior when you close the listener is today really ugly. It varies based on whether you do a sync or async accept, and whether you use TcpListener or Socket directly. Additionally, given the way accept loops are typically implemented, there is a race that results in a different exception if the close happens while an accept is pending vs happening after one accept completes but we haven\u0027t looped around to issue the next accept yet.\r\n\r\nIf you happen to stop the listener while the accept is pending, you will get a SocketException. For sync accept, you\u0027ll get SocketError=Interrupted. For async accept, you\u0027ll get SocketError=OperationAborted. (This is on Windows, but I believe the Linux behavior was implemented to match Windows.) I believe this is due to differences in sync/async handling in the underlying WinSock APIs, but this doesn\u0027t really help our users. \r\n\r\nAlso note that it\u0027s not correct to assume that any SocketException from accept is because the listener was closed -- other error conditions may cause different SocketExceptions. Instead, you have to explicitly check for the correct SocketError as listed above, depending on whether you do a sync or async accept.\r\n\r\nIf you lose the race and stop the listener while an accept is not pending, you will get ObjectDisposedException for Socket and InvalidOperationException for TcpListener (with the unhelpful message \"You must call the Start() method before calling this method.\"), for both sync and async accept. Since your dispatch logic is usually very short, you\u0027ll only rarely lose the race and see these exceptions, which may manifest to users as a rare and hard to diagnose exception.\r\n\r\nClosing the listener is a standard thing to do and shouldn\u0027t result in an exception from accept -- and especially shouldn\u0027t result in four different exceptions you need to check for.\r\n\r\nIdeally, Accept would have a way to return without exception but indicate that the listener was closed. Perhaps something like:\r\n\r\n```csharp\r\npublic class Socket\r\n{\r\n    public Socket? TryAccept();\r\n}\r\n```\r\n\r\nwhere returning null indicates that the listener was closed. Similarly for async and TcpListener methods.\r\n\r\nAlternatively, we could change the behavior of the existing accept methods to at least be consistent in the exceptions they throw when the listener is closed, and not be subject to the race described above. Throwing ObjectDisposedException in all cases seems reasonable. Note however that TcpListener doesn\u0027t implement IDisposable, so it\u0027s a bit weird to throw ObjectDisposedException there -- an alternative would be to throw InvalidOperationException for TcpListener, since that matches the behavior today when you lose the race. In theory, well-written apps should be handling these exceptions (ODE for Socket, IOE for TcpListener) today anyway, but in practice it seems likely that some are not, so changing the exception behavior here may break some apps -- though also lead to fixing the apps to work properly in all cases.\r\n\r\nRelated: https://github.com/dotnet/runtime/issues/63114\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003egeoffkizer\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Net`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-12-24T05:58:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc47qLDD",
                                           "createdAt":  "2021-12-24T18:10:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "scalablecory",
                                           "body":  "Instead of a boolean, consider returning a `SocketError`. While this does add an extra step for the caller of checking against a specific error code, it would be more generalized and in line with our other overloads e.g. `int Socket.Receive (Span\u003cbyte\u003e, SocketFlags, out System.Net.Sockets.SocketError)` and how `SocketAsyncEventArgs` works.",
                                           "updatedAt":  "2021-12-24T18:10:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc476E1v",
                                           "createdAt":  "2022-01-04T18:47:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "Harmonizing existing API-s seems to be way harder and more risky (in terms of breaking changes) than adding new API-s so I vote for the latter.\r\n\r\nA potential API proposal (that also deals with the concerns from https://github.com/dotnet/runtime/issues/63115#issuecomment-1000911043) may look like this:\r\n\r\n```C#\r\npublic class Socket {\r\n    public bool TryAccept(out Socket acceptSocket);\r\n    public bool TryAccept(out Socket acceptSocket, out SocketError error);\r\n\r\n    public ValueTask\u003c(Socket?,SocketError)\u003e TryAcceptAsync(CancellationToken cancellationToken=default);\r\n}\r\n\r\npublic class TcpListener {\r\n    public bool TryAcceptTcpClient(out TcpClient tcpClient);\r\n    public bool TryAcceptSocket(out Socket acceptSocket);\r\n\r\n    public ValueTask\u003c(TcpClient?,SocketError)\u003e TryAcceptTcpClientAsync(CancellationToken cancellationToken=default);\r\n    public ValueTask\u003c(Socket?,SocketError)\u003e TryAcceptSocketAsync(CancellationToken cancellationToken=default);\r\n}\r\n```\r\n\r\nThere are several open questions though:\r\n- The async methods do not really match semantics of methods we typically prefix with `Try*`. Ideally it would be much better if we could name them without the prefix, but that is conflicting with existing overloads.\r\n- Shall we really expose `TcpClient` API-s? Depends on the verdict on #63162 I guess.",
                                           "updatedAt":  "2022-01-04T18:48:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48NoMx",
                                           "createdAt":  "2022-01-11T17:41:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Triage: async may not be trivial.\r\nOverall we like the idea, it needs more details to be finalized. ASP.NET asked for similar thing as part of Connection Abstraction. cc @Tratcher \r\nNot critical -\u003e Future.",
                                           "updatedAt":  "2022-01-11T17:42:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48lYzO",
                                           "createdAt":  "2022-01-19T12:48:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nEvery TCP server accept loop works like this:\r\n(1) Create and start the listener\r\n(2) Loop, accepting TCP connections and dispatching them, typically by spawning a thread pool work item\r\n(3) Close the listener to stop accepting new connections (typically done from a separate thread, since the thread running the accept loop is busy waiting for connections to arrive)\r\n\r\nUnfortunately, the behavior when you close the listener is today really ugly. It varies based on whether you do a sync or async accept, and whether you use TcpListener or Socket directly. Additionally, given the way accept loops are typically implemented, there is a race that results in a different exception if the close happens while an accept is pending vs happening after one accept completes but we haven\u0027t looped around to issue the next accept yet.\r\n\r\nIf you happen to stop the listener while the accept is pending, you will get a `SocketException`. For sync accept, you\u0027ll get SocketError=Interrupted. For async accept, you\u0027ll get SocketError=OperationAborted. (This is on Windows, but I believe the Linux behavior was implemented to match Windows.) I believe this is due to differences in sync/async handling in the underlying WinSock APIs, but this doesn\u0027t really help our users. \r\n\r\nAlso note that it\u0027s not correct to assume that any `SocketException` from accept is because the listener was closed -- other error conditions may cause different SocketExceptions. Instead, you have to explicitly check for the correct SocketError as listed above, depending on whether you do a sync or async accept.\r\n\r\nIf you lose the race and stop the listener while an accept is not pending, you will get `ObjectDisposedException` for Socket and `InvalidOperationException` for `TcpListener` (with the unhelpful message \"You must call the Start() method before calling this method.\"), for both sync and async accept. Since your dispatch logic is usually very short, you\u0027ll only rarely lose the race and see these exceptions, which may manifest to users as a rare and hard to diagnose exception.\r\n\r\nClosing the listener is a standard thing to do and shouldn\u0027t result in an exception from accept -- and especially shouldn\u0027t result in four different exceptions you need to check for.\r\n\r\nIdeally, Accept would have a way to return without exception but indicate that the listener was closed. Perhaps something like:\r\n\r\n```csharp\r\npublic class Socket\r\n{\r\n    public Socket? TryAccept();\r\n}\r\n```\r\n\r\nwhere returning null indicates that the listener was closed. Similarly for async and TcpListener methods.\r\n\r\nAlternatively, we could change the behavior of the existing accept methods to at least be consistent in the exceptions they throw when the listener is closed, and not be subject to the race described above. Throwing ObjectDisposedException in all cases seems reasonable. Note however that TcpListener doesn\u0027t implement IDisposable, so it\u0027s a bit weird to throw ObjectDisposedException there -- an alternative would be to throw InvalidOperationException for TcpListener, since that matches the behavior today when you lose the race. In theory, well-written apps should be handling these exceptions (ODE for Socket, IOE for TcpListener) today anyway, but in practice it seems likely that some are not, so changing the exception behavior here may break some apps -- though also lead to fixing the apps to work properly in all cases.\r\n\r\nRelated: https://github.com/dotnet/runtime/issues/63114\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003egeoffkizer\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Net.Sockets`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003eFuture\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-01-19T12:48:10Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "Improve behavior of Accept when the listener is closed",
        "labels":  [
                       "api-suggestion",
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/63162",
        "createdAt":  "2021-12-28T07:38:21Z",
        "number":  63162,
        "author":  "geoffkizer",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODMYFVw==",
                          "nodes":  [
                                        {
                                            "content":  "EYES",
                                            "user":  "samsosa",
                                            "createdAt":  "2021-12-28T07:50:17Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "Seb-stian",
                                            "createdAt":  "2021-12-28T08:24:14Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Symbai",
                                            "createdAt":  "2021-12-28T12:16:51Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "huoyaoyuan",
                                            "createdAt":  "2021-12-28T12:46:02Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "gfoidl",
                                            "createdAt":  "2021-12-28T13:46:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "samsosa",
                                            "createdAt":  "2021-12-28T14:39:55Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "reflectronic",
                                            "createdAt":  "2021-12-30T15:52:08Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MineCake147E",
                                            "createdAt":  "2022-01-05T04:00:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dersia",
                                            "createdAt":  "2022-01-06T04:17:36Z"
                                        },
                                        {
                                            "content":  "LAUGH",
                                            "user":  "GSPP",
                                            "createdAt":  "2022-01-18T15:57:08Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "GSPP",
                                            "createdAt":  "2022-01-18T15:57:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kevingosse",
                                            "createdAt":  "2022-02-03T15:36:33Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SommerEngineering",
                                            "createdAt":  "2022-03-02T08:02:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "escalonn",
                                            "createdAt":  "2022-04-01T23:03:46Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "lukeb1961",
                                            "createdAt":  "2022-05-12T08:31:00Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "NN---",
                                            "createdAt":  "2022-05-17T05:02:44Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Antonius-S",
                                            "createdAt":  "2022-05-20T12:45:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pentp",
                                            "createdAt":  "2022-06-06T14:07:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "deeprobin",
                                            "createdAt":  "2022-08-28T18:11:37Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "liveans",
                                            "createdAt":  "2022-10-11T11:23:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "michaldobrodenka",
                                            "createdAt":  "2022-12-05T20:17:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "omariom",
                                            "createdAt":  "2023-01-25T21:13:14Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "divyeshio",
                                            "createdAt":  "2023-05-12T04:04:37Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pedro823",
                                            "createdAt":  "2023-05-26T12:15:25Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MitchRazga",
                                            "createdAt":  "2023-06-09T07:32:03Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "angelofb",
                                            "createdAt":  "2024-02-21T20:14:42Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-08-13T22:58:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rducom",
                                            "createdAt":  "2025-02-09T17:59:49Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Athari",
                                            "createdAt":  "2025-07-19T00:23:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "neon-sunset",
                                            "createdAt":  "2025-08-23T08:00:29Z"
                                        }
                                    ],
                          "totalCount":  30
                      },
        "updatedAt":  "2022-11-29T18:54:47Z",
        "body":  "### Background and motivation\r\n\r\nWhen writing a TCP client or server, you have a choice of two APIs today: Socket or TcpClient/TcpListener.\r\n\r\nYou can use the Socket class directly. However, Socket is a low-level, general-purpose API that isn’t specific to TCP – it supports UDP, Unix Domain Sockets, raw sockets, and arbitrary socket types. Using it requires understanding concepts like AddressFamily, SocketType, ProtocolType, dual mode sockets, the EndPoint abstract base class and derived IPEndPoint class, how and when to use Bind, which Socket APIs work for TCP (Send/Receive) vs disconnected UDP (SendTo, ReceiveFrom), etc. If you are already familiar with Sockets, this is not a big deal – though note I’ve seen us mess some of this up in our own code, e.g. not enabling dual mode sockets properly because we used the wrong Socket constructor. If you are not already familiar with Sockets, and just want to write some basic TCP client or server code, then understanding Sockets is an unnecessary barrier to entry.\r\n\r\nAlternatively, you can use TcpClient and TcpListener, which provide a higher-level, TCP-specific API. These simplify creating and accepting TCP connections and provide some convenience APIs for common TCP tasks like setting NoDelay, controlling LingerState, or specifying a local IP and port to use when connecting.\r\n\r\nUnfortunately, TcpClient is an awful API.\r\n\r\nTcpClient is an old-style “create-set-use” API. You create an instance, configure it, and then call Connect[Async] to actually establish the connection. You then retrieve the associated NetworkStream using GetStream().\r\n\r\nThe overall TCP connection functionality is split between NetworkStream and TcpClient, with some (but not all) functionality in both places. Want to read or write? Use NetworkStream. Want to set NoDelay, or configure the send and receive buffer sizes? Use TcpClient. Want to set a read or write timeout? You can use either.\r\n\r\nWant to close the connection? You can use either. Both NetworkStream and TcpClient implement IDisposable and also have a Close method. Either one will dispose both the NetworkStream and the TcpClient, but this is not at all obvious – and in fact the **docs for GetStream() get this wrong**; see #63154.\r\n\r\nEven worse, TcpClient is finalizable even though its finalizer simply calls Dispose(false), which, unless you override it, does nothing. Socket itself is finalizable and so classes that use it, like TcpClient and NetworkStream, don’t need to be finalizable themselves.\r\n\r\nEven **worse**, some basic TCP functionality is missing from both TcpClient and NetworkStream. There is no way to shutdown the connection, no access to local or remote endpoints, no way to configure TCP keep-alive.\r\n\r\nOn top of that, some of the TcpClient APIs are just confusing. The property you use to access the underlying socket is called “Client”… why? Why not “Socket”?? One constructor takes a hostname and port and performs a (synchronous) Connect for you; another takes an IPEndPoint, but instead of performing the Connect, it uses this as the local endpoint for the connection.\r\n\r\nEven **more** confusing, TcpClient is also used in TCP server scenarios. TcpListener has AcceptTcpClient[Async] methods that return a TcpClient instance to represent the accepted connection. This allows you to configure NoDelay and get the associated NetworkStream. Or even access the underlying socket using the Client property, even though you’re a server… gahhhhhhh.\r\n\r\nWe shouldn’t have two types that each incompletely represent a TCP connection. We should have a single type that represents a TCP connection and allows you to perform all common TCP connection operations. And we should have simple APIs that return this type for TCP client scenarios (Connect) and TCP server scenarios (Listen/Accept).\r\n\r\n### API Proposal\r\n\r\n(Note this is a general sketch and is not intended to include all potential overloads, optional params, etc.)\r\n\r\n```C#\r\nnamespace System.Net.Sockets\r\n{\r\n    // New class\r\n    public sealed class TcpConnection : NetworkStream\r\n    {\r\n        // Create from existing Socket. Socket must be connected. TcpConnection takes ownership.\r\n        public TcpConnection(Socket socket);\r\n\r\n        public IPAddress LocalAddress { get; }\r\n        public int LocalPort { get; }\r\n        public IPAddress RemoteAddress { get; }\r\n        public int RemotePort { get; }\r\n\r\n        public bool NoDelay { get; set; }\r\n        \r\n        public int SendBufferSize { get; set; }\r\n        public int ReceiveBufferSize { get; set; }\r\n\r\n        public void Shutdown(SocketShutdown how);\r\n\r\n        public Socket Socket { get; }\r\n\r\n        // Read[Async], Write[Async], and Close are inherited from NetworkStream\r\n        // Other possible additions, now or in the future: TCP keep-alive, LingerState\r\n    }\r\n\r\n    // New class\r\n    public static class Tcp\r\n    {\r\n        public static TcpConnection Connect(IPAddress address, int port);\r\n        public static ValueTask\u003cTcpConnection\u003e ConnectAsync(IPAddress address, int port, CancellationToken cancellationToken = default);\r\n        public static TcpConnection Connect(string hostname, int port);\r\n        public static ValueTask\u003cTcpConnection\u003e ConnectAsync(string hostname, int port, CancellationToken cancellationToken = default);\r\n\r\n        // Note, the returned TcpListener is already started\r\n        public static TcpListener Listen(IPAddress address, int port, int backlog = 100);\r\n    }\r\n\r\n    // Existing class\r\n    public class TcpListener\r\n    {\r\n        public TcpConnection AcceptConnection();\r\n        public ValueTask\u003cTcpConnection\u003e AcceptConnectionAsync(CancellationToken cancellationToken = default);\r\n    }    \r\n}\r\n```\r\n\r\nThe following are obsoleted:\r\n(1) TcpClient class\r\n(2) TcpListener.AcceptTcpClient[Async], Start(), existing constructors, etc.\r\n\r\n### API Usage\r\n\r\nClient example:\r\n\r\n```C#\r\n    TcpConnection connection = await Tcp.ConnectAsync(\"www.microsoft.com\", 80);\r\n    Console.WriteLine($\"Established connection from {connection.LocalAddress}:{connection.LocalPort} to {connection.RemoteAddress}:{connection.RemotePort}\");\r\n\r\n    // Do something with the connection\r\n```\r\n\r\nServer example:\r\n\r\n```C#\r\n    TcpListener listener = Tcp.Listen(IPAddress.Any, 80);\r\n    Console.WriteLine($\"Server listening on {listener.ListenAddress()}:{listener.ListenPort()}\");\r\n\r\n    while (true)\r\n    {\r\n        TcpConnection connection = await listener.AcceptConnectionAsync();\r\n        Console.WriteLine($\"Accepted connection from {connection.RemoteAddress}:{connection.RemotePort} to {connection.LocalAddress}:{connection.RemotePort}\");\r\n\r\n        // Do something with the connection\r\n    }\r\n```\r\n\r\nExample for both client and server:\r\n\r\n```C#\r\n    using (TcpConnection connection = ...)\r\n    {\r\n        // Configure TCP connection before we use it\r\n        connection.NoDelay = true;\r\n        connection.ReceiveBufferSize = MyReceiveBufferSize;\r\n        connection.SendBufferSize = MySendBufferSize;\r\n\r\n        // Perform reads and writes here\r\n\r\n        // Half-close the connection\r\n        connection.Shutdown(SocketShutdown.Send);\r\n\r\n        // Read any remaining data from peer\r\n    }\r\n```\r\n\r\n### Alternative Designs\r\n\r\nSome of the methods/properties defined on TcpConnection above may make more sense on NetworkStream, since they are not specific to TCP. E.g. Send/ReceiveBufferSize. Since TcpConnection derives from NetworkStream, these will be available to users of TcpConnection either way.\r\n\r\nAnother alternative is to just obsolete TcpClient and TcpListener entirely and tell users to always use Sockets. I don\u0027t think this is ideal; I think there\u0027s value in having simple APIs specifically for TCP. But if we don\u0027t think there is, then let\u0027s please obsolete the existing awful APIs and point people in the right direction.\r\n\r\n### Related\r\n\r\nWe should consider similar API updates for SSL, UDP, and Unix Domain Sockets.\r\n\r\nSee also these related TcpListener issues: #63114, #63115, #63117\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOT1bxug==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc47uAq0",
                                           "createdAt":  "2021-12-28T07:38:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nWhen writing a TCP client or server, you have a choice of two APIs today: Socket or TcpClient/TcpListener.\r\n\r\nYou can use the Socket class directly. However, Socket is a low-level, general-purpose API that isn’t specific to TCP – it supports UDP, Unix Domain Sockets, raw sockets, and arbitrary socket types. Using it requires understanding concepts like AddressFamily, SocketType, ProtocolType, dual mode sockets, the EndPoint abstract base class and derived IPEndPoint class, how and when to use Bind, which Socket APIs work for TCP (Send/Receive) vs disconnected UDP (SendTo, ReceiveFrom), etc. If you are already familiar with Sockets, this is not a big deal – though note I’ve seen us mess some of this up in our own code, e.g. not enabling dual mode sockets properly because we used the wrong Socket constructor. If you are not already familiar with Sockets, and just want to write some basic TCP client or server code, then understanding Sockets is an unnecessary barrier to making progress.\r\n\r\nAlternatively, you can use TcpClient and TcpListener, which provide a higher-level, TCP-specific API. These simplify creating and accepting TCP connections and provide some convenience APIs for common TCP tasks like setting NoDelay, controlling LingerState, or specifying a local IP and port to use when connecting.\r\n\r\nUnfortunately, TcpClient is an awful API.\r\n\r\nTcpClient is an old-style “create-set-use” API. You create an instance, configure it, and then call Connect[Async] to actually establish the connection. You then retrieve the associated NetworkStream using GetStream().\r\n\r\nThe overall TCP connection functionality is split between NetworkStream and TcpClient, with some (but not all) functionality in both places. Want to read or write? Use NetworkStream. Want to set NoDelay, or configure the send and receive buffer sizes? Use TcpClient. Want to set a read or write timeout? You can use either.\r\n\r\nWant to close the connection? You can use either. Both NetworkStream and TcpClient implement IDisposable and also have a Close method. Either one will dispose both the NetworkStream and the TcpClient, but this is not at all obvious – and in fact the **docs for GetStream() get this wrong**; see #63154.\r\n\r\nEven worse, TcpClient is finalizable even though its finalizer simply calls Dispose(false), which, unless you override it, does nothing. Socket itself is finalizable and so classes that use it, like TcpClient and NetworkStream, don’t need to be finalizable themselves.\r\n\r\nEven **worse**, some basic TCP functionality is missing from both TcpClient and NetworkStream. There is no way to shutdown the connection, no access to local or remote endpoints, no way to configure TCP keep-alive.\r\n\r\nOn top of that, some of the TcpClient APIs are just confusing. The property you use to access the underlying socket is called “Client”… why? Why not “Socket”?? One constructor takes a hostname and port and performs a (synchronous) Connect for you; another takes an IPEndPoint, but instead of performing the Connect, it uses this as the local endpoint for the connection.\r\n\r\nEven **more** confusing, TcpClient is also used in TCP server scenarios. TcpListener has AcceptTcpClient[Async] methods that return a TcpClient instance to represent the accepted connection. This allows you to configure NoDelay and get the associated NetworkStream. Or even access the underlying socket using the Client property, even though you’re a server… gahhhhhhh.\r\n\r\nWe shouldn’t have two types that each incompletely represent a TCP connection. We should have a single type that represents a TCP connection and allows you to perform all common TCP connection operations. And we should have simple APIs that return this type for TCP client scenarios (Connect) and TCP server scenarios (Listen/Accept).\r\n\r\n\n\n### API Proposal\n\n(Note this is a general sketch and is not intended to include all potential overloads, optional params, etc.)\r\n\r\n```C#\r\nnamespace System.Net.Sockets\r\n{\r\n    // New class\r\n    public sealed class TcpConnection : NetworkStream\r\n    {\r\n        // Create from existing Socket. Socket must be connected. TcpConnection takes ownership.\r\n        public TcpConnection(Socket socket);\r\n\r\n        public IPAddress LocalAddress { get; }\r\n        public int LocalPort { get; }\r\n        public IPAddress RemoteAddress { get; }\r\n        public int RemotePort { get; }\r\n\r\n        public bool NoDelay { get; set; }\r\n        \r\n        public int SendBufferSize { get; set; }\r\n        public int ReceiveBufferSize { get; set; }\r\n\r\n        public void Shutdown(SocketShutdown how);\r\n\r\n        public Socket Socket { get; }\r\n\r\n        // Read[Async], Write[Async], and Close are inherited from NetworkStream\r\n        // Other possible additions, now or in the future: TCP keep-alive, LingerState\r\n    }\r\n\r\n    // New class\r\n    public static class Tcp\r\n    {\r\n        public static TcpConnection Connect(IPAddress address, int port);\r\n        public static ValueTask\u003cTcpConnection\u003e ConnectAsync(IPAddress address, int port, CancellationToken cancellationToken = default);\r\n        public static TcpConnection Connect(string hostname, int port);\r\n        public static ValueTask\u003cTcpConnection\u003e ConnectAsync(string hostname, int port, CancellationToken cancellationToken = default);\r\n\r\n        // Note, the returned TcpListener is already started\r\n        public static TcpListener Listen(IPAddress address, int port, int backlog = 100);\r\n    }\r\n\r\n    // Existing class\r\n    public class TcpListener\r\n    {\r\n        public TcpConnection AcceptConnection();\r\n        public ValueTask\u003cTcpConnection\u003e AcceptConnectionAsync(CancellationToken cancellationToken = default);\r\n    }    \r\n}\r\n```\r\n\r\nThe following are obsoleted:\r\n(1) TcpClient class\r\n(2) TcpListener.AcceptTcpClient[Async], Start(), existing constructors, etc.\r\n\r\n\n\n### API Usage\n\nClient example:\r\n\r\n```C#\r\n    TcpConnection connection = await Tcp.ConnectAsync(\"www.microsoft.com\", 80);\r\n    Console.WriteLine($\"Established connection from {connection.LocalIPAddress}:{connection.LocalPort} to {connection.RemoteIPAddress}:{connection.RemotePort}\");\r\n\r\n    // Do something with the connection\r\n```\r\n\r\nServer example:\r\n\r\n```C#\r\n    TcpListener listener = Tcp.Listen(IPAddress.Any, 80);\r\n    Console.WriteLine($\"Server listening on {listener.ListenIPAddress()}:{listener.ListenPort()}\");\r\n\r\n    while (true)\r\n    {\r\n        TcpConnection connection = await listener.AcceptTcpConnectionAsync();\r\n        Console.WriteLine($\"Accepted connection from {connection.RemoteIPAddress}:{connection.RemotePort} to {connection.LocalIPAddress}:{connection.RemotePort}\");\r\n\r\n        // Do something with the connection\r\n    }\r\n```\r\n\r\nExample for both client and server:\r\n\r\n```C#\r\n    using (TcpConnection connection = ...)\r\n    {\r\n        // Configure TCP connection before we use it\r\n        connection.NoDelay = true;\r\n        connection.ReceiveBufferSize = MyReceiveBufferSize;\r\n        connection.SendBufferSize = MySendBufferSize;\r\n\r\n        // Perform reads and writes here\r\n\r\n        // Half-close the connection\r\n        connection.Shutdown(SocketShutdown.Send);\r\n\r\n        // Read any remaining data from peer\r\n    }\r\n```\n\n### Alternative Designs\n\nSome of the methods/properties defined on TcpConnection above may make more sense on NetworkStream, since they are not specific to TCP. E.g. Send/ReceiveBufferSize. Since TcpConnection derives from NetworkStream, these will be available to users of TcpConnection either way.\r\n\r\n\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003egeoffkizer\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Net.Sockets`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-12-28T07:38:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc47uqFh",
                                           "createdAt":  "2021-12-28T12:47:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "`NetworkStream` is not hard to use in simple scenarios. I\u0027d expect more support for Udp.",
                                           "updatedAt":  "2021-12-28T12:47:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc47urtv",
                                           "createdAt":  "2021-12-28T12:58:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "filipnavara",
                                           "body":  "Side note: I think you should look into what Apple did with the Network.framework APIs. They aimed to simplify similar scenarios but also have a concept of layering to implement things like TLS or application-level protocols. The main reason I am suggesting that though is that on newer Apple platforms the Network.framework is the only supported API [bundled with the system] for establishing TLS (over UDP/TCP) connections. The current `SslStream` API cannot easily be implemented using the Network.framework APIs because it allows arbitrary underlying transport and the Apple API does not. There are workarounds for client-side scenarios (albeit crude and inefficient, such as creating dummy domain socket and then layering a custom transport over it to redirect the raw TLS stream into appropriate API layer). However, there are no workarounds for server-side scenarios. It would be nice if any new abstraction of TCP connections was built with the restrictions in mind to allow implementation of both TCP and TLS-over-TCP through the Apple APIs.",
                                           "updatedAt":  "2021-12-28T12:59:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc47uw2x",
                                           "createdAt":  "2021-12-28T13:48:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gfoidl",
                                           "body":  "\u003e `public static class Tcp`\r\n\r\nInstead of a static class should this be something like `public class TcpBuilder : ITcpBuilder`? (naming may be better, of course).\r\nMotivation against the static class is testability of the components that will use this type.",
                                           "updatedAt":  "2021-12-28T13:48:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc47vCd9",
                                           "createdAt":  "2021-12-28T16:32:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCvBWlA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "gfoidl",
                                                                               "createdAt":  "2021-12-28T18:20:14Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "antonfirsov",
                                                                               "createdAt":  "2022-01-03T17:16:32Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "GSPP",
                                                                               "createdAt":  "2022-01-18T16:12:47Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "rzikm",
                                                                               "createdAt":  "2022-11-04T08:21:01Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "svick",
                                           "body":  "\u003e ```c#\r\n\u003e public sealed class TcpConnection : NetworkStream\r\n\u003e ```\r\n\r\nNote that [this violates Framework Design Guidelines, which say](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/names-of-classes-structs-and-interfaces#names-of-common-types):\r\n\r\n\u003e |Base Type|Derived/Implementing Type Guideline|\r\n\u003e |---------------|------------------------------------------|\r\n\u003e |`System.IO.Stream`|✔️ DO add the suffix \"Stream.\"|",
                                           "updatedAt":  "2021-12-28T16:32:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc47vLTB",
                                           "createdAt":  "2021-12-28T18:05:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gfoidl",
                                           "body":  "Edit: please ignore this comment\r\n\r\n~[NetworkStream](https://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.networkstream?view=net-6.0) already exists in the framework for a long time -- so it\u0027s too late to change this.\r\nOr did you have something different on focus here?~",
                                           "updatedAt":  "2021-12-28T18:29:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc47vMa9",
                                           "createdAt":  "2021-12-28T18:18:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCwtwpQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "gfoidl",
                                                                               "createdAt":  "2021-12-28T18:20:11Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "shahid-pk",
                                                                               "createdAt":  "2021-12-29T13:39:20Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "omariom",
                                                                               "createdAt":  "2022-12-05T21:15:45Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "alexrp",
                                           "body":  "\u003e [NetworkStream](https://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.networkstream?view=net-6.0) already exists in the framework for a long time -- so it\u0027s too late to change this. Or did you have something different on focus here?\r\n\r\n`NetworkStream` is fine. The point is that, to comply with the guidelines, this proposal should be `TcpConnectionStream`, `TcpStream`, or something along those lines, not `TcpConnection`.\r\n\r\n(Though I tend to agree with @filipnavara that extending `NetworkStream` is fundamentally not the way to go for a \"modern\" TCP API.)",
                                           "updatedAt":  "2021-12-28T18:18:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc47voPj",
                                           "createdAt":  "2021-12-29T00:45:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "FiniteReality",
                                           "body":  "IMHO if a \"modern\" TCP API was added, it should operate similarly to the types in the `System.IO.Pipelines` namespace. That is, the read/write endpoints should be separate by default, and a \"combined\" interface (using IDuplexPipe) can be passed around for those needing both read and write access. This \"combined\" interface could have an API for retrieving a Stream for consumers needing legacy stream-based read-write access (e.g. SSL) but it should default to keeping them separate using the newer, more efficient primitives.",
                                           "updatedAt":  "2021-12-29T00:48:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc47w4hY",
                                           "createdAt":  "2021-12-29T16:15:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCQ_m2g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "filipnavara",
                                                                               "createdAt":  "2021-12-29T17:56:04Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "SommerEngineering",
                                                                               "createdAt":  "2022-03-02T08:05:19Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "zlatanov",
                                           "body":  "@geoffkizer doesn\u0027t https://github.com/dotnet/runtime/issues/1793 already cover this?",
                                           "updatedAt":  "2021-12-29T16:15:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc47xDPx",
                                           "createdAt":  "2021-12-29T17:56:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "filipnavara",
                                           "body":  "At first sight #1793 is much more like the Apple API model.",
                                           "updatedAt":  "2021-12-29T17:56:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4724co",
                                           "createdAt":  "2022-01-03T17:27:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "Though I mostly agree with the proposal, I think we should investigate synergies with #1793, and potentially merge the two.\r\n\r\nIf - for some reason - we decide to implement Connection Abstractions for let\u0027s say .NET 8, we\u0027ll end up having two sets of very similar API\u0027s for TCP connection creation, which will generate some confusion.\r\n\r\nAlternatively we may decide that we don\u0027t want #1793 to be part of the BCL and close it.",
                                           "updatedAt":  "2022-01-03T17:27:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48DaC6",
                                           "createdAt":  "2022-01-07T16:03:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCJBliA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "antonfirsov",
                                                                               "createdAt":  "2022-01-07T19:14:40Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "scalablecory",
                                           "body":  "Can we see some side-by-side examples where this will have the best impact?",
                                           "updatedAt":  "2022-01-07T16:03:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48iGdQ",
                                           "createdAt":  "2022-01-18T16:17:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GSPP",
                                           "body":  "\u003e Unfortunately, TcpClient is an awful API.\r\n\r\nI find your rant very refreshing 😆. So I\u0027m not the only one who finds `TcpClient` nasty.\r\n\r\n\u003chr\u003e\r\n\r\n1. Maybe those IP/port pairs should be represented with `IPEndPoint`?\r\n2. I think `backlog = 100` shouldn\u0027t default to some arbitrary value. The behavior should be what existing APIs do. I believe, they use the OS default.\r\n3. Do we really want to carry forward the nastiness brought by `TcpListener`? If we take your criticism seriously (we should) then this class is unsalvagable. Reusing it will just result in an even more involved, weirdly coupled API surface.\r\n4. The synchronous connect APIs could be made to support cancellation as well. With `Socket`, you can cancel that by closing the socket. With this new factory-style APIs there is no way to cancel.\r\n5. Should those connect APIs support a timeout (as `TimeSpan`, *please* no more `int milliseconds`)? Otherwise, you\u0027d have to create a `CancellationTokenSource` just for the timeout.\r\n\r\n",
                                           "updatedAt":  "2022-01-18T16:41:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48ov4N",
                                           "createdAt":  "2022-01-20T10:10:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tactical-drone",
                                           "body":  "The overall Socket API is bad for out of the box use.\r\n\r\nThese are the kinds of contraptions one has to create on top of .net sockets currently to normalize the design:\r\n\r\nhttps://github.com/tactical-drone/zero/tree/net-standard/zero.core/network/ip\r\n\r\nThe amount of work seems excessive.\r\n\r\nThen there are still other problems. Having to `new CancellationTokenSource(timeout).Token` every time you want to send with timeout does not make sense for example. So that entire API needs a sanity check I think.  ",
                                           "updatedAt":  "2022-01-20T10:43:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Ban2U",
                                           "createdAt":  "2022-04-13T02:53:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "\u003e 4\\. The synchronous connect APIs could be made to support cancellation as well. With `Socket`, you can cancel that by closing the socket. With this new factory-style APIs there is no way to cancel.\r\n\r\nThat is not necessarily true. Since we use SafeHandle under the cover `Close` does not really work while in `connect` system call - at least on Linux. And AFAIK we did not mix sync methods with `CancellationToken` so far. For consistency, it may be best if synchronous methods depend on timeout values while `*Async` use the token.  However, through some other discussion I feel there is sentiment for old good timeouts even in Async as the exceptions are sometimes hard to decode and troubleshoot. \r\n\r\nOne that note, we tend to provide synchronous versions for compatibility. If anything, I would question that for the new API. There is significant complication (at least on Unix) for mixing the modes.",
                                           "updatedAt":  "2022-04-13T02:53:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5BawoF",
                                           "createdAt":  "2022-04-13T04:11:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "I did look at the link @tactical-drone but lot of the code does not make sense to me - like `Poll` before `WriteAsync`.  It would be more useful IMHO to describe what problems you trying to solve.\r\n\r\nI did more searching within runtime and found [TlsStream](https://github.com/dotnet/runtime/blob/main/src/libraries/Common/src/System/Net/TlsStream.cs) that wraps `SslStream` as `NetworkStream` and then  [NetworkStreamWrapper](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Net.Requests/src/System/Net/NetworkStreamWrapper.cs) that wraps transparently either one. If that is more common it would support what @filipnavara suggested. I would not mind do blend it with https://github.com/dotnet/runtime/issues/63663.\r\n\r\nThat other proposal also brings concept of connect policy. People trying to prefer given address family, or some way how to impact interface or address used. \r\n```c#\r\n [Flags]\r\n    public enum ConnectOptions\r\n    {\r\n       Default = 0,\r\n       IPv4Only,\r\n       IPv6Only,\r\n       Parallel, // Happy-Eyeball\r\n       FastOpen,\r\n       ...\r\n    }\r\n```\r\nI\u0027m wondering if anybody here would find it interesting. For example, the `Happy-Eyeball` is on todo list for a while. But instead of bolting it to `Sockets` we could put it here as added value. ",
                                           "updatedAt":  "2022-04-13T04:11:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5BaxSg",
                                           "createdAt":  "2022-04-13T04:16:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "Lastly, the https://github.com/dotnet/runtime/issues/1793 is dead as right now. I think it may be because it tried to solve everything.  While related, I see this proposal as way how to make writing simple networking endpoints easier. In order to do that, I think we should focus on simplicity and consistency. If combined with TLS it may go beyond the `TCP`     @geoffkizer envisioned but we can still probably keep it simple. ",
                                           "updatedAt":  "2022-04-13T04:16:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5BayEk",
                                           "createdAt":  "2022-04-13T04:23:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "```c#\r\n    public static ValueTask\u003cTcpConnection\u003e ConnectAsync(string hostname, int port, SslClientAuthenticationOptions? sslOptions = null, CancellationToken cancellationToken = default);\r\n    public ValueTask\u003cTcpConnection\u003e AcceptConnectionAsync(SslServerAuthenticationOptions? sslOptions = null, CancellationToken cancellationToken = default);\r\n```\r\n\r\nthat would optionally negotiate TLS if `sslOptions` is not null. (The server may be little bit more complicated)",
                                           "updatedAt":  "2022-04-13T04:23:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5PVvG6",
                                           "createdAt":  "2022-11-29T18:16:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "A few thoughts:\r\n\r\n1. I agree with https://github.com/dotnet/runtime/issues/63162#issuecomment-1002227389. `TcpConnection` should be `TcpStream` to conform to existing conventions.\r\n\r\n\r\n2. Instead of exposing TCP settings (`NoDelay`, `SendBufferSize`, `ReceiveBufferSize` ...) on `TcpStream`, we should consider encapsulating them in a separate `TcpConnectionOptions` type the same way we do in [QUIC](https://learn.microsoft.com/en-us/dotnet/api/system.net.quic.quicclientconnectionoptions?view=net-7.0). This would achieve API symmetry, discoverability of options and also make sure the socket is configured upfront:\r\n\r\n```C#\r\n\r\npublic sealed class TcpConnectionOptions\r\n{\r\n        public IPEndPoint RemoteEndPoint { get; set; }\r\n\r\n        public bool NoDelay { get; set; }       \r\n        public int SendBufferSize { get; set; }\r\n        public int ReceiveBufferSize { get; set; }\r\n        \r\n        // APIs for TCP Keepalive etc.\r\n}\r\n\r\npublic static class Tcp\r\n{\r\n    ValueTask\u003cTcpStream\u003e ConnectAsync(TcpConnectionOptions options, CancellationToken cancellationToken = default);\r\n}\r\n```\r\n\r\n3. @wfurt regarding https://github.com/dotnet/runtime/issues/63162#issuecomment-1097539876:\r\n\r\nThis would require merging `System.Net.Sockets.dll` with `System.Net.Security.dll`, which is not possible. Instead, we can consider a variant of #63663, that would provide an easy way to \"convert\" an existing `TcpStream` into an `SslStream` instead of creating it from scratch. This would enable layering things with simple API-s:\r\n\r\n```c#\r\nnamespace System.Net.Security;\r\n\r\npublic static class NetworkStreamExtensions\r\n{\r\n    public static async ValueTask\u003cSslStream\u003e AuthenticateAsClientSslStream(this NetworkStream networkStream, SslClientAuthenticationOptions options);\r\n}\r\n```",
                                           "updatedAt":  "2022-11-29T18:54:47Z"
                                       }
                                   ],
                         "totalCount":  19
                     },
        "title":  "[API Proposal]: Simple, modern TCP APIs",
        "labels":  [
                       "api-suggestion",
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/64551",
        "createdAt":  "2022-01-31T18:35:18Z",
        "number":  64551,
        "author":  "jaimefinat",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC-H-SQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pgrawehr",
                                            "createdAt":  "2022-02-12T20:12:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "tipa",
                                            "createdAt":  "2025-01-14T13:41:19Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2025-01-26T08:25:40Z",
        "body":  "Hi\r\nwe are experiencing an issue in macos (Monterey) when closing a UdpClient socket from the server side.\r\nAlso related to previously detected issue [#21392](https://github.com/dotnet/runtime/issues/24513)\r\n\r\n1. We create the UdpClient: \r\n`mUdpClient = new UdpClient(listenPort);`\r\n2. The UdpClient calls Receive method:\r\n`byte[] bytes = mUdpClient.Receive(ref groupEP);`\r\n3. While waiting to receive something from any client, the Close() method is called in another thread:\r\n`mUdpClient.Close();`\r\n\r\nAttached to this, I\u0027m sending a minimum version of a Server-Client application to reproduce the issue. \r\n\r\nExpected behaviour:\r\nIn Windows it is rising an exception which allos us to stop the server:\r\n```\r\nSystem.Net.Sockets.SocketException (10004): A blocking operation was interrupted by a call to WSACancelBlockingCall.\r\n   at System.Net.Sockets.Socket.ReceiveFrom(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags, EndPoint\u0026 remoteEP)\r\n   at System.Net.Sockets.UdpClient.Receive(IPEndPoint\u0026 remoteEP)\r\n   at Server.StartListener() in C:\\experiments\\client-server\\server\\Server.cs:line 21\r\n```\r\n\r\nIn macos it hangs in Receive until it gets a message from the client, so it processes the request and then triggers another exception:\r\n```\r\nUnhandled exception. System.ObjectDisposedException: Cannot access a disposed object.\r\nObject name: \u0027System.Net.Sockets.Socket\u0027.\r\n   at System.Net.Sockets.Socket.ThrowObjectDisposedException()\r\n   at System.Net.Sockets.Socket.ReceiveFrom(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags, EndPoint\u0026 remoteEP)\r\n   at System.Net.Sockets.UdpClient.Receive(IPEndPoint\u0026 remoteEP)\r\n   at Server.StartListener() in /Users/daniel.hompanera/wkspaces/UdpApp/Server/Server.cs:line 21\r\n   at System.Threading.ThreadHelper.ThreadStart_Context(Object state)\r\n   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state)\r\n--- End of stack trace from previous location ---\r\n   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state)\r\n   at System.Threading.ThreadHelper.ThreadStart()\r\n[1]    29462 abort      dotnet Server.dll\r\n```\r\n\r\nTo reproduce the issue (different behaviour in macos/windows) download and build the solution from this post, start the server and type: _efss_ to EndFromServerSide.\r\n\r\nThe code has been modified from the basic version [here](https://docs.microsoft.com/en-us/dotnet/framework/network-programming/using-udp-services)\r\n\r\nThank you very much for your kind support!\r\nJaime\r\n\r\n[UdpApp.zip](https://github.com/dotnet/runtime/files/7973222/UdpApp.zip)\r\n ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOm4kNzQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc49KNQG",
                                           "createdAt":  "2022-01-31T18:35:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nHi\r\nwe are experiencing an issue in macos (Monterey) when closing a UdpClient socket from the server side.\r\nAlso related to previous detected issue [#21392](https://github.com/dotnet/runtime/issues/24513)\r\n\r\n1. We create the UdpClient: \r\n`mUdpClient = new UdpClient(listenPort);`\r\n2. The UdpClient calls Receive method:\r\n`byte[] bytes = mUdpClient.Receive(ref groupEP);`\r\n3. While waiting to receive something from any client, the Close() method is called in another thread:\r\nmUdpClient.Close();\r\n\r\nAttached to this, I\u0027m sending a minimum version of a Server-Client application to reproduce the issue. \r\n\r\nExpected behaviour:\r\nIn Windows it is rising an exception which allos us to stop the server:\r\n```\r\nSystem.Net.Sockets.SocketException (10004): A blocking operation was interrupted by a call to WSACancelBlockingCall.\r\n   at System.Net.Sockets.Socket.ReceiveFrom(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags, EndPoint\u0026 remoteEP)\r\n   at System.Net.Sockets.UdpClient.Receive(IPEndPoint\u0026 remoteEP)\r\n   at Server.StartListener() in C:\\experiments\\client-server\\server\\Server.cs:line 21\r\n```\r\n\r\nIn macos it hangs in Receive until it receives a message from the client, so it process the request and then triggers another exception:\r\n```\r\nUnhandled exception. System.ObjectDisposedException: Cannot access a disposed object.\r\nObject name: \u0027System.Net.Sockets.Socket\u0027.\r\n   at System.Net.Sockets.Socket.ThrowObjectDisposedException()\r\n   at System.Net.Sockets.Socket.ReceiveFrom(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags, EndPoint\u0026 remoteEP)\r\n   at System.Net.Sockets.UdpClient.Receive(IPEndPoint\u0026 remoteEP)\r\n   at Server.StartListener() in /Users/daniel.hompanera/wkspaces/UdpApp/Server/Server.cs:line 21\r\n   at System.Threading.ThreadHelper.ThreadStart_Context(Object state)\r\n   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state)\r\n--- End of stack trace from previous location ---\r\n   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state)\r\n   at System.Threading.ThreadHelper.ThreadStart()\r\n[1]    29462 abort      dotnet Server.dll\r\n```\r\n\r\nTo reproduce the issue (different behaviour in macos/windows) download and build the solution from this post, start the server and type: _efss_ to EndFromServerSide.\r\n\r\nThe code has been modified from the basic version [here](https://docs.microsoft.com/en-us/dotnet/framework/network-programming/using-udp-services)\r\n\r\nThank you very much for your kind support!\r\nJaime\r\n\r\n[UdpApp.zip](https://github.com/dotnet/runtime/files/7973222/UdpApp.zip)\r\n \n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejaimefinat\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Net.Sockets`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-01-31T18:35:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49KRVP",
                                           "createdAt":  "2022-01-31T18:56:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "may be related to dotnet/corefx#38804. I think Disconnect does not work on UDP. \r\nOne way how to work around it is to use ReceiveAsync.\r\ncc: @tmds ",
                                           "updatedAt":  "2022-01-31T18:56:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49KUl7",
                                           "createdAt":  "2022-01-31T19:12:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jaimefinat",
                                           "body":  "We are using a timeout, as the async alternative would imply some more refactoring and redesign. I hope it is also OK.\r\n\r\nIn case someone else gets into this thread, our workaround:\r\n\r\n1. Set the timeout property:\r\n`UdpClient.Client.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, 500);`\r\n2. Wrap inside a try-catch the Receive method\r\n3. Catch the SocketError exception and assure its ErrorCode is TimedOut:\r\n```c#\r\ncatch (SocketException ex)\r\n{\r\n    // Attention, do not use int codes as they might be different between OS\u0027s:\r\n    // https://blog.jetbrains.com/dotnet/2020/04/27/socket-error-codes-depend-runtime-operating-system/\r\n    if (ex.SocketErrorCode == SocketError.TimedOut)\r\n        continue;\r\n```\r\n4. In case it is TimedOut, continue with the loop and Receive again :\r\n\r\nThank you for your quick response!\r\nBest,\r\nJaime",
                                           "updatedAt":  "2022-02-10T17:01:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49KX-b",
                                           "createdAt":  "2022-01-31T19:27:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCMYO1g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jaimefinat",
                                                                               "createdAt":  "2022-01-31T19:28:59Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "antonfirsov",
                                                                               "createdAt":  "2022-01-31T19:34:12Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "wfurt",
                                           "body":  "Understand. However, I\u0027m not sure if there is any good fox for this case.\r\nYou could use something like\r\n```c#\r\nusing CancellationTokenSource cts = new CancellationTokenSource();\r\ncts.CancelAfter(timeout);\r\nvar result = socket.ReceiveAsync(memory, flags, cts.Token).GetAwaiter().GetResult();\r\n```\r\nWhile this is generally not recommended it should avoid the hang. \r\nThe exception would be different.\r\n\r\nActually digging deeper this seems like dup of https://github.com/dotnet/runtime/issues/47342\r\n\r\nhttps://github.com/dotnet/runtime/blob/a2235e775b55efab0e195d2850f1b4bb12c8a4f1/src/libraries/System.Net.Sockets/tests/FunctionalTests/ReceiveFrom.cs#L174-L181\r\n",
                                           "updatedAt":  "2022-01-31T19:27:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49L_wY",
                                           "createdAt":  "2022-02-01T07:44:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCMdCVw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "jaimefinat",
                                                                               "createdAt":  "2022-02-01T07:55:47Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jaimefinat",
                                                                               "createdAt":  "2022-02-01T07:55:52Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "tmds",
                                           "body":  "It\u0027s a known limitation that we\u0027re unable to unblock sync receives and TCP connects:\r\n\r\nhttps://github.com/dotnet/runtime/blob/daf77fc9a5ee0417d691a19322cc0bc74d8562df/src/libraries/System.Net.Sockets/src/System/Net/Sockets/SafeSocketHandle.Unix.cs#L189-L190\r\n\r\nYou need to use an async API if you want to be able to cancel them.",
                                           "updatedAt":  "2022-02-01T07:44:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49OPQ0",
                                           "createdAt":  "2022-02-01T18:13:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "I was thinking about it more @tmds and I\u0027m wondering if we can do something like:\r\n```\r\n tmp = handle;\r\n handle = -1;\r\n close(tmp);\r\n```\r\n\r\ne.g. set handle to invalid to prevent future operations or mixup when the handle is closed but actually use `close()` to finalize all pending operations.  \r\n\r\nThe FIN behavior does not matter for UDP and may be acceptable for TCP in corner cases. Still feels better than blocking forever. \r\n",
                                           "updatedAt":  "2022-02-01T18:13:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49QOTN",
                                           "createdAt":  "2022-02-02T07:40:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCMqNwg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "jaimefinat",
                                                                               "createdAt":  "2022-02-02T07:59:59Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "tmds",
                                           "body":  "On macOS, when there is a pending UDP `receive`, `close` does not cause it to return.\r\nIt\u0027s not something we\u0027re causing, it is how the kernel behaves.",
                                           "updatedAt":  "2022-02-02T07:40:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49S-dS",
                                           "createdAt":  "2022-02-02T21:41:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "I don\u0027t think that is true @tmds. Consider following example\r\n```c#\r\nusing System;\r\nusing System.Net.Sockets;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\nusing System.Runtime.InteropServices;\r\n\r\nnamespace udpListener\r\n{\r\n    class Program\r\n    {\r\n        [DllImport(\"libc\", EntryPoint = \"close\", SetLastError = true)]\r\n        static extern internal int MyClose(IntPtr handle);\r\n\r\n        static void Receive(Socket s)\r\n        {\r\n            try\r\n            {\r\n                byte[] b = new byte[10024];\r\n                int received = s.Receive(b);\r\n                Console.WriteLine(\"Received {0} bytes\", received);\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Console.WriteLine(ex);\r\n            }\r\n        }\r\n        static void Main(string[] args)\r\n        {\r\n            int listenPort = 9000;\r\n            var mUdpClient = new UdpClient(listenPort);\r\n            Console.WriteLine(\"Got listening socket on {0}\", mUdpClient.Client.Handle);\r\n            var t = Task.Run(() =\u003e Receive(mUdpClient.Client));\r\n            Thread.Sleep(1000);\r\n            Console.WriteLine(\"Cancelling\");\r\n\r\n            if (args.Length \u003e 0)\r\n            {\r\n                MyClose(mUdpClient.Client.Handle);\r\n            }\r\n            else\r\n            {\r\n                mUdpClient.Client.Close();\r\n            }\r\n\r\n            t.GetAwaiter().GetResult();\r\n            Console.WriteLine(\"All done\");\r\n        }\r\n    }\r\n}\r\n```\r\nIt hangs when executed without parameters but\r\n```\r\nShining:udpListener furt$ ~/dotnet-6/dotnet run a\r\nHello World!\r\nGot listening socket on 33\r\nCancelling\r\nSystem.Net.Sockets.SocketException (89): Operation canceled\r\n   at System.Net.Sockets.Socket.Receive(Byte[] buffer)\r\n   at udpListener.Program.Receive(Socket s) in /Users/furt/projects/udpListener/Program.cs:line 20\r\nAll done\r\n```\r\n\r\nI think it is OK to close the handle while used in p/invoke but we need to avoid case when it is closed but old value could be used. This is why I suggested to set the handle to invalid to prevent further use before closing the handle. \r\n",
                                           "updatedAt":  "2022-02-02T21:41:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49UKdS",
                                           "createdAt":  "2022-02-03T07:53:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "\u003e I don\u0027t think that is true\r\n\r\nYes, you\u0027re right. Calling `close` causes the `recv` to unblock.\r\n\r\n\u003e This is why I suggested to set the handle to invalid to prevent further use before closing the handle.\r\n\r\nThis has a race. When the handle gets closed between adding the reference to the `SafeHandle` and passing the fd to the syscall, the fd passed to the syscall may no longer refer to the right socket.",
                                           "updatedAt":  "2022-02-03T07:53:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49UMjs",
                                           "createdAt":  "2022-02-03T08:06:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCM3nJA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "jaimefinat",
                                                                               "createdAt":  "2022-02-03T08:32:02Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "wfurt",
                                           "body":  "\u003e This has a race. When the handle gets closed between adding the reference to the `SafeHandle` and passing the fd to the syscall, the fd passed to the syscall may no longer refer to the right socket.\r\n\r\ncan we fix that somehow? I\u0027m not sure if setting the handler to invalid is sufficient but it can be start.",
                                           "updatedAt":  "2022-02-03T08:06:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49UV1Q",
                                           "createdAt":  "2022-02-03T08:53:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "\u003e can we fix that somehow? I\u0027m not sure if setting the handler to invalid is sufficient but it can be start.\r\n\r\nNo. This is the race:\r\n\r\n```\r\nThread A: takes ref on safe handle\r\nThread A: int fd = safehandle.DangerousGetHandle();\r\nThread B: close(fd)\r\nThread B: int s = socket(); // the raw handle \u0027s\u0027 equals the \u0027fd\u0027\r\nThread A: recvmsg(fd); // recvmsg was supposed to be called on safehandle, but it is called on \u0027s\u0027 instead.\r\n```",
                                           "updatedAt":  "2022-02-03T08:53:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49s4h_",
                                           "createdAt":  "2022-02-10T17:06:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Triage: We don\u0027t see a way how to fix it. Given that this is the first report, we will keep it open for Future.\r\nThe only option we thought about is to call `close` early, which would invalidate some additional assumptions on parallel calls.\r\n\r\nWorkaround is to use `ReadAsync` and wait for result - while it is not best practice, it may be decent alternative in this case.",
                                           "updatedAt":  "2022-02-10T17:06:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6biQ3N",
                                           "createdAt":  "2025-01-23T10:33:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEJPPhA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "puntor",
                                                                               "createdAt":  "2025-03-10T19:32:39Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "tipa",
                                           "body":  "I am using a Socket (in order to get an NTP timestamp) on macOS and I\u0027m hitting two problems:\n\n#### 1) Cancelling either `ConnectAsync`, `SendAsync` or `ReceiveAsync` doesn\u0027t seem to be working reliably\nIn my code (see code example below) I am using a cancellation token that should abort all socket operations after 1.5 seconds (and throw a `TaskCanceledException`). Therefore, the code shouldn\u0027t go into the `else`-branch that is only entered when my `Task.Delay` task, which is configured to wait 2.5 sec, is finishing earlier. But my logging shows that the code does enter that branch - even though `linked_tcs.IsCancellationRequested` is set to true. How is this possible? Is the `IsCancellationRequested` property not checked at least every second?\n\n#### 2) Users are reporting that the app is hanging and unresponsive\nEven though I am using async methods, users are reporting that the app is hanging/unresponsive and they have to force-quit it. Are there any blocking operatings that are executed in the main thread, even when using the async `Connect`, `Send` or `Receive` methods of the `Socket` class?\n\n```\nusing var linked_tcs = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);\nlinked_tcs.CancelAfter(1500); // only wait 1.5 sec for NTP timestamp\nvar delayTask = Task.Delay(2500, cancellationToken); // only wait 2.5 sec for Task.WhenAny to return\nvar queryTask = QueryAsync(linked_tcs.Token);\nvar winner = await Task.WhenAny(queryTask, delayTask).ConfigureAwait(false);\nif (winner == queryTask)\n{\n    // all good, we got the response\n}\nelse\n{\n    // we should never get here because linked_tcs is cancelled after 1.5 sec and Task.Delay() waits for 2.5 sec\n    // linked_tcs.IsCancellationRequested is *true* here\n    // cancellationToken.IsCancellationRequested is *false* here\n}\n\npublic static async Task\u003cSpan\u003cbyte\u003e buffer\u003e QueryAsync(CancellationToken token = default)\n{\n    using var socket = new Socket(SocketType.Dgram, ProtocolType.Udp);\n    await socket.ConnectAsync(\"pool.ntp.org\", 123, token).ConfigureAwait(false);\n    var rcvbuff = new byte[160];\n    await socket.SendAsync(GetRequestBytes(), token).ConfigureAwait(false);\n    int length = await socket.ReceiveAsync(rcvbuff, token).ConfigureAwait(false);\n    return rcvbuff.AsSpan(0, length);\n}\n```\n\nI\u0027m using the latest .NET9 version. If this is the wrong thread to post this in, I can also open a new issue",
                                           "updatedAt":  "2025-01-26T08:25:40Z"
                                       }
                                   ],
                         "totalCount":  13
                     },
        "title":  "UdpClient hangs when Receive is waiting and gets a Close() in macos",
        "labels":  [
                       "bug",
                       "area-System.Net.Sockets",
                       "os-mac-os-x"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/66639",
        "createdAt":  "2022-03-15T04:33:07Z",
        "number":  66639,
        "author":  "geoffkizer",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-03-17T17:00:34Z",
        "body":  "As of .NET 5, the only calls to the async methods in SocketAsyncContext are via SocketAsyncEventArgs. (Previously, we had some old IAsyncResult async APIs that were implemented directly on top of SocketAsyncContext; however, as of .NET 5, these now wrap the Task-based async APIs, and the Task-based async APIs wrap SocketAsyncEventArgs.)\r\n\r\nThis opens up the possibility of significant simplification of the SocketAsyncContext code, and improvements in memory usage and overall codepath length in general, by removing the current strict layering between SocketAsyncEventArgs and SocketAsyncContext.\r\n\r\nSpecifically: There is a whole hierarchy of AsyncOperation classes in SocketAsyncContext, which store state for the current operation and its result, like the user\u0027s send or receive buffer(s), SocketAddress and length for SendTo/ReceiveFrom, bytes transferred, socket flags, and the completion callback. All of these effectively duplicate state already held on the SocketAsyncEventArgs. \r\n\r\nFor example, we could simply pass the associated SocketAsyncEventArgs object in to every async method on SocketAsyncContext, e.g. ReceiveAsync. Then, instead of using BufferMemoryReceiveOperation to store user\u0027s buffer, socket flags, callback, resulting bytes transferred etc, we would simply use the relevant fields on the SocketAsyncEventArgs instead. Effectively, SocketAsyncContext.ReceiveAsync (and other async methods) only need to take a SocketAsyncEventArgs argument and simply operate on that.\r\n\r\nNote that this applies only to the async operations in SocketAsyncContext. SocketAsyncContext also supports synchronous operations, including sync-over-async when necessary. Those can also be simplified. but the details are different. See https://github.com/dotnet/runtime/issues/46600.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOP6GV9g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc4_oZX2",
                                           "createdAt":  "2022-03-15T04:33:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nAs of .NET 5, the only calls to the async methods in SocketAsyncContext are via SocketAsyncEventArgs. (Previously, we had some old IAsyncResult async APIs that were implemented directly on top of SocketAsyncContext; however, as of .NET 5, these now wrap the Task-based async APIs, and the Task-based async APIs wrap SocketAsyncEventArgs.)\r\n\r\nThis opens up the possibility of significant simplification of the SocketAsyncContext code, and improvements in memory usage and overall codepath length in general, by removing the current strict layering between SocketAsyncEventArgs and SocketAsyncContext.\r\n\r\nSpecifically: There is a whole hierarchy of AsyncOperation classes in SocketAsyncContext, which store state for the current operation and its result, like the user\u0027s send or receive buffer(s), SocketAddress and length for SendTo/ReceiveFrom, bytes transferred, socket flags, and the completion callback. All of these effectively duplicate state already held on the SocketAsyncEventArgs. \r\n\r\nFor example, we could simply pass the associated SocketAsyncEventArgs object in to every async method on SocketAsyncContext, e.g. ReceiveAsync. Then, instead of using BufferMemoryReceiveOperation to store user\u0027s buffer, socket flags, callback, resulting bytes transferred etc, we would simply use the relevant fields on the SocketAsyncEventArgs instead. Effectively, SocketAsyncContext.ReceiveAsync (and other async methods) only need to take a SocketAsyncEventArgs argument and simply operate on that.\r\n\r\nNote that this applies only to the async operations in SocketAsyncContext. SocketAsyncContext also supports synchronous operations, including sync-over-async when necessary. Those can also be simplified. but the details are different. See https://github.com/dotnet/runtime/issues/46600.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003egeoffkizer\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Net.Sockets`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-03-15T04:33:13Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Linux Sockets: Reduce overhead and simplify code in SocketAsyncContext",
        "labels":  [
                       "enhancement",
                       "area-System.Net.Sockets",
                       "os-linux"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/67417",
        "createdAt":  "2022-04-01T06:22:56Z",
        "number":  67417,
        "author":  "InCerryGit",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-04-07T16:04:56Z",
        "body":  "### Background and motivation\r\n\r\nI try use Socket.SendFile API send a specified part of a file, but this API dose not have the file `offset` and `count` paramenters.I don\u0027t want to use application buffer, this API provides higher performance with 0-copy.\r\nnow i have a solution, but it\u0027s unsafe and not support `await`。\r\n\r\n``` C#\r\n[return: MarshalAs(UnmanagedType.Bool)]\r\n[DllImport(\"mswsock.dll\", SetLastError = true)]\r\npublic static extern unsafe bool TransmitFile(\r\n    SafeHandle socket,\r\n    IntPtr fileHandle,\r\n    int numberOfBytesToWrite,\r\n    int numberOfBytesPerSend,\r\n    NativeOverlapped* overlapped,\r\n    TransmitFileBuffers* buffers,\r\n    TransmitFileOptions flags);\r\n[StructLayout(LayoutKind.Sequential)]\r\npublic struct TransmitFileBuffers\r\n{\r\n    internal IntPtr Head;\r\n    internal int HeadLength;\r\n    internal IntPtr Tail;\r\n    internal int TailLength;\r\n}\r\nprivate static unsafe void SendFile(this Socket socket, string path, int offset, long? length)\r\n{\r\n    using var file = File.Open(path, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);\r\n    if (offset != 0)\r\n    {\r\n        file.Seek(offset, SeekOrigin.Begin);\r\n    }\r\n    \r\n    var count = length ?? file.Length - offset;\r\n    if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))\r\n    {\r\n        TransmitFile(socket.SafeHandle, file.SafeFileHandle.DangerousGetHandle(), \r\n            (int)count, 0, null, null, TransmitFileOptions.UseKernelApc);   \r\n    }\r\n    else\r\n    {\r\n        throw new PlatformNotSupportedException();\r\n    }\r\n}\r\n```\r\n\r\n### API Proposal\r\n\r\nI wish there was an API like this:\r\n```C#\r\n    public class Socket\r\n    {\r\n        /// \u003csummary\u003e\r\n        /// Sends a specified part of file synchronously to a connected Socket.\r\n        /// \u003c/summary\u003e\r\n        /// \u003cparam name=\"fileName\"\u003eA String that contains the path and name of the file to be sent. This parameter can be null.\u003c/param\u003e\r\n        /// \u003cparam name=\"offset\"\u003eThe position in the file where writing starts.\u003c/param\u003e\r\n        /// \u003cparam name=\"length\"\u003eThe number of bytes to send, or null to send the remainder of the file.\u003c/param\u003e\r\n        public void SendFile(string fileName, long offset, long? length);\r\n\r\n        /// \u003csummary\u003e\r\n        /// Sends a specified part of file to a connected Socket.\r\n        /// \u003c/summary\u003e\r\n        /// \u003cparam name=\"fileName\"\u003eA String that contains the path and name of the file to be sent. This parameter can be null.\u003c/param\u003e\r\n        /// \u003cparam name=\"offset\"\u003eThe position in the file where writing starts.\u003c/param\u003e\r\n        /// \u003cparam name=\"length\"\u003eThe number of bytes to send, or null to send the remainder of the file.\u003c/param\u003e\r\n        /// \u003cparam name=\"cancellationToken\"\u003eA cancellation token that can be used to cancel the asynchronous operation.\u003c/param\u003e\r\n        public ValueTask SendFileAsync(string fileName, long offset, long? length, System.Threading.CancellationToken cancellationToken = default);\r\n    }\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```C#\r\n\r\n// get a socket\r\nvar socket = GetUploadSocket();\r\n\r\n// sync \r\nsocket.SendFile(\"data.log\", 512, 1024);\r\nsocket.SendFile(\"data.log\", 512, null);\r\n\r\n// async\r\nawait socket.SendFileAsync(\"data.log\", 512, 1024, token);\r\nawait socket.SendFileAsync(\"data.log\", 512, null, token);\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOQRVfMg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5Asxip",
                                           "createdAt":  "2022-04-01T06:23:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-io\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nI try use Socket.SendFile API send a specified part of a file, but this API dose not have the file `offset` and `count` paramenters.I don\u0027t want to use application buffer, this API provides higher performance with 0-copy.\r\nnow i have a solution, but it\u0027s inconvenient and not support `await`。\r\n\r\n``` C#\r\n[return: MarshalAs(UnmanagedType.Bool)]\r\n[DllImport(\"mswsock.dll\", SetLastError = true)]\r\npublic static extern unsafe bool TransmitFile(\r\n    SafeHandle socket,\r\n    IntPtr fileHandle,\r\n    int numberOfBytesToWrite,\r\n    int numberOfBytesPerSend,\r\n    NativeOverlapped* overlapped,\r\n    TransmitFileBuffers* buffers,\r\n    TransmitFileOptions flags);\r\n[StructLayout(LayoutKind.Sequential)]\r\npublic struct TransmitFileBuffers\r\n{\r\n    internal IntPtr Head;\r\n    internal int HeadLength;\r\n    internal IntPtr Tail;\r\n    internal int TailLength;\r\n}\r\nprivate static unsafe void SendFile(this Socket socket, string path, int offset, long? length)\r\n{\r\n    using var file = File.Open(path, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);\r\n    if (offset != 0)\r\n    {\r\n        file.Seek(offset, SeekOrigin.Begin);\r\n    }\r\n    \r\n    var count = length ?? file.Length - offset;\r\n    if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))\r\n    {\r\n        TransmitFile(socket.SafeHandle, file.SafeFileHandle.DangerousGetHandle(), \r\n            (int)count, 0, null, null, TransmitFileOptions.UseKernelApc);   \r\n    }\r\n    else\r\n    {\r\n        throw new PlatformNotSupportedException();\r\n    }\r\n}\r\n```\n\n### API Proposal\n\nI wish there was an API like this:\r\n```C#\r\n    public class Socket\r\n    {\r\n        /// \u003csummary\u003e\r\n        /// Sends a specified part of file synchronously to a connected Socket.\r\n        /// \u003c/summary\u003e\r\n        /// \u003cparam name=\"fileName\"\u003eA String that contains the path and name of the file to be sent. This parameter can be null.\u003c/param\u003e\r\n        /// \u003cparam name=\"offset\"\u003eThe position in the file where writing starts.\u003c/param\u003e\r\n        /// \u003cparam name=\"length\"\u003eThe number of bytes to write, starting at offset.\u003c/param\u003e\r\n        public void SendFile(string fileName, long offset, long length);\r\n\r\n        /// \u003csummary\u003e\r\n        /// Sends a specified part of file to a connected Socket.\r\n        /// \u003c/summary\u003e\r\n        /// \u003cparam name=\"fileName\"\u003eA String that contains the path and name of the file to be sent. This parameter can be null.\u003c/param\u003e\r\n        /// \u003cparam name=\"offset\"\u003eThe position in the file where writing starts.\u003c/param\u003e\r\n        /// \u003cparam name=\"length\"\u003eThe number of bytes to write, starting at offset.\u003c/param\u003e\r\n        /// \u003cparam name=\"cancellationToken\"\u003eA cancellation token that can be used to cancel the asynchronous operation.\u003c/param\u003e\r\n        public ValueTask SendFileAsync(string fileName, long offset, long length, System.Threading.CancellationToken cancellationToken = default);\r\n    }\r\n```\r\n\n\n### API Usage\n\n```C#\r\n\r\n// get a socket\r\nvar socket = GetUploadSocket();\r\n\r\n// sync\r\nsocket.SendFile(\"data.log\", 0, 1024);\r\n\r\n// async\r\nawait socket.SendFileAsync(\"data.log\", 0, 1024);\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eInCerryGit\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.IO`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-04-01T06:23:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5As2IR",
                                           "createdAt":  "2022-04-01T06:49:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nI try use Socket.SendFile API send a specified part of a file, but this API dose not have the file `offset` and `count` paramenters.I don\u0027t want to use application buffer, this API provides higher performance with 0-copy.\r\nnow i have a solution, but it\u0027s inconvenient and not support `await`。\r\n\r\n``` C#\r\n[return: MarshalAs(UnmanagedType.Bool)]\r\n[DllImport(\"mswsock.dll\", SetLastError = true)]\r\npublic static extern unsafe bool TransmitFile(\r\n    SafeHandle socket,\r\n    IntPtr fileHandle,\r\n    int numberOfBytesToWrite,\r\n    int numberOfBytesPerSend,\r\n    NativeOverlapped* overlapped,\r\n    TransmitFileBuffers* buffers,\r\n    TransmitFileOptions flags);\r\n[StructLayout(LayoutKind.Sequential)]\r\npublic struct TransmitFileBuffers\r\n{\r\n    internal IntPtr Head;\r\n    internal int HeadLength;\r\n    internal IntPtr Tail;\r\n    internal int TailLength;\r\n}\r\nprivate static unsafe void SendFile(this Socket socket, string path, int offset, long? length)\r\n{\r\n    using var file = File.Open(path, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);\r\n    if (offset != 0)\r\n    {\r\n        file.Seek(offset, SeekOrigin.Begin);\r\n    }\r\n    \r\n    var count = length ?? file.Length - offset;\r\n    if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))\r\n    {\r\n        TransmitFile(socket.SafeHandle, file.SafeFileHandle.DangerousGetHandle(), \r\n            (int)count, 0, null, null, TransmitFileOptions.UseKernelApc);   \r\n    }\r\n    else\r\n    {\r\n        throw new PlatformNotSupportedException();\r\n    }\r\n}\r\n```\n\n### API Proposal\n\nI wish there was an API like this:\r\n```C#\r\n    public class Socket\r\n    {\r\n        /// \u003csummary\u003e\r\n        /// Sends a specified part of file synchronously to a connected Socket.\r\n        /// \u003c/summary\u003e\r\n        /// \u003cparam name=\"fileName\"\u003eA String that contains the path and name of the file to be sent. This parameter can be null.\u003c/param\u003e\r\n        /// \u003cparam name=\"offset\"\u003eThe position in the file where writing starts.\u003c/param\u003e\r\n        /// \u003cparam name=\"length\"\u003eThe number of bytes to write, starting at offset.\u003c/param\u003e\r\n        public void SendFile(string fileName, long offset, long length);\r\n\r\n        /// \u003csummary\u003e\r\n        /// Sends a specified part of file to a connected Socket.\r\n        /// \u003c/summary\u003e\r\n        /// \u003cparam name=\"fileName\"\u003eA String that contains the path and name of the file to be sent. This parameter can be null.\u003c/param\u003e\r\n        /// \u003cparam name=\"offset\"\u003eThe position in the file where writing starts.\u003c/param\u003e\r\n        /// \u003cparam name=\"length\"\u003eThe number of bytes to write, starting at offset.\u003c/param\u003e\r\n        /// \u003cparam name=\"cancellationToken\"\u003eA cancellation token that can be used to cancel the asynchronous operation.\u003c/param\u003e\r\n        public ValueTask SendFileAsync(string fileName, long offset, long length, System.Threading.CancellationToken cancellationToken = default);\r\n    }\r\n```\r\n\n\n### API Usage\n\n```C#\r\n\r\n// get a socket\r\nvar socket = GetUploadSocket();\r\n\r\n// sync\r\nsocket.SendFile(\"data.log\", 0, 1024);\r\n\r\n// async\r\nawait socket.SendFileAsync(\"data.log\", 0, 1024);\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eInCerryGit\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Net.Sockets`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-04-01T06:49:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5AtuRq",
                                           "createdAt":  "2022-04-01T10:27:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gfoidl",
                                           "body":  "As a \"workaround\" you can use [`Socket.SendPacketsAsync`](https://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.socket.sendpacketsasync?view=net-6.0). There is the possibility to specify offset and length in the filestream. Though not as elegant as in your proposal.",
                                           "updatedAt":  "2022-04-01T10:27:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5AuN2N",
                                           "createdAt":  "2022-04-01T12:47:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "InCerryGit",
                                           "body":  "\u003e As a \"workaround\" you can use [`Socket.SendPacketsAsync`](https://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.socket.sendpacketsasync?view=net-6.0). There is the possibility to specify offset and length in the filestream. Though not as elegant as in your proposal.\r\n\r\nI have a question, Does [`Socket.SendPacketsAsync`](https://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.socket.sendpacketsasync?view=net-6.0) api support linux OS and zero-copy？Now i use the below code on linux OS to send sepcify part file。\r\nThanks! @gfoidl \r\n``` C#\r\n[DllImport(\"libSystem.Native\", EntryPoint = \"SystemNative_SendFile\", SetLastError = true)]\r\nprivate static extern Error SendFile(SafeHandle out_fd, SafeHandle in_fd, long offset, long count, out long sent);\r\n```",
                                           "updatedAt":  "2022-04-01T12:49:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5AuVEc",
                                           "createdAt":  "2022-04-01T13:14:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gfoidl",
                                           "body":  "If I\u0027m not mistaken on Linux this goes down to https://man7.org/linux/man-pages/man2/sendfile.2.html, so it\u0027s done within the kernel.\r\nAlso see https://github.com/dotnet/runtime/issues/46848#issuecomment-758590633 (the code-pathes of SendFileAsync and SendPacketsAsync go down a similar route on Linux).",
                                           "updatedAt":  "2022-04-01T13:14:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5AuW62",
                                           "createdAt":  "2022-04-01T13:21:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Now i use the below code on linux OS to send sepcify part file\r\n\r\nPlease don\u0027t do this. libSystem.Native is a private implementation detail of the runtime.  These are not public APIs and can and do frequently change.  Relying on them is a great way to be broken on next patch or update.",
                                           "updatedAt":  "2022-04-01T13:21:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Aujte",
                                           "createdAt":  "2022-04-01T14:06:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "InCerryGit",
                                           "body":  "\u003e Please don\u0027t do this. libSystem.Native is a private implementation detail of the runtime. These are not public APIs and can and do frequently change. Relying on them is a great way to be broken on next patch or update.\r\n\r\nThanks for your advice.  I understand the risks. But i have no other good ideas right now. \r\n",
                                           "updatedAt":  "2022-04-01T14:06:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5AumQS",
                                           "createdAt":  "2022-04-01T14:14:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e But i have no other good ideas right now.\r\n\r\nWhy can\u0027t you use Socket.SendPacketsAsync?  As @gfoidl suggested, it\u0027s not as friendly to use, but it should do what you need and is fully supported. (I\u0027m not suggesting this as an alternative to adding new APIs, but rather as something you can use now.)",
                                           "updatedAt":  "2022-04-01T14:20:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Aur8I",
                                           "createdAt":  "2022-04-01T14:35:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "InCerryGit",
                                           "body":  "\u003e but it should do what you need and is fully supported.\r\n\r\nThe [document](https://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.socket.sendpacketsasync?view=net-6.0) say on windows server has optimized. I\u0027m not sure the same optimization (zero-copy) on linux. we service to require relatively high performance. I\u0027m need more research and test.\r\n\r\n\u003e On Windows client editions, the [SendPacketsAsync](https://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.socket.sendpacketsasync?view=net-6.0) method is optimized for minimum memory and resource utilization.",
                                           "updatedAt":  "2022-04-01T14:35:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5AushM",
                                           "createdAt":  "2022-04-01T14:37:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "As @gfoidl already mentioned, SendPacketsAsync ends up calling the native export you already mentioned.",
                                           "updatedAt":  "2022-04-01T14:37:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5AuuvH",
                                           "createdAt":  "2022-04-01T14:47:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "InCerryGit",
                                           "body":  "I will try use  Socket.SendPacketsAsync. \r\nThanks!  @gfoidl @stephentoub ",
                                           "updatedAt":  "2022-04-01T14:47:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5BFV8y",
                                           "createdAt":  "2022-04-07T16:04:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Triage: Sounds reasonable -- it is a convenience method, but one saving quite a few lines of code.\r\nNot critical for now, moving to Future.",
                                           "updatedAt":  "2022-04-07T16:04:49Z"
                                       }
                                   ],
                         "totalCount":  12
                     },
        "title":  "[API Proposal]: Socket.SendFile add offset and length paramenters",
        "labels":  [
                       "api-suggestion",
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/69595",
        "createdAt":  "2022-05-20T08:42:18Z",
        "number":  69595,
        "author":  "Antonius-S",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC2GjEA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Antonius-S",
                                            "createdAt":  "2022-05-27T07:13:05Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "crfrolik",
                                            "createdAt":  "2022-06-23T16:49:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kasthack",
                                            "createdAt":  "2023-01-28T21:13:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SuperPichu",
                                            "createdAt":  "2023-06-22T03:34:43Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Darcara",
                                            "createdAt":  "2024-02-25T13:31:32Z"
                                        }
                                    ],
                          "totalCount":  5
                      },
        "updatedAt":  "2022-05-26T16:04:57Z",
        "body":  "### Background and motivation\r\n\r\nNow proxies are supported for HTTP requests only but the world obviously is not limited to HTTP protocol. It would be nice to have proxy supported at the lower socket level so that any TCP connection could be proxied.\r\n\r\n### API Proposal\r\n\r\nCurrent SocksHelper.cs is based on a Stream so we\u0027ve to use NetworkStream but it requires already connected sockets. Thus proxy feature seems to be only pluggable into TcpClient.\r\n\r\n```csharp\r\nnamespace System.Net.Sockets;\r\n\r\nTcpClient\r\n{\r\n  public ProxyProps proxyProps;\r\n}\r\n```\r\n\r\nIf proxy is set, `Connect` methods should connect to the proxy host internally and then establish the proxy tunnel.\r\n\r\n### API Usage\r\n\r\n```csharp\r\ntcpConn.proxyProps.Uri = \"socks5://localhost:1080\";\r\nawait tcpConn.ConnectAsync(\"example.com:123\");\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\nJust make SocksHelper and HTTP tunnel helpers public?\r\n\r\n### Risks\r\n\r\nThose who use `Socket` directly won\u0027t get any benefit. Enhance NetworkStream with ability to create and connect a socket?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOQ9-5Ig==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5DgrwC",
                                           "createdAt":  "2022-05-20T08:42:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nNow proxies are supported for HTTP requests only but the world obviously is not limited to HTTP protocol. It would be nice to have proxy supported at the lower socket level so that any TCP connection could be proxied.\n\n### API Proposal\n\nCurrent SocksHelper.cs is based on a Stream so we\u0027ve to use NetworkStream but it requires already connected sockets. Thus proxy feature seems to be only pluggable into TcpClient.\r\n\r\n```csharp\r\nnamespace System.Net.Sockets;\r\n\r\nTcpClient\r\n{\r\n  public ProxyProps proxyProps;\r\n}\r\n```\r\n\r\nIf proxy is set, `Connect` methods should connect to the proxy host internally and then establish the proxy tunnel.\n\n### API Usage\n\n```csharp\r\ntcpConn.proxyProps = \"socks5://localhost:1080\";\r\nawait tcpConn.ConnectAsync(\"example.com:123\");\r\n```\r\n\n\n### Alternative Designs\n\nJust make SocksHelper and HTTP tunnel helpers public?\n\n### Risks\n\nThose who use `Socket` directly won\u0027t get any benefit. Enhance NetworkStream with ability to create and connect a socket?\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eAntonius-S\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Net.Http`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-05-20T08:42:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Dg2RZ",
                                           "createdAt":  "2022-05-20T09:28:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MihaZupan",
                                           "body":  "For socks I understand wanting arbitrary connections. But what is your use case for doing things other than http over an http proxy?",
                                           "updatedAt":  "2022-05-20T09:28:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DhN7o",
                                           "createdAt":  "2022-05-20T11:16:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Antonius-S",
                                           "body":  "\u003e For socks I understand wanting arbitrary connections. But what is your use case for doing things other than http over an http proxy?\r\n\r\nHTTP tunnel (aka CONNECT) could be used for anything, just like Socks. I personally prefer it over usual HTTP proxy manner (sending request with full remote Uri to proxy host) because of more clear semantic (connect to proxy -\u003e negotiate with proxy -\u003e send request to remote) and unmodified request contents",
                                           "updatedAt":  "2022-05-20T11:16:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DhT3i",
                                           "createdAt":  "2022-05-20T11:47:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MihaZupan",
                                           "body":  "You already can use `CONNECT` tunnels for anything - you send a CONNECT http request with `SocketsHttpHandler` and use the `response.Content.ReadAsStreamAsync()` as the transport stream.\r\nBut is it actually commonly used for things other than HTTP to warrant exposing a more convenient API for it?\r\n\r\n\r\nFor the socks part I think it\u0027s a reasonable request. We\u0027ve briefly discussed it when we were adding socks support to the HTTP stack. See https://github.com/dotnet/runtime/pull/48883#issuecomment-790608780.\r\nWhat is your use case for `Socks` proxies?\r\n\r\nI don\u0027t think we should be adding anything to `TcpClient` (see #63162). But we could consider exposing some sort of helper (like what `SocksHelper` is).\r\nSocks also offers more capabilities, like UDP, but I haven\u0027t seen any demand for that.\r\n\r\ncc: @huoyaoyuan",
                                           "updatedAt":  "2022-05-20T11:47:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DheHm",
                                           "createdAt":  "2022-05-20T12:31:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Antonius-S",
                                           "body":  "\u003eBut is it actually commonly used for things other than HTTP to warrant exposing a more convenient API for it?\r\n\r\nWell, I consider HTTP CONNECT option as a Socks analog with similar or even more easy protocol: only one req-resp while Socks requires 2 of them; it\u0027s HTTP-like and text-based; server could be written in 10 minutes. And like Socks it could be used for any TCP connection - f.ex., FTP, POP/SMTP/IMAP, SSH and so on. For example, I wrote primitive TLS tunneler exposing HTTP CONNECT interface in Node that occupies only 200 SLOC. However, I don\u0027t insist - if there will be only Socks, I\u0027ll still be happy.\r\n\r\n\u003eYou already can use CONNECT tunnels for anything - you send a CONNECT http request with SocketsHttpHandler and use the response.Content.ReadAsStreamAsync() as the transport stream.\r\n\r\nYep that\u0027s quite usable option for now.\r\n\r\n\u003eWhat is your use case for Socks proxies?\r\n\r\nTraffic balancing and routing. Running inet-powered apps on multiple hosts through single gateway host, selective accessing blocked domains, tunneling via SSH and many more.\r\n\r\n\u003eSocks also offers more capabilities, like UDP, but I haven\u0027t seen any demand for that.\r\n\r\nMe too. I know RDP and RTSP streaming use UDP but I\u0027ve never needed to proxy them. However, HTTP/3 uses QUIC that is built upon UDP so it likely to have much more attention soon",
                                           "updatedAt":  "2022-05-20T12:52:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DiTsP",
                                           "createdAt":  "2022-05-20T15:57:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "Generally, SOCKS can be used for any TCP and UDP session.\r\nUDP case is more complicated since there is bind-receive process.\r\n\r\nAs #63162 discussed, the TcpClient API is out of date now. We may consider such API on a new designed Tcp API, or we can expose the methods in `SocksHelper` some way. It can be directly used with `NetworkStream`.",
                                           "updatedAt":  "2022-05-20T15:57:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DtYGA",
                                           "createdAt":  "2022-05-24T14:00:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\r\n\r\nNow proxies are supported for HTTP requests only but the world obviously is not limited to HTTP protocol. It would be nice to have proxy supported at the lower socket level so that any TCP connection could be proxied.\r\n\r\n### API Proposal\r\n\r\nCurrent SocksHelper.cs is based on a Stream so we\u0027ve to use NetworkStream but it requires already connected sockets. Thus proxy feature seems to be only pluggable into TcpClient.\r\n\r\n```csharp\r\nnamespace System.Net.Sockets;\r\n\r\nTcpClient\r\n{\r\n  public ProxyProps proxyProps;\r\n}\r\n```\r\n\r\nIf proxy is set, `Connect` methods should connect to the proxy host internally and then establish the proxy tunnel.\r\n\r\n### API Usage\r\n\r\n```csharp\r\ntcpConn.proxyProps.Uri = \"socks5://localhost:1080\";\r\nawait tcpConn.ConnectAsync(\"example.com:123\");\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\nJust make SocksHelper and HTTP tunnel helpers public?\r\n\r\n### Risks\r\n\r\nThose who use `Socket` directly won\u0027t get any benefit. Enhance NetworkStream with ability to create and connect a socket?\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eAntonius-S\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Net.Sockets`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-05-24T14:00:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5D37ki",
                                           "createdAt":  "2022-05-26T16:03:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Triage: As described above, we agree with value for SOCKS support (not via `TcpClient`, but via some helper API).\r\nNot pressing, we will see how many people need it -- if you need it, please uptove top post. Thanks!",
                                           "updatedAt":  "2022-05-26T16:04:57Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "[API Proposal]: Proxy (HTTP, HTTP tunnel, Socks) support at the Socket level",
        "labels":  [
                       "api-suggestion",
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/69699",
        "createdAt":  "2022-05-24T00:22:53Z",
        "number":  69699,
        "author":  "mintgum",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-05-26T16:07:37Z",
        "body":  "### Background and motivation\n\nThe .NET Sockets API includes Receive and Send functions with output parameter SocketError such that when a non-blocking socket returns with SocketError.WouldBlock (10035) it does **not** throw an exception.  This allows program flow control without using exceptions.  (There may be other error codes that also do not throw.)\r\n\r\nThe .NET Sockets API Accept function does **not** include overloads with the SocketError output parameter.  It would be beneficial for those using non-blocking sockets to include these overloads such that program flow control does not require the use of exception handling which is an undesirable programming practice.\r\n\r\nThis is also applicable to the Socket.Connect API overloads.\r\n\r\n\n\n### API Proposal\n\npublic System.Net.Sockets.Socket Accept (out SocketError errorCode);\r\n\n\n### API Usage\n\ntry\r\n{\r\n  SocketError errorCode;\r\n  listener.Accept(out errorCode);\r\n  if (errorCode == SocketError.WouldBlock)\r\n  {\r\n    // handle the would block condition\r\n  }\r\n}\r\ncatch (Exception ex)\r\n{\r\n// handle the Exception or SocketException\r\n}\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOQ9_GdQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5DqszB",
                                           "createdAt":  "2022-05-24T00:22:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nThe .NET Sockets API includes Receive and Send functions with output parameter SocketError such that when a non-blocking socket returns with SocketError.WouldBlock (10035) it does **not** throw an exception.  This allows program flow control without using exceptions.  (There may be other error codes that also do not throw.)\r\n\r\nThe .NET Sockets API Accept function does **not** include overloads with the SocketError output parameter.  It would be beneficial for those using non-blocking sockets to include these overloads such that program flow control does not require the use of exception handling which is an undesirable programming practice.\r\n\r\nThis is also applicable to the Socket.Connect API overloads.\r\n\r\n\n\n### API Proposal\n\npublic System.Net.Sockets.Socket Accept (out SocketError errorCode);\r\n\n\n### API Usage\n\ntry\r\n{\r\n  SocketError errorCode;\r\n  listener.Accept(out errorCode);\r\n  if (errorCode == SocketError.WouldBlock)\r\n  {\r\n    // handle the would block condition\r\n  }\r\n}\r\ncatch (Exception ex)\r\n{\r\n// handle the Exception or SocketException\r\n}\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003emintgum\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Net.Sockets`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-05-24T00:22:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5D38Z1",
                                           "createdAt":  "2022-05-26T16:07:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "Triage: we already have similar overloads in Receive and Send. Might be good to add for consistency but doesn\u0027t seem critical. Moving to Future.",
                                           "updatedAt":  "2022-05-26T16:07:26Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[API Proposal]: Socket.Accept with SocketError output parameter",
        "labels":  [
                       "api-suggestion",
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/70272",
        "createdAt":  "2022-06-06T02:07:16Z",
        "number":  70272,
        "author":  "VincentBu",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-06-14T16:39:37Z",
        "body":  "Run: [runtime-coreclr gcstress-extra 20220604.1](https://dev.azure.com/dnceng/public/_build/results?buildId=1807222\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=48103782\u0026resultId=108159\u0026paneView=debug)\r\n\r\nFailed test:\r\n```\r\ncoreclr Linux arm Checked gcstress0xc_jitminopts_heapverify1 @ (Ubuntu.1804.Arm32.Open)Ubuntu.1804.Armarch.Open@mcr.microsoft.com/dotnet-buildtools/prereqs:ubuntu-18.04-helix-arm32v7-bfcd90a-20200121150440\r\n\r\n- JIT/Methodical/eh/interactions/gcincatch_ro/gcincatch_ro.cmd\r\n\r\n```\r\n**Error message:**\r\n```\r\nTest Infrastructure Failure: System.AggregateException: One or more errors occurred. (Unknown socket error)\r\n---\u003e System.IO.IOException: Unknown socket error\r\n---\u003e System.Net.Sockets.SocketException (0xFFFDFFFE): Unknown socket error\r\nat System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.CreateException(SocketError error, Boolean forAsyncThrow) in //src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.Tasks.cs:line 1460\r\nat System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.ReceiveAsync(Socket socket, CancellationToken cancellationToken) in //src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.Tasks.cs:line 1047\r\nat System.Net.Sockets.Socket.ReceiveAsync(Memory1 buffer, SocketFlags socketFlags, Boolean fromNetworkStream, CancellationToken cancellationToken) in /_/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.Tasks.cs:line 327 at System.Net.Sockets.Socket.ReceiveAsync(Memory1 buffer, SocketFlags socketFlags, CancellationToken cancellationToken) in //src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.Tasks.cs:line 310\r\nat System.IO.Pipes.PipeStream.ReadAsyncCore(Memory1 destination, CancellationToken cancellationToken) in /_/src/libraries/System.IO.Pipes/src/System/IO/Pipes/PipeStream.Unix.cs:line 307 at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[TStateMachine](TStateMachine\u0026 stateMachine) at System.IO.Pipes.PipeStream.ReadAsyncCore(Memory1 destination, CancellationToken cancellationToken)\r\nat System.IO.Pipes.PipeStream.ReadAsync(Memory1 buffer, CancellationToken cancellationToken) in /_/src/libraries/System.IO.Pipes/src/System/IO/Pipes/PipeStream.Unix.cs:line 102 at System.IO.Stream.\u003cCopyToAsync\u003eg__Core|27_0(Stream source, Stream destination, Int32 bufferSize, CancellationToken cancellationToken) at System.Runtime.CompilerServices.AsyncTaskMethodBuilder1.AsyncStateMachineBox1.ExecutionContextCallback(Object s) at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state) at System.Runtime.CompilerServices.AsyncTaskMethodBuilder1.AsyncStateMachineBox1.MoveNext(Thread threadPoolThread) at System.Runtime.CompilerServices.AsyncTaskMethodBuilder1.AsyncStateMachineBox1.MoveNext() at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(IAsyncStateMachineBox box, Boolean allowInlining) at System.Threading.Tasks.Task.RunContinuations(Object continuationObject) at System.Threading.Tasks.Task.FinishContinuations() at System.Threading.Tasks.Task1.TrySetResult(TResult result)\r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder1.SetExistingTaskResult(Task1 task, TResult result)\r\nat System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder1.SetResult(TResult result) at System.IO.Pipes.PipeStream.ReadAsyncCore(Memory1 destination, CancellationToken cancellationToken) in //src/libraries/System.IO.Pipes/src/System/IO/Pipes/PipeStream.Unix.cs:line 313\r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder1.AsyncStateMachineBox1.ExecutionContextCallback(Object s)\r\nat System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state)\r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder1.AsyncStateMachineBox1.MoveNext(Thread threadPoolThread)\r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder1.AsyncStateMachineBox1.MoveNext()\r\nat System.Threading.ThreadPool.\u003c\u003ec.\u003c.cctor\u003eb__78_0(Object state)\r\nat System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.InvokeContinuation(Action`1 continuation, Object state, Boolean forceAsync, Boolean requiresExecutionContextFlow) in /_/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.Tasks.cs:line 1321\r\nat System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.OnCompleted(SocketAsyncEventArgs ) in //src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.Tasks.cs:line 989\r\n\r\n\r\nStack trace\r\n   at Xunit.Assert.True(Nullable`1 condition, String userMessage) in /_/src/xunit.assert/Asserts/BooleanAsserts.cs:line 132\r\n   at Xunit.Assert.True(Boolean condition, String userMessage) in /_/src/xunit.assert/Asserts/BooleanAsserts.cs:line 116\r\n   at TestLibrary.OutOfProcessTest.RunOutOfProcessTest(String basePath, String assemblyPath)\r\n   at Program.\u003cMain\u003e$(String[] args)\r\n```\r\nNo Kusto information.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHORF043g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5EXTje",
                                           "createdAt":  "2022-06-06T02:07:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nRun: [runtime-coreclr gcstress-extra 20220604.1](https://dev.azure.com/dnceng/public/_build/results?buildId=1807222\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=48103782\u0026resultId=108159\u0026paneView=debug)\r\n\r\nFailed test:\r\n```\r\ncoreclr Linux arm Checked gcstress0xc_jitminopts_heapverify1 @ (Ubuntu.1804.Arm32.Open)Ubuntu.1804.Armarch.Open@mcr.microsoft.com/dotnet-buildtools/prereqs:ubuntu-18.04-helix-arm32v7-bfcd90a-20200121150440\r\n\r\n- JIT/Methodical/eh/interactions/gcincatch_ro/gcincatch_ro.cmd\r\n\r\n```\r\n**Error message:**\r\n```\r\nTest Infrastructure Failure: System.AggregateException: One or more errors occurred. (Unknown socket error)\r\n---\u003e System.IO.IOException: Unknown socket error\r\n---\u003e System.Net.Sockets.SocketException (0xFFFDFFFE): Unknown socket error\r\nat System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.CreateException(SocketError error, Boolean forAsyncThrow) in //src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.Tasks.cs:line 1460\r\nat System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.ReceiveAsync(Socket socket, CancellationToken cancellationToken) in //src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.Tasks.cs:line 1047\r\nat System.Net.Sockets.Socket.ReceiveAsync(Memory1 buffer, SocketFlags socketFlags, Boolean fromNetworkStream, CancellationToken cancellationToken) in /_/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.Tasks.cs:line 327 at System.Net.Sockets.Socket.ReceiveAsync(Memory1 buffer, SocketFlags socketFlags, CancellationToken cancellationToken) in //src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.Tasks.cs:line 310\r\nat System.IO.Pipes.PipeStream.ReadAsyncCore(Memory1 destination, CancellationToken cancellationToken) in /_/src/libraries/System.IO.Pipes/src/System/IO/Pipes/PipeStream.Unix.cs:line 307 at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[TStateMachine](TStateMachine\u0026 stateMachine) at System.IO.Pipes.PipeStream.ReadAsyncCore(Memory1 destination, CancellationToken cancellationToken)\r\nat System.IO.Pipes.PipeStream.ReadAsync(Memory1 buffer, CancellationToken cancellationToken) in /_/src/libraries/System.IO.Pipes/src/System/IO/Pipes/PipeStream.Unix.cs:line 102 at System.IO.Stream.\u003cCopyToAsync\u003eg__Core|27_0(Stream source, Stream destination, Int32 bufferSize, CancellationToken cancellationToken) at System.Runtime.CompilerServices.AsyncTaskMethodBuilder1.AsyncStateMachineBox1.ExecutionContextCallback(Object s) at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state) at System.Runtime.CompilerServices.AsyncTaskMethodBuilder1.AsyncStateMachineBox1.MoveNext(Thread threadPoolThread) at System.Runtime.CompilerServices.AsyncTaskMethodBuilder1.AsyncStateMachineBox1.MoveNext() at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(IAsyncStateMachineBox box, Boolean allowInlining) at System.Threading.Tasks.Task.RunContinuations(Object continuationObject) at System.Threading.Tasks.Task.FinishContinuations() at System.Threading.Tasks.Task1.TrySetResult(TResult result)\r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder1.SetExistingTaskResult(Task1 task, TResult result)\r\nat System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder1.SetResult(TResult result) at System.IO.Pipes.PipeStream.ReadAsyncCore(Memory1 destination, CancellationToken cancellationToken) in //src/libraries/System.IO.Pipes/src/System/IO/Pipes/PipeStream.Unix.cs:line 313\r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder1.AsyncStateMachineBox1.ExecutionContextCallback(Object s)\r\nat System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state)\r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder1.AsyncStateMachineBox1.MoveNext(Thread threadPoolThread)\r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder1.AsyncStateMachineBox1.MoveNext()\r\nat System.Threading.ThreadPool.\u003c\u003ec.\u003c.cctor\u003eb__78_0(Object state)\r\nat System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.InvokeContinuation(Action`1 continuation, Object state, Boolean forceAsync, Boolean requiresExecutionContextFlow) in /_/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.Tasks.cs:line 1321\r\nat System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.OnCompleted(SocketAsyncEventArgs ) in //src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.Tasks.cs:line 989\r\n\r\n\r\nStack trace\r\n   at Xunit.Assert.True(Nullable`1 condition, String userMessage) in /_/src/xunit.assert/Asserts/BooleanAsserts.cs:line 132\r\n   at Xunit.Assert.True(Boolean condition, String userMessage) in /_/src/xunit.assert/Asserts/BooleanAsserts.cs:line 116\r\n   at TestLibrary.OutOfProcessTest.RunOutOfProcessTest(String basePath, String assemblyPath)\r\n   at Program.\u003cMain\u003e$(String[] args)\r\n```\r\nNo Kusto information.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eVincentBu\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Net.Sockets`, `os-linux`, `GCStress`, `blocking-clean-ci-optional`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-06-06T02:07:25Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Test failure JIT/Methodical/eh/interactions/gcincatch_ro/gcincatch_ro.cmd",
        "labels":  [
                       "area-System.Net.Sockets",
                       "os-linux",
                       "GCStress",
                       "blocking-clean-ci-optional"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/71207",
        "createdAt":  "2022-06-23T15:07:42Z",
        "number":  71207,
        "author":  "sakno",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-06-30T16:29:19Z",
        "body":  "### Background and motivation\r\n\r\nI would like to verify remote peer connecting to my application through Unix Domain Socket. Linux and FreeBSD allow to do that using `SO_PEERCRED` (or `LOCAL_PEERCRED` on FreeBSD) socket option via `getsockopt` native function. This function needs to be called on accepted socket by server side.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Net.Sockets;\r\n\r\npublic enum SocketOptionName\r\n{\r\n   PeerCredentials = 65535, // on Linux, SOPEERCRED is equal to 17, but historically the enum follows WinSock constants\r\n}\r\n```\r\n\r\nThe returned data can be represented as `ValueTuple\u003cuint, uint, uint\u003e` to match the original [ucred](https://github.com/torvalds/linux/blob/master/include/linux/socket.h#L173) structure.\r\n\r\nThe option must be requested on accepted socket with `SocketOptionLevel.Socket` value. On Windows, `GetSocketOption` returns **null**.\r\n\r\n### API Usage\r\n\r\n```csharp\r\nusing var listener = new Socket(AddressFamily.Unix, SocketType.Stream, ProtocolType.Unspecified);\r\nlistener.Bind(new UnixDomainSocketEndPoint(\"/path/to/endpoint.sock\"));\r\nlistener.Listen();\r\n\r\nusing var client = await listener.AcceptAsync(CancellationToken.None);\r\nvar credentials = ((uint pid, uint uid, uint gid))client.GetSocketOption(SocketOptionLevel.Socket, SocketOptionName.PeerCredentials);\r\n```\r\n\r\n### Alternative Designs\r\n\r\nWe can keep `SocketOptionName` enum untouched and introduce static method in `UnixDomainSocketEndPoint` class:\r\n```csharp\r\npublic sealed class UnixDomainSocketEndPoint\r\n{\r\n    [CLSCompliant(false)]\r\n    public static bool TryGetPeerCredentials(Socket socket, out uint processId, out uint userId, out uint groupId);\r\n}\r\n```\r\n\r\nOn unsupported platforms, the method returns **false**.\r\n\r\n### Risks\r\n\r\nI don\u0027t see any.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHORdJ77w==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5FaWFv",
                                           "createdAt":  "2022-06-23T15:09:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nI would like to verify remote peer connecting to my application through Unix Domain Socket. Linux and FreeBSD allow to do that using `SO_PEERCRED` (or `LOCAL_PEERCRED` on FreeBSD) socket option via `getsockopt` native function. This function needs to be called on accepted socket by server side.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Net.Sockets;\r\n\r\npublic enum SocketOptionName\r\n{\r\n   PeerCredentials = 65535, // in Linux, SOPEERCRED is equal to 17, but historically the enum follows WinSock constants\r\n}\r\n```\r\n\r\nThe returned data can be represented as `ValueTuple\u003cuint, uint, uint\u003e` to match the original [ucred](https://github.com/torvalds/linux/blob/master/include/linux/socket.h#L173) structure.\r\n\r\nThe option must be requested on accepted socket with `SocketOptionLevel.Socket` value. On Windows, `GetSocketOption` returns **null**.\n\n### API Usage\n\n```csharp\r\nusing var listener = new Socket(endPoint.AddressFamily, SocketType.Stream, ProtocolType.Unspecified);\r\nlistener.Bind(new UnixDomainSocketEndPoint(\"/path/to/endpoint.sock\"));\r\nlistener.Listen();\r\n\r\nusing var client = await listener.AcceptAsync(CancellationToken.None);\r\nvar credentials = ((uint pid, uint uid, uint gid))client.GetSocketOption(SocketOptionLevel.Socket, SocketOptionName.PeerCredentials);\r\n```\n\n### Alternative Designs\n\nWe can keep `SocketOptionName` enum untouched and introduce static method in `UnixDomainSocketEndPoint` class:\r\n```csharp\r\npublic sealed class UnixDomainSocketEndPoint\r\n{\r\n    [CLSCompliant(false)]\r\n    public static bool TryGetPeerCredentials(Socket socket, out uint processId, out uint userId, out uint groupId);\r\n}\r\n```\r\n\r\nOn unsupported platforms, the method returns **false**.\n\n### Risks\n\nI don\u0027t see any.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003esakno\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Net.Sockets`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-06-23T15:09:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5FrCmM",
                                           "createdAt":  "2022-06-28T16:00:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCkJ5KQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "karelz",
                                                                               "createdAt":  "2022-06-28T16:40:43Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "@sakno have you tried using [`GetRawSocketOption`](https://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.socket.getrawsocketoption?view=net-6.0) for your scenario?\r\n\r\nI\u0027m not sure if it\u0027s a good idea to implement a seemingly xplat socket option that is not supported by all platforms in reality.",
                                           "updatedAt":  "2022-06-28T16:00:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5FrPol",
                                           "createdAt":  "2022-06-28T16:40:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "This issue has been marked `needs-author-action` and may be missing some important information.",
                                           "updatedAt":  "2022-06-28T16:40:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5FrTaa",
                                           "createdAt":  "2022-06-28T16:50:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sakno",
                                           "body":  "@antonfirsov , I\u0027ll try! Thanks for advice. Anyway, I don\u0027t see any problem with some API which is not supported on all platforms. .NET has a lot of such API.",
                                           "updatedAt":  "2022-06-28T16:50:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Fr_Lk",
                                           "createdAt":  "2022-06-28T19:44:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCkO0Pg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "antonfirsov",
                                                                               "createdAt":  "2022-06-28T22:46:47Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "sakno",
                                           "body":  "`GetRawSocketOption` works as expected! On FreeBSD, `xucred` differs from Linux version: https://cgit.freebsd.org/src/tree/sys/sys/ucred.h\r\n\r\nFeel free to close this issue.",
                                           "updatedAt":  "2022-06-28T19:44:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5FsyKh",
                                           "createdAt":  "2022-06-28T22:56:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "Happy to hear it works for you!\r\n\r\nWe have a couple of similar feature requests (like #1476 or #36170), so maybe we can keep this one open too, so people who are interested can upvote/comment.\r\n\r\nOn the other hand, it\u0027s very unlikely that we will address these in the near future, so it would also make sense to close all of them to shorten our backlog.",
                                           "updatedAt":  "2022-06-30T16:29:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5F0nvv",
                                           "createdAt":  "2022-06-30T16:22:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Triage: Given we have a few similar issues open in Future, let\u0027s keep this one as well. We can decide on it later.",
                                           "updatedAt":  "2022-06-30T16:22:16Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "[API Proposal]: SO_PEERCRED support for Unix Domain Sockets",
        "labels":  [
                       "api-suggestion",
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/73536",
        "createdAt":  "2022-08-07T19:21:42Z",
        "number":  73536,
        "author":  "karelz",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-08-08T04:39:04Z",
        "body":  "Regression as of **8/4** - happens in each Rolling run and some PRs with 7, 14, or 21 failures (based on which legs ran):\r\n\r\nAffected tests:\r\n- `SendFileGetsCanceledByDispose`\r\n    - `System.Net.Sockets.Tests.SendFile_Apm`\r\n    - `System.Net.Sockets.Tests.SendFile_CancellableTask`\r\n    - `System.Net.Sockets.Tests.SendFile_Task`\r\n- `AcceptGetsCanceledByDispose`\r\n    - `System.Net.Sockets.Tests.AcceptApm`\r\n    - `System.Net.Sockets.Tests.AcceptCancellableTask`\r\n    - `System.Net.Sockets.Tests.AcceptEap`\r\n    - `System.Net.Sockets.Tests.AcceptTask`\r\n\r\nFailure:\r\n```\r\n   at System.Net.Sockets.Socket.SendPacketsAsync(SocketAsyncEventArgs e, CancellationToken cancellationToken)\r\n   at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.SendPacketsAsync(Socket socket, CancellationToken cancellationToken)\r\n   at System.Net.Sockets.Socket.SendFileAsync(String fileName, ReadOnlyMemory`1 preBuffer, ReadOnlyMemory`1 postBuffer, TransmitFileOptions flags, CancellationToken cancellationToken)\r\n   at System.Net.Sockets.Socket.SendFileAsync(String fileName, CancellationToken cancellationToken)\r\n   at System.Net.Sockets.Tests.SocketHelperCancellableTask.SendFileAsync(Socket s, String fileName)\r\n   at System.Net.Sockets.Tests.SocketTestHelperBase`1[[System.Net.Sockets.Tests.SocketHelperCancellableTask, System.Net.Sockets.Tests, Version=7.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51]].SendFileAsync(Socket s, String fileName)\r\n   at System.Net.Sockets.Tests.SendFile`1.\u003c\u003ec__DisplayClass10_1.\u003c\u003cSendFileGetsCanceledByDispose\u003eb__2\u003ed[[System.Net.Sockets.Tests.SocketHelperCancellableTask, System.Net.Sockets.Tests, Version=7.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51]].MoveNext()\r\n--- End of stack trace from previous location ---\r\n   at System.Net.Sockets.Tests.SendFile`1.\u003c\u003ec__DisplayClass10_0.\u003c\u003cSendFileGetsCanceledByDispose\u003eb__0\u003ed[[System.Net.Sockets.Tests.SocketHelperCancellableTask, System.Net.Sockets.Tests, Version=7.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51]].MoveNext()\r\n--- End of stack trace from previous location ---\r\n   at System.RetryHelper.ExecuteAsync(Func`1 test, Int32 maxAttempts, Func`2 backoffFunc, Predicate`1 retryWhen, String testName)\r\n   at System.Net.Sockets.Tests.SendFile`1.\u003cSendFileGetsCanceledByDispose\u003ed__10[[System.Net.Sockets.Tests.SocketHelperCancellableTask, System.Net.Sockets.Tests, Version=7.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51]].MoveNext()\r\n--- End of stack trace from previous location ---\r\n```\r\n\r\n```kusto\r\nlet failedTests = (testNameSubstring : string, methodName : string, messageSubstr: string, includePR : bool, includePassedOnRerun : bool) {\r\ncluster(\u0027engsrvprod.kusto.windows.net\u0027).database(\u0027engineeringdata\u0027).AzureDevOpsTests\r\n    | where TestName contains testNameSubstring\r\n    | where includePassedOnRerun or (Outcome == \u0027Failed\u0027)\r\n    | extend startOfTestName = indexof_regex(TestName, @\"[^.]+$\")\r\n    | extend Method = substring(TestName, startOfTestName)\r\n    | extend Type = substring(TestName, 0, startOfTestName - 1)\r\n    | project-away startOfTestName\r\n    | where (methodName == \u0027\u0027) or (Method == methodName)\r\n    | where Message contains messageSubstr\r\n    | distinct JobId, WorkItemId, Message, StackTrace, Method, Type, Arguments, Outcome\r\n    | join kind=inner (cluster(\u0027engsrvprod.kusto.windows.net\u0027).database(\u0027engineeringdata\u0027).Jobs\r\n        | where ((Branch == \u0027refs/heads/main\u0027) or (Branch == \u0027refs/heads/master\u0027) or (includePR and (Source startswith \"pr/\")))\r\n        | where Type startswith \"test/functional/cli/\"\r\n            and not(Properties contains \"runtime-staging\")\r\n        | where Branch \u003c\u003e \u0027refs/pull/73374/merge\u0027\r\n        | summarize arg_max(Finished, Properties, Type, Branch, Source, Started, QueueName) by JobId\r\n        | project-rename JobType = Type) on JobId\r\n    | extend PropertiesJson = parse_json(Properties)\r\n    | extend OS = replace_regex(tostring(PropertiesJson.operatingSystem), @\u0027\\((.*)\\).*|([^\\(].*)\u0027, @\u0027\\1\\2\u0027)\r\n    | extend Runtime = iif(PropertiesJson.runtimeFlavor == \"mono\", \"Mono\", iif(PropertiesJson.DefinitionName contains \"coreclr\", \"CoreCLR\", \"\"))\r\n    | extend TargetBranch = extractjson(\"$.[\u0027System.PullRequest.TargetBranch\u0027]\", Properties)\r\n    | extend Architecture = PropertiesJson.architecture\r\n    | extend Scenario = iif(isempty(PropertiesJson.scenario), \"--\", PropertiesJson.scenario)\r\n    //| extend DefinitionName = PropertiesJson.DefinitionName\r\n    | project-away PropertiesJson\r\n};\r\nfailedTests(\r\n    \u0027System.Net.Sockets.Tests\u0027, //testNameSubstring\r\n    \u0027\u0027, //methodName\r\n    \u0027NotSupportedException\u0027, //messageSubstr\r\n    true,  //includePR\r\n    true); //includePassedOnRerun\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOSCzWhQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5H-IcW",
                                           "createdAt":  "2022-08-07T19:21:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nRegression as of **8/4** - happens in each Rolling run and some PRs with 7, 14, or 21 failures (based on which legs ran):\r\n\r\nAffected tests:\r\n- `SendFileGetsCanceledByDispose`\r\n    - `System.Net.Sockets.Tests.SendFile_Apm`\r\n    - `System.Net.Sockets.Tests.SendFile_CancellableTask`\r\n    - `System.Net.Sockets.Tests.SendFile_Task`\r\n- `AcceptGetsCanceledByDispose`\r\n    - `System.Net.Sockets.Tests.AcceptApm`\r\n    - `System.Net.Sockets.Tests.AcceptCancellableTask`\r\n    - `System.Net.Sockets.Tests.AcceptEap`\r\n    - `System.Net.Sockets.Tests.AcceptTask`\r\n\r\nFailure:\r\n```\r\n   at System.Net.Sockets.Socket.SendPacketsAsync(SocketAsyncEventArgs e, CancellationToken cancellationToken)\r\n   at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.SendPacketsAsync(Socket socket, CancellationToken cancellationToken)\r\n   at System.Net.Sockets.Socket.SendFileAsync(String fileName, ReadOnlyMemory`1 preBuffer, ReadOnlyMemory`1 postBuffer, TransmitFileOptions flags, CancellationToken cancellationToken)\r\n   at System.Net.Sockets.Socket.SendFileAsync(String fileName, CancellationToken cancellationToken)\r\n   at System.Net.Sockets.Tests.SocketHelperCancellableTask.SendFileAsync(Socket s, String fileName)\r\n   at System.Net.Sockets.Tests.SocketTestHelperBase`1[[System.Net.Sockets.Tests.SocketHelperCancellableTask, System.Net.Sockets.Tests, Version=7.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51]].SendFileAsync(Socket s, String fileName)\r\n   at System.Net.Sockets.Tests.SendFile`1.\u003c\u003ec__DisplayClass10_1.\u003c\u003cSendFileGetsCanceledByDispose\u003eb__2\u003ed[[System.Net.Sockets.Tests.SocketHelperCancellableTask, System.Net.Sockets.Tests, Version=7.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51]].MoveNext()\r\n--- End of stack trace from previous location ---\r\n   at System.Net.Sockets.Tests.SendFile`1.\u003c\u003ec__DisplayClass10_0.\u003c\u003cSendFileGetsCanceledByDispose\u003eb__0\u003ed[[System.Net.Sockets.Tests.SocketHelperCancellableTask, System.Net.Sockets.Tests, Version=7.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51]].MoveNext()\r\n--- End of stack trace from previous location ---\r\n   at System.RetryHelper.ExecuteAsync(Func`1 test, Int32 maxAttempts, Func`2 backoffFunc, Predicate`1 retryWhen, String testName)\r\n   at System.Net.Sockets.Tests.SendFile`1.\u003cSendFileGetsCanceledByDispose\u003ed__10[[System.Net.Sockets.Tests.SocketHelperCancellableTask, System.Net.Sockets.Tests, Version=7.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51]].MoveNext()\r\n--- End of stack trace from previous location ---\r\n```\r\n\r\n```kusto\r\nlet failedTests = (testNameSubstring : string, methodName : string, messageSubstr: string, includePR : bool, includePassedOnRerun : bool) {\r\ncluster(\u0027engsrvprod.kusto.windows.net\u0027).database(\u0027engineeringdata\u0027).AzureDevOpsTests\r\n    | where TestName contains testNameSubstring\r\n    | where includePassedOnRerun or (Outcome == \u0027Failed\u0027)\r\n    | extend startOfTestName = indexof_regex(TestName, @\"[^.]+$\")\r\n    | extend Method = substring(TestName, startOfTestName)\r\n    | extend Type = substring(TestName, 0, startOfTestName - 1)\r\n    | project-away startOfTestName\r\n    | where (methodName == \u0027\u0027) or (Method == methodName)\r\n    | where Message contains messageSubstr\r\n    | distinct JobId, WorkItemId, Message, StackTrace, Method, Type, Arguments, Outcome\r\n    | join kind=inner (cluster(\u0027engsrvprod.kusto.windows.net\u0027).database(\u0027engineeringdata\u0027).Jobs\r\n        | where ((Branch == \u0027refs/heads/main\u0027) or (Branch == \u0027refs/heads/master\u0027) or (includePR and (Source startswith \"pr/\")))\r\n        | where Type startswith \"test/functional/cli/\"\r\n            and not(Properties contains \"runtime-staging\")\r\n        | where Branch \u003c\u003e \u0027refs/pull/73374/merge\u0027\r\n        | summarize arg_max(Finished, Properties, Type, Branch, Source, Started, QueueName) by JobId\r\n        | project-rename JobType = Type) on JobId\r\n    | extend PropertiesJson = parse_json(Properties)\r\n    | extend OS = replace_regex(tostring(PropertiesJson.operatingSystem), @\u0027\\((.*)\\).*|([^\\(].*)\u0027, @\u0027\\1\\2\u0027)\r\n    | extend Runtime = iif(PropertiesJson.runtimeFlavor == \"mono\", \"Mono\", iif(PropertiesJson.DefinitionName contains \"coreclr\", \"CoreCLR\", \"\"))\r\n    | extend TargetBranch = extractjson(\"$.[\u0027System.PullRequest.TargetBranch\u0027]\", Properties)\r\n    | extend Architecture = PropertiesJson.architecture\r\n    | extend Scenario = iif(isempty(PropertiesJson.scenario), \"--\", PropertiesJson.scenario)\r\n    //| extend DefinitionName = PropertiesJson.DefinitionName\r\n    | project-away PropertiesJson\r\n};\r\nfailedTests(\r\n    \u0027System.Net.Sockets.Tests\u0027, //testNameSubstring\r\n    \u0027\u0027, //methodName\r\n    \u0027NotSupportedException\u0027, //messageSubstr\r\n    true,  //includePR\r\n    true); //includePassedOnRerun\r\n```\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ekarelz\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Net.Sockets`, `blocking-clean-ci`, `os-ios`, `os-tvos`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-08-07T19:21:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5H-If8",
                                           "createdAt":  "2022-08-07T19:23:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "These tests are significantly impacting Rolling runs and CI overall. Please disable the tests ASAP.\r\n\r\nNote that similar errors first appeared in unmerged PRs: #73258 and #73374 which both seem related -- @directhex perhaps you might know what\u0027s going on?\r\n\r\ncc @steveisok ",
                                           "updatedAt":  "2022-08-07T19:24:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5H-I-K",
                                           "createdAt":  "2022-08-07T19:37:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCqK5IQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "karelz",
                                                                               "createdAt":  "2022-08-07T19:42:01Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "MihaZupan",
                                           "body":  "Potentially related: #72000\r\ncc: @tmds ",
                                           "updatedAt":  "2022-08-07T19:37:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5H-Kcp",
                                           "createdAt":  "2022-08-07T20:16:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "```\r\n   at System.Net.Sockets.Socket.SendPacketsAsync(SocketAsyncEventArgs e, CancellationToken cancellationToken)\r\n```\r\n\r\nI guess this is at:\r\n\r\nhttps://github.com/dotnet/runtime/blob/99297533df71e0d9e38ccf4a6bb6afd236a5f665/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs#L2981-L2984\r\n\r\nSo on these platforms the new cases added in https://github.com/dotnet/runtime/pull/72000 throw because we can\u0027t determine the `Socket` is connected at:\r\n\r\nhttps://github.com/dotnet/runtime/blob/99297533df71e0d9e38ccf4a6bb6afd236a5f665/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs#L177-L178\r\n\r\nI\u0027m not sure what happens in the `AcceptGetsCanceledByDispose` case (may be similar). A stacktrace would help.\r\n\r\n@antonfirsov can you take a look? I\u0027m still on leave for a week.",
                                           "updatedAt":  "2022-08-07T20:17:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5H-Lk5",
                                           "createdAt":  "2022-08-07T20:46:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "directhex",
                                           "body":  "There are plenty of indications that UNIX Domain Sockets are not actually supported on tvOS/iOS, and only work in the simulator by accident. The PRs you mention are part of the investigation in that regard. Waiting on some test results from Alex to determine whether the whole of UDS should be PNSE on one or both of those OSes.",
                                           "updatedAt":  "2022-08-08T15:41:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5IAuaO",
                                           "createdAt":  "2022-08-08T13:43:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "akoeplinger",
                                           "body":  "@directhex this is about normal sockets not Unix Domain Sockets.\r\n\r\nI think @tmds\u0027s investigation makes sense and this is due to new cases added in https://github.com/dotnet/runtime/pull/72000. @antonfirsov @wfurt would you mind taking a look?",
                                           "updatedAt":  "2022-08-08T13:43:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5IBc2_",
                                           "createdAt":  "2022-08-08T16:25:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "I think we should disable the tests on affected platforms. I don\u0027t know why the UDS would not be connected. The second link make sense only when `Socket` is created from handle and I don\u0027t think this is the case. ",
                                           "updatedAt":  "2022-08-08T16:25:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ICTR2",
                                           "createdAt":  "2022-08-08T20:12:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCqRQcw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "karelz",
                                                                               "createdAt":  "2022-08-09T12:23:33Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "directhex",
                                           "body":  "OK, I\u0027ve caught up with what\u0027s going on now. I\u0027ll ActiveIssue those with this bug.",
                                           "updatedAt":  "2022-08-08T20:12:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5IFKuG",
                                           "createdAt":  "2022-08-09T12:24:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "@directhex thanks! Looking forward for the tests to be disabled.\r\nPlease also triage this issue into appropriate milestone. Thanks!",
                                           "updatedAt":  "2022-08-09T12:24:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5IKjii",
                                           "createdAt":  "2022-08-10T14:08:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "simonrozsival",
                                           "body":  "The tests were disabled in #73374 ",
                                           "updatedAt":  "2022-08-10T14:08:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ILNaF",
                                           "createdAt":  "2022-08-10T15:48:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffschwMSFT",
                                           "body":  "With the test being disabled, I am removing the blocking-clean-ci label, thanks",
                                           "updatedAt":  "2022-08-10T15:48:34Z"
                                       }
                                   ],
                         "totalCount":  11
                     },
        "title":  "Sockets tests SendFileGetsCanceledByDispose and AcceptGetsCanceledByDispose - throw NotSupportedException - on AppleTV/iOS",
        "labels":  [
                       "area-System.Net.Sockets",
                       "disabled-test",
                       "runtime-mono",
                       "os-ios",
                       "os-tvos"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/73920",
        "createdAt":  "2022-08-14T18:25:35Z",
        "number":  73920,
        "author":  "okarpov",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-08-22T08:48:36Z",
        "body":  "### Description\r\n\r\nEnabling SO_REUSEPORT throws exception on Ubuntu Server 20.04\r\n\r\n```\r\nOperation not supported System.Net.Http.HttpRequestException: Operation not supported \r\n ---\u003e System.Net.Sockets.SocketException (95): Operation not supported\r\n```\r\n\r\n### Reproduction Steps\r\n\r\n```c#\r\n// Default socket creation logic\r\nSocket socket = new Socket(SocketType.Stream, ProtocolType.Tcp);\r\nsocket.NoDelay = true;\r\n\r\n// Enable SO_REUSE_UNICASTPORT:\r\nsocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseUnicastPort, 1);\r\n\r\ntry\r\n{\r\n    await socket.ConnectAsync(context.DnsEndPoint, cancellationToken).ConfigureAwait(false);\r\n    return new NetworkStream(socket, ownsSocket: true);\r\n}\r\ncatch (Exception ex)\r\n{\r\n    if (Log.IsEnabled)\r\n    {\r\n        Log._Log(this, ex.Message, ex);\r\n    }\r\n    socket.Dispose();\r\n    throw;\r\n}\r\n```\r\n\r\n### Expected behavior\r\n\r\nshould reuse ports as per SO_REUSEPORT feature\r\n\r\n### Actual behavior\r\n\r\n```\r\nOperation not supported System.Net.Http.HttpRequestException: Operation not supported \r\n ---\u003e System.Net.Sockets.SocketException (95): Operation not supported\r\n```\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\nUbuntu server 20.04\r\n.Net Core 6\r\n\r\n### Other information\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOSNb1ag==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5IYq-8",
                                           "createdAt":  "2022-08-14T18:25:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\nEnabling SO_REUSEPORT throws exception on Ubuntu Server 20.04\r\n\r\nOperation not supported System.Net.Http.HttpRequestException: Operation not supported \r\n ---\u003e System.Net.Sockets.SocketException (95): Operation not supported\n\n### Reproduction Steps\n\n```\r\n                   // Default socket creation logic\r\n                    Socket socket = new Socket(SocketType.Stream, ProtocolType.Tcp);\r\n                    socket.NoDelay = true;\r\n\r\n                    // Enable SO_REUSE_UNICASTPORT:\r\n                    socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseUnicastPort, 1);\r\n\r\n                    try\r\n                    {\r\n                        await socket.ConnectAsync(context.DnsEndPoint, cancellationToken).ConfigureAwait(false);\r\n                        return new NetworkStream(socket, ownsSocket: true);\r\n                    }\r\n                    catch (Exception ex)\r\n                    {\r\n                        if (Log.IsEnabled)\r\n                        {\r\n                            Log._Log(this, ex.Message, ex);\r\n                        }\r\n                        socket.Dispose();\r\n                        throw;\r\n                    }\r\n```\n\n### Expected behavior\n\nshould reuse ports as per SO_REUSEPORT feature\n\n### Actual behavior\n\nOperation not supported System.Net.Http.HttpRequestException: Operation not supported \r\n ---\u003e System.Net.Sockets.SocketException (95): Operation not supported\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\nUbuntu server 20.04\r\n.Net Core 6\n\n### Other information\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eokarpov\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Net`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-08-14T18:25:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5IYwUR",
                                           "createdAt":  "2022-08-14T21:07:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "it seems like that API is Windows specific. cc: @tmds @antonfirsov \r\nYou can probably use `SocketOptionName.ReuseAddress` on Linux.\r\nIt will set both...\r\n\r\n```\r\nstrace -e network -f  /tmp/socket/bin/Debug/net6.0/linux-x64/publish/socket\r\n....\r\n[pid 46509] setsockopt(40, SOL_IPV6, IPV6_V6ONLY, [1], 4) = 0\r\n[pid 46509] setsockopt(40, SOL_IPV6, IPV6_V6ONLY, [0], 4) = 0\r\n[pid 46509] setsockopt(40, SOL_TCP, TCP_NODELAY, [1], 4) = 0\r\n[pid 46509] setsockopt(40, SOL_SOCKET, SO_REUSEPORT, [1], 4) = 0\r\n[pid 46509] setsockopt(40, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0\r\n```",
                                           "updatedAt":  "2022-08-14T21:07:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5IZcCR",
                                           "createdAt":  "2022-08-15T05:18:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "okarpov",
                                           "body":  "\u003e it seems like that API is Windows specific. cc: @tmds @antonfirsov You can probably use `SocketOptionName.ReuseAddress` on Linux. It will set both...\r\n\u003e \r\n\u003e ```\r\n\u003e strace -e network -f  /tmp/socket/bin/Debug/net6.0/linux-x64/publish/socket\r\n\u003e ....\r\n\u003e [pid 46509] setsockopt(40, SOL_IPV6, IPV6_V6ONLY, [1], 4) = 0\r\n\u003e [pid 46509] setsockopt(40, SOL_IPV6, IPV6_V6ONLY, [0], 4) = 0\r\n\u003e [pid 46509] setsockopt(40, SOL_TCP, TCP_NODELAY, [1], 4) = 0\r\n\u003e [pid 46509] setsockopt(40, SOL_SOCKET, SO_REUSEPORT, [1], 4) = 0\r\n\u003e [pid 46509] setsockopt(40, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0\r\n\u003e ```\r\n\r\nThx, I will check it",
                                           "updatedAt":  "2022-08-15T05:18:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5IaUuV",
                                           "createdAt":  "2022-08-15T10:21:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "okarpov",
                                           "body":  "\u003e it seems like that API is Windows specific. cc: @tmds @antonfirsov You can probably use `SocketOptionName.ReuseAddress` on Linux. It will set both...\r\n\u003e \r\n\u003e ```\r\n\u003e strace -e network -f  /tmp/socket/bin/Debug/net6.0/linux-x64/publish/socket\r\n\u003e ....\r\n\u003e [pid 46509] setsockopt(40, SOL_IPV6, IPV6_V6ONLY, [1], 4) = 0\r\n\u003e [pid 46509] setsockopt(40, SOL_IPV6, IPV6_V6ONLY, [0], 4) = 0\r\n\u003e [pid 46509] setsockopt(40, SOL_TCP, TCP_NODELAY, [1], 4) = 0\r\n\u003e [pid 46509] setsockopt(40, SOL_SOCKET, SO_REUSEPORT, [1], 4) = 0\r\n\u003e [pid 46509] setsockopt(40, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0\r\n\u003e ```\r\n\r\ndoes not work :(",
                                           "updatedAt":  "2022-08-15T10:21:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5IaWyX",
                                           "createdAt":  "2022-08-15T10:32:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "okarpov",
                                           "body":  "```\r\nSystem.AggregateException: One or more errors occurred. (Sockets on this platform are invalid for use after a failed connection attempt. )\r\n ---\u003e System.Net.Http.HttpRequestException: Sockets on this platform are invalid for use after a failed connection attempt. \r\n ---\u003e System.PlatformNotSupportedException: Sockets on this platform are invalid for use after a failed connection attempt.\r\n   at System.Net.Sockets.Socket.ThrowMultiConnectNotSupported()\r\n   at System.Net.Sockets.Socket.ConnectAsync(SocketAsyncEventArgs e, Boolean userSocket, Boolean saeaCancelable)\r\n   at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.ConnectAsync(Socket socket)\r\n   at System.Net.Sockets.Socket.ConnectAsync(EndPoint remoteEP, CancellationToken cancellationToken)\r\n```\r\n```\r\n\r\n                    // Default socket creation logic\r\n                    Socket socket = new Socket(SocketType.Stream, ProtocolType.Tcp);\r\n                    socket.NoDelay = true;\r\n\r\n                    // Enable SO_REUSE_UNICASTPORT:\r\n                    //socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseUnicastPort, 1);\r\n                    socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, 1);\r\n\r\n                    try\r\n                    {\r\n                        await socket.ConnectAsync(context.DnsEndPoint, cancellationToken).ConfigureAwait(false);\r\n                        return new NetworkStream(socket, ownsSocket: true);\r\n                    }\r\n                    catch (Exception ex)\r\n                    {\r\n                        if (Log.IsEnabled)\r\n                        {\r\n                            Log._Log(this, ex.Message, ex);\r\n                        }\r\n                        socket.Dispose();\r\n                        throw;\r\n                    }\r\n```",
                                           "updatedAt":  "2022-08-15T10:32:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Ib1EV",
                                           "createdAt":  "2022-08-15T16:08:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "This is not what I see @okarpov. Can you pose complete stand alone repro? (instead of just fragment)",
                                           "updatedAt":  "2022-08-15T16:08:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Ib1S6",
                                           "createdAt":  "2022-08-15T16:08:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\n\r\nEnabling SO_REUSEPORT throws exception on Ubuntu Server 20.04\r\n\r\n```\r\nOperation not supported System.Net.Http.HttpRequestException: Operation not supported \r\n ---\u003e System.Net.Sockets.SocketException (95): Operation not supported\r\n```\r\n\r\n### Reproduction Steps\r\n\r\n```c#\r\n// Default socket creation logic\r\nSocket socket = new Socket(SocketType.Stream, ProtocolType.Tcp);\r\nsocket.NoDelay = true;\r\n\r\n// Enable SO_REUSE_UNICASTPORT:\r\nsocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseUnicastPort, 1);\r\n\r\ntry\r\n{\r\n    await socket.ConnectAsync(context.DnsEndPoint, cancellationToken).ConfigureAwait(false);\r\n    return new NetworkStream(socket, ownsSocket: true);\r\n}\r\ncatch (Exception ex)\r\n{\r\n    if (Log.IsEnabled)\r\n    {\r\n        Log._Log(this, ex.Message, ex);\r\n    }\r\n    socket.Dispose();\r\n    throw;\r\n}\r\n```\r\n\r\n### Expected behavior\r\n\r\nshould reuse ports as per SO_REUSEPORT feature\r\n\r\n### Actual behavior\r\n\r\n```\r\nOperation not supported System.Net.Http.HttpRequestException: Operation not supported \r\n ---\u003e System.Net.Sockets.SocketException (95): Operation not supported\r\n```\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\nUbuntu server 20.04\r\n.Net Core 6\r\n\r\n### Other information\r\n\r\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eokarpov\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Net.Sockets`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-08-15T16:08:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Ib1dL",
                                           "createdAt":  "2022-08-15T16:09:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "This issue has been marked `needs-author-action` and may be missing some important information.",
                                           "updatedAt":  "2022-08-15T16:09:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5IdHuj",
                                           "createdAt":  "2022-08-15T18:36:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "okarpov",
                                           "body":  "Welcome to Ubuntu 20.04 LTS (GNU/Linux 5.4.0-29-generic x86_64)\r\n\r\n * Documentation:  https://help.ubuntu.com\r\n * Management:     https://landscape.canonical.com\r\n * Support:        https://ubuntu.com/advantage\r\n\r\n  System information as of Mon 15 Aug 2022 08:11:09 PM CEST\r\n\r\n  System load:  0.17               Processes:             118\r\n  Usage of /:   4.7% of 137.27GB   Users logged in:       1\r\n  Memory usage: 3%                 IPv4 address for eth0: xx.xx.xx.xx\r\n  Swap usage:   0%\r\n\r\n * Super-optimized for small spaces - read how we shrank the memory\r\n   footprint of MicroK8s to make it the smallest full K8s around.\r\n\r\n   https://ubuntu.com/blog/microk8s-memory-optimisation\r\n\r\n65 updates can be applied immediately.\r\n25 of these updates are standard security updates.\r\nTo see these additional updates run: apt list --upgradable\r\n\r\nNew release \u002722.04.1 LTS\u0027 available.\r\nRun \u0027do-release-upgrade\u0027 to upgrade to it.",
                                           "updatedAt":  "2022-08-15T18:36:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5IdH7N",
                                           "createdAt":  "2022-08-15T18:36:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "okarpov",
                                           "body":  "\u003e This is not what I see @okarpov. Can you pose complete stand alone repro? (instead of just fragment)\r\n\r\nwill create repro",
                                           "updatedAt":  "2022-08-15T18:36:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5IdM6d",
                                           "createdAt":  "2022-08-15T18:59:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "okarpov",
                                           "body":  "```\r\n        static void Main(string[] args)\r\n        {\r\n            //repro\r\n\r\n            var coo = new CookieContainer();\r\n            var socketsHandler = new System.Net.Http.HttpClientHandler()\r\n            {\r\n                AutomaticDecompression = System.Net.DecompressionMethods.GZip | System.Net.DecompressionMethods.Deflate | System.Net.DecompressionMethods.Brotli,\r\n                AllowAutoRedirect = false,\r\n                SslProtocols = System.Security.Authentication.SslProtocols.Tls11 | System.Security.Authentication.SslProtocols.Tls | System.Security.Authentication.SslProtocols.Tls12 | System.Security.Authentication.SslProtocols.Tls13,\r\n                ServerCertificateCustomValidationCallback = (s, e, a, b) =\u003e\r\n                {\r\n                    return true;\r\n                },\r\n                CookieContainer = coo,\r\n                UseCookies = true,\r\n                MaxAutomaticRedirections = 50,\r\n                MaxConnectionsPerServer = int.MaxValue,\r\n                PreAuthenticate = false,\r\n            };\r\n\r\n            var field = typeof(System.Net.Http.HttpClientHandler).GetField(\"_underlyingHandler\", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);\r\n            var sockHandler = (System.Net.Http.SocketsHttpHandler)field?.GetValue(socketsHandler);\r\n\r\n\r\n            sockHandler.ConnectCallback = async (context, cancellationToken) =\u003e\r\n            {\r\n                // Default socket creation logic\r\n                Socket socket = new Socket(SocketType.Stream, ProtocolType.Tcp);\r\n                socket.NoDelay = true;\r\n\r\n                // Enable SO_REUSE_UNICASTPORT:\r\n                //socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseUnicastPort, 1);\r\n                socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, 1);\r\n\r\n                try\r\n                {\r\n                    await socket.ConnectAsync(context.DnsEndPoint, cancellationToken).ConfigureAwait(false);\r\n                    return new NetworkStream(socket, ownsSocket: true);\r\n                }\r\n                catch (Exception ex)\r\n                {\r\n                    Console.WriteLine(ex);\r\n                    socket.Dispose();\r\n                    throw;\r\n                }\r\n            };\r\n\r\n            sockHandler.EnableMultipleHttp2Connections = true;\r\n            sockHandler.UseCookies = true;\r\n            sockHandler.CookieContainer = coo;\r\n\r\n\r\n            System.Net.Http.HttpClient wr = new System.Net.Http.HttpClient(socketsHandler, true);\r\n\r\n            wr.DefaultRequestHeaders.Clear();\r\n            wr.DefaultRequestHeaders.Accept.TryParseAdd(\"*/*\");\r\n            wr.DefaultRequestHeaders.AcceptEncoding.TryParseAdd(\"gzip, deflate, br\");\r\n            wr.DefaultRequestHeaders.AcceptLanguage.TryParseAdd(\"en-US,en;q=0.9\");\r\n            wr.DefaultRequestHeaders.ConnectionClose = false;\r\n            wr.DefaultRequestHeaders.Connection.Add(\"keep-alive\");\r\n            wr.DefaultRequestHeaders.CacheControl = new System.Net.Http.Headers.CacheControlHeaderValue() { NoCache = true };\r\n            wr.DefaultRequestHeaders.Pragma.TryParseAdd(\"no-cache\");\r\n\r\n            wr.DefaultRequestHeaders.Add(\"Upgrade-Insecure-Requests\", \"1\");\r\n\r\n            wr.DefaultVersionPolicy = System.Net.Http.HttpVersionPolicy.RequestVersionOrHigher;\r\n            wr.Timeout = TimeSpan.FromSeconds(10);\r\n\r\n            System.Net.Http.HttpRequestMessage req = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, \"https://www.google.com\")\r\n            {\r\n                Version = System.Net.HttpVersion.Version30,\r\n                VersionPolicy = System.Net.Http.HttpVersionPolicy.RequestVersionOrLower\r\n            };\r\n\r\n            req.Headers.ConnectionClose = false;\r\n            req.Headers.UserAgent.TryParseAdd(\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36\");\r\n            req.Content = new System.Net.Http.StringContent(\"\", null, null);\r\n            req.Content.Headers.ContentType = null;\r\n\r\n            try\r\n            {\r\n                var r = wr.SendAsync(req, System.Net.Http.HttpCompletionOption.ResponseContentRead).Result;\r\n                string response = r.Content.ReadAsStringAsync().Result;\r\n\r\n                Console.WriteLine(response);\r\n            }\r\n            catch(Exception ex)\r\n            {\r\n                Console.WriteLine(ex);\r\n            }\r\n\r\n            return;\r\n}\r\n```\r\n\r\nLinux:\r\n\r\n```\r\nSystem.PlatformNotSupportedException: Sockets on this platform are invalid for use after a failed connection attempt.\r\n   at System.Net.Sockets.Socket.ThrowMultiConnectNotSupported()\r\n   at System.Net.Sockets.Socket.ConnectAsync(SocketAsyncEventArgs e, Boolean userSocket, Boolean saeaCancelable)\r\n   at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.ConnectAsync(Socket socket)\r\n   at System.Net.Sockets.Socket.ConnectAsync(EndPoint remoteEP, CancellationToken cancellationToken)\r\n   at ConsoleApp1.Program.\u003c\u003ec.\u003c\u003cMain\u003eb__0_0\u003ed.MoveNext() in \\ConsoleApp1\\Program.cs:line 53\r\nSystem.AggregateException: One or more errors occurred. (Sockets on this platform are invalid for use after a failed connection attempt. (www.google.com:443))\r\n ---\u003e System.Net.Http.HttpRequestException: Sockets on this platform are invalid for use after a failed connection attempt. (www.google.com:443)\r\n ---\u003e System.PlatformNotSupportedException: Sockets on this platform are invalid for use after a failed connection attempt.\r\n   at System.Net.Sockets.Socket.ThrowMultiConnectNotSupported()\r\n   at System.Net.Sockets.Socket.ConnectAsync(SocketAsyncEventArgs e, Boolean userSocket, Boolean saeaCancelable)\r\n   at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.ConnectAsync(Socket socket)\r\n   at System.Net.Sockets.Socket.ConnectAsync(EndPoint remoteEP, CancellationToken cancellationToken)\r\n   at ConsoleApp1.Program.\u003c\u003ec.\u003c\u003cMain\u003eb__0_0\u003ed.MoveNext() in \\ConsoleApp1\\Program.cs:line 53\r\n--- End of stack trace from previous location ---\r\n   at System.Net.Http.HttpConnectionPool.ConnectToTcpHostAsync(String host, Int32 port, HttpRequestMessage initialRequest, Boolean async, CancellationToken cancellationToken)\r\n   --- End of inner exception stack trace ---\r\n   at System.Net.Http.HttpConnectionPool.ConnectToTcpHostAsync(String host, Int32 port, HttpRequestMessage initialRequest, Boolean async, CancellationToken cancellationToken)\r\n   at System.Net.Http.HttpConnectionPool.ConnectAsync(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken)\r\n   at System.Net.Http.HttpConnectionPool.AddHttp2ConnectionAsync(HttpRequestMessage request)\r\n   at System.Threading.Tasks.TaskCompletionSourceWithCancellation`1.WaitWithCancellationAsync(CancellationToken cancellationToken)\r\n   at System.Net.Http.HttpConnectionPool.GetHttp2ConnectionAsync(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken)\r\n   at System.Net.Http.HttpConnectionPool.SendWithVersionDetectionAndRetryAsync(HttpRequestMessage request, Boolean async, Boolean doRequestAuth, CancellationToken cancellationToken)\r\n   at System.Net.Http.DecompressionHandler.SendAsync(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken)\r\n   at System.Net.Http.HttpClient.\u003cSendAsync\u003eg__Core|83_0(HttpRequestMessage request, HttpCompletionOption completionOption, CancellationTokenSource cts, Boolean disposeCts, CancellationTokenSource pendingRequestsCts, CancellationToken originalCancellationToken)\r\n   --- End of inner exception stack trace ---\r\n   at System.Threading.Tasks.Task.ThrowIfExceptional(Boolean includeTaskCanceledExceptions)\r\n   at System.Threading.Tasks.Task`1.GetResultCore(Boolean waitCompletionNotification)\r\n   at System.Threading.Tasks.Task`1.get_Result()\r\n   at ConsoleApp1.Program.Main(String[] args) in \\ConsoleApp1\\Program.cs:line 98\r\n```\r\n\r\n\r\nWindows:\r\n- works as expected",
                                           "updatedAt":  "2022-08-15T18:59:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5IdjJw",
                                           "createdAt":  "2022-08-15T19:50:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "It seems like the socket is failing to connect - and not failing on socket options as originally reported. I think you should try it without any HTTP - just getting to socket nailed down first. And the code above is still just a fragment referencing `wr`. (with that I cannot use it ASIS without further modifications) ",
                                           "updatedAt":  "2022-08-15T19:50:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5IdqZ4",
                                           "createdAt":  "2022-08-15T20:06:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "okarpov",
                                           "body":  "its complete console main method - why you can not use it?\r\n\r\nit works on Windows 11 with no errors and returns google page html",
                                           "updatedAt":  "2022-08-15T20:06:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5IdsSo",
                                           "createdAt":  "2022-08-15T20:14:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "okarpov",
                                           "body":  "changing the socket ConnectCallback to this - works on linux and windows with no errors\r\n\r\n```\r\n        sockHandler.ConnectCallback = async (context, cancellationToken) =\u003e\r\n        {\r\n                   var entry = await Dns.GetHostEntryAsync(context.DnsEndPoint.Host, AddressFamily.InterNetwork, cancellationToken);\r\n                    var s = new System.Net.Sockets.Socket(System.Net.Sockets.AddressFamily.InterNetwork, System.Net.Sockets.SocketType.Stream, System.Net.Sockets.ProtocolType.Tcp);\r\n                    s.Bind(new System.Net.IPEndPoint(System.Net.IPAddress.Parse(this.ipaddress), 0));\r\n\r\n                    s.NoDelay = true;\r\n\r\n                    await s.ConnectAsync(context.DnsEndPoint, cancellationToken).ConfigureAwait(false);\r\n                    return new System.Net.Sockets.NetworkStream(s, ownsSocket: true);\r\n        }\r\n```",
                                           "updatedAt":  "2022-08-15T20:14:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5IduE5",
                                           "createdAt":  "2022-08-15T20:22:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "okarpov",
                                           "body":  "commenting out that two lines returns google html page on linux as well\r\n\r\n```\r\n                 // Enable SO_REUSE_UNICASTPORT:\r\n                //socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseUnicastPort, 1);\r\n                //socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, 1);\r\n\r\n```",
                                           "updatedAt":  "2022-08-15T20:22:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Iduli",
                                           "createdAt":  "2022-08-15T20:24:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "okarpov",
                                           "body":  " dotnet --info\r\n\r\nHost (useful for support):\r\n  Version: 6.0.6\r\n  Commit:  7cca709db2\r\n\r\n.NET SDKs installed:\r\n  No SDKs were found.\r\n\r\n.NET runtimes installed:\r\n  Microsoft.AspNetCore.App 6.0.6 [/usr/share/dotnet/shared/Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 6.0.6 [/usr/share/dotnet/shared/Microsoft.NETCore.App]\r\n\r\nTo install additional .NET runtimes or SDKs:\r\n  https://aka.ms/dotnet-download",
                                           "updatedAt":  "2022-08-15T20:24:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Idwc7",
                                           "createdAt":  "2022-08-15T20:31:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "okarpov",
                                           "body":  "have just found this: https://github.com/dotnet/runtime/issues/24917",
                                           "updatedAt":  "2022-08-15T20:31:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5IfVBw",
                                           "createdAt":  "2022-08-16T05:40:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "```\r\nSystem.PlatformNotSupportedException: Sockets on this platform are invalid for use after a failed connection attempt.\r\n   at System.Net.Sockets.Socket.ThrowMultiConnectNotSupported()\r\n```\r\nis because you\u0027re calling `Socket.ConnectAsync` with a `DnsEndPoint`.\r\n\r\nYou need to resolve the hostname, and try to connect to each `IPEndPoint` creating a new `Socket` after each failed attempt (cfr https://github.com/dotnet/runtime/issues/73920#issuecomment-1215743144).",
                                           "updatedAt":  "2022-08-16T05:40:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Ifb5p",
                                           "createdAt":  "2022-08-16T06:27:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "okarpov",
                                           "body":  "i took this example from here: https://github.com/dotnet/runtime/issues/48219\r\nwhere the similar issue (Reuse Port) seems was resolved\r\n\r\nalso it works on windows, so this is not obvious why it does not work in linux",
                                           "updatedAt":  "2022-08-16T06:28:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Ifcot",
                                           "createdAt":  "2022-08-16T06:31:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "okarpov",
                                           "body":  "main issue is that i\u0027m trying to achieve is making our application to Reuse Port to avoid port exhausting on sending a lot of outbound connections.\r\n\r\nso, could you, please, provide any affordable solution?",
                                           "updatedAt":  "2022-08-16T06:32:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Ih7BN",
                                           "createdAt":  "2022-08-16T16:11:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "Triage: not critical for 7.0, moving to Future",
                                           "updatedAt":  "2022-08-16T16:11:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5I1vVq",
                                           "createdAt":  "2022-08-22T08:47:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "okarpov",
                                           "body":  "setting this \r\n`sysctl net.ipv4.tcp_tw_reuse=1`\r\nseems resolve the issue partially and now i can set\r\n`s.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, 1);`\r\n\r\nbut this still throws exception\r\n`s.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseUnicastPort, 1);`",
                                           "updatedAt":  "2022-08-22T08:48:36Z"
                                       }
                                   ],
                         "totalCount":  22
                     },
        "title":  "Ubuntu Server 20.04 SO_REUSEPORT throws System.Net.Sockets.SocketException (95): Operation not supported",
        "labels":  [
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/78143",
        "createdAt":  "2022-11-10T04:09:34Z",
        "number":  78143,
        "author":  "murshex",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCrc33w==",
                          "nodes":  [
                                        {
                                            "content":  "EYES",
                                            "user":  "samsosa",
                                            "createdAt":  "2022-11-14T21:31:06Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2023-02-02T17:02:38Z",
        "body":  "I think this would help increase performance of many projects including Kestrel.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOTjXmSg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5OERXH",
                                           "createdAt":  "2022-11-10T04:09:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nI think this would help increase performance of many projects including Kestrel.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ec0nd3v\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Net.Sockets`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-11-10T04:09:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5OJ9t0",
                                           "createdAt":  "2022-11-11T05:05:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "murshex",
                                           "body":  "cc: @davidfowl @stephentoub",
                                           "updatedAt":  "2022-11-11T05:05:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5OLTqS",
                                           "createdAt":  "2022-11-11T11:35:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "https://github.com/dotnet/runtime/issues/14101",
                                           "updatedAt":  "2022-11-11T11:35:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5OLYMH",
                                           "createdAt":  "2022-11-11T11:55:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "murshex",
                                           "body":  "\u003e #14101\r\n\r\nI saw this, but it’s closed and marked as resolved.",
                                           "updatedAt":  "2022-11-11T11:55:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5OLtU4",
                                           "createdAt":  "2022-11-11T13:23:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "\u003e of many projects including Kestrel.\r\n\r\nKestrel has a transport abstraction, they don\u0027t have to rely on `System.Net.Sockets` for improvements. There was a community attempt to implement RIO transport in https://github.com/aspnet/KestrelHttpServer/pull/1630. For some reason [they are not interested](https://github.com/dotnet/aspnetcore/issues/4780#issuecomment-808920023) going RIO. /cc @davidfowl @halter73 \r\n\r\n@c0nd3v: are there particular use cases important to you where you think this would bring a significant improvement?",
                                           "updatedAt":  "2022-11-11T13:25:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ONeZK",
                                           "createdAt":  "2022-11-11T20:10:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "The issue was auto-closed and all the discussions are very old. To me the difficulty here is that this is really Windows specific and would not work anywhere else. There was some effort to see if we can come up with something that would also abstract and cover uring on Linux.  ",
                                           "updatedAt":  "2022-11-11T20:10:26Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "Implement Registered I/O for sockets on Windows",
        "labels":  [
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/78993",
        "createdAt":  "2022-11-29T20:06:24Z",
        "number":  78993,
        "author":  "antonfirsov",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-02-02T17:08:52Z",
        "body":  "### Background and motivation\r\n\r\nSerializing general `EndPoint` instances into buffers/structures to be used with low-level interop code requires instantiating a `SocketAddress` and copying its bytes to a separate buffer manually. This leads to 2 extra allocations: `SocketAddress` and the underlying buffer. This is one of the main reasons our SendTo/ReceiveFrom methods allocate a lot, see discussion in #30797.\r\n\r\nWe can workaround this by special-casing `IPEndPoint` (#78591), but that would introduce complexity to the Socket codebase if implemented across all sync and async variants and doesn\u0027t work with arbitrary endpoints. We can also expose `SocketAddress.Buffer` (#78757), but IMO it\u0027s a partial solution, since it doesn\u0027t help with the allocations.\r\n\r\nInstead of working around our own inefficient abstractions, we should consider adding an alternative modern and efficient API to serialize arbitrary `EndPoint`-s into user-provided buffers. This would help simplifying and improving socket code while keeping it compatible with arbitrary endpoints.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Net;\r\n\r\npublic abstract class EndPoint\r\n{\r\n    // Returns true if the EndPoint is serializable into a linear native sockaddr_xy structure\r\n    public virtual bool TryGetSocketAddressSize(out int size);\r\n\r\n    // Existing:\r\n    // public virtual SocketAddress Serialize();\r\n    \r\n    // Proposed:\r\n    public virtual void Serialize(Span\u003cbyte\u003e socketAddress);\r\n    \r\n    // Existing:\r\n    // public virtual EndPoint Create(SocketAddress socketAddress);\r\n    \r\n    // Proposed:\r\n    public virtual EndPoint Create(ReadOnlySpan\u003cbyte\u003e socketAddress);\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\nif (endPoint.TryGetSocketAddressSize(out int size))\r\n{\r\n    Span\u003cbyte\u003e socketAddress = size \u003c 256 ? stackalloc byte[size] : new byte[size];\r\n    endPoint.Serialize(socketAddress);\r\n    \r\n    // use socketAddress\r\n}\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\nI can\u0027t think of a significantly different design that would also delegate the buffer lifecycle management to the consumer of the API.\r\n\r\nIf we think that `DnsEndpoint` is the only exception that is not serializable and needs special threatment, we can expose an `int Size` property instead of `TryGetSocketAddressSize`.\r\n\r\n### Risks\r\n\r\nConsidering compatibility, the only correct way to implement `TryGetSocketAddressSize(out int size)` is inefficient and may regress path that uses existing 3rd party endpoints which are not updated with overloads:\r\n\r\n```C#\r\npublic virtual bool TryGetSocketAddressSize(out int size)\r\n{\r\n    try\r\n    {\r\n        size = this.Serialize().Size;\r\n        return true;\r\n    }\r\n    catch\r\n    {\r\n        size = default;\r\n        return false;\r\n    }\r\n}\r\n```\r\n\r\nThis is not a concern if we think `DnsEndPoint` is the only special case that is not serializable.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOVEkpJQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5PWQQn",
                                           "createdAt":  "2022-11-29T20:06:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nSerializing general `EndPoint` instances into buffers/structures to be used with low-level interop code requires instantiating a `SocketAddress` and copying its bytes to a separate buffer manually. This leads to 2 extra allocations: `SocketAddress` and the underlying buffer. This is one of the main reasons our SendTo/ReceiveFrom methods allocate a lot, see discussion in #30797.\r\n\r\nWe can workaround this by special-casing `IPEndPoint` (#78591), but that would introduce complexity to the Socket codebase if implemented across all sync and async variants and doesn\u0027t work with arbitrary endpoints. We can also expose `SocketAddress.Buffer` (#78757), but IMO it\u0027s a partial solution, since it doesn\u0027t help with the allocations.\r\n\r\nInstead working around our own inefficient abstractions, we should consider adding an alternative modern and efficient API to serialize arbitrary `EndPoint`-s into user-provided buffers. This would help simplifying and improving socket code while keeping it compatible with arbitrary endpoints.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Net;\r\n\r\npublic abstract class EndPoint\r\n{\r\n    // Existing:\r\n    // public virtual SocketAddress Serialize();\r\n    // public virtual EndPoint Create(SocketAddress socketAddress);\r\n\r\n    // Returns true if the EndPoint is serializable into a linear native structure\r\n    public virtual bool TryGetSocketAddressSize(out int size);\r\n    public virtual void Serialize(Span\u003cbyte\u003e socketAddress);\r\n    public virtual EndPoint Create(ReadOnlySpan\u003cbyte\u003e socketAddress);\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nif (endPoint.TryGetSocketAddressSize(out int size))\r\n{\r\n    Span\u003cbyte\u003e socketAddress = size \u003c 256 ? stackalloc byte[size] : new byte[size];\r\n    endPoint.Serialize(socketAddress);\r\n    \r\n    // use socketAddress\r\n}\r\n```\r\n\n\n### Alternative Designs\n\nI can\u0027t think of a significantly different design that would also delegate the buffer lifecycle management to the user.\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eantonfirsov\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Net.Sockets`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-11-29T20:06:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5PXA_Z",
                                           "createdAt":  "2022-11-29T23:07:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "fbrosseau",
                                           "body":  "What would the default Create(ROS) implementation be to keep backward compatibility? A call to Create(SocketAddress)?",
                                           "updatedAt":  "2022-11-29T23:07:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5PXJa0",
                                           "createdAt":  "2022-11-29T23:52:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "Yes, that would be the only way to keep things compatible. `TryGetSocketAddressSize(out int)` is more tricky, I updated the Risks section.",
                                           "updatedAt":  "2022-11-29T23:52:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5P9YtL",
                                           "createdAt":  "2022-12-07T19:36:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericstj",
                                           "body":  "Seems odd that Create looks like a factory method but it\u0027s not static.  Maybe add sample API usage that shows how that\u0027s used?",
                                           "updatedAt":  "2022-12-07T19:45:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5P91wU",
                                           "createdAt":  "2022-12-07T21:19:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "@ericstj it\u0027s matching the [existing overload](https://learn.microsoft.com/en-us/dotnet/api/system.net.endpoint.create?view=net-7.0). The proposed overload takes `ReadOnlySpan\u003cbyte\u003e` instead of a `SocketAddress`.\r\n\r\nThe usage is unusual, but it\u0027s legacy design: an existing `EndPoint` instance is used to create a new instance of the same subclass from native socket address buffer, see [`Socket.cs`](https://github.com/dotnet/runtime/blob/13a9a3ce67b3ab88cd6c0a975a47ed856e005d42/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs#L1669). It meant to be invoked by low-level networking implementations, while third parties can implement EndPoints of arbitrary types by overriding `Create` and `Serialize`.",
                                           "updatedAt":  "2022-12-07T21:19:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5USSkl",
                                           "createdAt":  "2023-02-02T17:08:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "Triage: depends on the fate of #30797, moving to future.",
                                           "updatedAt":  "2023-02-02T17:08:33Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "[API Proposal]: Efficient EndPoint serialization",
        "labels":  [
                       "api-suggestion",
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/80169",
        "createdAt":  "2023-01-04T10:49:53Z",
        "number":  80169,
        "author":  "rzikm",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-15T17:21:01Z",
        "body":  "Seems https://github.com/dotnet/runtime/issues/75354 was not enough.\r\n\r\nKusto query:\r\n\r\n```kusto\r\ncluster(\u0027engsrvprod.kusto.windows.net\u0027).database(\u0027engineeringdata\u0027).AzureDevOpsTests\r\n    //| where TestName has \u0027ConnectWithRevocation_WithCallback\u0027\r\n    | where TestName has \"SendFileGetsCanceledByDispose\"\r\n        and Outcome == \u0027Failed\u0027 or Outcome == \u0027PassedOnRerun\u0027\r\n    | join kind=inner (cluster(\u0027engsrvprod.kusto.windows.net\u0027).database(\u0027engineeringdata\u0027).Jobs\r\n        | where Finished \u003e now(-14d)\r\n        | extend TargetBranch = extractjson(\"$.[\u0027System.PullRequest.TargetBranch\u0027]\", Properties)\r\n        | where (Branch == \u0027refs/heads/main\u0027) //or (Source startswith \"pr/\" and TargetBranch == \u0027main\u0027)\r\n        | where Type startswith \"test/functional/cli/\" and not(Properties contains \"runtime-staging\")\r\n        | summarize arg_max(Finished, Properties, Type, Branch, Source, Started, QueueName, Attempt, Build, TargetBranch) by JobId\r\n    | project-rename JobType = Type) on JobId\r\n;\r\n```\r\n\r\nMessage:\r\n```\r\nSystem.AggregateException : One or more errors occurred. (Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError) (Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError) (Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError) (Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError) (Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError) (Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError) (Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError) (Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError) (Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError) (Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError)\r\n---- Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError\r\n---- Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError\r\n---- Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError\r\n---- Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError\r\n---- Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError\r\n---- Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError\r\n---- Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError\r\n---- Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError\r\n---- Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError\r\n---- Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError\r\n```\r\n\r\nSeems to be contained to queues `osx.1200.arm64.open` and `osx.1200.amd64.open`",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOUbRF5A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5RtEXk",
                                           "createdAt":  "2023-01-04T10:50:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nKusto query:\r\n\r\n```kusto\r\ncluster(\u0027engsrvprod.kusto.windows.net\u0027).database(\u0027engineeringdata\u0027).AzureDevOpsTests\r\n    //| where TestName has \u0027ConnectWithRevocation_WithCallback\u0027\r\n    | where TestName has \"SendFileGetsCanceledByDispose\"\r\n        and Outcome == \u0027Failed\u0027 or Outcome == \u0027PassedOnRerun\u0027\r\n    | join kind=inner (cluster(\u0027engsrvprod.kusto.windows.net\u0027).database(\u0027engineeringdata\u0027).Jobs\r\n        | where Finished \u003e now(-14d)\r\n        | extend TargetBranch = extractjson(\"$.[\u0027System.PullRequest.TargetBranch\u0027]\", Properties)\r\n        | where (Branch == \u0027refs/heads/main\u0027) //or (Source startswith \"pr/\" and TargetBranch == \u0027main\u0027)\r\n        | where Type startswith \"test/functional/cli/\" and not(Properties contains \"runtime-staging\")\r\n        | summarize arg_max(Finished, Properties, Type, Branch, Source, Started, QueueName, Attempt, Build, TargetBranch) by JobId\r\n    | project-rename JobType = Type) on JobId\r\n;\r\n```\r\n\r\nMessage:\r\n```\r\nSystem.AggregateException : One or more errors occurred. (Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError) (Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError) (Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError) (Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError) (Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError) (Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError) (Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError) (Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError) (Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError) (Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError)\r\n---- Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError\r\n---- Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError\r\n---- Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError\r\n---- Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError\r\n---- Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError\r\n---- Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError\r\n---- Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError\r\n---- Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError\r\n---- Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError\r\n---- Assert.Equal() Failure\r\nExpected: OperationAborted\r\nActual:   SocketError\r\n```\r\n\r\nSeems to be contained to queues `osx.1200.arm64.open` and `osx.1200.amd64.open`\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003erzikm\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003ewfurt\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Net.Sockets`, `os-mac-os-x`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-01-04T10:50:00Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "[Test Failure] SendFileGetsCanceledByDispose fails on MacOS",
        "labels":  [
                       "area-System.Net.Sockets",
                       "os-mac-os-x"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/81437",
        "createdAt":  "2023-01-31T18:02:55Z",
        "number":  81437,
        "author":  "buyaa-n",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-02-02T17:17:01Z",
        "body":  "Found in a release/6.0 backport PR. https://github.com/dotnet/runtime/pull/81281/checks?check_run_id=10937030682\r\n\r\nLog: https://helix.dot.net/api/2019-06-17/jobs/1dacef47-5173-49ec-ac68-fc7446cf11ed/workitems/System.Net.Sockets.Tests/console\r\n```log\r\nSystem.Net.Sockets.Tests.DualModeAccept.AcceptV4BoundToAnyV6_Success [FAIL]\r\n      System.ArgumentException : The supplied System.Net.Internals.SocketAddress is an invalid size for the System.Net.IPEndPoint end point. (Parameter \u0027socketAddress\u0027)\r\n      Stack Trace:\r\n        /_/src/libraries/Common/src/System/Net/Internals/IPEndPointExtensions.cs(36,0): at System.Net.Sockets.IPEndPointExtensions.Create(EndPoint thisObj, SocketAddress socketAddress)\r\n        /_/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs(1092,0): at System.Net.Sockets.Socket.Accept()\r\n        /_/src/libraries/System.Net.Sockets/tests/FunctionalTests/DualModeSocketTest.cs(766,0): at System.Net.Sockets.Tests.DualModeAccept.Accept_Helper(IPAddress listenOn, IPAddress connectTo)\r\n        /_/src/libraries/System.Net.Sockets/tests/FunctionalTests/DualModeSocketTest.cs(756,0): at System.Net.Sockets.Tests.DualModeAccept.AcceptV4BoundToAnyV6_Success()\r\n    System.Net.Sockets.Tests.CreateSocket.Ctor_Raw_Supported_Success [SKIP]\r\n      Condition(s) not met: \"SupportsRawSockets\"\r\n  Finished:    System.Net.Sockets.Tests\r\n=== TEST EXECUTION SUMMARY ===\r\n   System.Net.Sockets.Tests  Total: 1888, Errors: 0, Failed: 1, Skipped: 1, Time: 5.332s\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOVElVAw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5UF6KX",
                                           "createdAt":  "2023-01-31T18:03:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nFound in a release/6.0 backport PR. https://github.com/dotnet/runtime/pull/81281/checks?check_run_id=10937030682\r\n\r\nLog: https://helix.dot.net/api/2019-06-17/jobs/1dacef47-5173-49ec-ac68-fc7446cf11ed/workitems/System.Net.Sockets.Tests/console\r\n```log\r\nSystem.Net.Sockets.Tests.DualModeAccept.AcceptV4BoundToAnyV6_Success [FAIL]\r\n      System.ArgumentException : The supplied System.Net.Internals.SocketAddress is an invalid size for the System.Net.IPEndPoint end point. (Parameter \u0027socketAddress\u0027)\r\n      Stack Trace:\r\n        /_/src/libraries/Common/src/System/Net/Internals/IPEndPointExtensions.cs(36,0): at System.Net.Sockets.IPEndPointExtensions.Create(EndPoint thisObj, SocketAddress socketAddress)\r\n        /_/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs(1092,0): at System.Net.Sockets.Socket.Accept()\r\n        /_/src/libraries/System.Net.Sockets/tests/FunctionalTests/DualModeSocketTest.cs(766,0): at System.Net.Sockets.Tests.DualModeAccept.Accept_Helper(IPAddress listenOn, IPAddress connectTo)\r\n        /_/src/libraries/System.Net.Sockets/tests/FunctionalTests/DualModeSocketTest.cs(756,0): at System.Net.Sockets.Tests.DualModeAccept.AcceptV4BoundToAnyV6_Success()\r\n    System.Net.Sockets.Tests.CreateSocket.Ctor_Raw_Supported_Success [SKIP]\r\n      Condition(s) not met: \"SupportsRawSockets\"\r\n  Finished:    System.Net.Sockets.Tests\r\n=== TEST EXECUTION SUMMARY ===\r\n   System.Net.Sockets.Tests  Total: 1888, Errors: 0, Failed: 1, Skipped: 1, Time: 5.332s\r\n```\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ebuyaa-n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Net.Sockets`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-01-31T18:03:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5USVUD",
                                           "createdAt":  "2023-02-02T17:16:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "Triage: we should keep monitoring if it happens again. We would only fix it if it fails massively, in that case we shall reprioritize.",
                                           "updatedAt":  "2023-02-02T17:17:01Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[6.0] CI test failure in OSX System.Net.Sockets.Tests.DualModeAccept.AcceptV4BoundToAnyV6_Success [FAIL]",
        "labels":  [
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/84364",
        "createdAt":  "2023-04-05T17:55:37Z",
        "number":  84364,
        "author":  "antonfirsov",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-09-10T17:18:45Z",
        "body":  "The following tests timeout the test run regularly on the `Debian.10.Arm32.Open` and the `Debian.11.Arm32.Open` queues:\r\n\r\n```\r\nSystem.Net.Sockets.Tests.SendReceive_*.TcpPeerReceivesFinOnShutdownWithPendingData\r\nSystem.Net.Sockets.Tests.SendReceive_*.TcpReceiveSendGetsCanceledByDispose\r\nSystem.Net.Sockets.Tests.AcceptTask.AcceptGetsCanceledByDispose\r\nSystem.Net.Sockets.Tests.AcceptApm.AcceptGetsCanceledByDispose\r\nSystem.Net.Sockets.Tests.NetworkStreamTest.ReadAsync_CancelPendingValueTask_ThrowsCancellationException\r\n```\r\n\r\n#84030 made sure `TcpPeerReceivesFinOnShutdownWithPendingData` will not hang the test process anymore, also addressing potential dual-mode issues with the test. We need to take similar measures for the rest.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOi5ECTw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5ZSAhM",
                                           "createdAt":  "2023-04-05T17:55:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThe following tests timeout the test run regularly on the `Debian.10.Arm32.Open` and the `Debian.11.Arm32.Open` queues:\r\n\r\n```\r\nSystem.Net.Sockets.Tests.SendReceive_*.TcpPeerReceivesFinOnShutdownWithPendingData\r\nSystem.Net.Sockets.Tests.SendReceive_*.TcpReceiveSendGetsCanceledByDispose\r\nSystem.Net.Sockets.Tests.AcceptTask.AcceptGetsCanceledByDispose\r\nSystem.Net.Sockets.Tests.AcceptApm.AcceptGetsCanceledByDispose\r\nSystem.Net.Sockets.Tests.NetworkStreamTest.ReadAsync_CancelPendingValueTask_ThrowsCancellationException\r\n```\r\n\r\n#84030 made sure `TcpPeerReceivesFinOnShutdownWithPendingData` will not hang the test process anymore, also addressing potential dual-mode issues with the test. We need to take similar measures for the rest.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eantonfirsov\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Net.Sockets`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-04-05T17:55:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6LkQJP",
                                           "createdAt":  "2024-09-10T17:18:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "do we still see timeouts @rzikm? I did not see any disabled tests and this is pretty old and perhaps could be closed? ",
                                           "updatedAt":  "2024-09-10T17:18:44Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Timeouts in Socket tests on Debian.*.Arm32.Open",
        "labels":  [
                       "area-System.Net.Sockets",
                       "test-bug",
                       "test-run-core",
                       "blocking-clean-ci-optional"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/87932",
        "createdAt":  "2023-06-22T18:07:22Z",
        "number":  87932,
        "author":  "liveans",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODHHo3A==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "carlreinke",
                                            "createdAt":  "2024-09-15T04:52:42Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "gmcchessney",
                                            "createdAt":  "2024-10-04T18:36:33Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "neon-sunset",
                                            "createdAt":  "2025-01-27T16:50:17Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "am11",
                                            "createdAt":  "2025-01-27T16:52:44Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "divyeshio",
                                            "createdAt":  "2025-02-15T18:36:55Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MichalPetryka",
                                            "createdAt":  "2025-06-24T18:09:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "albi005",
                                            "createdAt":  "2025-07-15T20:55:29Z"
                                        }
                                    ],
                          "totalCount":  7
                      },
        "updatedAt":  "2025-09-18T15:32:16Z",
        "body":  "This API has been proposed and approved on https://github.com/dotnet/runtime/issues/861.\r\nSince we\u0027re closing the mega-issue(https://github.com/dotnet/runtime/issues/33418) we\u0027ll track this here.\r\n\r\n```c#\r\nclass Socket\r\n{\r\n\t// existing: public static bool ConnectAsync(SocketType socketType, ProtocolType protocolType, SocketAsyncEventArgs e);\r\n\tpublic static bool ConnectAsync (SocketType socketType, ProtocolType protocolType, SocketAsyncEventArgs e, ConnectAlgorithm connectAlgorithm);\r\n}\r\n\r\n// new enum\r\nenum ConnectAlgorithm\r\n{\r\n    // use existing behavior.\r\n    Default,\r\n\r\n    // use a Happy Eyeballs-like algorithm to connect.\r\n    Parallel = 1\r\n}\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOxS5mOA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5fjWvf",
                                           "createdAt":  "2023-06-22T18:07:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThis API has been proposed and approved on https://github.com/dotnet/runtime/issues/861.\r\nSince we\u0027re closing the mega-issue(https://github.com/dotnet/runtime/issues/33418) we\u0027ll track this here.\r\n\r\n```c#\r\nclass Socket\r\n{\r\n\t// existing: public static bool ConnectAsync(SocketType socketType, ProtocolType protocolType, SocketAsyncEventArgs e);\r\n\tpublic static bool ConnectAsync (SocketType socketType, ProtocolType protocolType, SocketAsyncEventArgs e, ConnectAlgorithm connectAlgorithm);\r\n}\r\n\r\n// new enum\r\nenum ConnectAlgorithm\r\n{\r\n    // use existing behavior.\r\n    Default,\r\n\r\n    // use a Happy Eyeballs-like algorithm to connect.\r\n    Parallel = 1\r\n}\r\n```\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eliveans\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-approved`, `area-System.Net.Sockets`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-06-22T18:07:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5fmdle",
                                           "createdAt":  "2023-06-23T08:26:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODOibHA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "karelz",
                                                                               "createdAt":  "2023-06-23T13:49:15Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "MV10",
                                                                               "createdAt":  "2023-12-05T11:10:47Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "wfurt",
                                           "body":  "related to #26177  ",
                                           "updatedAt":  "2023-06-23T08:26:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6b8kCj",
                                           "createdAt":  "2025-01-27T16:50:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEEKr9Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "am11",
                                                                               "createdAt":  "2025-01-27T16:52:41Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "neon-sunset",
                                           "body":  "Just to add a token of community interest, Bunny.net would love to have this feature available in .NET 10.\n\nThanks!",
                                           "updatedAt":  "2025-01-27T16:50:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6y4WnK",
                                           "createdAt":  "2025-06-24T16:19:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEgWWfA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_DOWN",
                                                                               "user":  "MV10",
                                                                               "createdAt":  "2025-09-01T09:36:42Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "wfurt",
                                           "body":  "triage: we may not have time to complete it in 10.0",
                                           "updatedAt":  "2025-06-24T16:19:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7FKzWu",
                                           "createdAt":  "2025-09-18T14:54:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "murshex",
                                           "body":  "@stephentoub @davidfowl Please make this happen for .NET 10, we need it :(",
                                           "updatedAt":  "2025-09-18T14:54:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7FLmY4",
                                           "createdAt":  "2025-09-18T15:32:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEi3QGw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "liveans",
                                                                               "createdAt":  "2025-09-18T15:33:30Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "gfoidl",
                                           "body":  "\u003e for .NET 10\n\nFor .NET 10 it\u0027s too late, as it\u0027s feature complete -- meaning that no new features will be added. Further there\u0027s already .NET 10 RC1 out.\n\nMaybe it can go into the .NET 11 timeframe.",
                                           "updatedAt":  "2025-09-18T15:32:16Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "Happy Eyeballs support in Socket.ConnectAsync",
        "labels":  [
                       "api-approved",
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/97056",
        "createdAt":  "2024-01-16T23:19:46Z",
        "number":  97056,
        "author":  "as-TiEl",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-06-14T22:58:54Z",
        "body":  "### Description\r\n- the high frequency tcp-communication between TcpListener/TcpClient with NetworkStream.ReadAsync()/.WriteAsync() on the same machine (127.0.0.1) is with .net 8 significantly slower compared to .net 6\r\n\r\n### Configuration\r\n- .net 8.0.1 compared with .net 6.0.26 (AnyCpu) \r\n- Windows 10 /11 (x64)\r\n- Visual Studio 2022 17.8.4\r\n- c#\r\n\r\n### Regression?\r\n- throughput .net 6: ~44000 msg/s\r\n- throughput .net 8: ~28000 msg/s\r\n\r\n### Data\r\n- the attached zip-File contains a VS2022 solution with two c# console projects “SimpleConsoleServerTCP” and “SimpleConsoleClientTCP”.\r\n- Run both on the same machine to start data exchange for 100_000 * 16 Byte of meaningless messages. \r\n- the troughput in messages/second is printed to the console.\r\n- Change the .net-Version in the project settings and repeat the test to see the differences in throughput.\r\n[TcpPerformanceTest.zip](https://github.com/dotnet/runtime/files/13956386/TcpPerformanceTest.zip)\r\n\r\n### Analysis\r\n- the Performance for Network.Read()/.Write() on both .net versions are comparably fast\r\n- if client and server are running on different machines with gigabit connection, NetworkStream.ReadAsync()/.WriteAsync are comparably fast on both .net versions\r\n- it seems that high-frequency ReadAsync()WriteAsync()-calls makes here the difference\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOd8Nj9Q==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5w7nXK",
                                           "createdAt":  "2024-01-16T23:19:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\n- the high frequency tcp-communication between TcpListener/TcpClient with NetworkStream.ReadAsync()/.WriteAsync() on the same machine (127.0.0.1) is with .net 8 significantly slower compared to .net 6\r\n\r\n### Configuration\r\n- .net 8.0.1 compared with .net 6.0.26 (AnyCpu) \r\n- Windows 10 /11 (x64)\r\n- Visual Studio 2022 17.8.4\r\n- c#\r\n\r\n### Regression?\r\n- throughput .net 6: ~44000 msg/s\r\n- throughput .net 8: ~28000 msg/s\r\n\r\n### Data\r\n- the attached zip-File contains a VS2022 solution with two c# console projects “SimpleConsoleServerTCP” and “SimpleConsoleClientTCP”.\r\n- Run both on the same machine to start data exchange for 100_000 * 16 Byte of meaningless messages. \r\n- the troughput in messages/second is printed to the console.\r\n- Change the .net-Version in the project settings and repeat the test to see the differences in throughput.\r\n[TcpPerformanceTest.zip](https://github.com/dotnet/runtime/files/13956386/TcpPerformanceTest.zip)\r\n\r\n### Analysis\r\n- the Performance for Network.Read()/.Write() on both .net versions are comparably fast\r\n- if client and server are running on different machines with gigabit connection, NetworkStream.ReadAsync()/.WriteAsync are comparably fast on both .net versions\r\n- it seems that high-frequency ReadAsync()WriteAsync()-calls makes here the difference\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eas-TiEl\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Net`, `tenet-performance`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-01-16T23:19:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5w7oou",
                                           "createdAt":  "2024-01-16T23:26:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\n- the high frequency tcp-communication between TcpListener/TcpClient with NetworkStream.ReadAsync()/.WriteAsync() on the same machine (127.0.0.1) is with .net 8 significantly slower compared to .net 6\r\n\r\n### Configuration\r\n- .net 8.0.1 compared with .net 6.0.26 (AnyCpu) \r\n- Windows 10 /11 (x64)\r\n- Visual Studio 2022 17.8.4\r\n- c#\r\n\r\n### Regression?\r\n- throughput .net 6: ~44000 msg/s\r\n- throughput .net 8: ~28000 msg/s\r\n\r\n### Data\r\n- the attached zip-File contains a VS2022 solution with two c# console projects “SimpleConsoleServerTCP” and “SimpleConsoleClientTCP”.\r\n- Run both on the same machine to start data exchange for 100_000 * 16 Byte of meaningless messages. \r\n- the troughput in messages/second is printed to the console.\r\n- Change the .net-Version in the project settings and repeat the test to see the differences in throughput.\r\n[TcpPerformanceTest.zip](https://github.com/dotnet/runtime/files/13956386/TcpPerformanceTest.zip)\r\n\r\n### Analysis\r\n- the Performance for Network.Read()/.Write() on both .net versions are comparably fast\r\n- if client and server are running on different machines with gigabit connection, NetworkStream.ReadAsync()/.WriteAsync are comparably fast on both .net versions\r\n- it seems that high-frequency ReadAsync()WriteAsync()-calls makes here the difference\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eas-TiEl\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Net.Sockets`, `tenet-performance`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-01-16T23:26:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5xGqRx",
                                           "createdAt":  "2024-01-18T00:51:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "I don\u0027t see same results. 8.0 _seems_ somewhat slower but comparable. I also see large fluctuation in results:\r\n```\r\nY:\\TcpPerformanceTest\\SimpleConsoleClientTCP\u003edotnet run\r\nTCP-Client started (.net 8.0.0)\r\n-------------------------------\r\n\r\nClient: connection established\r\nClient: SendbufferSize = 65536\r\nClient: WriteTimout = -1\r\nClient: ReceivebufferSize = 65536\r\nClient: ReadTimout = -1\r\nClient: received byte = 1600000\r\n----------------------------------------------\r\nClient: throuput = 6854.64 messages/s\r\n----------------------------------------------\r\nfinished\r\n\r\nY:\\TcpPerformanceTest\\SimpleConsoleClientTCP\u003edotnet run\r\nTCP-Client started (.net 8.0.0)\r\n-------------------------------\r\n\r\nClient: connection established\r\nClient: SendbufferSize = 65536\r\nClient: WriteTimout = -1\r\nClient: ReceivebufferSize = 65536\r\nClient: ReadTimout = -1\r\nClient: received byte = 1600000\r\n----------------------------------------------\r\nClient: throuput = 13569.38 messages/s\r\n----------------------------------------------\r\nfinished\r\n```\r\n\r\nSome of the difference maybe because of initial jitting. Perhaps we should convert the scenario to real benchmark using benchmark.net. We already have similar test, so we can perhaps adjust the to the 16b messages. ",
                                           "updatedAt":  "2024-01-18T00:51:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5xIlul",
                                           "createdAt":  "2024-01-18T09:10:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "as-TiEl",
                                           "body":  "Hmm. interesting. I run this on two complete different machines (\"Intel I7-12800HX / 32GB RAM / Win11\" vs. \"AMD Ryzen7 2700X / 16GB RAM / Win10\"). Both showing the ~40% perf drop fairly stable. Do you run the Tests on a virtual machine (drive letter looks so :) )? This may cause the large jitter.\r\nYour suggestion regarding a better benchmark is a very good idea.\r\n",
                                           "updatedAt":  "2024-01-18T09:10:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53jRNX",
                                           "createdAt":  "2024-03-19T04:31:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "Hi @as-TiEl, did you had any luck progressing on the benchmark. I\u0027m afraid this is not actionable for us at the moment. ",
                                           "updatedAt":  "2024-03-19T04:31:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc53w2P1",
                                           "createdAt":  "2024-03-20T10:58:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "as-TiEl",
                                           "body":  "Hi @wfurt.  I have not gained any new insights to this issue. Actually, i have switched my TCP communication to Network.Read()/.Write() to avoid this behavior",
                                           "updatedAt":  "2024-03-20T10:58:19Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "tcp-throughput regression (localhost) with NetworkStream.ReadAsync()/WriteAsync() from .net 6.0.26 to .net 8.0.1",
        "labels":  [
                       "area-System.Net.Sockets",
                       "tenet-performance",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/101036",
        "createdAt":  "2024-04-15T03:39:00Z",
        "number":  101036,
        "author":  "neuecc",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODG9myQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SommerEngineering",
                                            "createdAt":  "2024-04-15T06:33:32Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "james0x0A",
                                            "createdAt":  "2024-04-15T06:59:13Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Tan90909090",
                                            "createdAt":  "2024-04-15T12:24:54Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2024-04-15T20:23:04Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "neon-sunset",
                                            "createdAt":  "2024-04-16T04:55:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "reflectronic",
                                            "createdAt":  "2025-07-14T23:15:08Z"
                                        }
                                    ],
                          "totalCount":  6
                      },
        "updatedAt":  "2024-05-02T16:04:28Z",
        "body":  "### Background and motivation\n\nOn Linux, when using Socket communication, by utilizing [sendmmsg](https://man7.org/linux/man-pages/man2/sendmmsg.2.html) and [recvmmsg](https://man7.org/linux/man-pages/man2/recvmmsg.2.html), it is possible to process multiple messages in a single call, which is expected to improve performance.\r\nIn fact, MsQuic also uses these for UDP processing.\r\nhttps://github.com/microsoft/msquic/pull/1279\r\nhttps://github.com/microsoft/msquic/pull/1280\r\n\r\nThe `Send` and `Receive` methods have overloads that accept `IList\u003cArraySegment\u003cbyte\u003e\u003e buffers`.\r\nOn the C# side, it appears to be creating a `Span\u003cInterop.Sys.IOVector\u003e`, but on the native runtime side, it seems to be simply looping through sendmsg and recvmsg.\r\nhttps://github.com/dotnet/runtime/blob/95b67ed92ee5b785f6dd92efad2404583e05a8e7/src/native/libs/System.Native/pal_networking.c#L1404\r\n\r\nIn my use case, I would like to use these system calls when creating a high-performance UDP server.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Net.Sockets\r\n{\r\n    public class Socket\r\n    {\r\n        public int Send(ReadOnlySpan\u003cReadOnlyMemory\u003cbyte\u003e\u003e buffers, Span\u003cint\u003e lengths, SocketFlags socketFlags) =\u003e throw new NotImplementedException();\r\n        public int Receive(ReadOnlySpan\u003cMemory\u003cbyte\u003e\u003e buffers, Span\u003cint\u003e lengths, SocketFlags socketFlags) =\u003e throw new NotImplementedException();\r\n        public ValueTask\u003cSocketSendMultiResult\u003e SendAsync(ReadOnlyMemory\u003cbyte\u003e buffers, SocketFlags socketFlags, CancellationToken cancellationToken = default) =\u003e throw new NotImplementedException();\r\n        public ValueTask\u003cSocketReceiveMultiResult\u003e ReceiveAsync(ReadOnlyMemory\u003cMemory\u003cbyte\u003e\u003e buffers, SocketFlags socketFlags, CancellationToken cancellationToken = default) =\u003e throw new NotImplementedException();\r\n\r\n        public int SendTo(ReadOnlySpan\u003cReadOnlyMemory\u003cbyte\u003e\u003e buffers, Span\u003cint\u003e lengths, SocketFlags socketFlags, SocketAddress socketAddress) =\u003e throw new NotImplementedException();\r\n        public int ReceiveFrom(ReadOnlySpan\u003cMemory\u003cbyte\u003e\u003e buffers, Span\u003cint\u003e lengths, SocketFlags socketFlags, SocketAddress socketAddress) =\u003e throw new NotImplementedException();\r\n        public ValueTask\u003cSocketSendMultiResult\u003e SendToAsync(ReadOnlyMemory\u003cbyte\u003e buffers, SocketFlags socketFlags, SocketAddress socketAddress, CancellationToken cancellationToken = default) =\u003e throw new NotImplementedException();\r\n        public ValueTask\u003cSocketReceiveMultiResult\u003e ReceiveFromAsync(ReadOnlyMemory\u003cMemory\u003cbyte\u003e\u003e buffers, SocketFlags socketFlags, SocketAddress receivedAddress, CancellationToken cancellationToken = default) =\u003e throw new NotImplementedException();\r\n    }\r\n\r\n    public struct SocketSendMultiResult\r\n    {\r\n        public int Length;\r\n        public Memory\u003cint\u003e SentBytes;\r\n    }\r\n\r\n    public struct SocketReceiveMultiResult\r\n    {\r\n        public int Length;\r\n        public Memory\u003cint\u003e ReceivedBytes;\r\n    }\r\n}\r\n```\n\n### API Usage\n\n```csharp\r\nusing Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);\r\nsocket.Bind(new IPEndPoint(IPAddress.Any, 12345));\r\n\r\nvar remoteAddress = new SocketAddress(AddressFamily.InterNetwork);\r\n\r\nReadOnlyMemory\u003cbyte\u003e message1 = Encoding.ASCII.GetBytes(\"hello\");\r\nReadOnlyMemory\u003cbyte\u003e message2 = Encoding.ASCII.GetBytes(\"world\");\r\n\r\nSpan\u003cint\u003e lengths = stackalloc int[2];\r\nvar len = socket.SendTo([message1, message2], lengths, SocketFlags.None, remoteAddress);\r\n```\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\nIn asynchronous APIs, the location to store the length of the return value must be zero-allocation.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOeoo-uw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc56eTg6",
                                           "createdAt":  "2024-04-15T03:39:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-04-15T03:39:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56ij67",
                                           "createdAt":  "2024-04-15T07:34:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "\u003e The Send and Receive methods have overloads that accept IList\u003cArraySegment\u003cbyte\u003e\u003e buffers.\r\nOn the C# side, it appears to be creating a Span\u003cInterop.Sys.IOVector\u003e, but on the native runtime side, it seems to be simply looping through sendmsg and recvmsg.\r\n\r\nThe methods pass the buffers using a single call to `sendmsg`/`recvmsg` through the `msghdr`:\r\n\r\nhttps://github.com/dotnet/runtime/blob/5aee4f43c9389239c72d3931a4b2bd5bf123243b/src/native/libs/System.Native/pal_networking.c#L922-L923\r\n\r\nThis enables receiving/sending multiple buffers with a single syscall for a stream socket.\r\n\r\nThe loop is for dealing with `EINTR`.\r\n\r\n\u003e In my use case, I would like to use these system calls when creating a high-performance UDP server.\r\n\r\nFor datagram sockets, like UDP, to receive multiple datagrams with a single syscall you indeed need `sendmmsg` and `recvmmsg`. These accept an array of `msghdr`.\r\n\r\nA single receive call can return datagrams from different senders. The API should support getting the different peer addresses.\r\n\r\nA single send call can send to different receivers. The API should probably support this as well.",
                                           "updatedAt":  "2024-04-15T08:50:05Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[API Proposal]: Add sendmmsg and recvmmsg to Socket for Linux",
        "labels":  [
                       "api-suggestion",
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/101210",
        "createdAt":  "2024-04-17T21:01:25Z",
        "number":  101210,
        "author":  "wfurt",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-02T18:10:56Z",
        "body":  "This is related to https://github.com/dotnet/runtime/pull/99181 and https://github.com/dotnet/runtime/pull/99490.\r\nI wanted to write some test that fail predictably and I failed to do so. \r\nSo I decided to open this to capture some conversation\r\nLet consider this\r\n```c#\r\n   [Fact]\r\n   public async Task SendAsync_WithIncompleteData_Throws()\r\n   {\r\n       using (var listen = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp))\r\n       {\r\n           listen.SendBufferSize = 100;\r\n           listen.ReceiveBufferSize = 100;\r\n           listen.Bind(new IPEndPoint(IPAddress.Loopback, 0));\r\n           listen.Listen();\r\n\r\n           int size = listen.SendBufferSize;\r\n\r\n           var client = new Socket(SocketType.Stream, ProtocolType.Tcp);\r\n       //    client.Blocking = false;\r\n           client.SendBufferSize = 100;\r\n           client.ReceiveBufferSize = 100;\r\n  \r\n          // take default ReceiveBufferSize and double it to make sure sending data do not fit into it\r\n           var sendBuffer = new byte[100_100];\r\n           var receiveBuffer = new byte[sendBuffer.Length];\r\n\r\n           Task\u003cSocket\u003e serverTask = listen.AcceptAsync();\r\n\r\n           Task t = client.ConnectAsync(listen.LocalEndPoint);\r\n           Socket serverSocket = await serverTask;\r\n           await t;\r\n           serverSocket.ReceiveBufferSize = 100;\r\n           serverSocket.SendBufferSize = 100;\r\n           serverSocket.Dispose();\r\n\r\n           int sentBytes = await client.SendAsync(sendBuffer);\r\n           Assert.Equal(sendBuffer.Length, sentBytes);\r\n           client.Shutdown(SocketShutdown.Both);\r\n           client.Close();\r\n       }\r\n   }\r\n```\r\n\r\nwhen I run it on my Windows 11 box everything finishes without error.\r\nBut looking at packet capture, we clearly did not sent 100K worth of data.\r\n![image](https://github.com/dotnet/runtime/assets/14356188/b3bd0115-5fd0-4067-b5e7-5a2645d77e6d)\r\n\r\nSame code throws on Linux. I thought it may be just timing so I did somewhat more elaborate test\r\n```c#\r\n[Fact]\r\npublic async Task ConnectAsync_WithIncompleteData_Throws()\r\n{\r\n    using (var listen = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp))\r\n    {\r\n        listen.SendBufferSize = 3000;\r\n        listen.ReceiveBufferSize = 3000;\r\n\r\n        listen.Bind(new IPEndPoint(IPAddress.Loopback, 0));\r\n        listen.Listen();\r\n\r\n        int size = listen.SendBufferSize;\r\n\r\n        var client = new Socket(SocketType.Stream, ProtocolType.Tcp);\r\n        client.Blocking = false;\r\n        client.SendBufferSize = 3000;\r\n        client.ReceiveBufferSize = 3000;\r\n\r\n\r\n        Task\u003cSocket\u003e serverTask = listen.AcceptAsync();\r\n        Task t = client.ConnectAsync(listen.LocalEndPoint);\r\n        Socket serverSocket = await serverTask;\r\n        await t;\r\n\r\n        var sendBuffer = new byte[client.SendBufferSize +  serverSocket.ReceiveBufferSize];\r\n        var receiveBuffer = new byte[sendBuffer.Length];\r\n\r\n        int sent = 0;\r\n        new Span\u003cByte\u003e(sendBuffer, 0, 100).Fill(65);\r\n        while (true)\r\n        {\r\n            try\r\n            {\r\n                client.Send(new ReadOnlySpan\u003cByte\u003e(sendBuffer, 0, 100));\r\n                sent += 100;\r\n            }\r\n            catch (SocketException ex) when (ex.SocketErrorCode == SocketError.WouldBlock)\r\n            {\r\n                break;\r\n            }\r\n        }\r\n        // read some data to free TCP Window \r\n        int receivedLength = serverSocket.Receive(new Span\u003cByte\u003e(receiveBuffer, 0, 100));\r\n    \r\n        new Span\u003cByte\u003e(sendBuffer, 0, 100).Fill(66);\r\n        client.Send(new ReadOnlySpan\u003cByte\u003e(sendBuffer, 0, 100 ));\r\n        client.Shutdown(SocketShutdown.Both);\r\n        client.Close();\r\n    }\r\n}\r\n```\r\n\r\nthis test is constructed to fill up socket buffers and TCP Window. The last Send succeeds as data are written to Socket buffer but not transmitted on the wire and ACKed back. (e.g. the \u0027B\u0027 block never goes out\r\n\r\n![image](https://github.com/dotnet/runtime/assets/14356188/985ff5d2-24c1-4364-ac48-79ce15fdc14a)\r\n\r\nLinux man page is pretty specific about it\r\n```\r\n  Dealing with error returns from close()\r\n       A careful programmer will check the return value of close(), since it is quite possible that errors on a previous write(2) operation are reported only on the final close()  that  releases\r\n       the open file description.  Failing to check the return value when closing a file may lead to silent loss of data.  This can especially be observed with NFS and with disk quota.\r\n\r\n       Note, however, that a failure return should be used only for diagnostic purposes (i.e., a warning to the application that there may still be I/O pending or there may have been failed I/O)\r\n       or remedial purposes (e.g., writing the file once more or creating a backup).\r\n\r\n       Retrying the close() after a failure return is the wrong thing to do, since this may cause a reused file descriptor from another thread to be closed.  This can  occur  because  the  Linux\r\n       kernel always releases the file descriptor early in the close operation, freeing it for reuse; the steps that may return an error, such as flushing data to the filesystem or device, occur\r\n       only later in the close operation.\r\n\r\n       A careful programmer who wants to know about I/O errors may precede close() with a call to fsync(2).\r\n```\r\n\r\nit seems like our API does not allow us to check for the error and therefore I don\u0027t know how `Socket` users would know that data written to `Socket` or `NetworkStream` were actually lost. \r\n\r\nFrom what I can see this looks like silent data loss.\r\ncc @tmds @antonfirsov @stephentoub for comments.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOg15QeQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc567I4T",
                                           "createdAt":  "2024-04-17T21:01:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-04-17T21:01:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56-QI6",
                                           "createdAt":  "2024-04-18T06:47:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "\u003e The last Send succeeds as data are written to Socket buffer but not transmitted on the wire\r\n\r\nTo have the bytes transmitted immediately you should set `Socket.NoDelay = true`.\r\n\r\n\u003e it seems like our API does not allow us to check for the error and therefore I don\u0027t know how Socket users would know that data written to Socket or NetworkStream were actually lost.\r\n\r\nHypothetically speaking: if socket send would need to report the error, it would have to block for at least a round trip to receive an acknowledgement from the peer. Also, this acknowledgement would be sent by the peer\u0027s kernel, so this doesn\u0027t tell the sender anything about how the peer is handling the data.\r\n\r\nWhat happens instead is that the acknowledgement is the responsibility of the application level protocol through replying back. For example: client sends HTTP POST, server sends back 200 OK.",
                                           "updatedAt":  "2024-04-18T07:02:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc57cPdJ",
                                           "createdAt":  "2024-04-22T21:41:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "\u003e \u003e The last Send succeeds as data are written to Socket buffer but not transmitted on the wire\r\n\u003e \r\n\u003e To have the bytes transmitted immediately you should set `Socket.NoDelay = true`.\r\n\r\nThat will not help. The test is purposely structured in a way that TCP windows is filled (as server does not read data) so we can test behavior when data cannot be transmitted. I could not find any existing tests that would cover that behavior. ",
                                           "updatedAt":  "2024-04-22T21:41:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc57d0Wx",
                                           "createdAt":  "2024-04-23T05:03:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "\u003e  The test is purposely structured in a way that TCP windows is filled (as server does not read data) so we can test behavior when data cannot be transmitted.\r\n\r\nSynchronous `Send` blocks until data can be transmitted and `SendAsync` will wait until poll says the socket is writable. In both cases, the application is blocked until it can write more data (or the connection is closed).\r\n\r\nTo stop the operation earlier users can set `SendTimeout`/`ReceiveTimeout` (on sync api) or pass a `CancellationToken` (on async API).\r\n\r\nOne way to know when the TCP window is full is calling `Send` with `Blocking` to `false`. That will `SocketError.WouldBlock`.",
                                           "updatedAt":  "2024-04-23T05:03:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6DXlB5",
                                           "createdAt":  "2024-07-02T18:10:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "liveans",
                                           "body":  "Triage: Moving to the future, we will back to this once time permits.",
                                           "updatedAt":  "2024-07-02T18:10:51Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "unable to detect Socket.Send failures ",
        "labels":  [
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/104000",
        "createdAt":  "2024-06-25T22:20:17Z",
        "number":  104000,
        "author":  "kaiohenrique",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-08-31T13:41:07Z",
        "body":  "### Description\r\n\r\nWe have set LingerOption to avoid TIME_WAIT socket state but it seems not change the behavior. Extending NetworkStream and calling socket Close and Dispose seems to be doing the trick. No sure why [Socket.InternalShutdown](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Net.Sockets/src/System/Net/Sockets/NetworkStream.cs#L391) is impedind the LingerOption to work as expected. Am I missing anything here?\r\nNote: in the the request headers, we are sending \"Connect: close\" to avoid pooling\r\n\r\n### Reproduction Steps\r\n\r\n\r\nSocketsHttpHandler ConnectCallback  overwrite\r\n```\r\n ConnectCallback = async (context, cts) =\u003e\r\n {\r\n     var socket = new Socket(SocketType.Stream, ProtocolType.Tcp)\r\n     {\r\n         NoDelay = true,\r\n         LingerState = new LingerOption(true, 0)\r\n     };\r\n\r\n     try\r\n     {                                \r\n         await socket.ConnectAsync(context.DnsEndPoint, cts);\r\n         return new OverrideNetworkStream(socket);\r\n     }\r\n     catch (Exception e)\r\n     {\r\n         socket.Dispose();\r\n         throw;\r\n     }\r\n   \r\n }\r\n```\r\n\r\n\r\nOverrideNetworkStream override the NetworkStream.Dispose as a wokaround because Socket.InternalShutdown seems to be causing the LingerOptions to not work as expected\r\n```\r\n public class OverrideNetworkStream : NetworkStream\r\n {        \r\n     private Socket _socket;        \r\n     public OverrideNetworkStream(Socket socket) : base(socket, false)\r\n     {            \r\n         _socket = socket;            \r\n     }\r\n     private  object call(object o, string methodName, params object[] args)\r\n     {\r\n         var mi = o.GetType().GetMethod(methodName, System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);\r\n         if (mi != null)\r\n         {\r\n             return mi.Invoke(o, args);\r\n         }\r\n         return null;\r\n     }\r\n\r\n     protected override void Dispose(bool disposing)\r\n     {\r\n         //call(_socket, \"InternalShutdown\", SocketShutdown.Both); to reproduce the TIME_WAIT you should not comment this line\r\n\r\n         _socket.Close();\r\n         _socket.Dispose();\r\n         base.Dispose(disposing);                    \r\n     }\r\n }\r\n```\r\n\r\n### Expected behavior\r\n\r\nNetworkStream should respect LingerOptions\r\n\r\n### Actual behavior\r\n\r\nAs NetworkStream is calling Socket.InternalShutdown, LingerOption is not being respected and socket is leaking in TIME_WAIT state\r\n\r\n### Regression?\r\n\r\nOnly tested in .Net8 both in Windows and Linux\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\n_No response_\r\n\r\n### Other information\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOiPrkZw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6CihW_",
                                           "createdAt":  "2024-06-25T22:20:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-06-25T22:20:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Cja2v",
                                           "createdAt":  "2024-06-26T01:06:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "Why do you set `ownsSocket: false`? AFAIK the behavior can change based on the ownership. cc @tmds ",
                                           "updatedAt":  "2024-06-26T01:06:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6CjgfS",
                                           "createdAt":  "2024-06-26T01:32:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kaiohenrique",
                                           "body":  "Hi, @wfurt \r\nIn this case, I want to avoid the NetworkStream.Dispose to execute the [Socket.InternalShutdown method](https://github.com/dotnet/runtime/blob/release/8.0/src/libraries/System.Net.Sockets/src/System/Net/Sockets/NetworkStream.cs#L391). Overriding the NetworkStream.Dispose  method with `ownsSocket: false` and only performing the Socket.Close and Socket.Dispose seems to workaround the issue and LingerOption is correctly applied. Is that a valid workaround?\r\n",
                                           "updatedAt":  "2024-06-26T01:38:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Cqf95",
                                           "createdAt":  "2024-06-26T16:41:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kaiohenrique",
                                           "body":  "Hi, @wfurt  @tmds\r\nI need help to understand if avoiding [Socket.InternalShutdown](https://github.com/dotnet/runtime/blob/release/8.0/src/libraries/System.Net.Sockets/src/System/Net/Sockets/NetworkStream.cs#L391) is a valid workaround so LingerOption works as expected. In our tests, avoiding the call to Socket.InternalShutdownm with LingerOptions(true, 0) got rid of connections in time_wait state completly. Are we missing any side effect?\r\n\r\nConsider that requests has Connection:close to avoid connection pooling, a customer requeriment",
                                           "updatedAt":  "2024-06-26T16:46:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Cq8C8",
                                           "createdAt":  "2024-06-26T17:47:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kaiohenrique",
                                           "body":  "Update:\r\nI have seen this behavior\r\nLingerOption(true,0)\r\n\r\n_socket.Shutdown(SocketShutdown.Receive); //avoid time_wait and LingerOption is respected \r\n_socket.Shutdown(SocketShutdown.Send); //lots of sockets in time_wait\r\n_socket.Shutdown(SocketShutdown.Both); //lots of sockets in time_wait\r\n_socket.Close();\r\n_socket.Dispose();",
                                           "updatedAt":  "2024-06-26T18:01:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6DXg4K",
                                           "createdAt":  "2024-07-02T18:00:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "liveans",
                                           "body":  "Triage: Not critical for 9.0. Moving to the future.",
                                           "updatedAt":  "2024-07-02T18:00:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6DrOEO",
                                           "createdAt":  "2024-07-04T14:37:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "I can\u0027t reproduce this on Linux (Fedora 39).\r\n\r\nI\u0027m using this code to try to reproduce the issue:\r\n```cs\r\nstring host = args.Length \u003e 0 ? args[0] : \"www.microsoft.com\";\r\n\r\nfor (int i = 0; i \u003c 10; i++)\r\n{\r\n    Socket clientSocket = new Socket(SocketType.Stream, ProtocolType.Tcp)\r\n    {\r\n        NoDelay = true,\r\n        LingerState = new LingerOption(true, 0)\r\n    };\r\n\r\n    Console.WriteLine($\"Connecting to \u0027{host}\u0027\");\r\n    await clientSocket.ConnectAsync(new DnsEndPoint(host, 80));\r\n    System.Console.WriteLine($\"Connect succeeded from {clientSocket.LocalEndPoint}!\");\r\n\r\n    NetworkStream ns = new NetworkStream(clientSocket, ownsSocket: true);\r\n    ns.Dispose();\r\n    System.Console.WriteLine($\"Disposed.\");\r\n}\r\n```\r\n\r\nWhen I comment out the `LingerState = new LingerOption(true, 0)` line, I get sockets in the `TIME_WAIT` state when the program is done. When I keep the line, they are gone.",
                                           "updatedAt":  "2024-07-04T14:39:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6DyJPe",
                                           "createdAt":  "2024-07-05T14:16:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kaiohenrique",
                                           "body":  "Hi, @tmds\r\nAre you able to reproduce adding a Task.Delay after the loop?  ",
                                           "updatedAt":  "2024-07-05T14:16:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6I-uRn",
                                           "createdAt":  "2024-08-20T07:18:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "\u003e Are you able to reproduce adding a Task.Delay after the loop?\r\n\r\nNo, also when the program doesn\u0027t exit, setting the `new LingerOption(true, 0)` option results in there being no `TIME_WAIT` sockets.\r\n\r\nI can\u0027t reproduce the issue (on Fedora Linux).",
                                           "updatedAt":  "2024-08-20T07:19:25Z"
                                       }
                                   ],
                         "totalCount":  9
                     },
        "title":  "Socket.InternalShutdown is ignoring LingerOption",
        "labels":  [
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/104542",
        "createdAt":  "2024-07-08T11:21:41Z",
        "number":  104542,
        "author":  "yurai007",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-08T16:15:53Z",
        "body":  "There are 2 test cases from _ArgumentValidation_ tests that fails on Qemu due to [reported bug](https://gitlab.com/qemu-project/qemu/-/issues/2410):\r\n```\r\nSystem.Net.Sockets.Tests.ArgumentValidation.Connect_ConnectTwice_NotSupported(invalidatingAction: 1) [FAIL]\r\n      System.Net.Sockets.SocketException : Protocol not available\r\n      Stack Trace:\r\n        /runtime/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs(3737,0): at System.Net.Sockets.Socket.UpdateStatusAfterSocketErrorAndThrowException(SocketError error, Boolean disconnectOnFailure, String callerName)\r\n        /runtime/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs(3728,0): at System.Net.Sockets.Socket.UpdateStatusAfterSocketOptionErrorAndThrowException(SocketError error, String callerName)\r\n        /runtime/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs(3466,0): at System.Net.Sockets.Socket.SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, Int32 optionValue, Boolean silent)\r\n        /runtime/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs(1966,0): at System.Net.Sockets.Socket.SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, Int32 optionValue)\r\n        /home/d.jurczak2/runtime/src/libraries/System.Net.Sockets/tests/FunctionalTests/ArgumentValidationTests.cs(809,0): at System.Net.Sockets.Tests.ArgumentValidation.Connect_ConnectTwice_NotSupported(Int32 invalidatingAction)\r\n           at InvokeStub_ArgumentValidation.Connect_ConnectTwice_NotSupported(Object, Span`1)\r\n           at System.Reflection.MethodBaseInvoker.InvokeWithOneArg(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)\r\n```\r\n\r\n```\r\nSystem.Net.Sockets.Tests.ArgumentValidation.ConnectAsync_ConnectTwice_NotSupported(invalidatingAction: 1) [FAIL]\r\n      System.Net.Sockets.SocketException : Protocol not available\r\n      Stack Trace:\r\n        /runtime/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs(3737,0): at System.Net.Sockets.Socket.UpdateStatusAfterSocketErrorAndThrowException(SocketError error, Boolean disconnectOnFailure, String callerName)\r\n        /runtime/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs(3728,0): at System.Net.Sockets.Socket.UpdateStatusAfterSocketOptionErrorAndThrowException(SocketError error, String callerName)\r\n        /runtime/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs(3466,0): at System.Net.Sockets.Socket.SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, Int32 optionValue, Boolean silent)\r\n        /runtime/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs(1966,0): at System.Net.Sockets.Socket.SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, Int32 optionValue)\r\n        /home/d.jurczak2/runtime/src/libraries/System.Net.Sockets/tests/FunctionalTests/ArgumentValidationTests.cs(842,0): at System.Net.Sockets.Tests.ArgumentValidation.ConnectAsync_ConnectTwice_NotSupported(Int32 invalidatingAction)\r\n           at InvokeStub_ArgumentValidation.ConnectAsync_ConnectTwice_NotSupported(Object, Span`1)\r\n           at System.Reflection.MethodBaseInvoker.InvokeWithOneArg(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)\r\n```\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOg_MiUg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6D8yJS",
                                           "createdAt":  "2024-07-08T11:22:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-07-08T11:22:02Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "System.Net.Sockets.Tests.ArgumentValidation failures on Qemu",
        "labels":  [
                       "area-System.Net.Sockets",
                       "arch-riscv"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/104545",
        "createdAt":  "2024-07-08T12:31:15Z",
        "number":  104545,
        "author":  "yurai007",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-08T16:14:50Z",
        "body":  "There are 3 test cases from _KeepAliveTest_ tests that fails on Qemu due to [reported issue](https://gitlab.com/qemu-project/qemu/-/issues/2390) :\r\n\r\n```\r\nSystem.Net.Sockets.Tests.KeepAliveTest.Socket_Get_KeepAlive_Time_AsByteArray_OptionLengthZero_Failure [FAIL]\r\n      System.Net.Sockets.SocketException : Bad address\r\n      Stack Trace:\r\n        /runtime/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs(3737,0): at System.Net.Sockets.Socket.UpdateStatusAfterSocketErrorAndThrowException(SocketError error, Boolean disconnectOnFailure, String callerName)\r\n        /runtime/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs(3728,0): at System.Net.Sockets.Socket.UpdateStatusAfterSocketOptionErrorAndThrowException(SocketError error, String callerName)\r\n        /runtime/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs(2145,0): at System.Net.Sockets.Socket.GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, Int32 optionLength)\r\n        /home/d.jurczak2/runtime/src/libraries/System.Net.Sockets/tests/FunctionalTests/KeepAliveTest.cs(136,0): at System.Net.Sockets.Tests.KeepAliveTest.Socket_Get_KeepAlive_Time_AsByteArray_OptionLengthZero_Failure()\r\n\r\n           at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)\r\n        /runtime/src/libraries/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.cs(57,0): at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)\r\n \r\n\r\nSystem.Net.Sockets.Tests.KeepAliveTest.Socket_Get_KeepAlive_Time_AsByteArray_BufferNullOrTooSmall_Failure(buffer: null) [FAIL]\r\n      System.Net.Sockets.SocketException : Bad address\r\n      Stack Trace:\r\n        /runtime/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs(3737,0): at System.Net.Sockets.Socket.UpdateStatusAfterSocketErrorAndThrowException(SocketError error, Boolean disconnectOnFailure, String callerName)\r\n        /runtime/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs(3728,0): at System.Net.Sockets.Socket.UpdateStatusAfterSocketOptionErrorAndThrowException(SocketError error, String callerName)\r\n        /runtime/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs(2121,0): at System.Net.Sockets.Socket.GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, Byte[] optionValue)\r\n        /home/d.jurczak2/runtime/src/libraries/System.Net.Sockets/tests/FunctionalTests/KeepAliveTest.cs(156,0): at System.Net.Sockets.Tests.KeepAliveTest.Socket_Get_KeepAlive_Time_AsByteArray_BufferNullOrTooSmall_Failure(Byte[] buffer)\r\n\r\n           at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)\r\n        /runtime/src/libraries/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.cs(178,0): at System.Reflection.MethodBaseInvoker.InvokeDirectByRefWithFewArgs(Object obj, Span`1 copyOfArgs, BindingFlags invokeAttr)\r\n\r\nSystem.Net.Sockets.Tests.KeepAliveTest.Socket_Get_KeepAlive_Time_AsByteArray_BufferNullOrTooSmall_Failure(buffer: []) [FAIL]\r\n      System.Net.Sockets.SocketException : Bad address\r\n      Stack Trace:\r\n        /runtime/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs(3737,0): at System.Net.Sockets.Socket.UpdateStatusAfterSocketErrorAndThrowException(SocketError error, Boolean disconnectOnFailure, String callerName)\r\n        /runtime/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs(3728,0): at System.Net.Sockets.Socket.UpdateStatusAfterSocketOptionErrorAndThrowException(SocketError error, String callerName)\r\n        /runtime/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs(2121,0): at System.Net.Sockets.Socket.GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, Byte[] optionValue)\r\n        /home/d.jurczak2/runtime/src/libraries/System.Net.Sockets/tests/FunctionalTests/KeepAliveTest.cs(156,0): at System.Net.Sockets.Tests.KeepAliveTest.Socket_Get_KeepAlive_Time_AsByteArray_BufferNullOrTooSmall_Failure(Byte[] buffer)\r\n           at InvokeStub_KeepAliveTest.Socket_Get_KeepAlive_Time_AsByteArray_BufferNullOrTooSmall_Failure(Object, Span`1)\r\n           at System.Reflection.MethodBaseInvoker.InvokeWithOneArg(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOg_Y2tQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6D9ja1",
                                           "createdAt":  "2024-07-08T12:31:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-07-08T12:31:41Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "System.Net.Sockets.Tests.KeepAliveTest failures on Qemu",
        "labels":  [
                       "area-System.Net.Sockets",
                       "arch-riscv"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/104547",
        "createdAt":  "2024-07-08T12:38:12Z",
        "number":  104547,
        "author":  "yurai007",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-08T16:14:34Z",
        "body":  "There are 3 test cases from _SocketOptionNameTest_ tests that fails on Qemu:\r\n```\r\nSystem.Net.Sockets.Tests.SocketOptionNameTest.MulticastInterface_Set_AnyInterface_Succeeds [FAIL]\r\n      System.Net.Sockets.SocketException : Unknown socket error\r\n      Stack Trace:\r\n        /runtime/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs(3737,0): at System.Net.Sockets.Socket.UpdateStatusAfterSocketErrorAndThrowException(SocketError error, Boolean disconnectOnFailure, String callerName)\r\n        /runtime/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs(3728,0): at System.Net.Sockets.Socket.UpdateStatusAfterSocketOptionErrorAndThrowException(SocketError error, String callerName)\r\n        /runtime/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs(3479,0): at System.Net.Sockets.Socket.SetMulticastOption(SocketOptionName optionName, MulticastOption MR)\r\n        /runtime/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs(2021,0): at System.Net.Sockets.Socket.SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, Object optionValue)\r\n        /home/d.jurczak2/runtime/src/libraries/System.Net.Sockets/tests/FunctionalTests/SocketOptionNameTest.cs(96,0): at System.Net.Sockets.Tests.SocketOptionNameTest.MulticastInterface_Set_Helper(Int32 interfaceIndex)\r\n        /home/d.jurczak2/runtime/src/libraries/System.Net.Sockets/tests/FunctionalTests/SocketOptionNameTest.cs(71,0): at System.Net.Sockets.Tests.SocketOptionNameTest.MulticastInterface_Set_AnyInterface_Succeeds()\r\n        --- End of stack trace from previous location ---\r\n\r\nSystem.Net.Sockets.Tests.SocketOptionNameTest.MulticastOption_CreateSocketSetGetOption_GroupAndInterfaceIndex_SetSucceeds_GetThrows [FAIL]\r\n      System.Net.Sockets.SocketException : Unknown socket error\r\n      Stack Trace:\r\n        /runtime/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs(3737,0): at System.Net.Sockets.Socket.UpdateStatusAfterSocketErrorAndThrowException(SocketError error, Boolean disconnectOnFailure, String callerName)\r\n        /runtime/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs(3728,0): at System.Net.Sockets.Socket.UpdateStatusAfterSocketOptionErrorAndThrowException(SocketError error, String callerName)\r\n        /runtime/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs(3479,0): at System.Net.Sockets.Socket.SetMulticastOption(SocketOptionName optionName, MulticastOption MR)\r\n        /runtime/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs(2021,0): at System.Net.Sockets.Socket.SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, Object optionValue)\r\n        /home/d.jurczak2/runtime/src/libraries/System.Net.Sockets/tests/FunctionalTests/SocketOptionNameTest.cs(61,0): at System.Net.Sockets.Tests.SocketOptionNameTest.MulticastOption_CreateSocketSetGetOption_GroupAndInterfaceIndex_SetSucceeds_GetThrows()\r\n\r\n           at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)\r\n        /runtime/src/libraries/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.cs(57,0): at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)\r\n\r\nSystem.Net.Sockets.Tests.SocketOptionNameTest.MulticastInterface_Set_IPv6_AnyInterface_Succeeds [FAIL]\r\n      System.Net.Sockets.SocketException : Protocol not available\r\n      Stack Trace:\r\n        /runtime/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs(3737,0): at System.Net.Sockets.Socket.UpdateStatusAfterSocketErrorAndThrowException(SocketError error, Boolean disconnectOnFailure, String callerName)\r\n        /runtime/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs(3728,0): at System.Net.Sockets.Socket.UpdateStatusAfterSocketOptionErrorAndThrowException(SocketError error, String callerName)\r\n        /runtime/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs(3466,0): at System.Net.Sockets.Socket.SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, Int32 optionValue, Boolean silent)\r\n        /runtime/src/libraries/System.Net.Sockets/src/System/Net/Sockets/Socket.cs(1966,0): at System.Net.Sockets.Socket.SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, Int32 optionValue)\r\n        /home/d.jurczak2/runtime/src/libraries/System.Net.Sockets/tests/FunctionalTests/SocketOptionNameTest.cs(199,0): at System.Net.Sockets.Tests.SocketOptionNameTest.MulticastInterface_Set_IPv6_Helper(Int32 interfaceIndex)\r\n        /home/d.jurczak2/runtime/src/libraries/System.Net.Sockets/tests/FunctionalTests/SocketOptionNameTest.cs(129,0): at System.Net.Sockets.Tests.SocketOptionNameTest.MulticastInterface_Set_IPv6_AnyInterface_Succeeds()\r\n        --- End of stack trace from previous location ---\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOg_ZxoQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6D9nGh",
                                           "createdAt":  "2024-07-08T12:38:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-07-08T12:38:38Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "System.Net.Sockets.Tests.SocketOptionNameTest failures on Qemu",
        "labels":  [
                       "area-System.Net.Sockets",
                       "arch-riscv"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/106149",
        "createdAt":  "2024-08-08T17:58:03Z",
        "number":  106149,
        "author":  "lkhore",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-08-22T12:32:35Z",
        "body":  "### Description\r\n\r\nTcpClient not working with Maui when there is multiple connection like with wifi and mobile internet so TcpClient always connect to mobile internet not with wifi local n/w like below code\r\n\r\n```csharp\r\npublic async Task ConnectUsingTcpClientAsync(string serverAddress, int port)\r\n{\r\n    var localAddress = IPAddress.Parse(\"192.168.0.100\");\r\n    // Create a socket and bind it to the local address\r\n    var localEndPoint = new IPEndPoint(localAddress, 0);\r\n    using (var socket = new Socket(AddressFamily.InterNetwork, System.Net.Sockets.SocketType.Stream, ProtocolType.Tcp))\r\n    {\r\n        // Bind the socket to the local IP address\r\n        socket.Bind(localEndPoint);\r\n\r\n        // Create TcpClient using the socket\r\n        using (var client = new TcpClient(new IPEndPoint(IPAddress.Any, 0)))\r\n        {\r\n            // Assign the socket to TcpClient\r\n            client.Client = socket;\r\n\r\n            try\r\n            {\r\n                // Connect to the server\r\n                await client.ConnectAsync(serverAddress, port);\r\n                Console.WriteLine(\"Connected successfully over the specified network interface.\");\r\n            }\r\n            catch (SocketException ex)\r\n            {\r\n                Console.WriteLine($\"Connection error: {ex.Message}\");\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n\r\n### Steps to Reproduce\r\n\r\n_No response_\r\n\r\n### Link to public reproduction project repository\r\n\r\n_No response_\r\n\r\n### Version with bug\r\n\r\n8.0.80 SR8\r\n\r\n### Is this a regression from previous behavior?\r\n\r\nYes, this used to work in .NET MAUI\r\n\r\n### Last version that worked well\r\n\r\n8.0.0-rc.1.9171\r\n\r\n### Affected platforms\r\n\r\nAndroid\r\n\r\n### Affected platform versions\r\n\r\n_No response_\r\n\r\n### Did you find any workaround?\r\n\r\nno\r\n\r\n### Relevant log output\r\n\r\n```shell\r\nthere is no output file\r\n```\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOiVy9_g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6Hr1Oj",
                                           "createdAt":  "2024-08-08T18:24:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODtT6kQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "lkhore",
                                                                               "createdAt":  "2024-08-08T18:37:12Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jfversluis",
                                           "body":  "Don\u0027t see anything MAUI specific here. I would think this is a runtime issue then.",
                                           "updatedAt":  "2024-08-08T18:24:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Hr1V0",
                                           "createdAt":  "2024-08-08T18:24:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-08-08T18:24:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6HsmnE",
                                           "createdAt":  "2024-08-08T20:40:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "why do you `Bind` on specific IP? I\u0027m not sure about android but generally this will limit outgoing interface AFAIK.\r\nThe routing logic is handled by OS kernel and besides the bind I don;t see anything that can be impacted but .NET Sockets.\r\ncc @simonrozsival   ",
                                           "updatedAt":  "2024-08-08T20:40:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Hukr-",
                                           "createdAt":  "2024-08-09T04:31:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lkhore",
                                           "body":  "I have scenarios where my mobile device is simultaneously connected to both Wi-Fi and mobile internet. The Wi-Fi network doesn\u0027t have internet access but is connected to IoT devices, so I need to make sure that calls are routed through the Wi-Fi network interface. However, the device often defaults to using the mobile internet connection instead.",
                                           "updatedAt":  "2024-08-09T04:31:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6IcyH2",
                                           "createdAt":  "2024-08-14T16:28:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "simonrozsival",
                                           "body":  "@lkhore I wasn\u0027t able to reproduce this issue on my Android device (Samsung, API 34). I can successfully connect to the server with your code snippet. Can you share more information about your setup?",
                                           "updatedAt":  "2024-08-14T16:28:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6IdXTi",
                                           "createdAt":  "2024-08-14T17:24:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lkhore",
                                           "body":  "I have a Redmi 12 5G. First, I need to enable mobile data on my device and then connect to a Wi-Fi network that doesn\u0027t have internet access but does have IoT capabilities. Both mobile data and Wi-Fi should be connected simultaneously. After that, when I try to create a TcpClient connection over the Wi-Fi, there\u0027s no connection because the network traffic is being routed through mobile data instead of the Wi-Fi.\"",
                                           "updatedAt":  "2024-08-14T17:24:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Iinxh",
                                           "createdAt":  "2024-08-15T06:55:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "simonrozsival",
                                           "body":  "\u003e there\u0027s no connection because the network traffic is being routed through mobile data instead of the Wi-Fi\r\n\r\nCan you confirm that when you try running `adb shell ping \u003cserver-address\u003e` and `adb shell ping -I wlan0 \u003cserver-address\u003e`, the device can actually reach the server?\r\n\r\nCan you also please give us more details about what exactly isn\u0027t working? Is `ConnectAsync` never awaited or does it throw an exception? If it throws an exception, please share it with the stack trace.",
                                           "updatedAt":  "2024-08-15T06:55:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Iitxd",
                                           "createdAt":  "2024-08-15T07:18:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lkhore",
                                           "body":  "Below are the ping result \r\nC:\\Users\\LKhore\u003eadb shell ping -I wlan0  192.168.0.1\r\nping: SO_BINDTODEVICE: Operation not permitted\r\n\r\nC:\\Users\\LKhore\u003eadb shell ping 192.168.0.1\r\n\r\n\r\n\r\nadb shell ping 192.168.0.1 is not gave any result\r\n\r\nBelow is the exception i got from code snippet\r\n\r\n{System.Net.Sockets.SocketException (110): Connection timed out\r\n   at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.ThrowException(SocketError error, CancellationToken cancellationToken)\r\n   at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.System.Threading.Tasks.Sources.IValueTaskSource.GetResult(Int16 token)\r\n   at System.Threading.Tasks.ValueTask.ValueTaskSourceAsTask.\u003c\u003ec.\u003c.cctor\u003eb__4_0(Object state)\r\n--- End of stack trace from previous location ---\r\n   at System.Net.Sockets.TcpClient.CompleteConnectAsync(Task task)\r\n   at MauiMobileAppServices.MainPage.ConnectUsingTcpClientAsync(String serverAddress, Int32 port) in D:\\Repo\\KKService8\\MauiMobileAppServices\\MainPage.xaml.cs:line 138}\r\n\r\n\r\n\r\n\r\n",
                                           "updatedAt":  "2024-08-15T07:44:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6IkKc8",
                                           "createdAt":  "2024-08-15T12:30:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "simonrozsival",
                                           "body":  "I am not able to replicate your network setup here, but I am able to bind `ping` to a specific network interface:\r\n```bash\r\nSimons-MacBook @ ~   \r\n\u003e_ adb shell ping -c 1 1.1.1.1\r\nPING 1.1.1.1 (1.1.1.1) 56(84) bytes of data.\r\n64 bytes from 1.1.1.1: icmp_seq=1 ttl=58 time=44.2 ms\r\n\r\n--- 1.1.1.1 ping statistics ---\r\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\r\nrtt min/avg/max/mdev = 44.284/44.284/44.284/0.000 ms\r\n\r\nSimons-MacBook @ ~   \r\n\u003e_ adb shell ping -c 1 -I wlan0 1.1.1.1\r\nPING 1.1.1.1 (1.1.1.1) from 10.105.96.84 wlan0: 56(84) bytes of data.\r\n\r\n--- 1.1.1.1 ping statistics ---\r\n1 packets transmitted, 0 received, 100% packet loss, time 0ms\r\n\r\nSimons-MacBook @ ~   \r\n\u003e_ adb shell ping -c 1 -I rmnet_data0 1.1.1.1\r\nPING 1.1.1.1 (1.1.1.1) from 10.82.253.40 rmnet_data0: 56(84) bytes of data.\r\n64 bytes from 1.1.1.1: icmp_seq=1 ttl=58 time=382 ms\r\n\r\n--- 1.1.1.1 ping statistics ---\r\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\r\nrtt min/avg/max/mdev = 382.329/382.329/382.329/0.000 ms\r\n\r\nSimons-MacBook @ ~   \r\n\u003e_ adb shell ping -c 1 -I rmnet_data2 1.1.1.1\r\nPING 1.1.1.1 (1.1.1.1) from 10.144.57.214 rmnet_data2: 56(84) bytes of data.\r\n\r\n--- 1.1.1.1 ping statistics ---\r\n1 packets transmitted, 0 received, 100% packet loss, time 0ms\r\n```\r\n\r\nIt seems that your device doesn\u0027t permit binding to a specific network interface. If you can\u0027t bind with `ping` in shell, I wouldn\u0027t expect you to be able to do so in .NET.\r\n\r\nAlso, it seems that your IoT device is not reachable from your phone if you can\u0027t ping it without restricting the interface. I suspect there is some problem in your networking setup (firewall?) that prevents you from talking to the other device and that makes me believe the issue is not specific to .NET.",
                                           "updatedAt":  "2024-08-15T12:31:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6IkSCH",
                                           "createdAt":  "2024-08-15T12:52:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lkhore",
                                           "body":  "But I can ping when i connect with the same wifi only without connecting to the internet and also this can be reproducible in some other mobile as well.",
                                           "updatedAt":  "2024-08-15T12:57:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6I25ZX",
                                           "createdAt":  "2024-08-19T09:23:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "simonrozsival",
                                           "body":  "\u003e But I can ping when i connect with the same wifi only without connecting to the internet and also this can be reproducible in some other mobile as well.\r\n\r\nI must admit I\u0027m a little confused. In your previous comment, based on the output you posted, ping wasn\u0027t able to reach `192.168.0.1`. What is the scenario in which you are able to ping that IP address? I don\u0027t see how being connected to the internet can affect whether you can access a device on a local network or not.",
                                           "updatedAt":  "2024-08-19T09:23:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6I98la",
                                           "createdAt":  "2024-08-20T04:26:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lkhore",
                                           "body":  "When I ping while connected to both Wi-Fi and mobile internet simultaneously, it doesn\u0027t work. However, when I\u0027m connected to only Wi-Fi, it works fine.",
                                           "updatedAt":  "2024-08-20T04:26:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6JEYou",
                                           "createdAt":  "2024-08-20T19:39:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "that seems like problem with your local setup. The routing is done by OS kernel and it _should_ follow the most specific route e.g. it should see your local LAN subnet directly connected. ",
                                           "updatedAt":  "2024-08-20T19:39:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6JXL3-",
                                           "createdAt":  "2024-08-22T12:32:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lkhore",
                                           "body":  "just to clarify confusion below are details of the phone i am using for testing and  responses of ping command along with list of available interfaces:\r\n \r\nIssue : not able to bind ping to any particular interface, getting error of **\"SO_BINDTODEVICE: Operation not permitted\"**\r\n \r\nRequirement : we would like to connect to socket available on Wi-Fi interface(which does not have internet i.e local network) where phone has been connected to internet over differnet interface (either Cellular or USB)\r\n\r\n ```\r\n\r\nC:\\Users\\**\u003eadb shell \"echo \u0027Model: \u0027 $(getprop ro.product.model) \u0026\u0026 echo \u0027Product Name: \u0027 $(getprop ro.product.name) \u0026\u0026 echo \u0027Manufacturer: \u0027 $(getprop ro.product.manufacturer) \u0026\u0026 echo \u0027Brand: \u0027 $(getprop ro.product.brand)\"\r\nModel:  22111317I\r\nProduct Name:  sunstone_in\r\nManufacturer:  Xiaomi\r\nBrand:  Redmi\r\n\r\nsunstone:/ $ ifconfig\r\nrmnet_data1 Link encap:UNSPEC\r\n          inet6 addr: 2402:8100:7076:7243:4800:72ff:fee7:c6f6/64 Scope: Global\r\n          inet6 addr: fe80::4800:72ff:fee7:c6f6/64 Scope: Link\r\n          UP RUNNING  MTU:1600  Metric:1\r\n          RX packets:75734 errors:0 dropped:0 overruns:0 frame:0\r\n          TX packets:86695 errors:0 dropped:0 overruns:0 carrier:0\r\n          collisions:0 txqueuelen:1000\r\n          RX bytes:78883027 TX bytes:16100929\r\n\r\nrmnet_data2 Link encap:UNSPEC\r\n          inet addr:100.96.89.24  Mask:255.255.255.240\r\n          inet6 addr: fe80::3c21:a3ff:fe9a:717a/64 Scope: Link\r\n          inet6 addr: 2402:8100:3872:402e:3c21:a3ff:fe9a:717a/64 Scope: Global\r\n          UP RUNNING  MTU:1500  Metric:1\r\n          RX packets:171724 errors:0 dropped:0 overruns:0 frame:0\r\n          TX packets:160670 errors:0 dropped:0 overruns:0 carrier:0\r\n          collisions:0 txqueuelen:1000\r\n          RX bytes:385559502 TX bytes:26803534\r\n\r\nwlan0     Link encap:UNSPEC    Driver icnss2\r\n          inet addr:192.168.0.100  Bcast:192.168.0.255  Mask:255.255.255.0\r\n          inet6 addr: fe80::fc76:c0ff:fee4:e58f/64 Scope: Link\r\n          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\r\n          RX packets:24940278 errors:0 dropped:0 overruns:0 frame:0\r\n          TX packets:6749812 errors:0 dropped:84 overruns:0 carrier:0\r\n          collisions:0 txqueuelen:3000\r\n          RX bytes:22953859392 TX bytes:1501244968\r\n\r\nrmnet_data0 Link encap:UNSPEC\r\n          inet6 addr: fe80::bcf6:cdff:fef8:4230/64 Scope: Link\r\n          UP RUNNING  MTU:1500  Metric:1\r\n          RX packets:933 errors:0 dropped:0 overruns:0 frame:0\r\n          TX packets:895 errors:0 dropped:0 overruns:0 carrier:0\r\n          collisions:0 txqueuelen:1000\r\n          RX bytes:62796 TX bytes:60546\r\n\r\ndummy0    Link encap:UNSPEC\r\n          inet6 addr: fe80::ac84:cdff:fe57:918e/64 Scope: Link\r\n          UP BROADCAST RUNNING NOARP  MTU:1500  Metric:1\r\n          RX packets:0 errors:0 dropped:0 overruns:0 frame:0\r\n          TX packets:25846 errors:0 dropped:0 overruns:0 carrier:0\r\n          collisions:0 txqueuelen:1000\r\n          RX bytes:0 TX bytes:3885086\r\n\r\nrmnet_ipa0 Link encap:UNSPEC\r\n          UP RUNNING  MTU:9216  Metric:1\r\n          RX packets:358680 errors:0 dropped:0 overruns:0 frame:0\r\n          TX packets:722928 errors:0 dropped:0 overruns:0 carrier:0\r\n          collisions:0 txqueuelen:1000\r\n          RX bytes:737258715 TX bytes:107416317\r\n\r\nlo        Link encap:UNSPEC\r\n          inet addr:127.0.0.1  Mask:255.0.0.0\r\n          inet6 addr: ::1/128 Scope: Host\r\n          UP LOOPBACK RUNNING  MTU:65536  Metric:1\r\n          RX packets:2362668 errors:0 dropped:0 overruns:0 frame:0\r\n          TX packets:2362668 errors:0 dropped:0 overruns:0 carrier:0\r\n          collisions:0 txqueuelen:1000\r\n          RX bytes:5875957605 TX bytes:5875957605\r\n\r\nsunstone:/ $ ^C\r\n130|sunstone:/ $ ^C\r\n130|sunstone:/ $ exit\r\n\r\nC:\\Users\\LKhore\u003eadb shell ping -c 1 -I wlan0 192.168.0.1\r\nping: SO_BINDTODEVICE: Operation not permitted\r\n\r\nC:\\Users\\LKhore\u003eadb shell ping -c 1 -I rmnet_data0 1.1.1.1\r\nping: SO_BINDTODEVICE: Operation not permitted\r\n\r\nC:\\Users\\LKhore\u003eadb shell ping -c 1 -I rmnet_data0\r\n\r\nC:\\Users\\LKhore\u003eadb shell ping -c 1 1.1.1.1\r\nPING 1.1.1.1 (1.1.1.1) 56(84) bytes of data.\r\n64 bytes from 1.1.1.1: icmp_seq=1 ttl=57 time=257 ms\r\n\r\n--- 1.1.1.1 ping statistics ---\r\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\r\nrtt min/avg/max/mdev = 257.526/257.526/257.526/0.000 ms\r\n\r\nC:\\Users\\LKhore\u003eadb shell ping -c 1 192.168.0.1\r\nPING 192.168.0.1 (192.168.0.1) 56(84) bytes of data.\r\n\r\n--- 192.168.0.1 ping statistics ---\r\n1 packets transmitted, 0 received, 100% packet loss, time 0ms\r\n\r\n\r\n```\r\n\r\n\r\n\r\n",
                                           "updatedAt":  "2024-08-22T12:32:33Z"
                                       }
                                   ],
                         "totalCount":  14
                     },
        "title":  "TcpClient not working with maui when there is multiple connection",
        "labels":  [
                       "question",
                       "area-System.Net.Sockets",
                       "os-android"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/108363",
        "createdAt":  "2024-09-29T04:34:41Z",
        "number":  108363,
        "author":  "ElectricVampire",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC7loOQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "alexkeh",
                                            "createdAt":  "2024-10-05T14:16:28Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2024-11-04T07:14:56Z",
        "body":  "### Description\r\n\r\n**UseCase**\r\nI am trying to add oracle support in query plan [visualizer visual studio extension](https://github.com/Giorgi/EFCore.Visualizer/tree/main?tab=readme-ov-file#oracle). The issue I am facing is that [connection.Open()](https://github.com/Giorgi/EFCore.Visualizer/blob/main/src/IQueryableObjectSource/DatabaseProvider.cs#L19) is taking 7 seconds which is timing out the debug visualizer.\r\nExact same connection.Open take milliseconds when done in without visualizer and I am able to reproduce this all the time.\r\n\r\nIn following image(Oracle traces showing difference between fast and slow use case) you can see for slower use case `ConnectIterate` takes 7 seconds which seems to be simple `BeginConnect` call on `TcpClient`\r\n![image](https://github.com/user-attachments/assets/f8c5c466-a83c-43d4-9113-d4d55ea291d9)\r\n\r\nI also enabled .Net Diagnostics events which shows where those missing 7 seconds went, between slow and fast .net traces, I can see in slower case GetOrAllocateThreadPoolBoundHandle took 7 Seconds which I think went for `ThreadPoolBoundHandle.BindHandle(this)` but why its not executed in faster use case and why its executed in slower use case.\r\n\r\n```\r\n03:45:03.1876310[ConnectStart] address: InterNetwork:16:{5,241,127,0,0,1,0,0,0,0,0,0,0,0}\r\n03:45:03.1880221[Info] thisOrContextObject: SafeSocketHandle#14421545, memberName: GetOrAllocateThreadPoolBoundHandle, message: calling ThreadPool.BindHandle()\r\n03:45:10.7995167[Connected] localEp: IPEndPoint#922213090, remoteEp: (null), socketHash: 33163964\r\n```\r\n**Problem:**\r\nWhen `connection.Open` happens from VS debugger it times out because it has 5 second limit and for every connection.Open it takes 7 seconds because of `GetOrAllocateThreadPoolBoundHandle`. Need a solution by which this can be reduced.\r\n\r\n### Reproduction Steps\r\n\r\nWe should be able to reproduced it all the time. Just doing connection.Open inside your code is very past but done [via visualizer]([connection.Open()](https://github.com/Giorgi/EFCore.Visualizer/blob/main/src/IQueryableObjectSource/DatabaseProvider.cs#L19)), it\u0027s very slow even when its the same process.\r\nI have attached .net trace and oracle trace. Oracle trace can provide you details on thread level information.\r\n\r\n[fast_net.txt](https://github.com/user-attachments/files/17177587/fast_net.txt)\r\n[fast_oracle.txt](https://github.com/user-attachments/files/17177588/fast_oracle.txt)\r\n[slow_net.txt](https://github.com/user-attachments/files/17177589/slow_net.txt)\r\n[slow_oracle.txt](https://github.com/user-attachments/files/17177590/slow_oracle.txt)\r\n\r\n**Sample App:**\r\nReplace your oracle connection string. Now here query returns immediately.\r\n[EfCoreTesting.zip](https://github.com/user-attachments/files/17177613/EfCoreTesting.zip)\r\n\r\nInstall vsix after building https://github.com/Giorgi/EFCore.Visualizer or just install from following zip file\r\n[EfCoreVisualizerExtension.zip](https://github.com/user-attachments/files/17177623/EfCoreVisualizerExtension.zip)\r\n\r\nAfter installing if you inspect query in visualizer it will timeout\r\n![image](https://github.com/user-attachments/assets/271d16ec-7ee4-4084-9c3b-ef8ee6dc557f)\r\n\r\n\r\n### Expected behavior\r\n\r\nGetOrAllocateThreadPoolBoundHandle should return immediately as it did in fast use case\r\n\r\n### Actual behavior\r\n\r\nGetOrAllocateThreadPoolBoundHandle takes 7 seconds\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\nNope\r\n\r\n### Configuration\r\n\r\n_No response_\r\n\r\n### Other information\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOkkSCbg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6N7vmI",
                                           "createdAt":  "2024-09-29T07:55:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MihaZupan",
                                           "body":  "\u003e 03:45:03.1876310[ConnectStart]\r\n\u003e 03:45:03.1880221[Info] message: calling ThreadPool.BindHandle()\r\n\u003e 03:45:10.7995167[Connected]\r\n\r\n\u003e I can see in slower case GetOrAllocateThreadPoolBoundHandle took 7 Seconds\r\n\r\nThat\u0027s not what those logs are implying. These are merely timestamps at different places in the code, so all you can glean from them is that you\u0027ve reached this line of code at some point:\r\nhttps://github.com/dotnet/runtime/blob/ba9b3ba83603d1f54c00c45a87344568d4277966/src/libraries/System.Net.Sockets/src/System/Net/Sockets/SafeSocketHandle.Windows.cs#L49\r\nand then 7 seconds later you got a connection, not that that specific call took 7 seconds.\r\n\r\nYou should be able to see how long the connection attempt took outside of .NET itself if you collect a network capture (e.g. Wireshark).",
                                           "updatedAt":  "2024-09-29T07:55:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6N78yM",
                                           "createdAt":  "2024-09-29T10:33:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ElectricVampire",
                                           "body":  "\u003e \u003e 03:45:03.1876310[ConnectStart]\r\n\u003e \u003e 03:45:03.1880221[Info] message: calling ThreadPool.BindHandle()\r\n\u003e \u003e 03:45:10.7995167[Connected]\r\n\u003e \r\n\u003e \u003e I can see in slower case GetOrAllocateThreadPoolBoundHandle took 7 Seconds\r\n\u003e \r\n\u003e That\u0027s not what those logs are implying. These are merely timestamps at different places in the code, so all you can glean from them is that you\u0027ve reached this line of code at some point:\r\n\u003e \r\n\u003e https://github.com/dotnet/runtime/blob/ba9b3ba83603d1f54c00c45a87344568d4277966/src/libraries/System.Net.Sockets/src/System/Net/Sockets/SafeSocketHandle.Windows.cs#L49\r\n\u003e \r\n\u003e \r\n\u003e and then 7 seconds later you got a connection, not that that specific call took 7 seconds.\r\n\u003e You should be able to see how long the connection attempt took outside of .NET itself if you collect a network capture (e.g. Wireshark).\r\n\r\n@MihaZupan \r\nThanks for guidance. I took the traces between slow and fast use case. \r\n[fast.pcapng.txt](https://github.com/user-attachments/files/17178895/fast.pcapng.txt)\r\n[slow.pcapng.txt](https://github.com/user-attachments/files/17178896/slow.pcapng.txt)\r\n \r\nI compared both cases and couldn\u0027t relate it to C# code on why one is always slow and another one is always fast. @MihaZupan Will really appreciate your help here\r\n![image](https://github.com/user-attachments/assets/d3fd9f47-fc87-41d7-b0ad-25fd47df443b)\r\n",
                                           "updatedAt":  "2024-09-29T10:36:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6OPfvd",
                                           "createdAt":  "2024-10-01T16:10:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "so the second capture has RST as the fist packet. It seems like there was some previous connection? And do you connect by name or IP address? It may be worth of trying to create small repro e.g. remove all the unnecessary layers to simplify the investigation. ",
                                           "updatedAt":  "2024-10-01T16:10:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6OwOVq",
                                           "createdAt":  "2024-10-05T10:10:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ElectricVampire",
                                           "body":  "\u003e so the second capture has RST as the fist packet. It seems like there was some previous connection? And do you connect by name or IP address? It may be worth of trying to create small repro e.g. remove all the unnecessary layers to simplify the investigation.\r\n\r\nI tested with both(same result), in this particular example its IP. It will be difficult to break down all the layers of code as its within Oracle and I don\u0027t have source code\r\nI also created a ticket with Oracle for this for which a bug is being created, hopefully they can better investigate this.\r\nhttps://github.com/oracle/dotnet-db-samples/issues/412",
                                           "updatedAt":  "2024-10-05T10:10:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6PREB5",
                                           "createdAt":  "2024-10-09T23:28:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ScotMac",
                                           "body":  "Yes, the RST is is for a totally different connection, as seen by the different source port.\n\nHowever, the rest of the wireshark traces combined with the ODP traces show this to be a .NET problem, where there is an 8 second delay from TcpClient.Connect. ie:\n\n* Call TcpClient.BeginConnect\n   =\u003e 5.688: SYN sent :\n   \u003c= 5.688: SYN, ACK\n   =\u003e 5.688: ACK\n****** 8 second delay ******\n* Return from WaitOne\n=\u003e 13.607 Send NS connect packet\n\nODP trace shows:\n\n2024-10-04 21:37:09.896510 TID:13  (NET)       (CID1) Trying (address=147.154.27.228) (port=1522)\n2024-10-04 21:37:17.403137 TID:13  (NET) (EXT) (CID1) TcpTransportAdapter.ConnectIterate()\n \nNote, that \"(NET) (EXT) (CID1) TcpTransportAdapter.ConnectIterate()\" trace happens immediately after the return from the TcpClient.BeginConnect/WaitOne, and therefore should have a timestamp close to the \"Trying (address= ...\" timestamp. The fact that it is 7 seconds later means control was not returned from TcpClient.Connect/WaitOne to ODP.\n\n ie, if the issue was an ODP code problem, then the timestamp for \"(NET) (EXT) (CID1) TcpTransportAdapter.ConnectIterate()\" would be not long after the \"Trying (address\" and we would see a LATER delay in the traces from later ODP statements.\n\nSpecifically, it appears after the tcp 3-way handshake, TcpClient does not return control to ODP for around 8 seconds (in the wireshark trace), and 7 seconds in the ODP trace.",
                                           "updatedAt":  "2024-10-09T23:28:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6SRIJu",
                                           "createdAt":  "2024-11-04T07:14:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ElectricVampire",
                                           "body":  "Any update on this?\n",
                                           "updatedAt":  "2024-11-04T07:14:55Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "GetOrAllocateThreadPoolBoundHandle is too slow in certain use case",
        "labels":  [
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/108421",
        "createdAt":  "2024-10-01T05:19:31Z",
        "number":  108421,
        "author":  "Santoshramani",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-10-17T18:28:59Z",
        "body":  "### Description\n\nI have TCP socket to receive IP camera stream(Playback data) via NVR. Implementation of data read from socket was working fine in xamarin native build but now in dotnet 8 build as soon as app starts receiving data from socket connection getting reset as seen in pcap. \r\nMy finding is this is because of socket buffer size is 2kb(as per mSocket.ReceiveBufferSize returns) only.\r\nAlso setting expected receive buffer size to socket does\u0027t helping.\n\n### Reproduction Steps\n\nCreate bulk data reading socket using dotnet 8 SDK for android project.\n\n### Expected behavior\n\nSocket should not reset connection when transferring bulk data.\n\n### Actual behavior\n\nSocket connection getting reset when transferring bulk data.\n\n### Regression?\n\nSocket was working fine for bulk data in xamarin native build.\n\n### Known Workarounds\n\nIncreasing receive buffer size of socket may help.\n\n### Configuration\n\n```\r\n.NET SDK:\r\n Version:           8.0.401\r\n Commit:            811edcc344\r\n Workload version:  8.0.400-manifests.56cd0383\r\n MSBuild version:   17.11.4+37eb419ad\r\n\r\nRuntime Environment:\r\n OS Name:     Mac OS X\r\n OS Version:  14.6\r\n OS Platform: Darwin\r\n RID:         osx-arm64\r\n Base Path:   /usr/local/share/dotnet/sdk/8.0.401/\r\n\r\n.NET workloads installed:\r\nConfigured to use loose manifests when installing new manifests.\r\n [ios]\r\n   Installation Source: SDK 8.0.400\r\n   Manifest Version:    17.5.8020/8.0.100\r\n   Manifest Path:       /usr/local/share/dotnet/sdk-manifests/8.0.100/microsoft.net.sdk.ios/17.5.8020/WorkloadManifest.json\r\n   Install Type:        FileBased\r\n\r\n [android]\r\n   Installation Source: SDK 8.0.400\r\n   Manifest Version:    34.0.113/8.0.100\r\n   Manifest Path:       /usr/local/share/dotnet/sdk-manifests/8.0.100/microsoft.net.sdk.android/34.0.113/WorkloadManifest.json\r\n   Install Type:        FileBased\r\n\r\n\r\nHost:\r\n  Version:      8.0.8\r\n  Architecture: arm64\r\n  Commit:       08338fcaa5\r\n\r\n.NET SDKs installed:\r\n  8.0.303 [/usr/local/share/dotnet/sdk]\r\n  8.0.401 [/usr/local/share/dotnet/sdk]\r\n\r\n.NET runtimes installed:\r\n  Microsoft.AspNetCore.App 6.0.32 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 7.0.20 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 8.0.0 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 8.0.7 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 8.0.8 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 6.0.32 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 7.0.20 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 8.0.0 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 8.0.7 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 8.0.8 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]\r\n\r\nOther architectures found:\r\n  None\r\n\r\nEnvironment variables:\r\n  Not set\r\n\r\nglobal.json file:\r\n  Not found\r\n```\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOkEIRrA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6OJu9y",
                                           "createdAt":  "2024-10-01T06:36:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD0YarQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_DOWN",
                                                                               "user":  "punchready",
                                                                               "createdAt":  "2024-10-01T08:41:04Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_DOWN",
                                                                               "user":  "rzikm",
                                                                               "createdAt":  "2024-10-01T10:27:22Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_DOWN",
                                                                               "user":  "karelz",
                                                                               "createdAt":  "2024-10-02T05:06:58Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "Santoshramani",
                                           "body":  "@karelz @vitek-karas @akoeplinger please look into this issue.",
                                           "updatedAt":  "2024-10-01T06:38:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6OLpjm",
                                           "createdAt":  "2024-10-01T10:30:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD0SURg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "karelz",
                                                                               "createdAt":  "2024-10-01T17:33:03Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "rzikm",
                                           "body":  "@Santoshramani Please don\u0027t tag individual people. The bot takes care of notifying the right team.\r\n\r\n\u003e My finding is this is because of socket buffer size is 2kb(as per mSocket.ReceiveBufferSize returns) only.\r\n\r\nHow do you know this? Does increasing the receive buffer size reliably resolve the issue?\r\n\r\n\u003e in dotnet 8 build as soon as app starts receiving data from socket connection getting reset as seen in pcap.\r\n\r\nIs the socket being reset by the remote peer (the camera?) or locally (by the application)? Can you share the network captures for us to investigate?",
                                           "updatedAt":  "2024-10-01T10:30:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6OMCLB",
                                           "createdAt":  "2024-10-01T11:23:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Santoshramani",
                                           "body":  "@rzikm \r\n\r\n\u003e Please don\u0027t tag individual people. The bot takes care of notifying the right team.\r\n\r\nI need solution as soon as possible that\u0027s why i\u0027ve tagged them, because i\u0027ve to upload my app to playstore as soon as possible due to their policies.\r\n\r\n\u003e How do you know this? Does increasing the receive buffer size reliably resolve the issue?\r\n\r\nYes i\u0027ve tried increasing receive buffer size but that doesn\u0027t had any effect in performance.\r\n\r\n\u003e Is the socket being reset by the remote peer (the camera?) or locally (by the application)? Can you share the network captures for us to investigate?\r\n\r\nSocket is being reset by the application.\r\nSorry i can\u0027t share pcap as i don\u0027t have it now but When socket gets reset at that time packet just before reset is \u0027TCP Window Full\u0027. ",
                                           "updatedAt":  "2024-10-01T11:23:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6OMFDL",
                                           "createdAt":  "2024-10-01T11:29:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "Could you please try this with .NET 9 RC 1 - it\u0027s very possible we fixed it there - https://github.com/dotnet/runtime/pull/104726.",
                                           "updatedAt":  "2024-10-01T11:29:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6OMjmW",
                                           "createdAt":  "2024-10-01T12:32:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Santoshramani",
                                           "body":  "@vitek-karas Yes i\u0027ve already tried using SDK 9 RC 1 but also not working with it.",
                                           "updatedAt":  "2024-10-01T12:32:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6OOb_V",
                                           "createdAt":  "2024-10-01T14:33:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "/cc @simonrozsival ",
                                           "updatedAt":  "2024-10-01T14:33:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6OPK4k",
                                           "createdAt":  "2024-10-01T15:32:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "simonrozsival",
                                           "body":  "@Santoshramani hi! would you be able to create a repro project? I\u0027m not able to reproduce this issue on my end based on the issue description.",
                                           "updatedAt":  "2024-10-01T15:32:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6OPXTy",
                                           "createdAt":  "2024-10-01T15:55:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "note that the socket buffer size should not impact the behavior. When it is getting full it will shrink TCP windows size. Also is there SSL involved or was this only plain socket? And if you use async mace cure you handle cases when the read is finished synchronously - something that did not happen (often) with older .NET releases. ",
                                           "updatedAt":  "2024-10-01T15:55:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6OQGzL",
                                           "createdAt":  "2024-10-01T17:36:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "@Santoshramani \r\n\r\n\u003e I need solution as soon as possible that\u0027s why i\u0027ve tagged them, because i\u0027ve to upload my app to playstore as soon as possible due to their policies.\r\n\r\nWe do not provide \"online\" / ASAP support on GitHub. If you have (paid) official Microsoft support, please reach out to them.\r\nWe can try to do our best, but you should not expect magic and 24/7 responses. I would highly recommend to look into workarounds - like keeping your old app version in the store before your upgrade to .NET 8.",
                                           "updatedAt":  "2024-10-01T17:36:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Oe6rw",
                                           "createdAt":  "2024-10-03T04:00:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Santoshramani",
                                           "body":  "@simonrozsival Sorry but i can not provide repro project but i can share my android application build(APK) to you but to check issue app needs NVR connection and currently i do not have NVR in internet so sharing APK also can\u0027t help you.",
                                           "updatedAt":  "2024-10-03T04:00:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Oe7tj",
                                           "createdAt":  "2024-10-03T04:05:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD0taUA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "wfurt",
                                                                               "createdAt":  "2024-10-03T15:17:10Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "Santoshramani",
                                           "body":  "@wfurt My socket is non-SSL only and i\u0027m using BeginReceive() and EndReceive() methods to start and end receiving data from socket. This was working fine with xamarin.",
                                           "updatedAt":  "2024-10-03T04:05:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Oe9l7",
                                           "createdAt":  "2024-10-03T04:15:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Santoshramani",
                                           "body":  "@karelz I will definitely contact microsoft support team if couldn\u0027t found any solution here in my buffer time.",
                                           "updatedAt":  "2024-10-03T04:15:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6OjmV1",
                                           "createdAt":  "2024-10-03T15:20:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD0waVw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "simonrozsival",
                                                                               "createdAt":  "2024-10-03T22:06:27Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "wfurt",
                                           "body":  "so definetly not related. to https://github.com/dotnet/runtime/pull/104726. \r\nThe original description has reference to pcap but I don;t see anything attached. Getting both the working and not working case could be useful.",
                                           "updatedAt":  "2024-10-03T15:20:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6PpSV2",
                                           "createdAt":  "2024-10-14T05:17:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Santoshramani",
                                           "body":  "Currently when issue is generated, there is this line in app logs.\n`[libc] Fatal signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x777746401f in tid 30722 (.NET TP Worker)` \n\nSocket pcap are also clean now there is nothing like \u0027socket reset\u0027 which i\u0027ve mentioned earlier.\n\nCan anyone please explain what exactly is the problem.",
                                           "updatedAt":  "2024-10-14T05:17:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6QQfp7",
                                           "createdAt":  "2024-10-17T18:25:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to \u0027arch-android\u0027: @vitek-karas, @simonrozsival, @steveisok, @akoeplinger\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-10-17T18:25:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6QQhGs",
                                           "createdAt":  "2024-10-17T18:28:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "That may be sign of corrupted memory. It is going to be very difficult to investigate IMHO with reasonable repro. You can try to craft simple \"bulk data reading socket using dotnet 8 SDK for android project.\" app that demonstrates this. I would expect that the actually data does not matter e.g. you could stub out the camera feed.  ",
                                           "updatedAt":  "2024-10-17T18:28:57Z"
                                       }
                                   ],
                         "totalCount":  16
                     },
        "title":  "TCP Socket - Connection reset while receiving data",
        "labels":  [
                       "area-System.Net.Sockets",
                       "os-android",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/108984",
        "createdAt":  "2024-10-17T17:18:11Z",
        "number":  108984,
        "author":  "vsfeedback",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-12-03T19:26:12Z",
        "body":  "_This issue has been moved from [a ticket on Developer Community](https://developercommunity.visualstudio.com/t/Icmp-only-triggers-when-socket-is-dispos/10718656)._\n\n---\nI have noticed that endreceive only gets called when the socket disposes\nthis will trigger\n```\ntry\n{\n    using var socket = new Socket(AddressFamily.InterNetwork, SocketType.Raw, ProtocolType.Icmp);\n    socket. Blocking = true;\n    socket. Bind(new IPEndPoint(_address, 0));\n    socket. BeginReceiveFrom(receiveBuffer, 0, receiveBuffer.Length, SocketFlags.None, ref remoteEndPoint, (IAsyncResult ar)=\u003e{ \n                       \nInterlocked.Increment(ref _received);                \n    }, null);\n    _logger?. Lazy(). LogInformation(\"BeginReceiveFrom called successfully\");\n}\ncatch (SocketException ex)\n{\n    _logger?. LogError(\"SocketException in BeginReceiveFrom: {0}\", ex. Message);\n}\ncatch (Exception ex)\n{\n    _logger?. LogError(\"Exception in BeginReceiveFrom: {0}\", ex. Message);\n}\n```\n\nreading the data from the below code would work as the socket doesn\u0027t get disposed, however it never fires. \n\n```\ntry\n{\n    var socket = new Socket(AddressFamily.InterNetwork, SocketType.Raw, ProtocolType.Icmp);\n    socket. Blocking = true;\n    socket. Bind(new IPEndPoint(_address, 0));\n    socket. BeginReceiveFrom(receiveBuffer, 0, receiveBuffer.Length, SocketFlags.None, ref remoteEndPoint, (IAsyncResult ar)=\u003e{ \n                       \nInterlocked.Increment(ref _received);                \n    }, null);\n    _logger?. Lazy(). LogInformation(\"BeginReceiveFrom called successfully\");\n}\ncatch (SocketException ex)\n{\n    _logger?. LogError(\"SocketException in BeginReceiveFrom: {0}\", ex. Message);\n}\ncatch (Exception ex)\n{\n    _logger?. LogError(\"Exception in BeginReceiveFrom: {0}\", ex. Message);\n}\n```\nWhen looking at the documentation:\nhttps://learn.microsoft.com/en-us/dotnet/api/system.net.sockets.socket.beginreceivefrom?view=net-8.0\n\nand using the Async method I have the error that it awaits only to throw the error that the socket is exposed. \n\nHow to use Icmp with .net?\n\n---\n### Original Comments\n\n#### Alison Jin [MSFT] on 8/8/2024, 11:14 PM: \n\n\u003cp\u003eThank you for your feedback! Does this reproduce for all project or the specific project? If it reproduces with the specific project, what kind of project it is (C#/C++ Console App, WinForms, WPF, AspNet, etc…)? Could you please provide a sample solution that has this problem so that we can conduct further research? It would be very helpful if you could provide some screenshots of this issue. Thanks for your help!\u003c/p\u003e\n\u003cp\u003eWe look forward to hearing from you!\u003c/p\u003e\n\n#### walter.verhoeven on 8/9/2024, 02:51 AM: \n\n\u003cp\u003eyes, copy the code in any project and add a IP address local to the device and the issue is reproducible\u003c/p\u003e\n\n#### Feedback Bot on 8/15/2024, 03:14 AM: \n\n\u003cp\u003eWe have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.\u003c/p\u003e\n\n#### Radek Zikmund [MSFT] on 8/20/2024, 07:25 AM: \n\n\u003cp\u003eHi, the sockets functionality exposed in .NET may behave slightly differently based on the platform you are running. You can read about Windows specifics at \u003ca target=\u0027_blank\u0027 href=\"https://learn.microsoft.com/en-us/windows/win32/winsock/tcp-ip-raw-sockets-2\"\u003ehttps://learn.microsoft.com/en-us/windows/win32/winsock/tcp-ip-raw-sockets-2\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eI was successfully able to receive ICMP message using your second example (the one without \u003ccode\u003eusing\u003c/code\u003e) using following code\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cs\"\u003e    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e socket2 = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e Socket(AddressFamily.InterNetwork, SocketType.Raw, ProtocolType.Icmp);\n    socket2.SendTo(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ebyte\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e], \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e IPEndPoint(_address, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003enote that applications may require elevated privilege in order to send data on raw sockets.\u003c/p\u003e\n\u003cp\u003eLet me know if you have other questions.\u003c/p\u003e\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOkD-lOw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6QP6U7",
                                           "createdAt":  "2024-10-17T17:19:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-10-17T17:19:17Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Icmp only triggers when socket is disposed",
        "labels":  [
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/110719",
        "createdAt":  "2024-12-15T11:34:50Z",
        "number":  110719,
        "author":  "szguoxz",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC9fdvg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_DOWN",
                                            "user":  "punchready",
                                            "createdAt":  "2024-12-16T03:59:06Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2024-12-16T12:23:57Z",
        "body":  "This code is copied from UDPClient, The decision made here is really ODD.\nAparently, \n      tempRemoteEP has nothing to do with remoteEP, which is a bug here, client will receive message from all EP instead of specified EP.\n\n      Then, simply because you didn\u0027t return a length, you decide to make a copy of the buffer, then your buffer is a new buffer, which would cause performance issue, and the worse, sometimes it\u0027s the same buffer you always use. If I assume it\u0027s always a new buffer, it will create bugs!\n\n```c#\n      public byte[] Receive([NotNull] ref IPEndPoint? remoteEP)\n        {\n            ThrowIfDisposed();\n\n            // this is a fix due to the nature of the ReceiveFrom() call and the\n            // ref parameter convention, we need to cast an IPEndPoint to it\u0027s base\n            // class EndPoint and cast it back down to IPEndPoint. ugly but it works.\n            EndPoint tempRemoteEP = _family == AddressFamily.InterNetwork ?\n                IPEndPointStatics.Any :\n                IPEndPointStatics.IPv6Any;\n\n            int received = Client.ReceiveFrom(_buffer, MaxUDPSize, 0, ref tempRemoteEP);\n            remoteEP = (IPEndPoint)tempRemoteEP;\n\n            // because we don\u0027t return the actual length, we need to ensure the returned buffer\n            // has the appropriate length.\n\n            if (received \u003c MaxUDPSize)\n            {\n                byte[] newBuffer = new byte[received];\n                Buffer.BlockCopy(_buffer, 0, newBuffer, 0, received);\n                return newBuffer;\n            }\n            return _buffer;\n        }\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOl7kOBw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6XoAdy",
                                           "createdAt":  "2024-12-15T12:07:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-12-15T12:07:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6XoBMF",
                                           "createdAt":  "2024-12-15T12:15:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD_J0bg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "wfurt",
                                                                               "createdAt":  "2024-12-15T15:33:55Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "antonfirsov",
                                                                               "createdAt":  "2024-12-16T12:03:14Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "\u003e tempRemoteEP has nothing to do with remoteEP, which is a bug here\n\nThis is incorrect. `remoteEP` is a `ref` variable, which may be changed out of the method. `tempRemoteEP` is a copy to new location and won\u0027t be changed.\n\n\u003e Then, simply because you didn\u0027t return a length, you decide to make a copy of the buffer\n\n`UDPClient` isn\u0027t actively maintained or designed for performance. It doesn\u0027t provide convenience over `Socket`. `Socket` provides a lot of overloads of `RecieveFrom{Async}` to allow better control of buffer.",
                                           "updatedAt":  "2024-12-15T12:15:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6XoBYv",
                                           "createdAt":  "2024-12-15T12:17:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "szguoxz",
                                           "body":  "I see what you are saying.\nThe problem with the buffer is: It\u0027s readonly sometime (when it\u0027s full, you returned the inner buffer), or mutable sometime (You create a copy when it\u0027s not full).\n\nSo if I assume it\u0027s mutable, my code will create a bug if the buffer is full.\nWhich means, I have to create a copy again for each result I receive if I want to process the data in a different thread.\nGet Outlook for iOS\u003chttps://aka.ms/o0ukef\u003e\n",
                                           "updatedAt":  "2024-12-15T13:52:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6XoSKa",
                                           "createdAt":  "2024-12-15T15:36:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "With Socket.ReceiveFrom you can use pool allocator and return the buffer when it is processed by other thread. Socket api in general provides more control.",
                                           "updatedAt":  "2024-12-15T15:36:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6XrhT0",
                                           "createdAt":  "2024-12-16T07:08:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "How could we provide \"recommendation against\" for `UdpClient`, and potentially `TcpClient`? The api of `Socket` is a mixture, can there be a documentation to highlight APIs for typical TCP and UDP usage?",
                                           "updatedAt":  "2024-12-16T07:08:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6XrieA",
                                           "createdAt":  "2024-12-16T07:11:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "liveans",
                                           "body":  "\u003e The api of `Socket` is a mixture, can there be a documentation to highlight APIs for typical TCP and UDP usage?\n\nWe have it for [TcpClient](https://learn.microsoft.com/en-us/dotnet/fundamentals/networking/sockets/tcp-classes#finite-tcp-control-with-the-socket-class), but not for `UdpClient`.",
                                           "updatedAt":  "2024-12-16T07:11:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6XuQ4H",
                                           "createdAt":  "2024-12-16T12:22:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "We should consider creating a similar docs for UDP. We definitely don\u0027t want to invest into `UdpClient` perf.",
                                           "updatedAt":  "2024-12-16T12:22:21Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "UdpClient BUG and Performance Issue",
        "labels":  [
                       "documentation",
                       "area-System.Net.Sockets",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/110889",
        "createdAt":  "2024-12-22T11:29:38Z",
        "number":  110889,
        "author":  "snikeguo",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-03-18T14:21:16Z",
        "body":  "### Description\n\nthe UdpClient cannot listen to IPv6 multicast messages.\ncode:\n\n\nBefore this, someone else has encountered this issue: https://github.com/dotnet/runtime/issues/83336\n\n### Reproduction Steps\n\n```\n var localEndPoint = new IPEndPoint( IpAddrOfNetworkInterface, 15118);\n var udpClient = new UdpClient(localEndPoint);\n // \nvar multicastAddress = IPAddress.Parse(\"FF02::1\");\n udpClient.JoinMulticastGroup(multicastAddress);\n var remoteEndPoint= new IPEndPoint(IPAddress.IPv6Any, 0);\nvar data= udpClient.Receive(ref remoteEndPoint);\n Console.WriteLine(\"receive ipv6 Multicast Group message ok!\");\n```\n\n\n### Expected behavior\n\nThe console should output information.\n\n### Actual behavior\n\nThe console has no output.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\nI can receive multicast messages using a network debugging tool.\n![Image](https://github.com/user-attachments/assets/3ad3dab5-c090-4cef-b932-208feb8c3df1)\n\nreceived datas:\n![Image](https://github.com/user-attachments/assets/c92a5bf1-67c6-4059-bbfd-a569c9ae854c)\n\n**There are multiple network interface on my computer, could that be the reason?**\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOmJOaCg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6YfnF_",
                                           "createdAt":  "2024-12-22T11:30:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-12-22T11:30:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Yf-g-",
                                           "createdAt":  "2024-12-22T17:00:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-12-22T17:00:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Yk5oK",
                                           "createdAt":  "2024-12-23T14:29:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "snikeguo",
                                           "body":  "@antonfirsov ",
                                           "updatedAt":  "2024-12-23T14:29:38Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "The UdpClient cannot listen to IPv6 multicast messages.",
        "labels":  [
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/111400",
        "createdAt":  "2025-01-14T11:14:32Z",
        "number":  111400,
        "author":  "stalexig",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODFGXxw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DusperD",
                                            "createdAt":  "2025-06-29T21:16:23Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-03-20T17:23:17Z",
        "body":  "### Description\n\nI\u0027m using UdpClient to read data asynchronously over Udp. To cancel the operation after a timeout, I use CancellationTokenSource. I noticed that with a slow device, the timeout often triggers and the memory begins to grow. DotMemory shows a constant increase in the number of these objects:\n\n![Image](https://github.com/user-attachments/assets/40413e91-cc99-4972-a62d-9f9189e06e26)\n\n### Reproduction Steps\n\n**The problem only exists on Unix systems, there is no leak on Windows.** \n\nHere is test code that reproduces the described problem:\n\n```\nusing var udpClient = new UdpClient();\nudpClient.Connect(IPAddress.Parse(addr), port);\n\nwhile (true)\n{\n    try\n    {\n        using var tokenSource = new CancellationTokenSource(100);\n        var result = await udpClient.ReceiveAsync(tokenSource.Token);\n    }\n    catch (OperationCanceledException)\n    {\n    }\n    \n    await Task.Delay(100).ConfigureAwait(false);\n}\n```\n\n### Expected behavior\n\nAll resources should be released after ReceiveAsync exits with a cancellation token\n\n### Actual behavior\n\nThere is a memory leak on Unix\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOo1WgGA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6aXed8",
                                           "createdAt":  "2025-01-14T12:56:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-01-14T12:56:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6aagzN",
                                           "createdAt":  "2025-01-14T17:28:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "we should figure out if they are rooted (e.g. leak) or if that is just lazy GC. Do you see it grow if you add `GC.Collect`  to the loop @stalexig \n`UDPClient` is just very thin layer on top of `Socket` and I did not see any suspicious code there (like pool allocations) ",
                                           "updatedAt":  "2025-01-14T17:28:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6abefy",
                                           "createdAt":  "2025-01-14T19:04:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEaS-Yg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "wfurt",
                                                                               "createdAt":  "2025-01-14T19:30:04Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "DusperD",
                                                                               "createdAt":  "2025-07-11T18:56:40Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "stalexig",
                                           "body":  "1. Adding `GC.Collect` to the test project does not solve the problem - the memory continues to grow. \n\n2. I also tried using sockets directly without UdpClient. The code below has the same problem:\n\n```\nvar inBuffer = new byte[64 * 1024];\n    \nusing var socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);\nvar ipEndPoint = new IPEndPoint(IPAddress.Any, 0);\nsocket.Bind(ipEndPoint);\n\nwhile (true)\n{\n    try\n    {\n        using var tokenSource = new CancellationTokenSource(100);\n        \n        var remote = new IPEndPoint(IPAddress.Any,0);\n        var result = await socket\n            .ReceiveFromAsync(inBuffer, SocketFlags.None, remote, tokenSource.Token)\n            .ConfigureAwait(false);\n    }\n    catch (OperationCanceledException)\n    {\n        \n    }\n    \n    GC.Collect();\n    \n    await Task.Delay(100).ConfigureAwait(false);\n}\n```\n\n3. I\u0027m using dotmemory for leak analysis. In this utility, in the Retention tab, I see a long linked list of \"System.Net.Sockets.SocketAsyncContext+BufferMemoryReceiveOperation\" objects:\n\n\u003cimg width=\"1183\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/34e2c1af-7336-400f-84b5-e5244bc55b5c\" /\u003e\n\nThe number of objects in this list is constantly growing, although the code shows that I am not performing more than one read operation at a time. The Retention tab also shows that these objects has references to the CancelationToken and byte[] buffer. The comparison of snapshots shows that their number is also continuously growing:\n\n\u003cimg width=\"1179\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/8b7a6ade-42c3-4cbe-a8c8-8649df2a689a\" /\u003e\n\nI looked at the Socket code for Unix and I have a feeling that when the cancellation token fires, the read operation is not removed from the linked list of operations in the SocketAsyncContext.\n\nThere may be a bug in my code, but it is very simple and works without problems on Windows. I don\u0027t have any ideas yet what could be wrong.",
                                           "updatedAt":  "2025-01-14T19:07:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6azo_n",
                                           "createdAt":  "2025-01-17T01:13:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "NinoFloris",
                                           "body":  "Might be related to this comment: https://github.com/dotnet/runtime/blob/6afd223111ab297863728a67a4bc9daa1828de3c/src/libraries/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncContext.Unix.cs#L237-L238",
                                           "updatedAt":  "2025-01-17T01:13:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6jM4RK",
                                           "createdAt":  "2025-03-19T20:43:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "\u003e Might be related to this comment:\n\u003e https://github.com/dotnet/runtime/blob/6afd223111ab297863728a67a4bc9daa1828de3c/src/libraries/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncContext.Unix.cs#L237-L238\n\nThis is true, we leave all cancelled operations in the queue. While for TCP this doesn\u0027t lead to issues since a TCP socket is considered to be unusable after a cancellation, with UDP, continuing working with the socket might be valid. Regardless, I\u0027m not sure if the impact of this issue is high.\n\n\u003e with a slow device, the timeout often triggers and the memory begins to grow\n\n@stalexig does this happen with short timeouts? What is the goal of the timeout if you will retry the recieve anyways?",
                                           "updatedAt":  "2025-03-19T20:45:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6jSOjg",
                                           "createdAt":  "2025-03-20T07:35:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEYacVw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "antonfirsov",
                                                                               "createdAt":  "2025-03-20T12:29:25Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "DusperD",
                                                                               "createdAt":  "2025-06-29T21:16:35Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "stalexig",
                                           "body":  "@antonfirsov\nI can describe my situation: in my case, the program requests data from hundreds of devices. The timeout is needed because the device may simply not respond to the request if it is too busy. So there is no point in waiting too long, the request will just need to be repeated later. \n\nHowever, the device may simply be turned off for repair. Or a whole group of devices may be turned off. In this case, the requests also go away, but there is no response, and the read operation is cancelled due to a timeout. The memory immediately begins to grow. To avoid this I have to recreate the socket every time I cancel reading operation.",
                                           "updatedAt":  "2025-03-20T07:35:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6jSnzq",
                                           "createdAt":  "2025-03-20T08:29:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "When would we cleanup the queue @antonfirsov? When the socket is closed or is that truly a leak? Or would we re-use the operation on next read? \n",
                                           "updatedAt":  "2025-03-20T08:29:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6jVaAY",
                                           "createdAt":  "2025-03-20T12:28:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "\u003e When would we cleanup the queue\n\nWhen a socket is closed, `SocketAsyncContext` is abandoned together with its queues, so this isn\u0027t truly a leak. However as https://github.com/dotnet/runtime/issues/111400#issuecomment-2739464416 notes, the current behavior forces the user to throw away \u0026 recreate the socket after cancellation. This wouldn\u0027t be necessary if we removed the cancelled operation from the queue when cancellation happens. We do this for sync-over async timeouts:\n\nhttps://github.com/dotnet/runtime/blob/d34ef7e2d3f41f85d35d23ec484f7af566fd0d2f/src/libraries/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncContext.Unix.cs#L1424-L1428\n\nI don\u0027t know why we decided to leave the operation in the queue for async cancellations.",
                                           "updatedAt":  "2025-03-20T12:29:17Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "Memory leak in UdpClient on Unix",
        "labels":  [
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/112039",
        "createdAt":  "2025-01-31T16:40:51Z",
        "number":  112039,
        "author":  "antonfirsov",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-01-31T17:02:59Z",
        "body":  "#106977 introduced support for Wasi sockets, but opted-out from test cases using `PortBlocker`.\n\n@pavelsavara could this be fixed by replacing `libc` with the right name to import wasi-libc here?\n\nhttps://github.com/dotnet/runtime/blob/572533b433aa1b0b5a498cec2d310b939acd3a93/src/libraries/Common/tests/System/Net/Sockets/SocketTestExtensions.cs#L205-L209",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOnKC0cg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6coLFL",
                                           "createdAt":  "2025-01-31T16:41:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to \u0027arch-wasm\u0027: @lewing\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-01-31T16:41:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6coLRy",
                                           "createdAt":  "2025-01-31T16:41:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-01-31T16:41:20Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Consider enabling PortBlocker tests on Wasi",
        "labels":  [
                       "arch-wasm",
                       "area-System.Net.Sockets",
                       "os-wasi"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/113904",
        "createdAt":  "2025-02-19T01:51:14Z",
        "number":  113904,
        "author":  "zhh0000zhh",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-03-26T08:58:17Z",
        "body":  "Due to special needs, I need to manually set MSS. Currently, it can only be called through P/Invoke. I hope it can be natively supported.\n\n`        socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.MaxSegmentSize, mssValue);\n\nOr provide the ability to directly call the underlying setoption. At present, it only needs to allow optionname to be input as int and add optlen. Although the definition of optlen is different in different operating systems (windows is int, linux/unix is ​​uint), since optlen generally does not exceed int.max, such differences can be ignored.\n\n`        public void SetSocketOption(int optionLevel, int optionName, intptr optionValue, int optlen);",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOpCFd0Q==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6kE9aD",
                                           "createdAt":  "2025-03-25T23:30:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-03-25T23:30:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6kFDsH",
                                           "createdAt":  "2025-03-25T23:52:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MihaZupan",
                                           "body":  "Are you looking for [`void SetRawSocketOption(int optionLevel, int optionName, ReadOnlySpan\u003cbyte\u003e optionValue)`](https://learn.microsoft.com/dotnet/api/system.net.sockets.socket.setrawsocketoption)?",
                                           "updatedAt":  "2025-03-25T23:52:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6kGEEd",
                                           "createdAt":  "2025-03-26T02:04:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "Actually, this socket option is supported on both Windows and Linux, probably also on Mac, so we can theoretically add out-of-the-box support.\n\n@zhh0000zhh would you be interested to edit the issue so it more or less matches the formal [API proposal template](https://github.com/dotnet/runtime/blob/main/.github/ISSUE_TEMPLATE/02_api_proposal.yml)? Example: https://github.com/dotnet/runtime/issues/71207",
                                           "updatedAt":  "2025-03-26T02:04:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6kIV3R",
                                           "createdAt":  "2025-03-26T08:58:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "I would be supportive to add API. That should be small. The option @MihaZupan suggested may be good short term option and at least avoids interop code. ",
                                           "updatedAt":  "2025-03-26T08:58:05Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "It is recommended to add MaxSegmentSize to Socket.SetSocketOption",
        "labels":  [
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/113216",
        "createdAt":  "2025-03-06T14:43:42Z",
        "number":  113216,
        "author":  "huoyaoyuan",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC_2elA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2025-03-08T18:06:01Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-03-18T14:24:34Z",
        "body":  "### Background and motivation\n\nCurrently, `Socket.SendFile` and `Socket.SendFileAsync` requires a file name to process. All supported implementations are then opening a `SafeFileHandle` to process. Accepting an existing `SafeFileHandle` allows potentially more advanced scenarios, for example opening the file with different priviledge.\n\n### API Proposal\n\n```diff\nnamespace System.Net.Sockets;\n\npublic partial class Socket\n{\n    // existing\n    public void SendFile(string? fileName);\n    public void SendFile(string? fileName, byte[]? preBuffer, byte[]? postBuffer, TransmitFileOptions flags);\n    public void SendFile(string? fileName, ReadOnlySpan\u003cbyte\u003e preBuffer, ReadOnlySpan\u003cbyte\u003e postBuffer, TransmitFileOptions flags);\n    public ValueTask SendFileAsync(string? fileName, CancellationToken cancellationToken = default);\n    public ValueTask SendFileAsync(string? fileName, ReadOnlyMemory\u003cbyte\u003e preBuffer, ReadOnlyMemory\u003cbyte\u003e postBuffer, TransmitFileOptions flags, CancellationToken cancellationToken = default);\n    // new\n+   public void SendFile(SafeFileHandle? fileHandle);\n+   public void SendFile(SafeFileHandle? fileHandle, byte[]? preBuffer, byte[]? postBuffer, TransmitFileOptions flags);\n+   public void SendFile(SafeFileHandle? fileHandle, ReadOnlySpan\u003cbyte\u003e preBuffer, ReadOnlySpan\u003cbyte\u003e postBuffer, TransmitFileOptions flags);\n+   public ValueTask SendFileAsync(SafeFileHandle? fileHandle, CancellationToken cancellationToken = default);\n+   public ValueTask SendFileAsync(SafeFileHandle? fileHandle, ReadOnlyMemory\u003cbyte\u003e preBuffer, ReadOnlyMemory\u003cbyte\u003e postBuffer, TransmitFileOptions flags, CancellationToken cancellationToken = default);\n}\n```\n\n\n### API Usage\n\n```csharp\nusing (var fileHandle = File.OpenHandle(\"secretFile\", FileMode.Open, FileAccess.ReadWrite, FileShare.None))\n{\n    await socket.SendFileAsync(fileHandle);\n}\n```\n\n\n### Alternative Designs\n\n- Should the `byte[]` overloads be omitted? They are somehow out of date with the `Span\u003cbyte\u003e` overloads.\n  - Or, should the simple overloads be omitted and keep only the longest overload with default parameters? `SafeFileHandle` is considered more advanced instead of convenient.\n  - Should more parameters like #67417 be considered if we decide to go with \"ultimate\" overloads only?\n- Should the `SafeFileHandle` be non-nullable? Although existing implementations do support proceeding pre- and post-buffers only with an empty file name, it feels weird to do so with a \"send file\" method.\n- Should constructors of `SendPacketsElement` be included? Not interesting, because there are already `FileStream` overloads which can easily support `SafeFileHandle`.\n\n### Risks\n\nFile handles that are not file, or real files without name but handle only, are really not interesting to bother at .NET level. We are just exposing the capability of underlying OS. The user can acquire any valid handle using different mechanics, for example custom P/Invoke.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOou0d2w==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6hLJWy",
                                           "createdAt":  "2025-03-06T14:44:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-03-06T14:44:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6hMXS9",
                                           "createdAt":  "2025-03-06T16:40:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "\u003e Accepting an existing `SafeFileHandle` allows potentially more advanced scenarios, for example opening the file with different priviledge.\n\n\u003e Should constructors of `SendPacketsElement` be included?\n\nAre there any scenarios that cannot be achieved using `SendPacketsElement` and `FileStream`? (--\u003e would this be a convenience API only?) Is there any hard advantage using `SafeFileHandle` over `FileStream`?",
                                           "updatedAt":  "2025-03-06T16:41:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6hMsEy",
                                           "createdAt":  "2025-03-06T17:15:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "\u003e Is there any hard advantage using `SafeFileHandle` over `FileStream`?\n\nI would say better semantics. Streams imply sequential and non-concurrent I/O, that\u0027s why `System.IO.RandomAccess` works with file handles and not streams.\n\n\u003e Should constructors of `SendPacketsElement` be included?\n\nYes, there is prior art in adding overloads for handles (#79187).",
                                           "updatedAt":  "2025-03-06T17:15:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6i7R3b",
                                           "createdAt":  "2025-03-18T14:24:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "It looks reasonable to me. Seems mostly like advanced use and completeness .... not critical for 10. We can progress as time permits. ",
                                           "updatedAt":  "2025-03-18T14:24:24Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "[API Proposal]: Socket.SendFile{Async} overload with SafeFileHandle",
        "labels":  [
                       "api-suggestion",
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/113701",
        "createdAt":  "2025-03-19T17:33:11Z",
        "number":  113701,
        "author":  "NinoFloris",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-05-07T18:29:55Z",
        "body":  "Related: https://github.com/dotnet/runtime/issues/1760\n\nSyscall:\nhttps://man7.org/linux/man-pages/man2/pidfd_getfd.2.html\n\nIt should be possible to use this syscall to implement DuplicateAndClose, it seems with it Linux no longer fundamentally differs from Windows\u0027 WSADuplicateSocket. Though I can imagine the ptrace permission requirement may be problematic.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOqnU85A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6jLYyv",
                                           "createdAt":  "2025-03-19T18:39:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-03-19T18:39:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6jMUgx",
                                           "createdAt":  "2025-03-19T19:45:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mconnew",
                                           "body":  "FYI, this would be enable implementing NetTcp port sharing in a way which works on Windows and Linux for CoreWCF when I get to implementing that feature.",
                                           "updatedAt":  "2025-03-19T19:45:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6jNmi0",
                                           "createdAt":  "2025-03-19T21:56:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "\u003e ptrace permission requirement may be problematic.\n\nThat requirement makes me think `pidfd_getfd()` rather exists for implementing things like isolation or debugging, and using it for implementing multi-process servers (the typical use-case for `DuplicateAndClose()`) would be unusual, maybe even unprecedental and might burn users with permission issues.",
                                           "updatedAt":  "2025-03-19T21:56:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6jsNlw",
                                           "createdAt":  "2025-03-23T15:33:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "fbrosseau",
                                           "body":  "The more common and universal way to implement this feature is with sendmsg/recvmsg and `SCM_RIGHTS`. It\u0027s slightly more involved because it requires setting up a unix-domain socket to make the transfer, but it will work everywhere.",
                                           "updatedAt":  "2025-03-23T15:33:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6jsRcZ",
                                           "createdAt":  "2025-03-23T16:11:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "NinoFloris",
                                           "body":  "We are aware, but it fundamentally doesn\u0027t fit with the way the windows model works. Primarily because it needs cooperation from both processes.",
                                           "updatedAt":  "2025-03-23T16:11:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6jsYvi",
                                           "createdAt":  "2025-03-23T17:21:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "fbrosseau",
                                           "body":  "It doesn\u0027t fit the shape of DuplicateHandle/wsaduplicatesocket alone (while pidfd_getfd does, yes), but I feel like for scenarios as advanced as WCF wants to do (multiprocess port sharing), having a higher level abstraction that completes whatever handshake is necessary to allow for passing around handles between a parent process and its children (yes, with cooperation/knowledge of the other side) may be preferrable to trying to match the DuplicateAndClose pattern 1:1.\n\nPermission bits are really messy to deal with (when possible at all), especially in containers.",
                                           "updatedAt":  "2025-03-23T17:21:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6kEmIa",
                                           "createdAt":  "2025-03-25T22:12:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "\u003e The more common and universal way to implement this feature is with sendmsg/recvmsg\n\nI also prefer following established practices and avoid exposing users to permission issues. I don\u0027t think it\u0027s possible to create a reliable cross-platform API here and the FD migration feature request is already tracked by #932 and #48637.\n\nMy preference would be to close this as _not planned_, @wfurt yay or nay?",
                                           "updatedAt":  "2025-03-25T22:16:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6kEoKs",
                                           "createdAt":  "2025-03-25T22:18:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOELc73g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "antonfirsov",
                                                                               "createdAt":  "2025-03-26T02:20:32Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "NinoFloris",
                                           "body":  "Sure this wasn\u0027t opened because I personally need it, or because there are no other alternatives. I happened to come across it and opened the issue to make sure the team is aware that this syscall exists, I did not.",
                                           "updatedAt":  "2025-03-25T22:18:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6qdTzk",
                                           "createdAt":  "2025-05-07T18:29:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "I don\u0027t have strong preference @antonfirsov. While I feel we may not expose it directly we can leave it around as implementation detail. My primary concern would be dependency on. `PTRACE_MODE_ATTACH_REALCREDS`. It probably deserves some research to see if that would be common enough to explore it.",
                                           "updatedAt":  "2025-05-07T18:29:36Z"
                                       }
                                   ],
                         "totalCount":  9
                     },
        "title":  "Support Socket.DuplicateAndClose through pidfd_getfd on Linux",
        "labels":  [
                       "area-System.Net.Sockets",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/114450",
        "createdAt":  "2025-04-09T17:08:32Z",
        "number":  114450,
        "author":  "matouskozak",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-21T00:03:24Z",
        "body":  "## Build Information\nBuild: https://dev.azure.com/dnceng-public/public/_build/results?buildId=1009757\nBuild error leg or test failing: `System.Net.Sockets.Tests`\nAffected CI: `maccatalyst-x64 Release AllSubsets_Mono`\n\nDuring migration to newer macOS queues (from 12 to 15, https://github.com/dotnet/runtime/pull/113313), we encountered issues in `System.Net.Sockets.Tests.SendTo_.*.Datagram_UDP_AccessDenied_Throws_DoesNotBind` tests running on MacCatalyst x64 where host is unreachable.\n\nError message:\n```\n[06:43:43] dbug: Assert.Equal() Failure: Values differ\n[06:43:43] dbug: Expected: AccessDenied\n[06:43:43] dbug: Actual:   HostUnreachable\n```\n\n\u003c!-- Error message template  --\u003e\n## Error Message\n\nFill the error message using [step by step known issues guidance](https://github.com/dotnet/arcade/blob/main/Documentation/Projects/Build%20Analysis/KnownIssueJsonStepByStep.md).\n\n\u003c!-- Use ErrorMessage for String.Contains matches. Use ErrorPattern for regex matches (single line/no backtracking). Set BuildRetry to `true` to retry builds with this error. Set ExcludeConsoleLog to `true` to skip helix logs analysis. --\u003e\n\n```json\n{\n  \"ErrorPattern\": \"\\\\[FAIL\\\\] System\\\\.Net\\\\.Sockets\\\\.Tests\\\\.SendTo_.+\\\\.Datagram_UDP_AccessDenied_Throws_DoesNotBind\",\n  \"BuildRetry\": false,\n  \"ExcludeConsoleLog\": false\n}\n```\n\r\n\u003c!-- Known issue validation start --\u003e\r\n ### Known issue validation\r\n**Build: :mag_right:** https://dev.azure.com/dnceng-public/public/_build/results?buildId=1009757\r\n**Error message validated:** `[\\[FAIL\\] System\\.Net\\.Sockets\\.Tests\\.SendTo_.+\\.Datagram_UDP_AccessDenied_Throws_DoesNotBind`]\r\n**Result validation:** :white_check_mark: Known issue matched with the provided build.\r\n**Validation performed at:** 4/9/2025 5:09:04 PM UTC\r\n\u003c!-- Known issue validation end --\u003e\r\n\u003c!--Known issue error report start --\u003e\r\n\r\n### Report\r\n\r\n|Build|Definition|Test|Pull Request|\r\n|---|---|---|---|\r\n|[1153847](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1153847)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1153847\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31873046\u0026resultId=205018)||\r\n|[1153786](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1153786)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1153786\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31870716\u0026resultId=205434)||\r\n|[1153569](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1153569)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1153569\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31867056\u0026resultId=212083)||\r\n|[1153429](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1153429)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1153429\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31861014\u0026resultId=205018)||\r\n|[1153299](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1153299)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1153299\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31858494\u0026resultId=212039)||\r\n|[1152975](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1152975)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1152975\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31855740\u0026resultId=212039)||\r\n|[1152834](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1152834)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1152834\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31847444\u0026resultId=211611)||\r\n|[1152408](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1152408)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1152408\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31832190\u0026resultId=188683)||\r\n|[1152248](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1152248)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1152248\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31829782\u0026resultId=211595)||\r\n|[1152181](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1152181)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1152181\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31829000\u0026resultId=212055)||\r\n|[1151980](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1151980)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1151980\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31823956\u0026resultId=212039)||\r\n|[1151850](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1151850)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1151850\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31820300\u0026resultId=212039)||\r\n|[1151627](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1151627)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1151627\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31814532\u0026resultId=210131)||\r\n|[1150893](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1150893)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1150893\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31801488\u0026resultId=212039)||\r\n|[1151114](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1151114)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1151114\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31800578\u0026resultId=210119)||\r\n|[1150702](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1150702)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1150702\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31788330\u0026resultId=212053)||\r\n|[1150447](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1150447)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1150447\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31782226\u0026resultId=209965)||\r\n|[1150014](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1150014)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1150014\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31766190\u0026resultId=209963)||\r\n|[1149890](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1149890)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1149890\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31763958\u0026resultId=212053)||\r\n|[1149341](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1149341)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1149341\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31748896\u0026resultId=209960)||\r\n|[1148828](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1148828)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1148828\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31727616\u0026resultId=204826)||\r\n|[1148757](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1148757)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1148757\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31727688\u0026resultId=212037)||\r\n|[1148550](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1148550)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1148550\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31720788\u0026resultId=212037)||\r\n|[1148204](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1148204)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1148204\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31705710\u0026resultId=209962)||\r\n|[1147783](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1147783)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1147783\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31688472\u0026resultId=209978)||\r\n|[1147677](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1147677)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1147677\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31682372\u0026resultId=209978)||\r\n|[1147526](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1147526)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1147526\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31675504\u0026resultId=210006)||\r\n|[1147326](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1147326)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1147326\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31669620\u0026resultId=209962)||\r\n|[1147118](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1147118)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1147118\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31663570\u0026resultId=212037)||\r\n|[1146807](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1146807)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1146807\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31651616\u0026resultId=209962)||\r\n|[1146290](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1146290)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1146290\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31632142\u0026resultId=209962)||\r\n|[1146119](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1146119)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1146119\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31627120\u0026resultId=212081)||\r\n|[1145845](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1145845)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1145845\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31616432\u0026resultId=212035)||\r\n|[1145829](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1145829)|dotnet/runtime|[System.Net.Sockets.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1145829\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31615696\u0026resultId=210004)||\r\n#### Summary\r\n|24-Hour Hit Count|7-Day Hit Count|1-Month Count|\r\n|---|---|---|\r\n|3|26|34|\r\n\u003c!--Known issue error report end --\u003e",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOplJibw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6mUmAL",
                                           "createdAt":  "2025-04-09T17:08:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to \u0027os-maccatalyst\u0027: @vitek-karas, @kotlarmilos, @ivanpovazan, @steveisok, @akoeplinger\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-04-09T17:08:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mUmJv",
                                           "createdAt":  "2025-04-09T17:09:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-04-09T17:09:02Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[maccatalyst][x64] SendTo_.*.Datagram_UDP_AccessDenied_Throws_DoesNotBind cannot reach host",
        "labels":  [
                       "area-System.Net.Sockets",
                       "disabled-test",
                       "arch-x64",
                       "os-maccatalyst",
                       "Known Build Error"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/117548",
        "createdAt":  "2025-07-11T17:38:49Z",
        "number":  117548,
        "author":  "antonfirsov",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODHMAwg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "wfurt",
                                            "createdAt":  "2025-07-11T17:53:03Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "liveans",
                                            "createdAt":  "2025-07-12T10:42:03Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "albi005",
                                            "createdAt":  "2025-07-16T09:15:36Z"
                                        }
                                    ],
                          "totalCount":  3
                      },
        "updatedAt":  "2025-08-18T13:07:41Z",
        "body":  "### Background and motivation\n\nOne of the original motivations behind #861 / #87932 was to utilize Happy Eyeballs in `SocketsHttpHandler`, see https://github.com/dotnet/runtime/issues/26177#issuecomment-540141586, however since then the `SocketsHttpHandler` code has been updated to use the `ValueTask` overload. Unless we are willing to duplicate code into `SocketsHttpHandler`, the SAEA overload is insufficient for utilizing Happy Eyeballs in `SocketsHttpHandler`. Moreover `ValueTask`-based overloads would be more useful for the general public.\n\n### API Proposal\n\n```csharp\nnamespace System.Net.Sockets;\n\npublic class Socket\n{\n    // Existing:\n    public ValueTask ConnectAsync(EndPoint remoteEP, CancellationToken cancellationToken);\n    public static bool ConnectAsync(SocketType socketType, ProtocolType protocolType, SocketAsyncEventArgs e)\n\n    // Approved in #861 / #87932\n    public static bool ConnectAsync(SocketType socketType, ProtocolType protocolType, SocketAsyncEventArgs e, ConnectAlgorithm connectAlgorithm);\n\n    // Proposed:\n    public ValueTask ConnectAsync(DnsEndPoint remoteEP, ConnectAlgorithm connectAlgorithm, CancellationToken cancellationToken = default);\n\n    // Also consider (needs more implementation work)\n    public ValueTask ConnectAsync(IPAddress[] addresses, int port, ConnectAlgorithm connectAlgorithm, CancellationToken cancellationToken)\n}\n```\n\n\n### API Usage\n\n### Using `DnsEndpoint` overload in `SocketsHttpHandler` (simplified)\n\n```csharp\npublic async ValueTask\u003cStream\u003e ConnectToTcpHostAsync(string host, int port, CancellationToken cancellationToken)\n{\n    try\n    {\n        Socket socket = new Socket(SocketType.Stream, ProtocolType.Tcp) { NoDelay = true };\n        await socket.ConnectAsync(endPoint, ConnectAlgorithm.Parallel, cancellationToken).ConfigureAwait(false);\n        return new NetworkStream(socket, ownsSocket: true);\n    }\n    catch\n    {\n        socket.Dispose();\n        throw;\n    }\n}\n```\n\n### Using `IPAddress[]` overload in `ConnectCallback`\n\n```C#\nusing SocketsHttpHandler handler = new SocketsHttpHandler();\nhandler.ConnectCallback = async (ctx, ct) =\u003e\n{\n    DnsEndPoint dnsEndPoint = ctx.DnsEndPoint;\n    IPAddress[] addresses = await Dns.GetHostAddressesAsync(dnsEndPoint.Host, dnsEndPoint.AddressFamily, ct);\n\n    LogResolvedAdresses(addresses);\n\n    var s = new Socket(SocketType.Stream, ProtocolType.Tcp) { NoDelay = true };\n    try\n    {\n        await s.ConnectAsync(addresses, dnsEndPoint.Port, ConnectAlgorithm.Parallel, ct);\n        return new NetworkStream(s, ownsSocket: true);\n    }\n    catch\n    {\n        s.Dispose();\n        throw;\n    }\n};\n```\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\nI see no high risks from the API itself, however adaption (#26177) should be done with care.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOtpR9sg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc62lH2y",
                                           "createdAt":  "2025-07-11T17:39:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-07-11T17:39:31Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "[API Proposal]: ValueTask-based Socket.ConnectAsync overloads for Happy Eyeballs",
        "labels":  [
                       "api-suggestion",
                       "area-System.Net.Sockets"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/118055",
        "createdAt":  "2025-07-25T08:03:36Z",
        "number":  118055,
        "author":  "296370493",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-28T16:18:49Z",
        "body":  "### Description\n\nWhen I was using UdpClient, I found that even when UdpClient.EnableBroadcast was set to false, it could still successfully send data via broadcast.\n\n### Reproduction Steps\n\n```c#\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\n\nnamespace ConsoleApp1\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            using (var udpClient = new UdpClient(8080))\n            {\n                udpClient.EnableBroadcast = false;\n                var ipEndPoint = new IPEndPoint(IPAddress.Broadcast, 8081);\n                byte[] data = Encoding.UTF8.GetBytes(\"test\");\n                udpClient.Send(data, data.Length, ipEndPoint);\n            }\n        }\n    }\n}\n```\n\n### Expected behavior\n\nWhen UdpClient.EnableBroadcast is set to false, shouldn\u0027t an exception occur?\n\n### Actual behavior\n\nWhen UdpClient.EnableBroadcast is set to false, data can be sent normally via broadcast.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n.NET version：.NET 8\nSystem: Windows 10 22H2\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOunGTVw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc65xt-M",
                                           "createdAt":  "2025-07-25T08:04:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-07-25T08:04:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc66P_Uv",
                                           "createdAt":  "2025-07-27T22:07:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-07-27T22:07:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc66cZNX",
                                           "createdAt":  "2025-07-28T16:18:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "`UdpClient.EnableBroadcast` is just passthrough to underlying socelt. But it  seems like `UDPClient` has some extra logic to enabled it as needed. \n\nhttps://github.com/dotnet/runtime/blob/96b8cdcf45e54cb063675ed4925eca510ec123cb/src/libraries/System.Net.Sockets/src/System/Net/Sockets/UDPClient.cs#L250-L264\n\nI\u0027m not sure if this is worth of change but we can handle the case when somebody explicitly disables sending broadcasts. Or at least update the documentation. I would expect that using the Socket directly works as expected e.g. `udpClient.Client.Send()`\n",
                                           "updatedAt":  "2025-07-28T16:18:36Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Regarding the issue of the UdpClient.EnableBroadcast property",
        "labels":  [
                       "area-System.Net.Sockets",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/119638",
        "createdAt":  "2025-09-12T13:16:17Z",
        "number":  119638,
        "author":  "logiclrd",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-16T18:44:59Z",
        "body":  "A common pattern with sockets is to set them to be Non-Blocking (`fcntl` with the `O_NONBLOCK` flag). In this mode, if a read or write is attempted and the full buffer size requested cannot be satisfied (a `read`/`recv` when fewer bytes are buffer, ready to be received, or a `write`/`send` when the available output buffer space cannot accommodate the full buffer provided), then the operation returns a successful response, indicating how many bytes were _actually_ processed, and `errno` is set to `EWOULDBLOCK`.\n\nThis allows code to transfer as many bytes as it can without blocking the thread and without it being treated as an error state.\n\nCurrently, as far as I can tell, there is no way to express this in .NET with the BCL. The `Socket` implementations assume and require that the sockets be blocking. In the `Socket` code, if you supply a non-blocking socket, then a partial operation translates to a `SocketException` with `SocketErrorCode == SocketError.WouldBlock`, and the number of bytes that were actually processed is lost. In the `Stream` code, there is no `Write` family method that has a return type other than `void`; the API is fundamentally built around writes _always_ fully completing.\n\nI note that there was previously some discussion of partial write support specifically in #48826. The discussion there provided a specific rationale for partial write support: The client is expecting there to be more data to write very soon, and wants to avoid a separate `send` call for the remaining partial buffer right now, which could result in an extra TCP frame that is inefficiently conveying little data.\n\nI feel like, more generally, this mode of operation is a core part of the way sockets and, on UNIX systems, file descriptors in general work, and should be reflected in the API.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOxLEGog==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc7D0YW1",
                                           "createdAt":  "2025-09-12T13:22:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEiIvRg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "ROCKET",
                                                                               "user":  "logiclrd",
                                                                               "createdAt":  "2025-09-13T12:46:31Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "MihuBot",
                                           "body":  "I\u0027m a bot. Here is a possible related and/or duplicate issue (I may be wrong):\n- https://github.com/dotnet/runtime/issues/22506",
                                           "updatedAt":  "2025-09-12T13:22:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7D1CfD",
                                           "createdAt":  "2025-09-12T14:14:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-09-12T14:14:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7D_8wn",
                                           "createdAt":  "2025-09-13T12:54:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "logiclrd",
                                           "body":  "\u003e I\u0027m a bot. Here is a possible related and/or duplicate issue (I may be wrong):\n\u003e \n\u003e * [Make NetworkStream compatible with non-blocking I/O #22506](https://github.com/dotnet/runtime/issues/22506)\n\nThis issue talks about related concepts, but spends a lot of time arguing over whether the interface of `Stream` could be modified to allow `Write` to have a non-`void` return (obviously it can\u0027t), and contains inaccurate assertions, such as that at the OS level, Windows does not support the socket non-blocking I/O model where `send` could do a partial send (it does), or that `System.Socket` already supports non-blocking I/O for send and receive (it doesn\u0027t, because if a partial operation occurs, it gets translated to a `System.SocketException` and you have no way to recover how many bytes were actually processed).",
                                           "updatedAt":  "2025-09-13T12:55:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7ErfeF",
                                           "createdAt":  "2025-09-16T17:39:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "The [Socket.Send](https://learn.microsoft.com/en-us/dotnet/api/system.net.sockets.socket.send?view=net-8.0#system-net-sockets-socket-send(system-byte())) already returns `int`. So clearly it knows it can write less than asked for. Perhaps we should not throw in that case...??? AFAIK we internally already tracking the blocking status. \n\nAlso you can ask for available buffer on socket e.g. get info how much you can write without blocking. While that is still kernel call it is probably pretty cheap and it does not impact the TCP segmentation if you are worried about that. In practice I doubt that has any real impact. When you are getting to the point the socket buffer is full I doubt extra `send` would have impact on the TCP.  \n\nThe Stream interface is different story. As high level API it would try to complete given task even if that means multiple IO operations. For `WriteAsync`, it always puts the socket in non-blocking mode and it deals with the outcome internally. \n\nIt would be curious to perhaps write some benchmark or provide C implementation that can demonstrate the benefits. That would help to prioritize this accordingly. ",
                                           "updatedAt":  "2025-09-16T17:39:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7EsQai",
                                           "createdAt":  "2025-09-16T18:44:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "logiclrd",
                                           "body":  "\u003e The Stream interface is different story. As high level API it would try to complete given task even if that means multiple IO operations.\n\nIt does not do this for `Read`, though. The `ReadAtLeast` and `ReadExactly` methods were added for the purpose of making `Read` have the same high-level semantics as `Write`. So, for symmetry, really, `Write` ought to return an `int` and support partial write operations, and there should be `WriteAtLeast` and `WriteExactly` methods. But, the ship has sailed on that one 🙂 \n\nEven if we can\u0027t have actual symmetry in the methods, though, we could at least have symmetry in the functionality that is offered. The counterpart to the relationship `Read` \u003c-\u003e `ReadExactly` could be `WriteSome` \u003c-\u003e `Write`.\n\n\u003e For `WriteAsync`, it always puts the socket in non-blocking mode and it deals with the outcome internally.\n\nIs this true?\n\nI just went and took a peek at the code, and, well, the code is very convoluted, and I don\u0027t have a local copy to analyze with an IDE that understands the type space, but it uses `Socket.SendAsync` (and actually has its own specialized internal `SendAsyncForNetworkStream` method to massage some semantics). Task-based async operations are *not* intrinsically the same thing as `O_NONBLOCK`, and I haven\u0027t managed to find any place that sets the socket to be non-blocking in order to process `SendAsync`. Maybe it\u0027s there, but I couldn\u0027t find it. (I did find a UNIX-specific implementation of `SendAsync` that _explicitly checks_ whether the socket is non-blocking and alters its behaviour accordingly.)\n\nEven if it is, though, that internal implementation detail doesn\u0027t really address the fact that the *user* has no access to non-blocking partial writes.",
                                           "updatedAt":  "2025-09-16T18:44:59Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "System.Stream, System.Socket: Partial reads \u0026 writes?",
        "labels":  [
                       "area-System.Net.Sockets",
                       "untriaged"
                   ]
    }
]
