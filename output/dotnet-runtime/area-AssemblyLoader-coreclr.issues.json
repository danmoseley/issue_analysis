[
    {
        "url":  "https://github.com/dotnet/runtime/issues/9185",
        "createdAt":  "2017-10-24T23:04:45Z",
        "number":  9185,
        "author":  "masonwheeler",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOAOuyxw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Suchiman",
                                            "createdAt":  "2017-10-25T19:07:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "3dGrabber",
                                            "createdAt":  "2017-10-26T08:50:52Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2021-11-04T07:53:31Z",
        "body":  "We\u0027ve all had it happen.  We go to load a program, or load an assembly into our program, and it fails with an \"assembly not found\" error on some assembly we didn\u0027t ask for, that doesn\u0027t look at first glance like it has anything to do with what we\u0027re trying to load.  Generally it\u0027s a dependency of a dependency of a dependency of a dependency of what we actually care about, and the actual problem to be fixed could lie at any point along that dependency chain.\r\n\r\nKnowing what this chain is is the information that we need to resolve the issue, but it\u0027s not provided, which makes fixing these problems like pulling teeth sometimes.\r\n\r\nIt would be great if we could get a \"stacktrace\" of the dependency chain, so that instead of simply saying:\r\n\r\n    Could not load file or assembly \u0027Foo, Version=0.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51\u0027. The system cannot find the file specified.\r\n\r\nit would then continue on and say:\r\n\r\n    while loading assembly Bar, Version=0.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51\r\n    while loading assembly Baz, Version=0.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51\r\n    while loading assembly Qux, Version=0.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51\r\n\r\nHow much work would it be to fix this up?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOOUB88Q==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMzOTIwNDUwMA==",
                                           "createdAt":  "2017-10-25T03:37:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "Related to https://github.com/dotnet/coreclr/issues/8302",
                                           "updatedAt":  "2017-10-25T03:37:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc45QHzx",
                                           "createdAt":  "2021-11-04T07:53:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MagicAndre1981",
                                           "body":  "you can already use [ETW to capture fusion loading events](https://stackoverflow.com/a/29374658/1466046) and view them in Perfview\r\n\r\n![image](https://user-images.githubusercontent.com/8274816/140276803-acb44bad-e272-4a80-875d-973c5ce05f5a.png)\r\n",
                                           "updatedAt":  "2021-11-04T07:53:31Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[Proposal] Provide a \"logical stacktrace\" when assemblies fail to load.",
        "labels":  [
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/11305",
        "createdAt":  "2018-10-24T01:27:42Z",
        "number":  11305,
        "author":  "Spongman",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCy5T3g==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mklement0",
                                            "createdAt":  "2019-04-18T19:38:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kvprasoon",
                                            "createdAt":  "2019-06-17T03:05:52Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "0x0309",
                                            "createdAt":  "2023-09-27T20:38:21Z"
                                        }
                                    ],
                          "totalCount":  3
                      },
        "updatedAt":  "2024-08-06T15:37:57Z",
        "body":  "when you publish a linux-x64 command-line using self-contained mode, and then run the program using the supplied ELF exe, `Environment.CommandLine` (and `Environment.GetCommandLineArgs()[0]`) refers to the `.dll` instad of the ELF.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOKlT8ew==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ1NDEwODkzNw==",
                                           "createdAt":  "2019-01-14T18:25:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "RussKeldorph",
                                           "body":  "@jeffschwMSFT Can you attach an `area-` label to this or move it to the repo it belongs?  ...or dispose of it as you see fit. :)",
                                           "updatedAt":  "2019-01-14T18:25:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ1NTMzOTkzOA==",
                                           "createdAt":  "2019-01-17T21:33:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffschwMSFT",
                                           "body":  "cc @sdmaclea (we may need to copy this to core-setup)",
                                           "updatedAt":  "2019-01-17T21:33:31Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4NDY2MjIzNg==",
                                           "createdAt":  "2019-04-18T19:47:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAnNoIw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kvprasoon",
                                                                               "createdAt":  "2019-04-19T03:03:54Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "mklement0",
                                           "body":  "Note that this problem surfaces on all platforms.\r\n\r\nE.g., using PowerShell Core v6.2 on Windows:\r\n\r\n```powershell\r\nPS\u003e [Environment]::GetCommandLineArgs()\r\nC:\\Program Files\\PowerShell\\6\\pwsh.dll\r\n```\r\n",
                                           "updatedAt":  "2019-04-18T19:47:05Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4NTMwMDcwMA==",
                                           "createdAt":  "2019-04-22T01:46:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sdmaclea",
                                           "body":  "@jeffschwMSFT I agree this should move to core-setup",
                                           "updatedAt":  "2019-04-22T01:46:56Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4NTQyNjE1MA==",
                                           "createdAt":  "2019-04-22T14:01:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e move to core-setup\r\n\r\nI am not sure about it.\r\n\r\nThere will be change required in CoreCLR to fix this. There may or may not be change required in core-setup too. It depends on the design. Maybe we should fix discuss what the fix is going to look like.",
                                           "updatedAt":  "2019-04-22T14:01:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4NTQ2NjQ4Mw==",
                                           "createdAt":  "2019-04-22T16:26:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sdmaclea",
                                           "body":  "\u003e I am not sure about it.\r\n\r\nI had assumed that CoreCLR was populating `Environment.CommandLine` from a property passed by AppHost to host policy.  \r\n\r\nI was intending to change `AppHost`, to correct the CommandLine.",
                                           "updatedAt":  "2019-04-22T16:26:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4NTUxMDEyMw==",
                                           "createdAt":  "2019-04-22T18:46:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBNf2qA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "mklement0",
                                                                               "createdAt":  "2020-08-16T16:52:25Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "`Environment.CommandLine` is create by stitching the managed entrypoint .dll name and individual arguments together: https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/System/Environment.cs#L64. AppHost has no control over it.",
                                           "updatedAt":  "2019-04-22T18:46:56Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4NzIwOTE0MA==",
                                           "createdAt":  "2019-04-26T21:36:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "fyi see linked issue for more details on how this works together.",
                                           "updatedAt":  "2019-04-26T21:36:18Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ5MTI3MjMzMA==",
                                           "createdAt":  "2019-05-10T12:31:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mklement0",
                                           "body":  "On a related note: Once this is fixed, will `Environment.CommandLine` / `Environment.GetCommandLineArgs` reflect an intentionally set _custom_ invocation name (`argv[0]`, reflected in `$0` in POSIX-like shells), as used on Unix-like platforms?\r\n\r\nPrepending the actual invocation name with `-` is a convention used to signal to POSIX-like shells such as Bash that they should act as _login shells_, and utilities such as `ssh`, macOS terminal emulators and Bash\u0027s `exec -l` use this mechanism.\r\n\r\nFor PowerShell to be a good Unix shell citizen (to be able to fully act as a user\u0027s default shell), it must therefore know its true invocation name, so it can check for `-` as the first character - see https://github.com/PowerShell/PowerShell-RFC/pull/171.\r\n\r\nA quick Bash example that shows that `exec -l` prepends `-` to the invocation name, which `sh` sees reflected in `$0`:\r\n\r\n```sh\r\n# Run from Bash.\r\n$ (exec -l sh -c \u0027echo $0\u0027)\r\n-sh\r\n```\r\n\r\nAlso, if invocation happened _via a symlink_, it is the symlink\u0027s path that should be reported by `Environment.CommandLine` / `Environment.GetCommandLineArgs`: see https://github.com/dotnet/runtime/issues/30212#issuecomment-710357008\r\n\r\n",
                                           "updatedAt":  "2020-10-16T18:18:15Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY3MzQxMzcxNg==",
                                           "createdAt":  "2020-08-13T11:07:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Artoria2e5",
                                           "body":  "For some reason the reference from #25841 is not showing up. Adding it manually here.\r\n\r\nThe PowerShell test suite currently uses a C# `testexe` to validate some aspects of command-line passing, but due to this issue I am currently unable to verify that a \"force quote\" thing is working. Many Windows apps need that.",
                                           "updatedAt":  "2020-08-13T11:08:22Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY3NDU1NDAxMA==",
                                           "createdAt":  "2020-08-16T17:27:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mklement0",
                                           "body":  "@Artoria2e5:\r\n\r\nI think the only thing to be fixed here, if feasible, is that the actual executable (original entry point) not the managed DLL filename should be reflected in `Environment.GetCommandLineArgs(0)` / the first argument in `Environment.CommandLine`.\r\n\r\nAs  @jkotas stated above, .NET Core _reconstructs_ a _hypothetical_ command line that may or may not exactly reflect the actual command line passed _on Windows_. On Unix, there is no command line to begin with.\r\n([permalink to the source code](https://github.com/dotnet/coreclr/blob/a9f3fc16483eecfc47fb79c362811d870be02249/src/System.Private.CoreLib/shared/System/Environment.cs#L73)).\r\n\r\n* On Windows, the reconstructed command line is fully _equivalent_ to the original one, assuming that (a) you make the call  without involvement of a shell (e.g., from the Windows `Run` dialog, \u003ckbd\u003eWinKey-R\u003c/kbd\u003e) and (b) a .NET / Microsoft C/C++-compiler-based executable parses it.\r\n\r\n* On Unix, the reconstructed command line is not robustly usable in any real-world sense, because you\u0027d need a _shell_ to call it, and a shell\u0027s own up-front interpretation of such a command line would alter the call (e.g., `foo \u0027*.txt\u0027` would be reported as something like `/path/to/foo *.txt` - note the absence of quotes - which, if used as-is in a POSIX-like shell such as `bash` would cause globbing (expansion of wildcard pattern `*.txt` to matching filenames in the current dir)).\r\n\r\nWhile calling the Windows API when running on Windows to get the true command line is [feasible](https://github.com/dotnet/runtime/issues/25841#issuecomment-380484617), I don\u0027t think it is worth the trouble to implement this in `Environment.CommandLine`.\r\n\r\nFor your use case, the simplest solution is to compile a .NET _Framework_ console application, where the true command line _is_ being reported; this is as simple as a single `Add-Type` call from _Windows PowerShell_; the following command creates a `printArgs.exe` executable in the current dir; when invoked, `printArgs.exe` prints its parsed arguments individually as well as the raw command line:\r\n\r\n```powershell\r\nAdd-Type -OutputType ConsoleApplication -OutputAssembly ./printArgs.exe -TypeDefinition @\u0027\r\n  using System;\r\n  static class ConsoleApp {\r\n    static int Main(string[] args) {\r\n      Console.WriteLine(\"\\n{0} argument(s) received (enclosed in \u003c...\u003e for delineation):\\n\", args.Length);\r\n      for (int i = 0; i \u003c args.Length; ++i) {\r\n          Console.WriteLine(\"  \u003c{0}\u003e\", args[i]);\r\n      }\r\n      Console.WriteLine(\"\\nCommand line:\\n\\n  {0}\\n\", Environment.CommandLine);\r\n      return 0;\r\n    }\r\n  }\r\n\u0027@\r\n```\r\n\r\nThis is essentially what the `dbea` (`Debug-ExecutableArguments`) command from the [`Native` PowerShell module](https://github.com/mklement0/Native) does behind the scenes.\r\n\r\nThe alternative is to use a P/Invoke call to the Windows API\u0027s `GetCommandLineW` function, as demonstrated in https://github.com/PowerShell/PowerShell/issues/1995#issuecomment-677664318.\r\n",
                                           "updatedAt":  "2020-08-20T13:35:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcxMDIxMjczMQ==",
                                           "createdAt":  "2020-10-16T16:50:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBTwnTg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Spongman",
                                                                               "createdAt":  "2020-10-16T16:52:21Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "mklement0",
                                           "body":  "A workaround for `Environment.GetCommandLineArgs()[0]` returning the wrong value is `System.Diagnostics.Process.GetCurrentProcess().MainModule.FileName` (#42768 will make this simpler and more efficient in .NET 6.0: `Environment.ProcessPath`); the added advantage is always getting a _full_ path back, whereas on Windows `Environment.GetCommandLineArgs()[0]` can situationally report a relative one.",
                                           "updatedAt":  "2024-08-06T15:37:57Z"
                                       }
                                   ],
                         "totalCount":  12
                     },
        "title":  "Environment.CommandLine for published ",
        "labels":  [
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/13015",
        "createdAt":  "2019-07-01T17:19:40Z",
        "number":  13015,
        "author":  "shvez",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-08-10T14:11:54Z",
        "body":  "@vitek-karas  you asked me here(https://github.com/dotnet/coreclr/issues/13277) to create a new issue. here it is.\r\n\r\nIn short:\r\nMy plugin application has a dependency from System.Diagnostics.PerformanceCounter.dll. I publish it as `dotnet publish -f netcoreapp3.0`\r\n\r\nThe issue is that if I just build my loader and start it, it loads plugin application without any issues. It takes a version of the library from `runtimes` folder.\r\nif I publish Loader application like \u0027dotnet publish -f netcoreapp3.0 -r win-x64\u0027 (it is important that I use RID \u0027win-x64\u0027, not \u0027win10-x64\u0027) it loads  System.Diagnostics.PerformanceCounter.dll assembly from the plugin application folder. And this version is generating an exception that platform is not supported.\r\n\r\nI\u0027ve checked the trace file for failure case and found out that it can not load from runtimes folder because RID win10-x64 is not compatible with platform \u0027win\u0027 where System.Diagnostics.PerformanceCounter.dll is situated.  `runtimes\\win\\lib\\netcoreapp2.0\\System.Diagnostics.PerformanceCounter.dll` to be precise.  I do not see such message for NotPublished version\r\nEDIT:\r\ntrace snippet for published version\r\n```\r\nAdding runtimeTargets runtime asset runtimes/win/lib/netcoreapp2.0/System.Diagnostics.PerformanceCounter.dll rid=win assemblyVersion=4.0.1.0 fileVersion=4.700.19.30308 from System.Diagnostics.PerformanceCounter/4.6.0-preview6.19303.8\r\nThe targeted framework does not support the runtime \u0027win10-x64\u0027. Some native libraries from [System.Diagnostics.PerformanceCounter/4.6.0-preview6.19303.8] may fail to load on this platform.\r\nAdding runtime asset lib/netstandard2.0/System.Diagnostics.PerformanceCounter.dll assemblyVersion=4.0.1.0 fileVersion=4.700.19.30308 from System.Diagnostics.PerformanceCounter/4.6.0-preview6.19303.8\r\nReconciling library System.Diagnostics.PerformanceCounter/4.6.0-preview6.19303.8\r\n```\r\ntrace snippet for non published version\r\n```\r\nAdding runtimeTargets runtime asset runtimes/win/lib/netcoreapp2.0/System.Diagnostics.PerformanceCounter.dll rid=win assemblyVersion=4.0.1.0 fileVersion=4.700.19.30308 from System.Diagnostics.PerformanceCounter/4.6.0-preview6.19303.8\r\nAdding runtime asset lib/netstandard2.0/System.Diagnostics.PerformanceCounter.dll assemblyVersion=4.0.1.0 fileVersion=4.700.19.30308 from System.Diagnostics.PerformanceCounter/4.6.0-preview6.19303.8\r\nReconciling library System.Diagnostics.PerformanceCounter/4.6.0-preview6.19303.8\r\n```\r\ndifference is this line:\r\n```\r\nThe targeted framework does not support the runtime \u0027win10-x64\u0027. Some native libraries from [System.Diagnostics.PerformanceCounter/4.6.0-preview6.19303.8] may fail to load on this platform.\r\n```\r\nEnd of EDIT\r\n\r\nWhat do I do wrong? What should I do to get it working correctly? I need a version of my application which may run on windows, on linux, and on mac. \r\n\r\nhere is netcore info:\r\n```\r\n.NET Core SDK (reflecting any global.json):\r\n Version:   3.0.100-preview6-012264\r\n Commit:    be3f0c1a03\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.18362\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\3.0.100-preview6-012264\\\r\n\r\nHost (useful for support):\r\n  Version: 3.0.0-preview6-27804-01\r\n  Commit:  fdf81c6faf\r\n\r\n.NET Core SDKs installed:\r\n  2.1.604 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.700 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.800-preview-009696 [C:\\Program Files\\dotnet\\sdk]\r\n  2.2.300 [C:\\Program Files\\dotnet\\sdk]\r\n  3.0.100-preview6-012264 [C:\\Program Files\\dotnet\\sdk]\r\n```\r\n\r\nhere are links to trace files and to sample application:\r\nLoader app sample: https://www.dropbox.com/s/lqragpd26vfccr2/Loader.7z?dl=0\r\nit contains Loader - app, Application - the plugin, AppInterfaces - common interface lib. \r\n\u0027_out\u0027 folder which contains \u0027dev\u0027 folder with build results and \u0027publish\u0027 folder with results of publishing.\r\n\r\ntrace_p.7z(https://www.dropbox.com/s/vfwbzgfoyqf4umb/trace_p.log.7z?dl=0) - zipped version of trace for the version from \u0027publish\u0027 folder\r\ntrace.7z(https://www.dropbox.com/s/613qu1n8wy5a3rv/trace.log.7z?dl=0) - zipped version of trace for the version from \u0027dev\u0027 folder\r\n\r\nto start dev version you may use visual studio. to start published version you have to go to \u0027_out/publish/Loader\u0027 folder and start Loader.exe",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOHl-gbw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwODExMzExNw==",
                                           "createdAt":  "2019-07-03T14:17:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "shvez",
                                           "body":  "From the traces I\u0027ve attached to the initial post, I found out that in case of the published version the rid fallback graph is empty. I think this could be a reason for `The targeted framework does not support the runtime \u0027win10-x64\u0027` message",
                                           "updatedAt":  "2019-07-03T14:17:45Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwOTU2NTQ0Mg==",
                                           "createdAt":  "2019-07-09T09:24:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "This is a known problem with the component loading in self-contained apps. The master issue is here: https://github.com/dotnet/core-setup/issues/6961. In your case you\u0027re specifically hitting https://github.com/dotnet/core-setup/issues/6960.\r\n\r\nUnfortunately I\u0027m currently not aware of a good workaround. The only one I can think of is to add some code into your `AssemblyLoadContext.Load` and handle this case specifically. Alternatively you could modify the build of your host app and manually add the RID fallback graph into its `.deps.json` - then it should work. If you only have one or two cases like this I would probably go with the custom code in the load context - it\u0027s not clean, the host app has to know about which libraries the plugin loads - but it\u0027s probably the least amount of trouble.",
                                           "updatedAt":  "2019-07-09T09:24:31Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwOTU2Njk3Ng==",
                                           "createdAt":  "2019-07-09T09:28:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "shvez",
                                           "body":  "thank you for response\r\n\r\nare you going to fix those issues before netcore 3 release?",
                                           "updatedAt":  "2019-07-09T09:28:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwOTU3MDE2MA==",
                                           "createdAt":  "2019-07-09T09:37:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "I don\u0027t think it will happen - the one you\u0027re hitting we might be able to as it\u0027s just an SDK change, doesn\u0027t require fixes in the host or the runtime. The other will very likely not happen as it requires changes both in SDK and the host.",
                                           "updatedAt":  "2019-07-09T09:37:13Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwOTU4MzQ3MQ==",
                                           "createdAt":  "2019-07-09T10:16:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "shvez",
                                           "body":  "well, one more possible solution is the publishing of plugin with an explicit platform. Some what like -r win-x64.\r\nAlthough it may work for us (with a tradeoff of creating multiple copies of the same code in binary form) it may in some cases create troubles for our customers, who also provides plugins for our plugins ",
                                           "updatedAt":  "2019-07-09T10:16:37Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "AssemblyLoadContext: Loading of assemblies from \u0027runtimes\u0027 folder",
        "labels":  [
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/13226",
        "createdAt":  "2019-08-07T20:58:27Z",
        "number":  13226,
        "author":  "wall-code-solutions",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-05-24T14:56:30Z",
        "body":  "I have a problem with a plugin that has a wpf usercontrol. If an instance of the control is created then the plugin assembly will not be garbage collected. Whats wrong here?\r\n\r\n```\r\nProject1:\r\npublic interface IPlugin\r\n    {\r\n        object GuiControl { get; }\r\n    }\r\n```\r\n\r\n```\r\nProject2:\r\npublic class Plugin : IPlugin\r\n    {\r\n        public object GuiControl { get; }\r\n\r\n        public Plugin()\r\n        {\r\n            GuiControl = new UserControl1(); // Comment this line out =\u003e Assemblies are now garbage collected\r\n        }\r\n\r\n        ~Plugin()\r\n        {\r\n            Console.WriteLine(\"Plugin: Calling destructor\");\r\n        }\r\n    }\r\n```\r\n\r\n```\r\nProject3:\r\npublic class CollectableAssemblyLoadContext : AssemblyLoadContext\r\n    {\r\n        public CollectableAssemblyLoadContext(string name) : base(name, true) { }\r\n              \r\n        protected override Assembly Load(AssemblyName assemblyName) =\u003e null;\r\n\r\n        public Assembly Load(byte[] rawAssembly)\r\n        {\r\n            using (var memoryStream = new MemoryStream(rawAssembly))\r\n            {\r\n                var assembly = LoadFromStream(memoryStream);\r\n                return assembly;\r\n            }\r\n        }\r\n    }\r\n\r\nclass Program\r\n    {\r\n        [STAThread]\r\n        static void Main(string[] args)\r\n        {\r\n            for (int i = 0; i \u003c 500; i++)\r\n                TestRun();\r\n\r\n            int counter = 0;\r\n            //while(counter == 100)\r\n            //{\r\n            counter++;\r\n\r\n            GC.Collect();\r\n            GC.WaitForPendingFinalizers();\r\n\r\n            //Thread.Sleep(2500);\r\n            //}\r\n\r\n            Console.WriteLine(\"Assemblies: {0}\", AppDomain.CurrentDomain.GetAssemblies().Where(p =\u003e p.IsCollectible).Count()); // 500 Assemblies - Why?\r\n            Console.WriteLine(\"ALC\u0027s: {0}\", AssemblyLoadContext.All.Count()); // 1 ALC \"Default\"\r\n\r\n            Console.ReadKey();\r\n        }       \r\n        \r\n        public static void TestRun()\r\n        {\r\n            var context = new CollectableAssemblyLoadContext(Guid.NewGuid().ToString());\r\n            var assembly = context.LoadFromAssemblyPath(Path.Combine(Directory.GetCurrentDirectory(), \"GuiPlugin.dll\"));\r\n\r\n            var instance = (IPlugin) Activator.CreateInstance(assembly.GetType(\"GuiPlugin.Plugin\"));            \r\n\r\n            context.Unload();\r\n        }\r\n    }\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOP4H0Zw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUxOTI5MTg1OA==",
                                           "createdAt":  "2019-08-07T22:29:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mattwarren",
                                           "body":  "Out of interest, if you add `[MethodImpl(MethodImplOptions.NoInlining)]` to your `TestRun()` method, does that make any difference?\r\n\r\nI\u0027ve seen that attribute used in a several examples, as it helps prevent assemblies being inadvertently \u0027rooted\u0027, e.g.\r\n\r\n- [The official docs](https://docs.microsoft.com/en-us/dotnet/standard/assembly/unloadability-howto#example-source-with-unloadability-issues)\r\n- https://github.com/dotnet/coreclr/issues/20694",
                                           "updatedAt":  "2019-08-07T22:29:04Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUxOTMyMjM5NQ==",
                                           "createdAt":  "2019-08-08T01:03:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AndyAyersMS",
                                           "body":  "It\u0027s possible that the jit might extend GC lifetimes of inlinee locals beyond the extent of the inlinee. dotnet/coreclr#9479 tried to put a stop to this, so if you find examples where this happens I\u0027d be happy to take a look.\r\n\r\nFor allocations within the same method where you force GC, even if you null out your locals after using them, the jit may have stashed references in jit temporaries that don\u0027t get nulled.\r\n\r\nKeeping your expected to be dead allocations and references in a noinline method is the most reliable fix.",
                                           "updatedAt":  "2019-08-08T01:03:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUxOTM2MjQ3MA==",
                                           "createdAt":  "2019-08-08T04:51:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "cc @janvorli ",
                                           "updatedAt":  "2019-08-08T04:51:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUxOTY1OTM3Mw==",
                                           "createdAt":  "2019-08-08T19:39:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wall-code-solutions",
                                           "body":  "\u003e Out of interest, if you add `[MethodImpl(MethodImplOptions.NoInlining)]` to your `TestRun()` method, does that make any difference?\r\n\u003e \r\n\u003e I\u0027ve seen that attribute used in a several examples, as it helps prevent assemblies being inadvertently \u0027rooted\u0027, e.g.\r\n\u003e \r\n\u003e * [The official docs](https://docs.microsoft.com/en-us/dotnet/standard/assembly/unloadability-howto#example-source-with-unloadability-issues)\r\n\u003e * dotnet/runtime#11366\r\n\r\nAdding `[MethodImpl(MethodImplOptions.NoInlining)]` to the method `TestRun()` did not help.\r\n",
                                           "updatedAt":  "2019-08-08T19:39:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUxOTY2MTQxNQ==",
                                           "createdAt":  "2019-08-08T19:45:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wall-code-solutions",
                                           "body":  "It\u0027s strange ... if i am change\r\n`GuiControl = new UserControl1(); // Comment this line out =\u003e Assemblies are now garbage collected`\r\nto\r\n`GuiControl = new UserControl(); // Comment this line out =\u003e Assemblies are now garbage collected`\r\n\r\nAssemblies are now garbage collected.\r\n\r\n",
                                           "updatedAt":  "2019-08-08T19:45:56Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyMjEyNTExMw==",
                                           "createdAt":  "2019-08-16T19:29:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "@X1C3 how do UserControl and UserControl1 differ? ",
                                           "updatedAt":  "2019-08-16T19:29:53Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyMjEzODg5Mg==",
                                           "createdAt":  "2019-08-16T20:20:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wall-code-solutions",
                                           "body":  "@janvorli\r\n\r\nUserControl1 inherit from UserControl. UserControl1 has no special code implementation. It is empty.\r\n\r\n```\r\npublic partial class UserControl1 : UserControl\r\n    {\r\n        public UserControl1()\r\n        {\r\n            InitializeComponent();            \r\n        }\r\n\r\n        ~UserControl1()\r\n        {\r\n            Console.WriteLine(\"UserControl1: Calling destructor\");\r\n        }\r\n    }\r\n\r\n```\r\n```\r\n\u003cUserControl x:Class=\"GuiPlugin.UserControl1\"\r\n             xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\r\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\r\n             xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" \r\n             xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\" \r\n             xmlns:local=\"clr-namespace:GuiPlugin\"\r\n             mc:Ignorable=\"d\" \r\n             d:DesignHeight=\"450\" d:DesignWidth=\"800\"\u003e\r\n    \u003cGrid\u003e\r\n            \r\n    \u003c/Grid\u003e\r\n\u003c/UserControl\u003e\r\n```",
                                           "updatedAt":  "2019-08-16T21:03:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyMjE2MDAzMA==",
                                           "createdAt":  "2019-08-16T21:40:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "@X1C3 I have just noticed you only call GC.Collect(); GC.WaitForPendingFinalizers(); once. That doesn\u0027t guarantee that the unload will complete after that. If you want to make sure that everything is unloaded at some specific point, you need to do the following (as described in the https://docs.microsoft.com/en-us/dotnet/standard/assembly/unloadability-howto#example-source-with-unloadability-issues).\r\nSo in your test, you\u0027d need to:\r\n* Add [MethodImpl(MethodImplOptions.NoInlining)] to the TestRun\r\n* Change the TestRun to return WeakReference and return new WeakReference(context) from it\r\n* In your Main, have a loop that calls GC.Collect(); GC.WaitForPendingFinalizers(); while the weak reference is alive. Since you call the RunTest 500 times in a loop, you could either do it after each call to TestRun or have an array of 500 WeakReferences that you set while calling the RunTest and then have a loop that calls the GC.Collect(); GC.WaitForPendingFinalizers(); until all of the WeakReferences become invalid.\r\n\r\n",
                                           "updatedAt":  "2019-08-16T21:40:07Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyMjc0NTY2Nw==",
                                           "createdAt":  "2019-08-19T20:42:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wall-code-solutions",
                                           "body":  "@janvorli \r\n\r\nI think that the problem is not the implementation, but the wpf control (UserControl1). Without this UserControl1 the assembly load context and the loaded assembly is garbage collected immediately.\r\n\r\n```\r\n[STAThread]\r\n        static void Main(string[] args)\r\n        {\r\n            //for (int i = 0; i \u003c 500; i++) \r\n\r\n            WeakReference weakReference;\r\n            TestRun(out weakReference);\r\n\r\n            for (int i = 0; weakReference.IsAlive \u0026\u0026 (i \u003c 10000); i++)\r\n            {\r\n                GC.Collect();\r\n                GC.WaitForPendingFinalizers();\r\n                Console.WriteLine(\"{0}: \" + weakReference.IsAlive.ToString(), i);\r\n            }                  \r\n        }        \r\n\r\n        [MethodImpl(MethodImplOptions.NoInlining)]\r\n        public static void TestRun(out WeakReference weakReference)\r\n        {\r\n            var context = new CollectableAssemblyLoadContext(Guid.NewGuid().ToString());\r\n            weakReference = new WeakReference(context);\r\n\r\n            var assembly = context.LoadFromAssemblyPath(Path.Combine(Directory.GetCurrentDirectory(), \"GuiPlugin.dll\"));\r\n\r\n            var type = assembly.GetType(\"GuiPlugin.Plugin\");\r\n            Activator.CreateInstance(type);\r\n            type = null;\r\n\r\n            context.Unload();\r\n        }\r\n```",
                                           "updatedAt":  "2019-08-19T20:42:14Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyMjc1MjEyOQ==",
                                           "createdAt":  "2019-08-19T21:01:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "@X1C3 so do I understand it correctly that the code above fails to unload  with UserControl1 even with many iterations in the `for` loop?",
                                           "updatedAt":  "2019-08-19T21:01:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyMjg5NTQ3OQ==",
                                           "createdAt":  "2019-08-20T07:41:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wall-code-solutions",
                                           "body":  "@janvorli \r\nCorrect, the weakReference status is always \"alive\" = true.",
                                           "updatedAt":  "2019-08-20T07:42:12Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyMzYzNzU2Mg==",
                                           "createdAt":  "2019-08-21T20:33:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "@X1C3 I\u0027ve tried to replicate this locally and I get the following output:\r\n```\r\nPlugin: Calling destructor\r\n0: True\r\n1: True\r\n2: False\r\n```\r\nSo it seems to work. I wonder - is your main app that you are testing it with a WPF app or a console app? I am testing it with a console one, so that may cause the difference.",
                                           "updatedAt":  "2019-08-21T20:33:55Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyMzg3MTQxNg==",
                                           "createdAt":  "2019-08-22T11:49:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wall-code-solutions",
                                           "body":  "@janvorli  \r\nHere a repro: https://github.com/X1C3/WpfPlugin\r\n\r\nI am using a console app. I would like to know, what is different in your implementation.",
                                           "updatedAt":  "2019-08-22T11:49:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyMzg4ODc4OA==",
                                           "createdAt":  "2019-08-22T12:42:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "Ok, my local repro has the UserControl in a separate assembly. That makes the difference. I\u0027ve just split your Plugin project into two - one with the Plugin.cs and the other with the UserControl1 files. \r\nI have not tried to look into why it makes a difference yet.",
                                           "updatedAt":  "2019-08-22T12:42:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyMzkxNjU1MQ==",
                                           "createdAt":  "2019-08-22T13:54:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wall-code-solutions",
                                           "body":  "@janvorli \r\nThanks for the hint. Now it works if the UserControl is moved to a seperate assembly file. But that should not be the final solution.",
                                           "updatedAt":  "2019-08-22T13:54:00Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyMzkxNzMyMg==",
                                           "createdAt":  "2019-08-22T13:56:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "I agree that it is strange. I\u0027ll debug it to get full understanding of the different behavior.",
                                           "updatedAt":  "2019-08-22T13:56:00Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyNDQyNjIxMw==",
                                           "createdAt":  "2019-08-23T18:58:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAv5-kA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "liquidboy",
                                                                               "createdAt":  "2019-09-04T18:06:26Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "janvorli",
                                           "body":  "@X1C3 I have found why it works when the control is in a separate assembly. I have missed before that your custom CollectableAssemblyLoadContext doesn\u0027t resolve other assemblies than the plugin one into this context (the Load method returns null). So when the control is in a separate assembly, it is loaded into the default context and thus it doesn\u0027t prevent unloading of the context. But that\u0027s not what you wanted do end up with.\r\n\r\nThe real culprit is in the WPF itself. The MS.Internal.Resources.ResourceManagerWrapper holds on the assembly containing the control. And it is rooted (transitively) by two different roots. I\u0027ve just digged that from the !gcroots command in WinDbg at the point where the unload fails.\r\nMy knowledge of WPF and its source code is zero, so I am not sure if there is a way to somehow explicitly remove the ResourceManagerWrapper for our specific assembly using existing APIs or not. But looking at the source code of MS.Internal.AppModel.ResourceContainer that manages those, it seems assemblies can be only added, but never removed.\r\n\r\nSo it seems WPF will need to be made aware of unloadability to make your scenario work.\r\n",
                                           "updatedAt":  "2019-08-23T18:58:08Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyNDU3ODU2NA==",
                                           "createdAt":  "2019-08-24T20:33:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wall-code-solutions",
                                           "body":  "@janvorli\r\nThanks for analysing. Should this restriction fix by the wpf team? Is it kind of a bug or more an extension in wpf - what is the next step? \r\n",
                                           "updatedAt":  "2019-08-24T20:33:47Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyNTI2NjcyOA==",
                                           "createdAt":  "2019-08-27T11:52:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "Someone will need to fix this in the WPF repo (https://github.com/dotnet/wpf). Since it is open source, it doesn\u0027t have to be the wpf team.\r\nI would not call it a bug, rather a missing support for unloading. The unloadability support was added quite recently and so many libraries will need to catch up. I\u0027ll create a github issue in the wpf repo for making WPF unloadability friendly.",
                                           "updatedAt":  "2019-08-27T11:52:58Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyNzY2OTA4OA==",
                                           "createdAt":  "2019-09-03T22:45:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "Created issue here: https://github.com/dotnet/wpf/issues/1764",
                                           "updatedAt":  "2019-09-03T22:45:11Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyODYyOTY2Mw==",
                                           "createdAt":  "2020-11-17T01:38:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "netcorefan1",
                                           "body":  "I mentioned your issue in my post since, at least to me, seems related. The staff marked my post initially with the \"investigate\" label and now sent it to future milestone. This make me think that the fix is something that can take months and more.\r\nThanks\r\n\r\n[UnloadWpfLibrary.zip](https://github.com/dotnet/wpf/files/5543910/UnloadWpfLibrary.zip)\r\n(Solution file inside \"MainApp\" folder)",
                                           "updatedAt":  "2020-11-18T01:35:32Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyOTMxMzY5Mg==",
                                           "createdAt":  "2020-11-18T01:18:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "netcorefan1",
                                           "body":  "I just want to update this issue with a new sample project where I applied the [workaround](https://github.com/dotnet/runtime/issues/13226#issuecomment-523888788) suggested from @janvorli .\r\n[UnloadWpfLibraryWithWorkaround.zip](https://github.com/dotnet/wpf/files/5557080/UnloadWpfLibraryWithWorkaround.zip)\r\n(Solution file inside \"MainApp\" folder)\r\n\r\nThis time one of the two assemblies is unloaded, but all of the others are still loaded included WpfLibrary.\r\nI think that for me it\u0027s time to give up and recur to IPC (named pipes) although I am not sure if this could be a valid replacement.\r\nMay be I missed something and someone more expert can do further progress and attach here the project with the correct modifications, it would be of great benefit for all the users that want to use ALC to load and unload WPF.\r\nIt would be a total of 4 projects just to load and unload a wpf assembly on demand and this is not exactly clean, but if the final result is the same it would be acceptable.\r\n**P.s. Most of the sample projects here are uploaded in the repos and immediately deleted which lead to broken links! I want to encourage people to upload sample projects here as attachment!!**",
                                           "updatedAt":  "2020-11-18T01:36:25Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczMTQxNDQzMw==",
                                           "createdAt":  "2020-11-20T21:24:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "@netcorefan1 I have tried your latest sample and after the loop with GC collect, I have verified that everything was correctly unloaded. So I wonder if you were testing it when running under visual studio or standalone. We had some issues with Visual Studio itself locking the assemblies.\r\nI\u0027ve tested it by putting Debugger.Break() after the loop and running it under WinDbg. After that break was hit, I\u0027ve dumped all LoaderAllocator objects on the managed heap and there was none, which means the unload has completed.",
                                           "updatedAt":  "2020-11-20T21:24:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczMTg4NjAzMA==",
                                           "createdAt":  "2020-11-23T01:28:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "netcorefan1",
                                           "body":  "@janvorli Thanks for your help! I have tried through VS and standalone. In VS, after a few GC iterations the only assembly unloaded is ProxyClass.dll, but all the other WPF framework assemblies remain loaded:\r\n![sample1](https://user-images.githubusercontent.com/63934725/99922176-5d7b3300-2d2f-11eb-8383-14a796b1770b.gif)\r\n\r\n**In standalone, in process explorer the same WPF Framework assemblies are still loaded:**\r\n![sample3](https://user-images.githubusercontent.com/63934725/99922215-a501bf00-2d2f-11eb-84c0-4c525ae43210.png)\r\n\r\n**In standalone memory is not released. It should be around 4-5 mb (because when I instantiate MainWindow.cs it loads all the Framework dependencies and memory usage increases to 25Mb):**\r\n![sample2](https://user-images.githubusercontent.com/63934725/99922275-12155480-2d30-11eb-8f2b-33440b3a4a80.jpg)\r\n\r\nI opened in [StackOverflow](https://stackoverflow.com/questions/64923095/i-need-to-better-understand-the-memory-management-of-net-core-in-order-to-decid) a thread related to that matter where I show sample code which basically is made of just a WPF app. In that project I demonstrate that after some time (still to understand why at random time) the memory increase due to opening and closing a WPF MainWindow is freed and return back to its initial value. And I was asking to the users if its really worth to deal with AssemblyLoadContext which force to have 4 different projects when with one project I end up with the same memory reduction. You should find some interesting things in that thread.\r\nThanks\r\nP.s. I was sure that referencing ProxyInterface.dll in the MainApp was enough, but I have been forced to reference ProxyClass.dll too, otherwise I get \"Could not load file or assembly \u0027WpfLibrary\" when I call \"inst.ShowWindow(), even if the cast to the interface is successful and even if I manually copied WpfLibrary.dll in the working directory. This is very strange!",
                                           "updatedAt":  "2020-11-23T01:28:52Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczMjk4MjQxMw==",
                                           "createdAt":  "2020-11-24T13:46:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "The WPF assemblies are loaded into the default context, that\u0027s why they are not unloaded. Your implementation of the WpfAppAssemblyLoadContext returns null from the Load method, which means that all dependencies of the ProxyClass.dll should be loaded into the default context. ",
                                           "updatedAt":  "2020-11-24T13:46:15Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczMzM5OTI3Ng==",
                                           "createdAt":  "2020-11-25T01:11:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "netcorefan1",
                                           "body":  "The Load method is called only two times, for System.Runtime and ProxyInterface. I left them to return null because they are already loaded in the default context. None of the wpf assemblies pass through the same Load method although they are references of ProxyClass. All the wpf assemblies goes automatically into the default context, no matter what I do and I have no idea of what to do because Microsoft does not provide any doc on how to include the framework assemblies in the custom unloadable context. I don\u0027t understand why has not been implemented a simple boolean switch which allow to auto load in ALC all the references of the target assembly, not just the assembly itself.\r\nCould you give me the right directions? Because honestly I am afraid that I will never be able to do this job with my current skills.",
                                           "updatedAt":  "2020-11-25T01:11:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczMzQwMjQxNA==",
                                           "createdAt":  "2020-11-25T01:22:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "@vitek-karas do you have any idea why the Load method on the assembly load context is not called for the WpfLibrary.dll and PresentationFramework even though the ProxyClass.dll directly references it? \r\n\r\nThis is the list of references in the ProxyClass.dll:\r\n// Referenced assemblies (in metadata order):\r\n// PresentationFramework, Version=5.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35 (unresolved)\r\n// ProxyInterface, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null (unresolved)\r\n// System.Runtime, Version=5.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a (unresolved)\r\n// WpfLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null (unresolved)\r\n\r\nI\u0027ve tried the repro locally and I can confirm that it is really called just for the System.Runtime and ProxyInterface",
                                           "updatedAt":  "2020-11-25T01:22:05Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczMzY5OTY1MA==",
                                           "createdAt":  "2020-11-25T13:15:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "If the goal is to load a WPF control as a \"plugin\" and when unloaded all of WPF will be gone as well, then this is not currently possible.\r\n* WPF assemblies are from framework `Microsoft.WindowsDesktop.App` and as such they are always loaded into the default load context (the loading happens lazily, but a good way to think about it is that they are \"Registered\" with the default load context). This is why the code works at all, since there\u0027s no direct reference to WPF assemblies anywhere in the build, they are references as a framework because of the `net5.0-windows` TFM.\r\n* Currently it\u0027s not supported to load any framework assemblies into secondary (unloadable) load contexts. This is specifically true for WPF. WPF assemblies store quite a bit of static state which is \"process wide\", so allowing then to be loaded potentially multiple times would lead to trouble. Note that there\u0027s no \"block\u0027 in place, so it\u0027s possible to try this, but it\u0027s very likely it will break.\r\n* As @janvorli  mentioned there seems to be an issue with WPF where it holds onto assemblies with custom controls longer than it should - https://github.com/dotnet/wpf/issues/1764. This would prevent the control to be unloaded itself.\r\n\r\nCurrently the recommended solution is to load frameworks into the default load context (as this app does) and only the plugins are loaded into a custom load context - which can be unloaded. The framework remains loaded for the lifetime of the process. Unfortunately https://github.com/dotnet/wpf/issues/1764 makes it rather hard if not impossible to work with unloading when using WPF.\r\n\r\nAs for the project design - a good guide how to build a plugin app is here: https://docs.microsoft.com/en-us/dotnet/core/tutorials/creating-app-with-plugin-support (it has a working sample app here: https://github.com/dotnet/samples/tree/master/core/extensions/AppWithPlugin). Specifically I want to point out how to reference the \"shared\" assemblies from the plugin: https://docs.microsoft.com/en-us/dotnet/core/tutorials/creating-app-with-plugin-support#simple-plugin-with-no-dependencies. In your case this is about the project reference from `ProxyClass` to `ProxyInterface`. The plugin should specify Private=false and ExcludeAssets=runtime, this makes it so that the ProxyInterface is not included in the build output of the plugin.\r\n\r\nThen you should not need a project reference from the MainApp to the plugin (ProxyClass in your case) and using the AssemblyDependencyResolver in your custom load context to resolve its dependencies.",
                                           "updatedAt":  "2020-11-25T13:15:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczMzcwMTUxOQ==",
                                           "createdAt":  "2020-11-25T13:19:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "@vitek-karas I was actually also asking about the WpfLibrary, which is an assembly built by the sample project and that the ProxyClass depends on (verified using ILSpy). It seems strange that we don\u0027t call the Load method for it at all.",
                                           "updatedAt":  "2020-11-25T13:19:12Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczMzc2NDczOA==",
                                           "createdAt":  "2020-11-25T15:09:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "I see the `Load` method being called for `WpfLibrary`. Actually even for `PresentationFramework`. It doesn\u0027t happen immediately, only once the `ShowWindow` is called, but it does happen.",
                                           "updatedAt":  "2020-11-25T15:09:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczMzc4NTU1NQ==",
                                           "createdAt":  "2020-11-25T15:44:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "Ah, that\u0027s possible, I haven\u0027t realized that the load happens later and just debugged it till it loaded the test assembly.",
                                           "updatedAt":  "2020-11-25T15:44:25Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczMzg3MjI0MA==",
                                           "createdAt":  "2020-11-25T18:16:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "netcorefan1",
                                           "body":  "@vitek-karas @janvorli \r\nGuys, many thanks for the detailed explanations. It\u0027s not what I wanted to hear, but at least this will put an end to something which was unclear at all. I saw that long time ago @vatsan-madhavan removed assignment for [dotnet/wpf#1764](url) as a possible enhancement, therefore I have to deduce that this feature will never be supported.\r\n\r\n@ryalanms added my [issue](https://github.com/dotnet/wpf/issues/3816) to [Future milestone](https://github.com/dotnet/wpf/milestone/2). I am afraid he was not aware that this is not supported and probably will never be supported. Someone can remove my issue from Future milestone?\r\nThis is issue is specific to WPF and if I understood well @vitek-karas, it also applies to WinForms and any other framework (may be a more generic title would be better?)\r\n\r\nNow...\r\nMost people will have to be enough lucky to enter here in order to discover why the framework assemblies are not unloaded (despite all possible type of implementations I have tried and they will try without success). \r\nThere are applications where it is necessary to have a Gui on demand and rarely needed. Keeping a full framework assembly for a Gui which has been opened only once and for entire lifetime of the application (which could be hours, days, weeks and more) is something that everyone would like to avoid.\r\nGiven that AssemblyLoadContext is unable to unload the entire framework, the final question for people that read will be \"and now what can I do?\"\r\n\r\nAs far as I know, there are two only possible alternatives:\r\n1.  Interprocess communication through Named Pipes\r\n2.  Make the entire application a gui with a custom entry point and call the gui when needed. More [info](https://stackoverflow.com/questions/64923095/i-need-to-better-understand-the-memory-management-of-net-core-in-order-to-decid) in the thread I opened on Github. Here I show that when the Gui is closed, the entire memory loaded from the framework is freed and the application return to the same initial memory resource usage. This does not occurs immediately and seems to be that the unused memory is freed when the system free memory is near to exhaustion.\r\n\r\nI am not sure what is the best between the two solutions (and I never had to deal with IPC), so if I said something wrong please correct me. With solution 2, although memory will return to the initial state soon or later, the framework will be still loaded for the full lifetime of the application and I am not sure how this could affect system resource in comparison with an IPC solution which is supposed to keep everything isolated.\r\nIt would be great for me and the other users if you guys could point us to the right direction for the possible alternatives.\r\n",
                                           "updatedAt":  "2020-11-25T18:16:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczMzg3OTg4Mw==",
                                           "createdAt":  "2020-11-25T18:30:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "The WPF specific issue is that even if you do include the entire framework in the app, using plugins which rely on WPF may mean that the plugin cannot be unloaded (the plugin itself, not WPF).\r\n\r\nHaving WPF loaded should not hurt performance outside of some relatively small memory consumption. WPF assemblies should be R2R images so there should be very little JITing happening and so most of the memory should be files mapped into memory - so called \"shared\" memory. Meaning that if there\u0027s another WPF app using the same framework, the memory will be shared between the processes. Private working set introduced by having the assemblies loaded should be very small. That said WPF itself probably allocates lot of resources (all of the graphics stuff) - I don\u0027t know when/how is that freed if at all. That\u0027s something WPF owners should be able to answer.\r\n\r\nAs for recommendations:\r\n* If you want/need a very clean isolation then out-of-proc is the best.\r\n* Making the app GUI but run it as console is not that strange. For example Powershell Core does exactly that (`pwsh`), it\u0027s a .NET Core app build with WindowsDesktop framework, but the entry point is a console entry point. They did it for example the same reason - if something later on needs either WPF or WinForms, the app must support the framework - frameworks can\u0027t be added later on (and can\u0027t be unloaded).",
                                           "updatedAt":  "2020-11-25T18:30:36Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczMzg5NDkwMw==",
                                           "createdAt":  "2020-11-25T19:00:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vatsan-madhavan",
                                           "body":  "\u003e I saw that long time ago @vatsan-madhavan removed assignment for [dotnet/wpf#1764](https://github.com/dotnet/wpf/issues/1764] as a possible enhancement, therefore I have to deduce that this feature will never be supported.\r\n\r\nI moved to a different team, so no longer keeping issues assigned to me, that\u0027s all 😅... and I continue to help out occasionally and hope to contribute on and off. There are still folks like @ryalanms who continue to work on important stuff. \r\n\r\nThat said, eliminating global state in WPF is going to be tedious because there are certainly many global objects that are kept around intentionally. It can be done, but I can think of a handful of refactorings that that would make the framework more robust, performant and easier to contribute-to etc..., so these things always come down to prioritization 😄 ",
                                           "updatedAt":  "2020-11-25T19:00:37Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczMzk0MjY0NA==",
                                           "createdAt":  "2020-11-25T20:58:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "netcorefan1",
                                           "body":  "@vitek-karas Not sure if I have understood well, but in my case the plugin itself is just a WPF window and the only situation where I need WPF. Once I call CloseWindow() I don\u0027t need anymore that Window and all the related staff of the framework. A sample case could be a settings window or a window displaying an update progress, some operations that may occur rarely.\r\nYou mean that if I adopt solution 2 and say, for example, to style the window I reference [MaterialDesignInXamlToolkit](https://github.com/MaterialDesignInXAML/MaterialDesignInXamlToolkit) which adds a good amount of overhead, I will never be able to unload this library itself once closed the window, is that right? And this also applies to any other library that specifically relies on WPF framework, right? if I have WpfApp1 running with the same wpf framework and with the same MaterialDesignInXamlToolkit framework, my WpfApp2 will use the same memory already used from WpfApp1, right?\r\n\r\nWhen I run the program, before instantiating the MainWindow, in task manager the memory usage is 4.6 Mb, then becomes around 25-26 Mb. After some time, whether I call GC or not, the memory decrease and return to the initial value of 4.6 Mb. Sometimes within minutes, sometimes hours, sometimes after 12 hours the memory is still 25-26. With MaterialDesign framework can easily reach hundreds of MB and for a system with limited RAM I think I should take this in consideration especially after what seems to be my wrong assumptions regarding memory management because from I understood, even if task manager shows the memory returned in its initial state, it is not really fully released.\r\nUnless I am sure I am running another process with the same frameworks, seems to be that the only way to avoid such big consumption of system resource is IPC. Is that right?\r\n\r\n3- This is another solution that came to me in mind right now as an additional step of solution 2 to be used in case that our app is the only one that needs wpf (and consequently can\u0027t rely on shared memory). Restart the entire application which means saving some sort of state (if needed) in a settings file, call CloseWindow() and then something like \r\n`Application.Exit(); Process.Start(Application.ExecutablePath);`\r\nNot sure on how much this could be clean since it sounds more like an hack. May be that named pipes or any other IPC framework is more desiderable.\r\n\r\n@vatsan-madhavan Thanks for your participation. Yes, I saw how can be tedious and it\u0027s good to know that can be done. At least now we have some alternatives, not great like the ability to fully unload an assembly, but acceptable.",
                                           "updatedAt":  "2020-11-25T20:58:45Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczNDM1OTYyNg==",
                                           "createdAt":  "2020-11-26T15:26:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "In theory the MaterialDesign should be unloadable, there\u0027s no limitation to that on the runtime side of things. Unfortunately the WPF issue might mean this won\u0027t work either. Note that making WPF not hold onto random assemblies is very likely a MUCH easier fix than making entire WPF unloadable.\r\n\r\nDepending on the operation you need to do with the UI, but if it\u0027s for example the mentioned \"update\", you could run the application itself as a child process with some command line arguments to do the operation, while the parent simply waits for the child to exit. Maybe you won\u0027t even need any kind of complex IPC, just some command line stuff.",
                                           "updatedAt":  "2020-11-26T15:26:51Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczNTAyOTYzMw==",
                                           "createdAt":  "2020-11-28T02:27:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "netcorefan1",
                                           "body":  "Thanks for the precious information. I suppose this means that maybe needed the same [workaround](https://github.com/dotnet/runtime/issues/13226#issuecomment-523888788) from @janvorli until the Team fixes the issue.\r\n\r\nThis could be a nice solution although I have some concerns. The maximum I can do to get data back is redirect standard output and make some weird string extraction to get the required data. Problem is that I can\u0027t share objects. For example I may need HttpClient to some preliminary operations in MainApp and then reuse it to the child process for the real operation. I am not sure, but I am afraid this is only possible with IPC. Anyway its worth to try both the methods and see what is best suitable. Thanks for providing another jolly to play with.",
                                           "updatedAt":  "2020-11-28T02:27:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczNTczNzY5NA==",
                                           "createdAt":  "2020-11-30T11:47:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "With out-of-proc solution I don\u0027t think it\u0027s possible to share objects. You can serialize objects via some JSON/XML/gRPC to the other process, but it will not \"share\" the object as such. I highly doubt this would work for `HttpClient` for example.\r\n\r\n.NET Framework had remoting which sort of made this possible (but I\u0027m not sure it would have worked on `HttpClient`), .NET Core doesn\u0027t have remoting (it had too many issues, using BinaryFormatter as the serialization format being one of them).",
                                           "updatedAt":  "2020-11-30T11:47:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczNjk3NzM3MQ==",
                                           "createdAt":  "2020-12-02T04:10:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "netcorefan1",
                                           "body":  "Thanks vitek, you saved me from a lot of headaches. So, the trick is to leave an object on a side or another and interact with it from both the sides using commands passed through methods. Unless I encounter something unexpected, to me seems pretty straightforward. I will go for this solution and I think all the people reading this should, at least until (and if) the team will make possible to unload the framework assemblies too. Thanks to all guys! ",
                                           "updatedAt":  "2020-12-02T04:10:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_gfRn",
                                           "createdAt":  "2022-03-11T20:20:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ryan-weil",
                                           "body":  "It is 2022 and I presume this problem still has no solution to it. I have a WPF app, and I too cannot unload the plugin if it creates a WPF window. I don\u0027t care about unloading the actual WPF-related dependency assemblies that get loaded, since like I said my base app is WPF anyways. **I just need a way to unload the actual plugin with the WPF window in it.**\r\n\r\nIs there currently no way in .NET to create an application that has GUI plugins and unload them?",
                                           "updatedAt":  "2022-03-11T21:02:54Z"
                                       }
                                   ],
                         "totalCount":  40
                     },
        "title":  "AssemblyLoadContext - WPF - Collectable Assemblies are not garbage collected",
        "labels":  [
                       "question",
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/13314",
        "createdAt":  "2019-08-26T02:18:42Z",
        "number":  13314,
        "author":  "VincentBu",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-01T18:33:32Z",
        "body":  "**Detail:**\r\nhttps://helixre107v0xdeko0k025g8.blob.core.windows.net/dotnet-coreclr-refs-heads-master-f45d24b93b8645baa1/JIT.Regression/console.8fff52b5.log?sv=2018-03-28\u0026sr=c\u0026sig=R2IOEeUvPW6PDIVtPVuQhRo66C0zYtIJckCIPgyFL0A%3D\u0026se=2019-09-04T14%3A23%3A49Z\u0026sp=rl\r\n\r\n**Failed tests:**\r\nJIT\\\\Regression\\\\JitBlue\\\\GitHub_25468\\\\GitHub_25468\\\\GitHub_25468.cmd\r\n\r\n**Log:**\r\n```\r\nJIT\\Regression\\JitBlue\\GitHub_25468\\GitHub_25468\\GitHub_25468.cmd [FAIL]\r\n      \r\n      Return code:      1\r\n      Raw output file:      C:\\dotnetbuild\\work\\f45d24b9-3b86-45ba-a105-8639bd52afeb\\Work\\051fe643-e9da-4146-97d0-833c5589d0f8\\Exec\\JIT\\Regression\\Reports\\JIT.Regression\\JitBlue\\GitHub_25468\\GitHub_25468\\GitHub_25468.output.txt\r\n      Raw output:\r\n      BEGIN EXECUTION\r\n      call C:\\dotnetbuild\\work\\f45d24b9-3b86-45ba-a105-8639bd52afeb\\Payload\\runincontext.cmd C:\\dotnetbuild\\work\\f45d24b9-3b86-45ba-a105-8639bd52afeb\\Work\\051fe643-e9da-4146-97d0-833c5589d0f8\\Exec\\JIT\\Regression\\JitBlue\\GitHub_25468\\GitHub_25468\\ GitHub_25468.dll \r\n      Serializing System.Drawing.Bitmap\r\n        {110,100,73744,96,96}\r\n      Deserializing System.Drawing.Bitmap\r\n      FAILURE: Unload failed\r\n      \r\n      RunInContext FAIL! Exiting with code 213\r\n      RunInContext FAIL! Exiting due to unhandled exception in the test: System.IO.FileLoadException: Could not load file or assembly \u0027System.Threading.Thread, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\u0027. An operation is not legal in the current state. (0x80131509 (COR_E_INVALIDOPERATION))\r\n      File name: \u0027System.Threading.Thread, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\u0027\r\n       ---\u003e System.InvalidOperationException: AssemblyLoadContext is unloading or was already unloaded.\r\n         at System.Runtime.Loader.AssemblyLoadContext.VerifyIsAlive()\r\n         at System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyPath(String assemblyPath)\r\n         at TestAssemblyLoadContext.Load(AssemblyName name) in /_/src/tools/runincontext/runincontext.cs:line 179\r\n         at System.Runtime.Loader.AssemblyLoadContext.ResolveUsingLoad(AssemblyName assemblyName)\r\n         at System.Runtime.Loader.AssemblyLoadContext.Resolve(IntPtr gchManagedAssemblyLoadContext, AssemblyName assemblyName)\r\n         at System.Drawing.SafeNativeMethods.Gdip.ClearThreadData()\r\n         at System.Drawing.SafeNativeMethods.Gdip.Shutdown()\r\n         at System.Drawing.SafeNativeMethods.Gdip.OnProcessExit(Object sender, EventArgs e)\r\n         at System.EventHandler.Invoke(Object sender, EventArgs e)\r\n         at System.AppContext.OnProcessExit()\r\n      \r\n      \r\n      Expected: 100\r\n      Actual: 213\r\n      END EXECUTION - FAILED\r\n      FAILED\r\n      Test Harness Exitcode is : 1\r\n      To run the test:\r\n      \u003e set CORE_ROOT=C:\\dotnetbuild\\work\\f45d24b9-3b86-45ba-a105-8639bd52afeb\\Payload\r\n      \u003e C:\\dotnetbuild\\work\\f45d24b9-3b86-45ba-a105-8639bd52afeb\\Work\\051fe643-e9da-4146-97d0-833c5589d0f8\\Exec\\JIT\\Regression\\JitBlue\\GitHub_25468\\GitHub_25468\\GitHub_25468.cmd\r\n      Expected: True\r\n      Actual:   False\r\n      Stack Trace:\r\n        F:\\workspace.8\\_work\\1\\s\\bin\\tests\\Windows_NT.x86.Checked\\TestWrappers\\JIT.Regression\\JIT.Regression.XUnitWrapper.cs(122748,0): at JIT_Regression._JitBlue_GitHub_25468_GitHub_25468_GitHub_25468_._JitBlue_GitHub_25468_GitHub_25468_GitHub_25468_cmd()\r\n      Output:\r\n        \r\n        Return code:      1\r\n        Raw output file:      C:\\dotnetbuild\\work\\f45d24b9-3b86-45ba-a105-8639bd52afeb\\Work\\051fe643-e9da-4146-97d0-833c5589d0f8\\Exec\\JIT\\Regression\\Reports\\JIT.Regression\\JitBlue\\GitHub_25468\\GitHub_25468\\GitHub_25468.output.txt\r\n        Raw output:\r\n        BEGIN EXECUTION\r\n        call C:\\dotnetbuild\\work\\f45d24b9-3b86-45ba-a105-8639bd52afeb\\Payload\\runincontext.cmd C:\\dotnetbuild\\work\\f45d24b9-3b86-45ba-a105-8639bd52afeb\\Work\\051fe643-e9da-4146-97d0-833c5589d0f8\\Exec\\JIT\\Regression\\JitBlue\\GitHub_25468\\GitHub_25468\\ GitHub_25468.dll \r\n        Serializing System.Drawing.Bitmap\r\n          {110,100,73744,96,96}\r\n        Deserializing System.Drawing.Bitmap\r\n        FAILURE: Unload failed\r\n        \r\n        RunInContext FAIL! Exiting with code 213\r\n        RunInContext FAIL! Exiting due to unhandled exception in the test: System.IO.FileLoadException: Could not load file or assembly \u0027System.Threading.Thread, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\u0027. An operation is not legal in the current state. (0x80131509 (COR_E_INVALIDOPERATION))\r\n        File name: \u0027System.Threading.Thread, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\u0027\r\n         ---\u003e System.InvalidOperationException: AssemblyLoadContext is unloading or was already unloaded.\r\n           at System.Runtime.Loader.AssemblyLoadContext.VerifyIsAlive()\r\n           at System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyPath(String assemblyPath)\r\n           at TestAssemblyLoadContext.Load(AssemblyName name) in /_/src/tools/runincontext/runincontext.cs:line 179\r\n           at System.Runtime.Loader.AssemblyLoadContext.ResolveUsingLoad(AssemblyName assemblyName)\r\n           at System.Runtime.Loader.AssemblyLoadContext.Resolve(IntPtr gchManagedAssemblyLoadContext, AssemblyName assemblyName)\r\n           at System.Drawing.SafeNativeMethods.Gdip.ClearThreadData()\r\n           at System.Drawing.SafeNativeMethods.Gdip.Shutdown()\r\n           at System.Drawing.SafeNativeMethods.Gdip.OnProcessExit(Object sender, EventArgs e)\r\n           at System.EventHandler.Invoke(Object sender, EventArgs e)\r\n           at System.AppContext.OnProcessExit()\r\n        \r\n        \r\n        Expected: 100\r\n        Actual: 213\r\n        END EXECUTION - FAILED\r\n        FAILED\r\n        Test Harness Exitcode is : 1\r\n        To run the test:\r\n        \u003e set CORE_ROOT=C:\\dotnetbuild\\work\\f45d24b9-3b86-45ba-a105-8639bd52afeb\\Payload\r\n        \u003e C:\\dotnetbuild\\work\\f45d24b9-3b86-45ba-a105-8639bd52afeb\\Work\\051fe643-e9da-4146-97d0-833c5589d0f8\\Exec\\JIT\\Regression\\JitBlue\\GitHub_25468\\GitHub_25468\\GitHub_25468.cmd\r\n  Finished:    JIT.Regression.XUnitWrapper\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOJF-Asg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyNDkzMTIxMQ==",
                                           "createdAt":  "2019-08-26T16:34:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffschwMSFT",
                                           "body":  "I believe this suggests there is a race on Process shutdown and AssemblyLoadContexts being marked as unloaded.\r\n\r\nThe TestAssemblyLoadContextBase is marked as collectible (https://github.com/dotnet/coreclr/blob/d7db5ab9bd3ad449b18dd96b3ac37592b207205b/src/tools/runincontext/runincontext.cs#L141).  \r\nWinforms expects to be able to run code at shutdown (loading System.Threading.Thread).\r\nTestAssemblyLoadContextBase tries to load this assembly and fails as it is part of an unloaded Context.\r\n\r\nI initially considered this a test issue and was preparing a fix in TestAssemblyLoadContext (https://github.com/dotnet/coreclr/blob/d7db5ab9bd3ad449b18dd96b3ac37592b207205b/src/tools/runincontext/runincontext.cs#L164), but I do not believe there is a reliable way for this process to know that it is safe to unload except for handling the Exception that occurs in that case.  This scenario would work fine, if the TestAssemblyLoadContext returned null and let the default context handle the request.\r\n\r\nThoughts?  @janvorli @vitek-karas @elinor-fung \r\n\r\n",
                                           "updatedAt":  "2019-08-26T16:34:15Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyNDkzNDg1Mw==",
                                           "createdAt":  "2019-08-26T16:44:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "I\u0027ll take a look at the test. It is possible that it needs to be marked as incompatible with unloadability testing. ",
                                           "updatedAt":  "2019-08-26T16:44:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyNDk0MTU1Ng==",
                                           "createdAt":  "2019-08-26T17:02:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "I guess I understand what\u0027s going on:\r\n* The unloading of the test assembly fails for some reason\r\n* The runincontext tool reports that (RunInContext FAIL! Exiting with code 213)\r\n* The runincontext tool starts to exit. Now since the unloading failed, the TestAssemblyLoadContext is still there with all the assemblies loaded. And System.Drawing has registered handler for OnProcessExit event, which fires due to the testing tool exiting.\r\n* In that event, System.Drawing tries to use a type or a method from an assembly that was not loaded yet and so it calls into ALC.Load. And it correctly throws since the unloading was initiated before and thus we cannot load anything into the ALC.\r\n\r\nSo the question is why unloading of the GitHub_25468 test fails. It can be the case that something the test or its dependencies does prevents unloading in an expected way. In such case, the test should be marked as unloadability incompatible. Or, there is a bug that needs to be fixed.\r\n",
                                           "updatedAt":  "2019-08-26T17:02:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyNTAwOTA2OA==",
                                           "createdAt":  "2019-08-26T20:01:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffschwMSFT",
                                           "body":  "I agree with your analysis, but before we disable it from unloading validation I think it would be interesting to think through how the test would be changed to accommodate this situation (which could happen regardless of the stress mode).  I do not see a reliable way that the custom AssemblyLoadContext could be altered to accommodate the possibility that it has been unloaded on shutdown.   ",
                                           "updatedAt":  "2019-08-26T20:01:26Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyNTA3ODgwNw==",
                                           "createdAt":  "2019-08-26T23:59:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "The problem happens only because the GitHub_25468 test fails to unload if loaded into the unloadable context. If the unload succeeded, the problem would not happen, since the System.Drawing would get unloaded before the OnProcessExit event fires.\r\n\r\nMaybe you already know, but just to make sure we are on the same page - this reported failure happens only in the special test run when we run the GitHub_25468 using the runincontext tool. The test itself doesn\u0027t do anything unloadability related. \r\n\r\nAnyways, I\u0027ve looked into what\u0027s preventing the unload of the test and it turns out it is actually the System.AppContext.OnProcessExit event handler. The event handler is registered to point to the System.Drawing.SafeNativeMethods.Gdip.OnProcessExit. The actual event lives in the default context while the System.Drawing is loaded into the unloadable context. That keeps the System.Drawing alive forever, preventing the unload.\r\n\r\nSince loading the framework assemblies into the unloadable context is not a supported scenario, I would just exclude the test from the unloadability testing.\r\nOr alternatively, maybe it is time to change the runincontext tool to actually load only the test assemblies into the unloadable context and keep the framework in the default context. I\u0027ve made the runincontext tool to load everything except S.P.C. to the unloadable context at the very beginning since I wanted to make it kind of a stress testing, but also because at that time, I didn\u0027t know it will not be a supported scenario. But now things have settled down, the supported scenarios are much clearer and so we could change the tool.\r\n\r\nAs for the actual problem, developers can remedy such a case in their assemblies by hooking the Unload event and in its handler, removing their OnProcessExit handler.",
                                           "updatedAt":  "2019-08-26T23:59:21Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyODAwNzU2Ng==",
                                           "createdAt":  "2019-09-04T17:41:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "marklio",
                                           "body":  "\u003e Since loading the framework assemblies into the unloadable context is not a supported scenario, I would just exclude the test from the unloadability testing.\r\n\r\n@janvorli how does a developer know about this? Are there things in place that would prevent this from happening in normal scenarios?",
                                           "updatedAt":  "2019-09-04T17:41:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyODAyNzQxMQ==",
                                           "createdAt":  "2019-09-04T18:30:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "\u003e Are there things in place that would prevent this from happening in normal scenarios?\r\n\r\nThe only way how it can happen is that the code either explicitly loads a framework assembly into the context or an override of the AssemblyLoadContext.Load method does that. If this overload uses the AssemblyDependencyResolver to resolve the assemblies (which is used in our official examples), then no framework assembly gets loaded into a non-default context.\r\n\r\n@vitek-karas do you know if we mention somewhere that loading framework assemblies into a non-default AssemblyLoadContext is not a supported scenario?\r\n\r\n",
                                           "updatedAt":  "2019-09-04T18:30:15Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyODAzMjExOA==",
                                           "createdAt":  "2019-09-04T18:41:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffschwMSFT",
                                           "body":  "@janvorli loading Framework assemblies is not explicity not support (customers do that), but when they have issues we discourage them from doing it and ask what they are trying to achieve.\r\n\r\nTo @marklio\u0027s point, what if the assembly was not a framework assembly but rather an assembly that was hooking OnProcessExit.  Further, what if the app developer did not have control of that code and they were loading it into a plug-in.  That I feel is the core scenario that is being discussed.",
                                           "updatedAt":  "2019-09-04T18:41:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyODA0NjUxNg==",
                                           "createdAt":  "2019-09-04T19:21:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "To answer @janvorli : We have this in the docs: https://docs.microsoft.com/en-us/dotnet/api/system.runtime.loader.assemblyloadcontext?view=netcore-2.2#technical-challenges\r\n\u003e  Caution\r\n\u003e Loading multiple copies or different versions of framework assemblies can lead to unexpected and hard to diagnose behavior.\r\n\r\nAs @jeffschwMSFT points out, there are unfortunately cases where it\u0027s somewhat useful as a workaround to problems in the framework itself (for example internal caches which hold on to types making unloadability hard to achieve). But in general we discourage it and only suggest it as a last chace workaround in specific cases.",
                                           "updatedAt":  "2019-09-04T19:21:36Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyODA2NDI2Ng==",
                                           "createdAt":  "2019-09-04T20:08:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "\u003e what if the assembly was not a framework assembly but rather an assembly that was hooking OnProcessExit.\r\n\r\nAs you know, the AssemblyLoadContext unloadability is based on GC references. So if anything outside of an unloadable context holds a strong reference to something inside of the context, the context cannot be unloaded until that reference is gone. The event handler like OnProcessExit handler is one of such cases. These cases are described in https://docs.microsoft.com/en-us/dotnet/standard/assembly/unloadability-howto#troubleshoot-unloadability-issues\r\nMaybe we can explicitly call out the OnProcessExit event there as a specific example there.\r\n\r\n\u003e Further, what if the app developer did not have control of that code and they were loading it into a plug-in\r\n\r\nThen there is nothing that can be done besides fixing or not using the third party component. Except of some ugly reflection hacks, of course.\r\n",
                                           "updatedAt":  "2019-09-04T20:08:07Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYxMDIzODY0Mg==",
                                           "createdAt":  "2020-04-07T08:00:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AriNuer",
                                           "body":  "Test `JIT/Regression/JitBlue/GitHub_25468/GitHub_25468/GitHub_25468.sh` failed again:\r\n**Job:**\r\n[runtime-coreclr jitstressregs:20200405.1](https://dev.azure.com/dnceng/public/_build/results?buildId=589399\u0026view=results)\r\n**Error message:**\r\n```\r\nReturn code: 1\r\nRaw output file: /home/helixbot/work/A5F508FC/w/990D083F/e/JIT/Regression/Reports/JIT.Regression/JitBlue/GitHub_25468/GitHub_25468/GitHub_25468.output.txt\\nRaw output:\r\nBEGIN EXECUTION\r\n/home/helixbot/work/A5F508FC/p/corerun GitHub_25468.dll \u0027\u0027\r\nSerializing System.Drawing.Bitmap\r\n{110,100,73744,96,96}\r\nDeserializing System.Drawing.Bitmap\r\nFailed:\r\n{110,100,77840,12212297,832.2818}\r\nExpected: 100\r\nActual: 255\r\nEND EXECUTION - FAILED\r\nTest Harness Exitcode is : 1\r\nTo run the test:\r\n\u003e set CORE_ROOT=/home/helixbot/work/A5F508FC/p\r\n\u003e /home/helixbot/work/A5F508FC/w/990D083F/e/JIT/Regression/JitBlue/GitHub_25468/GitHub_25468/GitHub_25468.sh\r\nExpected: True \r\nActual: False\r\n```\r\n**Stack trace:**\r\n```\r\n   at JIT_Regression._JitBlue_GitHub_25468_GitHub_25468_GitHub_25468_._JitBlue_GitHub_25468_GitHub_25468_GitHub_25468_sh() in /__w/1/s/artifacts/tests/coreclr/Linux.x64.Checked/TestWrappers/JIT.Regression/JIT.Regression.XUnitWrapper.cs:line 120226\r\n```\r\n**Details:**\r\nhttps://dev.azure.com/dnceng/public/_build/results?buildId=589399\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=18577150\u0026resultId=108879\u0026paneView=debug",
                                           "updatedAt":  "2020-04-07T08:00:41Z"
                                       }
                                   ],
                         "totalCount":  11
                     },
        "title":  "System.InvalidOperationException: AssemblyLoadContext is unloading or was already unloaded",
        "labels":  [
                       "arch-x86",
                       "os-windows",
                       "tenet-reliability",
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/1025",
        "createdAt":  "2019-12-18T20:33:06Z",
        "number":  1025,
        "author":  "elinor-fung",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-07-30T16:28:43Z",
        "body":  "If an event handler for `AssemblyLoadContext.Resolving` or override of `AssemblyLoadContext.Load` throws a `FileNotFoundException`, the `AppDomain.AssemblyResolve` event is still fired, so other extension points still have an opportunity to resolve the assembly.\r\n\r\nFor any other kind of exception, it is not fired.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  null,
                         "nodes":  [

                                   ],
                         "totalCount":  0
                     },
        "title":  "AppDomain.AssemblyResolve can be fired/not fired depending on the type of exception thrown by other extension points",
        "labels":  [
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/31743",
        "createdAt":  "2020-01-31T16:55:14Z",
        "number":  31743,
        "author":  "Farengeto",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-01-05T04:42:04Z",
        "body":  "Operating System Version: Azure virtual machine with a Windows 10 Pro, Version 1809 base\r\n.NET Core Version: 3.1\r\nVisual Studio Version: 16.4.3 and 16.4.4\r\n\r\nWhenever I attempt to access a C++/CLI project (targeted for .NET Core 3.1) from a C# project, the execution will immediately crash when attempting to load the assembly.\r\n\r\nI have managed to reproduce this error in multiple independent solutions, on multiple computers, so it does not appear to be tied to a code- or computer-specific issue on my end.\r\n\r\nIf the project is executed in Visual Studio with the debugger, the debugger itself appears crash upon reaching the method which calls the C++/CLI DLL. No information will be provided in Debug other than these lines:\r\n\r\n\u003e The program \u0027[13640] NET Core CLI Test.exe: Program Trace\u0027 has exited with code 0 (0x0).\r\n\u003e The program \u0027[13640] NET Core CLI Test.exe\u0027 has exited with code -529697949 (0xe06d7363) \u0027Microsoft C++ Exception\u0027.\r\n\r\nAs a curious note, the debugger also skips over the calling method if I attempt to step into it, reporting it as \"non-user code\".\r\n\r\nIf executed without a debugger, more information is provided when the crash occurs:\r\n\r\n\u003e Unhandled exception. System.BadImageFormatException: Could not load file or assembly \u0027Mock CLI Project, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\u0027. An attempt was made to load a program with an incorrect format.\r\n\u003e File name: \u0027Mock CLI Project, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\u0027\r\n\u003e    at NET_Core_CLI_Test.Program.CallingMethod(Int32 a, Int32 b)\r\n\u003e    at NET_Core_CLI_Test.Program.Main(String[] args) in C:\\Users\\travis.ridge\\source\\repos\\NET Core CLI Test\\NET Core CLI Test\\Program.cs:line 11\r\n\r\nIn both situations, an error will be added to the Windows event log, displaying the same basic information each time.\r\n\r\n\u003e Faulting application name: NET Core CLI Test.exe, version: 1.0.0.0, time stamp: 0x5dedc13b\r\n\u003e Faulting module name: KERNELBASE.dll, version: 10.0.17763.914, time stamp: 0xfb6790ac\r\n\u003e Exception code: 0xe0434352\r\n\u003e Fault offset: 0x0000000000039159\r\n\u003e Faulting process id: 0x31e0\r\n\u003e Faulting application start time: 0x01d5d8549d80476e\r\n\u003e Faulting application path: C:\\Users\\travis.ridge\\source\\repos\\NET Core CLI Test\\NET Core CLI Test\\bin\\x64\\Debug\\netcoreapp3.1\\NET Core CLI Test.exe\r\n\u003e Faulting module path: C:\\windows\\System32\\KERNELBASE.dll\r\n\u003e Report Id: 575a2b9a-1f69-4d48-8d07-ac8dfe6917d4\r\n\u003e Faulting package full name: \r\n\u003e Faulting package-relative application ID: \r\n\r\nBelow I\u0027ve included the code example from a minimal solution in Visual Studio with which I am able to consistently reproduce this issue.\r\n\r\nExample C# script. The program crashes when CallingMethod() is invoked.\r\n```\r\nusing CLI;\r\n\r\nnamespace NET_Core_CLI_Test\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            int a = 2;\r\n            int b = 2;\r\n            int sum = CallingMethod(a, b); //Crash occurs when executing this line\r\n        }\r\n\r\n        static int CallingMethod(int a, int b)\r\n        {\r\n            //Execution never reaches here\r\n            MockWrapper wrapper = new MockWrapper();\r\n            return wrapper.Add(a, b);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThe ModelWrapper.cpp class:\r\n```\r\n#pragma once\r\n#include \"pch.h\"\r\n#include \"MockWrapper.h\"\r\n\r\n#include \u003cexception\u003e\r\n\r\nusing namespace System;\r\nusing namespace System::Runtime::InteropServices;\r\n\r\nnamespace CLI {\r\n\tMockWrapper::MockWrapper() {\r\n\r\n\t}\r\n\r\n\tint MockWrapper::Add(int a, int b) {\r\n\t\treturn a + b;\r\n\t}\r\n}\r\n```\r\n\r\nI can provide further information upon request.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOUcOgJg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU4MjEwNzkxMQ==",
                                           "createdAt":  "2020-02-04T20:48:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "scalablecory",
                                           "body":  "@jeffschwMSFT ",
                                           "updatedAt":  "2020-02-04T20:48:32Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU4MjEwODIwMQ==",
                                           "createdAt":  "2020-02-04T20:49:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "scalablecory",
                                           "body":  "Are you trying to load a 64-bit DLL inside a 32-bit process, or vice-versa?",
                                           "updatedAt":  "2020-02-04T20:49:12Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU4MjExMTcxNA==",
                                           "createdAt":  "2020-02-04T20:58:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vcsjones",
                                           "body":  "Perhaps related to #521.",
                                           "updatedAt":  "2020-02-04T20:58:07Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU4MjExMjM1Nw==",
                                           "createdAt":  "2020-02-04T20:59:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Farengeto",
                                           "body":  "\u003e Are you trying to load a 64-bit DLL inside a 32-bit process, or vice-versa?\r\n\r\nIn my solutions all projects were being built in the 64-bit configuration.\r\n\r\nI\u0027ve rechecked the test solution just to be sure: the C# project was set for x64 platform target, and the reference to the C++ project points to the x64 build. However the error persists.",
                                           "updatedAt":  "2020-02-04T20:59:36Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU4MjE2NjA2NQ==",
                                           "createdAt":  "2020-02-04T23:28:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffschwMSFT",
                                           "body":  "@jkoritzinsky ",
                                           "updatedAt":  "2020-02-04T23:28:08Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU4MjE2ODY5Ng==",
                                           "createdAt":  "2020-02-04T23:36:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCNPf3Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "smkanadl",
                                                                               "createdAt":  "2021-01-19T11:48:54Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "afriron",
                                                                               "createdAt":  "2021-04-06T08:17:59Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Danielku15",
                                                                               "createdAt":  "2021-04-12T15:53:51Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Psycho900",
                                                                               "createdAt":  "2021-05-15T19:45:37Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "fiercekittenz",
                                                                               "createdAt":  "2022-02-05T16:48:24Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  5
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "@TravisRidge do you have the ijwhost.dll deployed next to your C++/CLI assembly and are all of your native dependencies resolved/resolvable? Sometimes people miss that file when copying their outputs around.\r\n\r\nOur diagnostics for mixed-mode assembly loading need a bit of work since they throw a BadImageFormatException for basically every failure.",
                                           "updatedAt":  "2020-02-04T23:36:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU4MjQzMTEzNw==",
                                           "createdAt":  "2020-02-05T14:23:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Farengeto",
                                           "body":  "\u003e @TravisRidge do you have the ijwhost.dll deployed next to your C++/CLI assembly and are all of your native dependencies resolved/resolvable? Sometimes people miss that file when copying their outputs around.\r\n\u003e \r\n\u003e Our diagnostics for mixed-mode assembly loading need a bit of work since they throw a BadImageFormatException for basically every failure.\r\n\r\n@jkoritzinsky The \"Ijwhost.dll\" was added automatically in the folder next to the assembly in both the builds for the C++ and C# projects. (Curiously the dll had used an uppercase \"i\", but I tried changing it to lowercase on a hunch with no difference in error message.)\r\n\r\nAs for the others, I\u0027m not sure how I can verify that. I\u0027ve adjusted my test project\u0027s code to remove those unnecessary includes, so at this point the only explicit external references are those in the automatically generated code (namely the \"framework.h\" and its reference to \"windows.h\").",
                                           "updatedAt":  "2020-02-05T14:23:24Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyMTY4NTI0NQ==",
                                           "createdAt":  "2020-04-30T08:13:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "nefen",
                                           "body":  "I face exactly the same issue with @TravisRidge.\r\nNative dll=\u003eC++/CLI Wrapper=\u003easpnet core 3.1 Razor Pages Project. \r\nCompiles. Run breaks with BadImageFormat.  Debugging breaks too.\r\nI checked all involved dll\u0027s with dumpbin and all were built against x64.\r\nAny New?",
                                           "updatedAt":  "2020-04-30T08:15:05Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNDY1NTMwNQ==",
                                           "createdAt":  "2020-05-06T13:39:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "msedi",
                                           "body":  "The same happens from our side, is there any news?",
                                           "updatedAt":  "2020-05-06T13:39:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNzIwOTc0OQ==",
                                           "createdAt":  "2020-05-12T08:58:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "RaviBadry",
                                           "body":  "Any updates on this error\r\n",
                                           "updatedAt":  "2020-05-12T08:58:47Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNzUwNzkyMQ==",
                                           "createdAt":  "2020-05-12T18:14:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "Can you validate that all of your native dependencies of the C++/CLI assembly are available on the target machine? Including the VC++ redistributable?",
                                           "updatedAt":  "2020-05-12T18:14:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNzUzMDQwMw==",
                                           "createdAt":  "2020-05-12T18:57:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "nefen",
                                           "body":  "Program crashes in the development machine too. All dendencies are present.\n\nI created a wrapper for a substantial cpp solution. I commented out\neverything from the cpp unmanaged entry function.  I just cslled it ans\nexecuted the return statement. It worked. So, all dll\u0027s have been loaded.\n\n\n\n\nΣτις Τρί, 12 Μαΐ 2020, 21:14 ο χρήστης Jeremy Koritzinsky \u003c\nnotifications@github.com\u003e έγραψε:\n\n\u003e Can you validate that all of your native dependencies of the C++/CLI\n\u003e assembly are available on the target machine? Including the VC++\n\u003e redistributable?\n\u003e\n\u003e —\n\u003e You are receiving this because you commented.\n\u003e Reply to this email directly, view it on GitHub\n\u003e \u003chttps://github.com/dotnet/runtime/issues/31743#issuecomment-627507921\u003e,\n\u003e or unsubscribe\n\u003e \u003chttps://github.com/notifications/unsubscribe-auth/AF23M7NFSKTATTG7D4C6I7TRRGGXXANCNFSM4KP5XB6A\u003e\n\u003e .\n\u003e\n",
                                           "updatedAt":  "2020-05-12T18:57:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNzU0NDA2Ng==",
                                           "createdAt":  "2020-05-12T19:25:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "Where is the BadImageFormatException thrown from?\r\nIs it possible that you have an architecture mismatch or that you\u0027re missing ijwhost.dll?",
                                           "updatedAt":  "2020-05-12T19:25:05Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNzcyMzUyMQ==",
                                           "createdAt":  "2020-05-13T03:30:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "RaviBadry",
                                           "body":  "Yes,  All the Native MFC native dlls are build and available on the target machine.\r\n\r\nFrom: Jeremy Koritzinsky \u003cnotifications@github.com\u003e\r\nSent: 12 May 2020 23:44\r\nTo: dotnet/runtime \u003cruntime@noreply.github.com\u003e\r\nCc: Ravishankar Badry \u003cRavishankar.Badry@arup.com\u003e; Comment \u003ccomment@noreply.github.com\u003e\r\nSubject: [External] Re: [dotnet/runtime] BadImageFormatException when loading C++/CLI DLLs in Core 3.1 (#31743)\r\n\r\n\r\nCan you validate that all of your native dependencies of the C++/CLI assembly are available on the target machine? Including the VC++ redistributable?\r\n\r\n—\r\nYou are receiving this because you commented.\r\nReply to this email directly, view it on GitHub\u003chttps://secure-web.cisco.com/1hGoynaN5NcpEKL80rp-O-qXvy9-bSydFO2oCtbgmvdGiujcqCTj7I9pGVUpg7IXRkQL_68cVcfXkRBH1osjL9jtYSeaT8XkUngxesEP63h3Viyi1X1BWn0z0VlEo6wfPqkUQKVYxx6zmsP_C4o28J-8DeGKIY3LhKjK4cLoC-C4wunNVmlDNIbjd1QdJD5t8QX9m24yyryfowKEMKcIIfc3RouG02hdA9puopdokhdQTBZfWY42TtoXPr8SZA6zJ27ysSeUBUyEqlJI9bsX8umOrG2RMGWxzxmPdG3yZakbGYRy392JfvD_sPZXmT9kNUrBOGjPjxpu3fEdvmR2N-g/https%3A%2F%2Fgithub.com%2Fdotnet%2Fruntime%2Fissues%2F31743%23issuecomment-627507921\u003e, or unsubscribe\u003chttps://secure-web.cisco.com/1ADYcsVr274Sol99upC9B_9f9yruSYLJIxIq0pORKSN_wEqJ2zYBA4nB7vQhvc3cLumc2jrNOUCWzYI_E_F_HxYF6XIa-942PnjK_7UcKDc5IkBWCR1dxTL0ouNLfzFgGOk031H6CZsJdpQLQIHIow-54MnDBJ61f3AonxjbpZgK3BYhGF0p5_cr5YJTy-xaMPHT9Vu7I_472a_Cm0wLYY9MjiEx3VRjs06zHhfbYD4lKqy64isdXEHzHbc0NcurMPLeWNcja6T_Uom-Bl9DcFFvowPWIf7-mkJbRVJFA62LheFoQUcGmQmpkyglNpRwI48bXMTp7Qi-rbQIRMNpnTw/https%3A%2F%2Fgithub.com%2Fnotifications%2Funsubscribe-auth%2FAOMNBBL6HMIUHMKJVBT4JSDRRGGXXANCNFSM4KP5XB6A\u003e.\r\n ____________________________________________________________\nElectronic mail messages entering and leaving Arup business systems are scanned for viruses and acceptability of content.\n",
                                           "updatedAt":  "2020-05-13T03:30:51Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyODE1ODI0MA==",
                                           "createdAt":  "2020-05-13T18:10:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "I\u0027m honestly not sure what\u0027s going on then. Can you turn on loader snaps and put it under the debugger so we can see where in the loading process we get an error?",
                                           "updatedAt":  "2020-05-13T18:10:18Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyODM2MzExMA==",
                                           "createdAt":  "2020-05-14T03:22:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "RaviBadry",
                                           "body":  "I understand the reason in my case. I have a). MFC dlls, b) Wrapper dll , c) C++/CLI .net core dll and d) .net core NUnit test project.\r\n\r\nNunit test project is creating an additional folder Netcoreapp3.1. This project (Nunit test) referencing C++/CLI .net core dll and hence C++/CLI ,Net core dll is copying to the folder Netcoreapp3.1 but not the wrapper dlls. \r\n\r\nTherefore, the wrapper dll and other subsequent dlls are not found when executing the Nunit test.\r\n\r\nHope this information is useful for others.\r\n\r\n\r\n",
                                           "updatedAt":  "2020-05-14T03:22:46Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzNDk5NzY0Nw==",
                                           "createdAt":  "2020-05-27T23:30:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tylerpayne",
                                           "body":  "Running into this problem as well.\r\n\r\nI SWIG\u0027d a C++ project to generate C# wrappers. Linked my wrappers and the native x86 DLLs with x86 cl.exe. OBJDUMPing the resulting DLL confirms all my expected exports are there. Unfortunately, the moment my x86 C# project tries to PInvoke I get `BadImageFormatException: An attempt was made to load a program with an incorrect format. (0x8007000B).` \r\n\r\nI\u0027ve also attempted to access the DLL via `Assembly.LoadFile` but get the slightly different exception `System.BadImageFormatException: \u0027Bad IL format.\u0027`\r\n\r\nWindows 10\r\n.NET Core 3.1\r\nVisual Studio Community 2019\r\n",
                                           "updatedAt":  "2020-05-27T23:30:48Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzNjM5Mjk0Mg==",
                                           "createdAt":  "2020-05-30T22:26:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODhwh0w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "oskiyu",
                                                                               "createdAt":  "2020-10-28T10:16:50Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "christo-vdw",
                                                                               "createdAt":  "2021-07-21T13:58:03Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "woopelderly",
                                                                               "createdAt":  "2024-05-14T13:37:44Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "IsaacSchemm",
                                           "body":  "When I had a similar problem with a C# WinForms app (.NET Core 3.1) referencing a C++/CLI .NET Core assembly, it turned out that my Visual Studio configurations were set to always build the C# project as Any CPU, regardless of the active solution platform. I added x86 and x64 platforms to my C# project and set the solution platforms to use them, and it seems OK now.",
                                           "updatedAt":  "2020-05-30T22:26:25Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzODI1NTI1Nw==",
                                           "createdAt":  "2020-06-03T15:00:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOB-S8nQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Achilles1515",
                                                                               "createdAt":  "2020-10-22T15:25:37Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "mill1000",
                                                                               "createdAt":  "2020-10-29T02:41:18Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Sparrow1831",
                                                                               "createdAt":  "2020-12-14T06:55:23Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jonproch117",
                                                                               "createdAt":  "2021-10-14T12:00:58Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "Da-Teach",
                                           "body":  "I ran into a similar issue today and it turns out the server didn\u0027t have the redist installed.\r\n\r\nAfter installing it from this link:\r\nhttps://support.microsoft.com/en-us/help/2977003/the-latest-supported-visual-c-downloads\r\n\r\nIt worked for me. Nice error though, bad image format on a clean windows 2019 install which in turn was a redist not installed. A better error message would have saved me a ton of work.",
                                           "updatedAt":  "2020-06-03T15:00:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY2NDk3MTUwOA==",
                                           "createdAt":  "2020-07-28T10:52:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "emanuel-v-r",
                                           "body":  "I am having the same issue running on docker with the image mcr.microsoft.com/dotnet/core/aspnet:3.1.6-nanoserver-2004, I have the `ijwhost.dll` installed in the folder, I am making sure that everything is built using x64, even tried to install vc_redist.x64.exe but still getting System.BadImageFormatException.\r\n",
                                           "updatedAt":  "2020-07-28T10:52:07Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY2NDk4Nzk0OA==",
                                           "createdAt":  "2020-07-28T11:33:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "yunfandev",
                                           "body":  "@imaramos \r\n\r\nhttps://github.com/dotnet/core/issues/3927#issuecomment-638580305",
                                           "updatedAt":  "2020-07-28T11:33:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY2NDk5MDY5OQ==",
                                           "createdAt":  "2020-07-28T11:40:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "emanuel-v-r",
                                           "body":  "\u003e @imaramos\r\n\u003e \r\n\u003e [dotnet/core#3927 (comment)](https://github.com/dotnet/core/issues/3927#issuecomment-638580305)\r\n\r\nI see, thanks for the help. So it is specific to nanoserver? Should I use windows/servercore instead and install aspnetcore runtime manually? Unfortunately the image is much bigger :(.",
                                           "updatedAt":  "2020-07-28T11:40:25Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY2NDk5NjM0OQ==",
                                           "createdAt":  "2020-07-28T11:55:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "yunfandev",
                                           "body":  "@imaramos \r\n\r\nI have tried to compile dotnet core c++/cli program to self-contained exe, and it can only run on mcr.microsoft.com/dotnet/framework/sdk, windows/servercore image will not work.\r\n\r\nmcr.microsoft.com/dotnet/framework/sdk is over 7GB after decompression.  😂😂😂",
                                           "updatedAt":  "2020-07-28T11:57:40Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY2NDk5ODg4Mg==",
                                           "createdAt":  "2020-07-28T12:01:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "emanuel-v-r",
                                           "body":  "\u003e @imaramos\r\n\u003e \r\n\u003e I have tried dotnet core c++/cli program can only run on mcr.microsoft.com/dotnet/framework/sdk, windows/servercore image will not work.\r\n\u003e \r\n\u003e mcr.microsoft.com/dotnet/framework/sdk is over 7GB after decompression. 😂😂😂\r\n\r\nWow, that is awful, and in my case is useless because I am using dotnet core 3.1, not the full framework.\r\nIf c++/cli is not going to be supported in linux, at least it should be a light and easy to build image.",
                                           "updatedAt":  "2020-07-28T12:01:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgzMzIxNjczOA==",
                                           "createdAt":  "2021-05-06T04:34:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBq9wJg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Psycho900",
                                                                               "createdAt":  "2021-05-15T19:48:12Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "Weijee",
                                           "body":  "I have tested this issue on .NETCore3.1/.NET5 by using ConsoleApp/WebApplication/WebApi, and the result goes like this:  \r\n|Reference|ConsoleApp|WebApplication|WebApi|\r\n|:-|:-:|:-:|:-:|\r\n|Reference C++/CLI Project|OK|OK|OK|\r\n|Reference C++/CLI Dll|NG|NG|NG|  \r\n\r\nNG: **_BadImageFormatException_** occurs\r\nI dont know what is the defference between these two reference modes.  \r\nAny ideas?\r\n",
                                           "updatedAt":  "2021-05-06T04:34:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg0NDc2NjQxNQ==",
                                           "createdAt":  "2021-05-20T06:56:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ryangle",
                                           "body":  "\u003e I have tested this issue on .NETCore3.1/.NET5 by using ConsoleApp/WebApplication/WebApi, and the result goes like this:\r\n\u003e \r\n\u003e Reference\tConsoleApp\tWebApplication\tWebApi\r\n\u003e Reference C++/CLI Project\tOK\tOK\tOK\r\n\u003e Reference C++/CLI Dll\tNG\tNG\tNG\r\n\u003e NG: **_BadImageFormatException_** occurs\r\n\u003e I dont know what is the defference between these two reference modes.\r\n\u003e Any ideas?\r\n\r\nCheck the \"Copy C++ Runtime to OutDir\" in the C++/Cli project.\r\n",
                                           "updatedAt":  "2021-05-20T06:56:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg3MDU1NzQzMQ==",
                                           "createdAt":  "2021-06-29T12:28:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "intellild",
                                           "body":  "Same issue\r\nMy C# XAML application referencing my empty proxy c++/cli project works fine\r\nBut when I reference the native c++ DLL in the proxy project, the error occurs",
                                           "updatedAt":  "2021-06-29T12:28:55Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg3MjE1NzMwOA==",
                                           "createdAt":  "2021-07-01T11:19:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Gornhoth",
                                           "body":  "Similar issue with a .NET 5.0 project that references a C++ dll. All dlls are copied into the output directory when compiling, all of them and the project itself are targeting x64. When running the executable: \"Unhandled exception. System.BadImageFormatException: Could not load file or assembly \u0027...\u0027. An attempt was made to load a program with an incorrect format.\" I tried the same in a .NET Framework 4.7.2 project and there it loads all assemblies properly and runs without an issue. Any idea?",
                                           "updatedAt":  "2021-07-01T11:23:50Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg3MjE2MzMyMA==",
                                           "createdAt":  "2021-07-01T11:27:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "emanuel-v-r",
                                           "body":  "@Gornhoth this comment https://github.com/dotnet/core/issues/3927#issuecomment-674100138 may be helpful for you, it\u0027s an ugly solution but at least it worked, it was for .NET Core 3.1, but I am guessing it will work for .NET 5",
                                           "updatedAt":  "2021-07-01T11:28:14Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg3MjE5MTA1NA==",
                                           "createdAt":  "2021-07-01T12:08:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBw5c0A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "emanuel-v-r",
                                                                               "createdAt":  "2021-07-01T12:15:42Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "Gornhoth",
                                           "body":  "@imaramos thank you for the suggestion. I searched a bit more and found https://docs.microsoft.com/en-us/dotnet/standard/analyzers/portability-analyzer which i used to see if there were any compatibility issues between the managed c++ dlls targeting .net framework 4.7.2 (as seen in assembly explorer) and my .net 5.0 project which references them. Turns out there are several incompatibilities in some dlls which prevents me from using them.",
                                           "updatedAt":  "2021-07-01T12:08:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc47YRZ8",
                                           "createdAt":  "2021-12-16T21:46:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "FanjingLiu",
                                           "body":  "Same thing for me too, .Net5 console app referencing a c++cli dll, portability analyzer is all green.",
                                           "updatedAt":  "2021-12-16T21:46:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc47Y_Fu",
                                           "createdAt":  "2021-12-17T03:21:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "HengzheLi",
                                           "body":  "~~Same issue when debug .net 5 app from Visualstudio. But when I build the project using MSBuild outside the VS. The app can run smoothly.~~\r\n\r\nIt is strange. When I change \"Use Debug Libraries\" from Yes to No. All works. But this setting always work before I upgrade VS2019 to 16.11. But the source code could not be step into in this way.",
                                           "updatedAt":  "2021-12-17T05:15:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49bLJ7",
                                           "createdAt":  "2022-02-05T05:53:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "fiercekittenz",
                                           "body":  "I\u0027m experiencing this now with a x64 net5.0-windows C# application referencing a /clr:netcore (net5.0) library. Any time the code is used from the referenced CLR project, it crashes with this same exception.",
                                           "updatedAt":  "2022-02-05T05:53:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5AzdPU",
                                           "createdAt":  "2022-04-04T07:54:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kaba2",
                                           "body":  "I had a similar problem with BadImageFormatException using a C++/CLI library from C# (although with NET Framework). \r\n\r\nThe solution was to disable \"Prefer 32 bits\" from the C# library properties.",
                                           "updatedAt":  "2022-04-04T07:54:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Rw6Am",
                                           "createdAt":  "2023-01-05T04:42:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pawan-vinove",
                                           "body":  "\u003e When I had a similar problem with a C# WinForms app (.NET Core 3.1) referencing a C++/CLI .NET Core assembly, it turned out that my Visual Studio configurations were set to always build the C# project as Any CPU, regardless of the active solution platform. I added x86 and x64 platforms to my C# project and set the solution platforms to use them, and it seems OK now.\r\n\r\nThis is not working in my case. Code is running on x86 but not able to run it on docker..",
                                           "updatedAt":  "2023-01-05T04:42:04Z"
                                       }
                                   ],
                         "totalCount":  35
                     },
        "title":  "BadImageFormatException when loading C++/CLI DLLs in Core 3.1",
        "labels":  [
                       "question",
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/36814",
        "createdAt":  "2020-05-21T12:29:37Z",
        "number":  36814,
        "author":  "svick",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCIPVYg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "GSPP",
                                            "createdAt":  "2021-12-31T07:23:28Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2022-07-26T23:35:59Z",
        "body":  "Based on https://github.com/dotnet/roslyn/issues/39470, a relatively common issue when working with dynamically generated assemblies is that, due to a bug in your code, you attempt to load an empty assembly (e.g., you call `Assembly.Load(Stream)` with a `Stream` of `Length` 0). When this happens, you get a correct, but not particularly helpful exception:\r\n\r\n\u003e  System.BadImageFormatException: Bad IL format.\r\n\r\nWould it make sense to improve the exception message, to make it more clear what the issue is?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOJa5l_A==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzMjA1OTA0Mg==",
                                           "createdAt":  "2020-05-21T12:29:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Dotnet-GitSync-Bot",
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. Please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2020-05-21T12:29:43Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzMjE4NjM2NA==",
                                           "createdAt":  "2020-05-21T16:18:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas\nNotify danmosemsft if you want to be subscribed.",
                                           "updatedAt":  "2020-05-21T16:18:50Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Improve exception message when loading an empty assembly",
        "labels":  [
                       "help wanted",
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/37576",
        "createdAt":  "2020-06-08T04:03:12Z",
        "number":  37576,
        "author":  "John0King",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-07-08T18:33:35Z",
        "body":  "## background\r\nIn most time we need  alc fallback when doing plugin dynamic load. When a assembly can not be find it should look to it\u0027s parent alc instead of just default alc.  current issues like #13472 , #37231 also has the issue in alc fallback.\r\n\r\nafter I look to those issue I also notice that  people in .net team seems not “support” to use the `CurrentContextualReflectionContext` ,  and I do see a valuable usage when I create the [sub app for asp.net core](https://github.com/John0King/LazyMan.ModularLoader/blob/220c510fe868ae6ababe26b5b28ded067cd996d4/src/LazyMan.ModularLoader.AspNetCore/Infrastructure/PipelineCacheManager.cs#L40)\r\n\r\n## the problem\r\nwhen create my library `sub app for asp.net core`,  I need to share two type from the `Host` and the `SubApp` ===\u003e   `HttpContext` and `RequestDelegate`  , but after assembly fallback to use  the `HostAlc`\u0027s Assembly (the current HostAlc is also the default alc),  for example:  `ConfigureLogging()` on `IHostBuilder`  the `IHostBuilder` and the parameter will also use from `default alc`, then it end up  type `IHostBuilder`  is not the type `IHostBuilder` , the reason this issue happen is because a few assembly from  `\u003cFrameworkReference  Include=\"Microsoft.AspNetCore.App\"/\u003e` is being copy or not copy  to the app directory. (this is uncommon from a clear plugin loader   which the `abstract` will only exist in the `HostAlc`)  anyway,  after `ConfigureLogging` on `host alc` being called `everything` will call into the `HostAlc` even the `CurrentContextualReflectionContext `  is  `Plugin Alc`\r\n\r\n##  the current solution\r\nthe current solution is make a full `framework assembly manifest`  that force it being loaded to `HostAlc`\r\n\r\n## the future solution\r\n1. force to use `AssemblyLoadContext.CurrentContextualReflectionContext`  to fallback again to the plugin alc , every time  looking for a type look  \"CurrentContextualReflectionContext\" fist\r\n2.  `AssemblyLoadContext.Load(AssemlbyName)` and `AssemblyLoadContext.LoadUmanagedDll(string)`  to handle the alc fallback by default  from  `ContextualReflectionScope` , so we need a new static property of `Stack\u003cAssemblyLoadContext\u003e` in `ContextualReflectionScope` itself or `AssemblyLoadContext` , and people can just call `base.Load(assemlbyName)`  to do this complex thing eg.\r\n```c#\r\nstruct ContextualReflectionScope : IDisposeable\r\n{\r\n   //  the AssemblyLoadContext.Load  and LoadUnmanagedDll \"virtual\" method need to access this property ,\r\n   // when the stack is empty then raise assembly not fond\r\n   //  this property in struct won\u0027t be copied right?\r\n    internal static Stack\u003cAssemblyLoadContext\u003e Predecessor= new ();\r\n    internal ContextualReflectionScope(AssemblyLoadContext? activating)\r\n    {\r\n             ///////  add to stack\r\n            if(AssemblyLoadContext.CurrentContextualReflectionContext != null)\r\n            {\r\n                // this property is not be null for application, but when clr call default alc\u0027s\r\n                // EnterContextualReflection()  this property is null  see the change in 3\r\n                Predecessor = AssemblyLoadContext.CurrentContextualReflectionContext;\r\n            }\r\n           \r\n            AssemblyLoadContext.SetCurrentContextualReflectionContext(activating);\r\n            _activated = activating;\r\n            _initialized = true;\r\n    }\r\n\r\n    Dispose()\r\n    {\r\n        if (_initialized)\r\n                {\r\n                    // Do not clear initialized. Always restore the _predecessor in Dispose()\r\n                    // _initialized = false;\r\n                   ////////  note of use .Pop() method\r\n                    AssemblyLoadContext.SetCurrentContextualReflectionContext(Predecessor.Pop());\r\n                }\r\n    }\r\n}\r\n```\r\n3.  `CurrentContextualReflectionContext` will default to the `AseemlbyLoadContext.Default` ,  we are alway in a `ContextualReflectionScope` , so the fallback to default alc is not being affect (see  1)  eg.\r\n```c#\r\nusing(AssemlbyLoadContext.Default.EnterContextualReflection())\r\n{\r\n    Program.Main(args)\r\n}\r\n```\r\n4.  `Assemlby? AssemblyLoadContext.EntryAssembly`  and  optional constructor `AssemblyLoadContext(string name, boo isCollectible, string entryAssemlbyPath,)`    this `EntryAssembly` property is the first Assemlby this alc load,   the constructor will also have `AssemblyDependencyResolver`  but I think maybe this contronctor is not nesssory, because  using it we also need  to add a  `SharedAssemblies` property, maybe the best is to add a sub class .\r\n5.  to support the `Resolving` event and avoid dead loop,  the `AssemblyLoadContext` need to add a new private property `_currentPredecessor`  with is a copy of `ContextualReflectionScope.Predecessor`   when `EnterContextualReflection()` is called.   and when `.Load(  .LoadUnmananedDll()` being called each time it will `.Pop()`  an alc  ,  and when this event being fired, this `Statc\u003cAssemblyLoadContext\u003e`  is empty,  so  it\u0027s safe to call  `AssemlbyLoadContext.Default.LoadFromAssemblyName()`\r\n \r\n\r\n##  by using Stack\u003cT\u003e, will the perf too slow\r\n\r\nfor 99% user case  ,  the stack will only contains 1 item, which is the default alc,  so it will not fallbak many times for most user , unless there many child of alc\r\n \r\n\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOMMEyrQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY1NTEzNzAwOQ==",
                                           "createdAt":  "2020-07-07T21:11:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "Due to 5.0 schedule constraints, this is being moved to Future.",
                                           "updatedAt":  "2020-07-07T21:11:12Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc2MDEwNTY0OA==",
                                           "createdAt":  "2021-01-14T10:27:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCtU9DA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AndreyFedorovIID",
                                                                               "createdAt":  "2022-10-05T09:06:32Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "John0King",
                                           "body":  "![未标题-1](https://user-images.githubusercontent.com/13639146/104578798-1d349300-5696-11eb-9420-55ebc0240290.jpg)\r\n\r\na image describe the problem .",
                                           "updatedAt":  "2021-01-14T10:27:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3Mjk3ODg0Ng==",
                                           "createdAt":  "2021-02-04T02:32:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "John0King",
                                           "body":  "@steveharter Is there any discussion in your team for this issue ?\r\n\r\nif you use .net 5.0.100 sdk  and use a nuget package newer version `micrsoft.extension.*` package  ,  the dll from nuget will be copy and cause a  assembly redirection,   but it will not for a plugin alc.\r\n\r\n### default ALC (named  $0)\r\n-   Assembly :  Microsoft.Extension.Configuration.Abstraction\r\n-  Assembly :  Microsoft.AspNetCore.Host  ( this reference many package)\r\n-   Assembly: App main\r\n\r\n### plugin ALC (named $1)\r\n\r\n-  Assembly :  Microsoft.Extension.Configuration.Abstraction\r\n- Assembly : plugin main   (need Microsoft.AspNetCore.Host)\r\n\r\n\r\nyou can see that in  $1  ,  it fallback to $0 to find the needed assemly,  but  after it goes into $0  it can\u0027t go back, it will find $0.Configuration.Json,   and in your plugin ,  you use $1.Configuration.Json ,  and this will not case assembly redirection.\r\n\r\n",
                                           "updatedAt":  "2021-02-04T02:32:52Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc5NDI1MjgxMA==",
                                           "createdAt":  "2021-03-09T18:11:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @coffeeflux\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n## background\r\nIn most time we need  alc fallback when doing plugin dynamic load. When a assembly can not be find it should look to it\u0027s parent alc instead of just default alc.  current issues like #13472 , #37231 also has the issue in alc fallback.\r\n\r\nafter I look to those issue I also notice that  people in .net team seems not “support” to use the `CurrentContextualReflectionContext` ,  and I do see a valuable usage when I create the [sub app for asp.net core](https://github.com/John0King/LazyMan.ModularLoader/blob/220c510fe868ae6ababe26b5b28ded067cd996d4/src/LazyMan.ModularLoader.AspNetCore/Infrastructure/PipelineCacheManager.cs#L40)\r\n\r\n## the problem\r\nwhen create my library `sub app for asp.net core`,  I need to share two type from the `Host` and the `SubApp` ===\u003e   `HttpContext` and `RequestDelegate`  , but after assembly fallback to use  the `HostAlc`\u0027s Assembly (the current HostAlc is also the default alc),  for example:  `ConfigureLogging()` on `IHostBuilder`  the `IHostBuilder` and the parameter will also use from `default alc`, then it end up  type `IHostBuilder`  is not the type `IHostBuilder` , the reason this issue happen is because a few assembly from  `\u003cFrameworkReference  Include=\"Microsoft.AspNetCore.App\"/\u003e` is being copy or not copy  to the app directory. (this is uncommon from a clear plugin loader   which the `abstract` will only exist in the `HostAlc`)  anyway,  after `ConfigureLogging` on `host alc` being called `everything` will call into the `HostAlc` even the `CurrentContextualReflectionContext `  is  `Plugin Alc`\r\n\r\n##  the current solution\r\nthe current solution is make a full `framework assembly manifest`  that force it being loaded to `HostAlc`\r\n\r\n## the future solution\r\n1. force to use `AssemblyLoadContext.CurrentContextualReflectionContext`  to fallback again to the plugin alc , every time  looking for a type look  \"CurrentContextualReflectionContext\" fist\r\n2.  `AssemblyLoadContext.Load(AssemlbyName)` and `AssemblyLoadContext.LoadUmanagedDll(string)`  to handle the alc fallback by default  from  `ContextualReflectionScope` , so we need a new static property of `Stack\u003cAssemblyLoadContext\u003e` in `ContextualReflectionScope` itself or `AssemblyLoadContext` , and people can just call `base.Load(assemlbyName)`  to do this complex thing eg.\r\n```c#\r\nstruct ContextualReflectionScope : IDisposeable\r\n{\r\n   //  the AssemblyLoadContext.Load  and LoadUnmanagedDll \"virtual\" method need to access this property ,\r\n   // when the stack is empty then raise assembly not fond\r\n   //  this property in struct won\u0027t be copied right?\r\n    internal static Stack\u003cAssemblyLoadContext\u003e Predecessor= new ();\r\n    internal ContextualReflectionScope(AssemblyLoadContext? activating)\r\n    {\r\n             ///////  add to stack\r\n            if(AssemblyLoadContext.CurrentContextualReflectionContext != null)\r\n            {\r\n                // this property is not be null for application, but when clr call default alc\u0027s\r\n                // EnterContextualReflection()  this property is null  see the change in 3\r\n                Predecessor = AssemblyLoadContext.CurrentContextualReflectionContext;\r\n            }\r\n           \r\n            AssemblyLoadContext.SetCurrentContextualReflectionContext(activating);\r\n            _activated = activating;\r\n            _initialized = true;\r\n    }\r\n\r\n    Dispose()\r\n    {\r\n        if (_initialized)\r\n                {\r\n                    // Do not clear initialized. Always restore the _predecessor in Dispose()\r\n                    // _initialized = false;\r\n                   ////////  note of use .Pop() method\r\n                    AssemblyLoadContext.SetCurrentContextualReflectionContext(Predecessor.Pop());\r\n                }\r\n    }\r\n}\r\n```\r\n3.  `CurrentContextualReflectionContext` will default to the `AseemlbyLoadContext.Default` ,  we are alway in a `ContextualReflectionScope` , so the fallback to default alc is not being affect (see  1)  eg.\r\n```c#\r\nusing(AssemlbyLoadContext.Default.EnterContextualReflection())\r\n{\r\n    Program.Main(args)\r\n}\r\n```\r\n4.  `Assemlby? AssemblyLoadContext.EntryAssembly`  and  optional constructor `AssemblyLoadContext(string name, boo isCollectible, string entryAssemlbyPath,)`    this `EntryAssembly` property is the first Assemlby this alc load,   the constructor will also have `AssemblyDependencyResolver`  but I think maybe this contronctor is not nesssory, because  using it we also need  to add a  `SharedAssemblies` property, maybe the best is to add a sub class .\r\n5.  to support the `Resolving` event and avoid dead loop,  the `AssemblyLoadContext` need to add a new private property `_currentPredecessor`  with is a copy of `ContextualReflectionScope.Predecessor`   when `EnterContextualReflection()` is called.   and when `.Load(  .LoadUnmananedDll()` being called each time it will `.Pop()`  an alc  ,  and when this event being fired, this `Statc\u003cAssemblyLoadContext\u003e`  is empty,  so  it\u0027s safe to call  `AssemlbyLoadContext.Default.LoadFromAssemblyName()`\r\n \r\n\r\n##  by using Stack\u003cT\u003e, will the perf too slow\r\n\r\nfor 99% user case  ,  the stack will only contains 1 item, which is the default alc,  so it will not fallbak many times for most user , unless there many child of alc\r\n \r\n\r\n\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eJohn0King\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-needs-work`, `area-AssemblyLoader-coreclr`, `area-System.Reflection`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003eFuture\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-03-09T18:11:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc5NDI1MzM4NA==",
                                           "createdAt":  "2021-03-09T18:11:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "@vitek-karas @jeffschwMSFT any thoughts on this proposal?",
                                           "updatedAt":  "2021-03-09T18:11:55Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc5NDQwODkzOA==",
                                           "createdAt":  "2021-03-09T20:25:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBi1P5w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2021-03-09T21:34:05Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "It\u0027s pretty simple to implement the parent/child relationship in a custom ALC. In the `Load` method simply instead of returning `null`, call the parent\u0027s ALC\u0027s `Load` instead. And track the parent ALC from the child ALC (member field). If we were to do this in the framework, this is pretty much the extent of the change we would do.\r\n\r\nI\u0027m not opposed in principal to introduce this into the framework, I just don\u0027t see a big need for it. Multi-level nested ALCs are not that common, and if they\u0027re needed the added complexity is minimal even without the framework supporting this directly.",
                                           "updatedAt":  "2021-03-09T20:25:08Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc5NDQxMTYxNQ==",
                                           "createdAt":  "2021-03-09T20:27:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "\u003e that people in .net team seems not “support” to use the CurrentContextualReflectionContext\r\n\r\nCan I ask where did you get this impression from? We added this feature in 3.0 timeframe, so not that long ago... so we definitely \"support\" it. It\u0027s true that it would be better if it was not needed - it\u0027s preferable to be explicit about load contexts in all operations which rely on them. The magical \"current context\" is problematic for many reasons, but it\u0027s a necessary workaround given the current state of the code both in the frameworks and in external libraries/apps.",
                                           "updatedAt":  "2021-03-09T20:27:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwMjY4MTI1OA==",
                                           "createdAt":  "2021-03-19T09:22:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "John0King",
                                           "body":  "@vitek-karas   the problem of one AssemblyLoadContext  is that you can not load different version of dependency when you implement a plugin architecture , for example:\r\n`AutoMapper` each major version have break change,  and plugins may use different version,  and this is not a problem in Php/Js and C++,  because  Php simply use file system and as long as the file is not conflict then it will work,  and js/ts and use webpack to pack the node_model into 1 file (like  static linking)， Cpp can use static link library.\r\n\r\nbut  **in .net ,the only way to load different version of same library is to use different `AssemblyLoadContext`**,   \r\nand now  **the major issue is to make some type across different ALC**, \r\ndue to the fact that .net do not have header file , and  nuget will  load every dependency into `Alc`  ,   and there no  clear  BCL  (`Microsft.Extensions.*`  is not BCL only, and `Microsoft.AspNetCore.*`  is from different Runtime Libraray)  , there no way to implement a Public-oriented plugin architecture \r\n\r\nand I already describe [the issue](https://github.com/dotnet/runtime/issues/37576#issuecomment-772978846)  ,\r\nwe obviously can not  force people to not reference any `Microsoft.Extension.*` in a plugin ! and in fact any nuget package can have the same issue.\r\n\r\nthe solution I thought is to make `CurrentContextualReflectionContext` to behave like the `AssemblyLoadContext.Default` ,  so that will be multiple assembly redirection in different `CurrentContextualReflectionContext`.\r\n\r\neg.\r\n\r\n```\r\ncurrent ALC --\u003e parent ALVC -\u003e ..... -\u003e current ALC \r\n\r\n=======example ==========\r\n\r\nclass Foo1{  public Foo2 B{get;set;}  }\r\nclass Foo2{}\r\n\r\nplugin$1 ----\u003e Default ALC (Found)   --(looking for Foo2)-\u003e   plugin$1\r\n[Foo2#1 ]  ···········  [Foo1, Foo2#0]\r\n\r\nresult:    in default alc , it treat Foo2#1 a different type than Foo2#0,\r\nand in current plugin :  Foo1  is reference Foo2#1\r\n\r\n```\r\n\r\nin this example ,  `Foo1` is the actual type that shared in different ALC,  but  it\u0027s dependency can be load different version\r\n\r\nand this is the current type looking behaviors in .net core 3.x and .net 5\r\n```\r\n=======current .net 5 example  (bad one) ==========\r\n\r\nclass Foo1{  public Foo2 B{get;set;}  }\r\nclass Foo2{}\r\n\r\nplugin$1 ----\u003e Default ALC (Found)   --(looking for Foo2)-\u003e  DefaultALC\r\n[Foo2#1 ]  ···········  [Foo1, Foo2#0]       ············   \r\n\r\nresult  :  plugin$1 use Foo2#1,  and Foo1 reference Foo2#0 , so Foo2#1 is not Foo2#0\r\n``` \r\n\r\n\r\nbut as long as we can solve this issue , any thought is welcome, maybe the simplest way is `CurrentContextualReflectionContext.SharedAssmelies.AddRange(  DependencyScaner.ScanDependencies( typeof(MyType).Assmebly ) )`",
                                           "updatedAt":  "2021-03-19T09:22:06Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwMjY5NzgwNw==",
                                           "createdAt":  "2021-03-19T09:48:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "The current assumption is that plugins have a clearly defined interface between them and the host. And that plugins don\u0027t talk to each other. It\u0027s technically possible to do all those things as well, but it gets complicated.\r\n\r\nIn this sense I don\u0027t see how this is different from the \"Static linking\" approach (other than it\u0027s obviously easier to use). Basically each plugin needs to carry all of its dependencies with it, EXCEPT the dependencies which the host provides (this is basically part of the interface between the host and the plugin). Each plugin gets isolated in its own ALC - all of the dependencies which it carried with it are also isolated.\r\n\r\nThis enforces the contract with the host, where only the defined interface is shared (no plugin should carry the assemblies from that interface).\r\n\r\nAgain similar to static-linking, statically linked C++ library will have a clearly defined interface (the ABI it exposes) and a set of external dependencies it requires (anything it loads as dynamic library and doesn\u0027t carry with it statically linked in). The only difference between C++ and .NET is that it\u0027s easier to do versioning of the host/plugin interfaces in C++ in some cases (since there\u0027s no type identity, if the struct matches it will work). On the .NET side if you need to version the host/plugin interface it will probably mean a need for multiple versions of the interface assemblies - but it depends on the actual interface and design.\r\n\r\nI agree that this is a change from .NET Framework, there it was kind of a \"load whatever you want\" which sometimes worked (and if it didn\u0027t one got stuck in binding redirect hell). In .NET Core the isolation is VERY explicit and so it typically enforces a clearly defined contracts between the components involved (plugins, host).",
                                           "updatedAt":  "2021-03-19T09:48:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwMjcyMTEwMg==",
                                           "createdAt":  "2021-03-19T10:26:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "John0King",
                                           "body":  "@vitek-karas  \r\n\u003e The current assumption is that plugins have a clearly defined interface between them and the host. \r\n\r\nthe truth is we almost can\u0027t in asp.net core.  for  an asp.net core plugin , it need to share a few  type `IApplicationBuilder` and `HttpContext` ,  but the host also has many dependency , and one is `Microsft.Extension.Configuration.Abstraction` ,  \r\n first,  it\u0027s a nuget package,  and second ,  it  not a key assembly of plugin ,    **but the host may carry this assmebly and may not**.   if you just use `Microsoft.AspNetCore.App` , then the host app not have this type ,   and if you use any dependent-ed nuget pakcage,  the host will have this type as well , and it\u0027s also the same with plugin.\r\n\r\nif your plugin have this assembly and your host have this assembly as well  , then the problem happened.\r\n1.  your plugin ALC will  load your version of  `Microsft.Extension.Configuration.Abstraction`  short name as `MECA`\r\n2. the host have `MECA` as well.\r\n3. any `MECA` type you write in your plugin is the plugin one\r\n4. any  type look happend in  host type   , will use the host one.\r\n\r\nthe result is that ,  the fallback to Default ALC  became a  assembly black hole, and any assembly fall in and will can not get out.\r\n\r\nso that means , the plugin must not use **any assembly** that host use.\r\nand that;s mean , if the host use 100 assembly , then any plugin must not use those 100 assembly as well,  even the plugin architecture shared is just  3 assemblies !!!!!\r\n ",
                                           "updatedAt":  "2021-03-19T10:26:15Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwMjczNDEzMw==",
                                           "createdAt":  "2021-03-19T10:47:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "That\u0027s a constraint of the plug-in system. The host can\u0027t \"pin\" dependencies or plugins can\u0027t load different versions of those assemblies. Especially if types are exchanged between the plug-in and the host, this \"restriction\" makes sense.  \n\nNow if you\u0027re saying that those types aren\u0027t exchanged and are totally self-contained in each plug-in then I agree there should be a way to make that work. I think it\u0027s possible today but not at all obvious (likely you need the host\u0027s deps file to not to include the dependencies that you want loads less by plug-in contexts).",
                                           "updatedAt":  "2021-03-19T10:47:29Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwMjc2NDkzNg==",
                                           "createdAt":  "2021-03-19T11:27:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "That\u0027s why I described that the list of assemblies which the host wants/needs to share with all plugins is effectively part of the contract. For example if I have an `Interface.dll` which defines the interface between the host and the plugin, then the full dependency closure of this assembly should be provided by the host - so that all plugins and host agree on those types.\r\n\r\nThis effectively encourages the interface to be minimalistic, so that the closure is as small as possible. Again not any different from the C++ static linking style - if the native library has lot of dynamic dependencies (which are used in the interface) then it will have the same problem.\r\n\r\nThe one unfortunate thing today is that the host can\u0027t declare/enforce which assemblies should be shared. But the custom ALC which loads the plugins can do this if it wants to (and that ALC is effectively part of the host). Currently the plugins should ideally know this up-front and build accordingly. Any dependencies which are to be shared should use `Private=false` which will avoid putting those assemblies into the output of the plugin.",
                                           "updatedAt":  "2021-03-19T11:27:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxNzc4MzgzNw==",
                                           "createdAt":  "2021-04-12T12:50:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "John0King",
                                           "body":  "@vitek-karas   @davidfowl  @steveharter  \r\n1st, let me apologies for my bad englisth.  Here is some thing I\u0027m thinking for a common used plugin/module framework.  https://github.com/John0King/LazyMan.ModularLoader/issues/2.\r\n\r\nfrom a script language,  the isolation is pretty simple,  all the isolation is done by the file system. for example \r\n\r\n```ts\r\n//ts\r\nimport { Foo } from \"Lib1\"\r\nimport { Foo as Foo2} from \"Lib1-copy\"\r\n\r\n\r\n```\r\n\r\n```php\r\n// php\r\n\r\nrequre_once(\u0027../host-shared.php\u0027)\r\n// do something with plugin host type\r\n\r\nrequir_once(\u0027./local-shared.php\u0027)\r\n\r\n// do something with local type\r\n```\r\nI dont\u0027s now about C/C++,  but I think it may be the same , isolated by file， at latest it can  use static linking with  plugin, and dynamic linking with plugin\u0027s host app (but I think it may work , but the method and type  may not be  fully isolated )\r\n\r\nI\u0027m wonder that can we using file system to do the isolation ?  after all the assemblies in  a plugin is identifiable， so why we need to do type  redirection in runtime instead of build time ?\r\npreviously  two dll have same namspace and type  can use `alias` （on `\u003creference /\u003e`）  add call using `alias:namespace.type`, it sound like this is our file system isolation.\r\n",
                                           "updatedAt":  "2021-04-12T12:50:29Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxNzg3NzUxMQ==",
                                           "createdAt":  "2021-04-12T14:51:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "Technically C# can do this: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/extern-alias\r\n.NET Core doesn\u0027t support this out of the box though - you would have to implement custom ALC and adapt the resolution accordingly, but it\u0027s technically possible.\r\n\r\nBut honestly that\u0027s not the main problem. The problem is if the explicitly specified \"plugin\" (by file path) references some other assembly. How is that reference resolved. I actually don\u0027t know how ts or php do this - if it\u0027s also filepath based, then it\u0027s pretty simple to do the same in .NET.\r\n\r\nBut then the main problem will be sharing of types - ts is basically javascript and so it relies on just shapes of objects (there are really no types). And so if the host\u0027s view and plugin\u0027s view of a given \"type\" are similar enough, they will be able to exchange instances of that \"type\". I honestly don\u0027t know PHP well enough to comment on that. .NET on the other hand is strongly typed - each instance has a strictly defined type, and so to exchange instances (without usage of reflection) both host and plugin must share the exact same type definition.\r\n\r\nThere are ways around this even in .NET, but they\u0027re not \"nice\" - you could use `dynamic`, or you could build something similar with `DispatchProxy`.",
                                           "updatedAt":  "2021-04-12T14:51:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxNzk2Nzc4OQ==",
                                           "createdAt":  "2021-04-12T16:52:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "John0King",
                                           "body":  "one problem is that now .net release 2 set of runtime +  2 more deploy mode. \r\nruntime:\r\n1) Server Runtime (.net BCL core +  asp.net core workload)\r\n2) DesktopRuntime (.net BCL core + Windows workload)\r\n3) ~~AndroidRuntime (.net BCL core + Android workload)~~\r\n4) ~~IOSRuntime (.Net BCL core + IOS workload)~\r\n\r\ndeploy mode:\r\n1)  Runtime installed + App\r\n2)  Self-containd\r\n3)  AOT  (all static linking , but no dynamic link)\r\n\r\nand with .net 6 , there\u0027s no  BCL assemblies in workload  can be known before you deploy it ( \"System.Drawing.Common\"  is an example), and the \"framework.extensions.*\" always be have an issue \"does it already include in host app ?   or  include those dll in plugin by accidentally reference one of the nuget package\"\r\n\r\nand another problem is  Share the type that need isolation :\r\n\r\nHost App  -----\u003e   a  stand alone app as plugin  (it\u0027s a host of it\u0027s won plugin)  ----\u003e  plugin of plugin\r\n\r\nApp.exe/dll   (+ PluginLoader.dll@v1 )  ----\u003e  (standApp.dll  +  PluginLoader.dll@v2)  ---\u003e   plugin.dll\r\n\r\nin this example, as the developer ,  we know the standApp.dll need share Plugin.Loader.dll from App， so it can not include the `PluginLoader.dll@v2`  otherwise it can not provide the type that the host App.exe can recognition，   and if it not provide this `PluginLoader.dll@v2` , then  the standApp.dll may won\u0027t work because it need this new version.\r\n\r\nI know this may be bad example , but it describe the problem:  we know there two type look exactly the same, but we know they are not the same one , but the C#\u0027s type system can not . \r\n\r\nand \r\n\u003e ts is basically javascript and so it relies on just shapes of objects (there are really no types). And so if the host\u0027s view and plugin\u0027s view of a given \"type\" are similar enough, they will be able to exchange instances of that \"type\"\r\n\r\nbut in my example , there no type exchange,  it just ts/js syntax can recognize those are two different type.\r\n```ts\r\n\r\n//ts\r\nimport { Module } from \"module-loader\" // package\r\nimport { Module as M2} from \"./module-loader/index\" //locale version\r\n\r\nexport class MyModule extends Module{\r\n         load(){\r\n                 let loader = new ModuleLoader();\r\n                 loader.load(new XModuleFromSomePlugin())\r\n        }\r\n}\r\n\r\n//\r\nexport class ModuleLoader{\r\n     load(m M2){\r\n          if(m instance of M2){\r\n                // real check for type , not the shape of object\r\n                m.load();\r\n          }\r\n           else{\r\n                throw new Error(\u0027you can not load this, because it\u0027s not a module\u0027)\r\n           }\r\n    }\r\n}\r\n\r\n```\r\n\r\nI conclude to follow conclusion：\r\n1) with nuget system , we lost more control on file system.\r\n2)  there no syntax in C#, can be use to  help us from pick the right type from right assembly.\r\n3) no core BCL ,   eg. ( `std` lib for `C++`  , `es` api for `javascript` , `php script env` for `PHP` )\r\n4) C#\u0027s Assmbly -\u003e module -\u003e type    , not make any thing better \r\n\r\n## The End: \r\nI hope all of  you the smart guy , can start create a module/plugin system,  can find ways to make this better.\r\nAs a .Net developer , don\u0027t you jealous  PHP\u0027s WordPress  can have such nice plugin system ? \r\n",
                                           "updatedAt":  "2021-04-12T16:52:45Z"
                                       }
                                   ],
                         "totalCount":  15
                     },
        "title":  "focusing on AssemblyLoadContext.CurrentContextualReflectionContext to support child/parent alc fallback",
        "labels":  [
                       "api-needs-work",
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/40547",
        "createdAt":  "2020-08-07T18:54:24Z",
        "number":  40547,
        "author":  "sankalan",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOBOQeuA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "piedar",
                                            "createdAt":  "2020-08-24T14:20:09Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2022-07-30T16:30:44Z",
        "body":  "### Description\r\n\r\nAs per this documentation - https://docs.microsoft.com/en-us/dotnet/standard/assembly/unloadability#troubleshoot-unloadability-issues, it seems like if we keep a reference to an assembly, loaded in a collectible assembly load context, the load context should not get collected. Let me know if I misunderstood this.\r\n\r\nBut it seems like to keep a collectible load context alive, depending on some case, a strong reference has to be be kept to the load context itself.\r\n\r\nI have a [demo project](https://github.com/sankalan/test-assembly-context-unloading/tree/develop) setup for this. You should find the description in the readme.\r\n\r\n### Configuration\r\n\r\n* Using .netcore3.1 on Windows 10.\r\n\r\n### Regression?\r\n\r\n* Refer to this [project](https://github.com/sankalan/test-assembly-context-unloading/tree/develop), steps should be mentioned in the readme.\r\n\r\n@vitek-karas \r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOKB7Fgg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY3MDY2MDg4OA==",
                                           "createdAt":  "2020-08-07T18:54:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke\nSee info in area-owners.md if you want to be subscribed.",
                                           "updatedAt":  "2020-08-07T18:54:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY3MDY4Mzk1OA==",
                                           "createdAt":  "2020-08-07T19:46:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "agocke",
                                           "body":  "cc @janvorli ",
                                           "updatedAt":  "2020-08-07T19:46:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY3MTEwNTcyOQ==",
                                           "createdAt":  "2020-08-09T21:57:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "I verified the repro and there really seems to be something weird going on. Holding a strong reference to the assembly in an ALC is apparently not enough to prevent it from unloading. In fact in this repro holding to an instance of a type from the ALC also still leaves it \"unloading\".\r\n\r\nJust a side note about the repro:\r\nI don\u0027t think that adding a callback to the the `ModuleResolve` actually creates a strong reference to the assembly on its own. The assembly and the callback will holds references to each other, but there\u0027s no GC root holding either so it\u0027s all still collectible. In this repro what holds onto the assembly is actually the `assemblies` local variable in the `Main`.\r\n\r\nIt would be best if @janvorli could take a quick look at this first.",
                                           "updatedAt":  "2020-08-09T21:57:11Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY3MTM1MDM5NA==",
                                           "createdAt":  "2020-08-10T13:21:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "The reference to an assembly loaded into a collectible context keeps the underlying data structures in the runtime alive (the managed LoaderAllocator, LoaderAllocatorScout and native AssemblyLoaderAllocator. That\u0027s what the document talks about. \r\nBut it doesn\u0027t keep reference to the AssemblyLoadContext instance. If you need that one to stay alive, you need to keep a strong reference to it. We cannot keep the AssemblyLoadContext instance alive by the assemblies loaded into it, because runtime needs to keep references to those assemblies internally and so it would keep the AssemblyLoadContext alive indefinitely.\r\n",
                                           "updatedAt":  "2020-08-10T13:21:21Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY3MTQwNDIxMA==",
                                           "createdAt":  "2020-08-10T14:53:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sankalan",
                                           "body":  "Ok, seems like it is working as expected then.\r\nJust trying to understand this better-\r\nThis means if I am keeping a reference to the assembly only, it keeps the assembly (and underlying data structures) alive but unloads the context, right? If yes, then what\u0027s the use of this assembly? As the context is unloaded, it will always throw exception trying to use it right? Or this is just unusable junk remains dangling?\r\n",
                                           "updatedAt":  "2020-08-10T14:53:36Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY3MTQxODQ1Mg==",
                                           "createdAt":  "2020-08-10T15:18:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "The load context will not be really unloaded as long as something holds onto an assembly in it - in that sense the docs are right. The specific issue here is that ALC is unloaded in two steps:\r\n* When there are no more references to the ALC itself it is marked for unload (I think this is similar to calling `Unload` on it) - this doesn\u0027t unload the ALC yet, it just starts the process\r\n* When there are no references to anything in the ALC, the ALC get actually unloaded\r\n\r\nAlmost everything still works after the first step, assembly loading is an exception - it will throw the exception you\u0027re experiencing.",
                                           "updatedAt":  "2020-08-10T15:18:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY3MTQ0MjU3NA==",
                                           "createdAt":  "2020-08-10T16:01:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sankalan",
                                           "body":  "Well I\u0027m more confused now. \r\nI think the load context gets unloaded in this example project -\r\n\r\n1) You can find the log gets printed in the unloading event handler for the concerned assembly (SubProj1).\r\n2) In the exception that gets thrown while I tried to invoke the api, has the inner exception stating that - \"The assembly load context is unloaded or unloading.\"\r\n\r\nNow my confusion is - are all these expected? Following the documentation I thought it\u0027s not.\r\n\r\nAlso, I will like to know if there is something that I am doing wrong here or is there any better approach that you can suggest for this use case?",
                                           "updatedAt":  "2020-08-10T16:01:20Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY3MTQ1Njk2NQ==",
                                           "createdAt":  "2020-08-10T16:28:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "Unloading event handler is called when unloading is initiated (so that you can clean up references that would prevent unloading). The exception says \"or unloading\". The unloading is initiated when there are no more references to the AssemblyLoadContext or you call the Unload method. So none of these two indicate that the unload has completed. And since the unloading is cooperative, it won\u0027t complete until It doesn\u0027t unload the context, it just initializes the unloading process. It doesn\u0027t unload anything until all references to the assemblies, types from those assemblies and instances of those types are gone. ",
                                           "updatedAt":  "2020-08-10T16:28:34Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY3MTQ4NjY2Mg==",
                                           "createdAt":  "2020-08-10T17:28:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sankalan",
                                           "body":  "Ok, referring to this [doc](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.loader.assemblyloadcontext.unloading?view=netcore-3.1) my understanding was the event gets triggered once the the load context is completely unloaded.\r\nAnyway, regardless it\u0027s unloaded or unloading, seems like the assembly is no longer usable. That\u0027s the problem I\u0027m having here. How can I have that not initialise unloading (of course having explicit ref is an option). \r\nHaving said that, what is the motive behind keeping this assembly dangling like this, context not unloaded but assembly not usable? This can neither get collected nor stay usable throughout the lifetime of the application.",
                                           "updatedAt":  "2020-08-10T17:28:15Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY3MTQ5MTY5MQ==",
                                           "createdAt":  "2020-08-10T17:38:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "The problem is that the assembly is trying to load another assembly. If it didn\u0027t do that, everything would just work. The assembly itself is still fully up and running.\r\n\r\nAnyways, if you don\u0027t want the unloading to start, all you need to do is to keep references to the AssemblyLoadContexts. Then everything should work reliably. Once you want it to unload, just get rid of the references to the AssemblyLoadContexts. You can also call the Unload method on the AssemblyLoadContexts before getting rid of the references to initiate the unloading right away instead of deferring it to the time when GC collects the AssemblyLoadContexts.\r\n\r\nThe key thing is that when you don\u0027t keep a strong reference to an AssemblyLoadContext, it means that you want it to be unloaded.\r\n",
                                           "updatedAt":  "2020-08-10T17:38:28Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY3MTQ5ODk1OA==",
                                           "createdAt":  "2020-08-10T17:54:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sankalan",
                                           "body":  "I think I get your point, thanks for your help.\r\n\r\nJust one more clarification I will ask for- keeping reference to the assembly keeps the assembly alive but marks it\u0027s context to unload (which will never eventually be unloaded as long as the assembly ref is maintained). This however makes other assemblies of the context unusable. So any other assembly (which doesn\u0027t have any strong ref to) of the **same** context will not be loadable any further. - Is this statement true? ",
                                           "updatedAt":  "2020-08-10T17:54:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY3MTUwMzMwNQ==",
                                           "createdAt":  "2020-08-10T18:03:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "\u003e This however makes other assemblies of the context unusable.\r\n\r\nThat\u0027s not really correct. It makes assemblies of the context that were not loaded yet unusable (in the sense that they cannot be loaded). All assemblies that were already loaded into the context are fine.",
                                           "updatedAt":  "2020-08-10T18:03:24Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY3MTUxMTQyMw==",
                                           "createdAt":  "2020-08-10T18:19:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sankalan",
                                           "body":  "Ok, I\u0027m with you now. \r\n\r\nReferring to your first comment - \r\n\r\n\u003e We cannot keep the AssemblyLoadContext instance alive by the assemblies loaded into it, because runtime needs to keep references to those assemblies internally and so it would keep the AssemblyLoadContext alive indefinitely.\r\n\r\nThis seems like you are only marking the ALCs not really collecting them anyway till ref to an assembly is maintained. \r\nSo you may consider not marking the ALCs as \"unloading\" too. This will keep the complete set alive and usable (allowing to load newer assemblies in the context on demand). Right now it seems all the pieces are there in the memory but not completely usable.\r\n\r\nIf you have reasons not to do that, you can close this issue. I am ok with the resolution you provided.\r\n\r\nThank you.\r\n\r\n\r\n",
                                           "updatedAt":  "2020-08-10T18:19:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY3MzEwNTI4Mg==",
                                           "createdAt":  "2020-08-12T20:53:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBOQbTQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "sankalan",
                                                                               "createdAt":  "2020-08-13T04:20:55Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "piedar",
                                                                               "createdAt":  "2020-08-24T14:13:54Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "janvorli",
                                           "body":  "I was actually considering trying to do something like that some time ago, but I didn\u0027t have a chance to get to that. I will give it a try in the .NET 6 timeframe.",
                                           "updatedAt":  "2020-08-12T20:53:10Z"
                                       }
                                   ],
                         "totalCount":  14
                     },
        "title":  "Collectible Assembly Load Context is getting collected even if there is a reference to one of the assemblies of that context",
        "labels":  [
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/41278",
        "createdAt":  "2020-08-24T17:31:55Z",
        "number":  41278,
        "author":  "agocke",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-07-28T17:25:15Z",
        "body":  "",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOKIlK3g==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY3OTI2NDkwNQ==",
                                           "createdAt":  "2020-08-24T17:31:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Dotnet-GitSync-Bot",
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2020-08-24T17:31:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY4MDA4NjIzOA==",
                                           "createdAt":  "2020-08-25T15:11:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke\nSee info in area-owners.md if you want to be subscribed.",
                                           "updatedAt":  "2020-08-25T15:11:42Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Docs: Write an \"introduction to linker\" featuring some of the common causes of warnings, and how to fix them using attributes",
        "labels":  [
                       "documentation",
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/41625",
        "createdAt":  "2020-08-31T20:33:38Z",
        "number":  41625,
        "author":  "groogiam",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-01-20T14:48:36Z",
        "body":  "I am running into an issue where I am trying to port some logic which creates dynamic assemblies from framework to core. In this particular scenario the code that creates the dynamic assembly is in a nuget package that use CodeDomCompiler. The assembly is loaded from CompilerResult.CompiledAssembly which appears to always use the default context. This also happens with typeof comparisons inside of the library that is being dynamically loaded. What I\u0027m seeing is that the AssemblyLoadContext seems to have some shortcomings in terms of control of how it can be used to isolate and unload dynamic code in libraries. The AppDomain concept supported these scenarios because all the types load in the domain where internally consistent. Is there any way to mimic the isolation of an AppDomain for libraries where a developer does not directly control the dynamic assembly load? If not is there any plans to perhaps support this in the future. Thanks.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOU1tUgg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY4NDAyMjgyOA==",
                                           "createdAt":  "2020-08-31T20:33:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke\nSee info in area-owners.md if you want to be subscribed.",
                                           "updatedAt":  "2020-08-31T20:33:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY4NDA0NTA4OQ==",
                                           "createdAt":  "2020-08-31T21:16:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "The problem is this line: \r\nhttps://github.com/dotnet/runtime/blob/731eaf35451c2076287416018d4dca5df9843258/src/libraries/System.CodeDom/src/System/CodeDom/Compiler/CompilerResults.cs#L26\r\n\r\n`Assembly.LoadFile` will\r\n* Create a new ALC for the each unique file path and load the assembly into it\r\n* The new ALC will always fallback to Default ALC for any other assembly resolution\r\n\r\nSo the end result is that it looks almost like loading it into Default - it gets all its dependencies from Default.\r\n\r\nIn the world of ALCs this compiler API should ideally provide a way to specify which ALC to load the file into. Or at the very least react to https://docs.microsoft.com/en-us/dotnet/api/system.runtime.loader.assemblyloadcontext.currentcontextualreflectioncontext?view=netcore-3.1\r\n\r\nAs for a workaround - if you can modify the code which calls the `CompilerResult.CompiledAssembly` you could instead of called that use the `CompilerResult.PathToAssembly` and load it yourself whichever way you want. If you don\u0027t control that code in any way - I\u0027m afraid there\u0027s no workaround - I really can\u0027t think of anything :sad:.\r\n\r\nThis is kind of related to https://github.com/dotnet/runtime/issues/29842 as it\u0027s a similar type of problem (which doesn\u0027t have a workaround at least via the ContextualReflectionContext)",
                                           "updatedAt":  "2020-08-31T21:16:53Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY4NjgyOTg1OQ==",
                                           "createdAt":  "2020-09-04T00:23:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "groogiam",
                                           "body":  "I have modified the code to pass in an assembly load context but I still am getting type checks that fail. I have the entire default context into the new context but performing == on typeof still seems to fail. Shouldn\u0027t this be using the types from the context of the caller before the default?",
                                           "updatedAt":  "2020-09-04T00:23:09Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY4NzM1MjYzNg==",
                                           "createdAt":  "2020-09-04T19:58:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "@groogiam I\u0027m sorry but I don\u0027t think I understand the problem you\u0027re describing.\r\nALCs are only used during assembly resolution - which basically means assembly loading. They decide which assembly will be loaded and from where. Once assemblies are loaded ALCs are basically just buckets holding the assemblies but they\u0027re not used during execution of the code in any way.\r\n\r\nSo for example typeof(MyType) in itself has no ALC interaction. What matters is which ALC the assembly which has this code in it is loaded into - and then when the MyType is loaded and causes to load its assembly MyAssembly - how does that ALC respond to the request of loading MyAssembly.\r\n\r\nIt\u0027s pretty hard to answer what\u0027s wrong without knowing a bit more about how your ALCs are setup and the code in question.\r\n\r\nOne way to debug this is to print out which ALC the type/assembly is from. This can be done by calling `AssemblyLoadContext.GetLoadContext(myAssembly)` or `AssemblyLoadContext.GetLoacContext(myType.Assembly)`. This should obviously work on any `System.Type` or `System.Reflection.Assembly` instance - so you can also use it on the result of `typeof` and so on.",
                                           "updatedAt":  "2020-09-04T19:58:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TSIMS",
                                           "createdAt":  "2023-01-19T16:30:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "OlegJakushkin",
                                           "body":  "@vitek-karas:  may be I have a similar issue and you could help me:\r\n\r\nSay we want to implement the `V` from [here](https://assets.ctfassets.net/9n3x4rtjlya6/7eA83FDPnEQ4jPyLX7eQYj/23144face7a433c303ee045d3e585f96/100788_279808118_Raffaele_Rialdi_An_in-depth_look_at_the_new_features_in_C_8.0_and_.NET_Core_3.0.pdf):\r\n![image](https://user-images.githubusercontent.com/2915361/213497369-7d90174c-20ef-4633-a16e-ac53c5db1d21.png)\r\n\r\ncorner right image where Json.Net is already loaded into Default ALC, yet we want to load an assembly that refrences Json.Net, yet while its referenced Json.Net version and name are same we want to use ALC to load it from another path. Currently when we load Addon Default resolves Json.Net and does not give us a chance to load it from the path we want. How would one do such thing?\r\n",
                                           "updatedAt":  "2023-01-19T16:31:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TSe4X",
                                           "createdAt":  "2023-01-19T17:32:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC0iD3A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "OlegJakushkin",
                                                                               "createdAt":  "2023-01-20T10:13:42Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "There\u0027s a guide how to write plugins/hosts here: https://learn.microsoft.com/en-us/dotnet/core/tutorials/creating-app-with-plugin-support\r\n\r\nYou have two choices on where/how to determine isolation:\r\n* The build of the plugin - if the plugin doesn\u0027t carry a specific assembly with itself, then it can\u0027t be isolated (the plugin\u0027s version doesn\u0027t exist effectively) and so the host needs to resolve it (typically from the Default). Usually if the plugin does carry a dependency with itself, then the host should isolate it (load it into plugin\u0027s ALC). This is what the guide and associated sample above implement.\r\n* The host has final say - even if the plugin does contain the dependency, the host may decide to not use it - this would be done in the `AssemblyLoadContext.Load` override. The implementation shown in the sample doesn\u0027t do that, it fully relies on `AssemblyDependencyResolver` which will be driven by what was included with the plugin. But it\u0027s a possibility if you have wrongly built plugins (hopefully not though). That part is shown specifically here: https://learn.microsoft.com/en-us/dotnet/core/tutorials/creating-app-with-plugin-support#reference-a-plugin-interface-from-a-nuget-package\r\n\r\nNote that the plugin project file needs to be aware of this. It needs to use the correct properties to mark dependencies it wants from the host (and thus those won\u0027t be copied to the build output of the plugin). Typically that should be anything from the core framework and the interface assembly which defines the interface with the host. ",
                                           "updatedAt":  "2023-01-19T17:32:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TVvSB",
                                           "createdAt":  "2023-01-20T10:43:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "OlegJakushkin",
                                           "body":  "Dear @vitek-karas: Yes, I am aware of general use pattern of AssemblyLoadContext, yet now please imagine the following situation:\r\n - We are inside an BaseApp that relies on Json.Net - it is already loaded into our AppDomain\r\n - We want to load a Plugin with a specific Json.Net implementation (that happens to share name and version with our BaseApp Json.Net yet is in another folder and has a set of changes made to it.\r\n \r\nThe problem is `AssemblyLoadContext.Load` overload only asks once for the assembly (on Plugin load) and then uses ones from default AppDomain including Json.Net implementation.\r\n\r\nOne may expect that if you load the desired modified Json.Net first and than load Plugin AssemblyLoadContext would use the modified version. Yet it does not happen.",
                                           "updatedAt":  "2023-01-20T10:43:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TVxQv",
                                           "createdAt":  "2023-01-20T10:52:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "I must admit I\u0027m a bit confused, but let me describe how it \"should\" work:\r\n* Create a new ALC for the new plugin\r\n* Implement the override of `AssemblyLoadContext.Load` which will resolve `Newtonsoft.Json` from the plugin\u0027s directory by calling `this.LoadFromAssemblyPath` and returning that.\r\n* Load the plugin into the ALC - `alc.LoadFromAssemblyPath(pathToPlugin)`\r\n* Through reflection get an instance of the plugin and call it\r\n* At some point the `AssemblyLoadContext.Load` override on the plugin\u0027s ALC will be called with `Newtonsoft.Json` assembly name. As per the implementation above, this should resolve by loading the assembly from disk.\r\n* From this point on, all references from the plugin\u0027s assembly to `Newtonsoft.Json` should be resolved to the assembly loaded in the above step.\r\n\r\nIt you need to diagnose this, you can try this: https://learn.microsoft.com/en-us/dotnet/core/dependency-loading/collect-details\r\nIt takes a bit of practice to look through the traces, but it should all of the information to figure out exactly what is happening. You can even combine it with live-debugging the project to see what happens inside the `Load` override.",
                                           "updatedAt":  "2023-01-20T10:52:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TWI8Q",
                                           "createdAt":  "2023-01-20T12:26:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "OlegJakushkin",
                                           "body":  "Dear @vitek-karas: created a small prototype to illustrate my point [here (compilable and runable)](https://github.com/OlegJakushkin/TestAssemblyLoadContextAfterCecil)\r\n\r\nIn it I:\r\n1. Create a new ALC for the new plugin [here ](https://github.com/OlegJakushkin/TestAssemblyLoadContextAfterCecil/blob/main/TestLibraryUser/LibraryTests.cs#L27 )\r\n2. Implement the override of `AssemblyLoadContext.Load` which will resolve dependencies from the plugin\u0027s directory. [here ](https://github.com/OlegJakushkin/TestAssemblyLoadContextAfterCecil/blob/main/Influence/AssemblyLoadContextThatUsesInsertionFactoryLibs.cs#L12-L20)\r\n3. Load the plugin into the ALC - `alc.LoadFromAssemblyName(typeof(TargetUser).Assembly.GetName())` [here ](https://github.com/OlegJakushkin/TestAssemblyLoadContextAfterCecil/blob/main/TestLibraryUser/LibraryTests.cs#L30)\r\n4. Through reflection get an instance of the plugin and call it [here ](https://github.com/OlegJakushkin/TestAssemblyLoadContextAfterCecil/blob/main/TestLibraryUser/LibraryTests.cs#L33-L34)\r\n5. At some point the AssemblyLoadContext.Load override on the plugin\u0027s ALC shall be called with dependancy assembly name.  _**Yet it does not.**_",
                                           "updatedAt":  "2023-01-20T12:26:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TWVYy",
                                           "createdAt":  "2023-01-20T13:15:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "The problem is [here](https://github.com/OlegJakushkin/TestAssemblyLoadContextAfterCecil/blob/b88a2938a5db06ed20e66b0fe0f3d791e4b35b3d/TestLibraryUser/LibraryTests.cs#L31). This calls `LoadFromAssemblyName` which will call the `Load` overload. But in this case the overload return `null`, so the call falls back to the `Default` load context which resolves it (to the already loaded version anyway). Any future calls to types from that assembly will be done in the `Default` context and thus won\u0027t hit the `Load` override in the custom ALC.\r\n\r\nI think the confusion is that `LoadFromAssemblyName` is not guaranteed to return an assembly from the target ALC - it\u0027s basically equivalent to \"Resolve this assembly name in the context of this ALC\". For example you could call `alc.LoadFromAssemblyName(typeof(object).Assembly.Name)` and that should always return the same `System.Private.CoreLib` no matter which alc you call it on (as CoreLib can\u0027t every be loaded more than once).\r\n\r\nUnlike `LoadFromAssemblyPath` which in fact guarantees that it returns assembly from the target context (it either loads a new one, or returns an existing one).\r\n\r\nThe resolution of an assembly reference is purely based on the ALC into which the calling assembly belongs - in this case you start with assembly in Default, and thus the reference resolution happens in the Default context.",
                                           "updatedAt":  "2023-01-20T13:15:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TWriQ",
                                           "createdAt":  "2023-01-20T14:15:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "OlegJakushkin",
                                           "body":  "Dear @vitek-karas: even using `LoadFromAssemblyPath`  and having both \r\n1) Main library I want to use directly (placed into a new .dll)\r\n2) and a Dependency library (referenced from Main) (placed into a new .dll)\r\n\r\n`AssemblyLoadContext` only loads Main library I want to use directly and explicitly (with `Load` call), yet all subsequent dependencies such as a library I want it to reference do not get to have a `Load` call.\r\n\r\nEven if I modify ALC Load with so that it always loads not `null` and even loads from File:\r\n```\r\n    protected override Assembly Load(AssemblyName assemblyName)\r\n    {\r\n        string path = \"\";\r\n        if (InsertionFactory.AssemblyNameToPath.TryGetValue(assemblyName.FullName, out path))\r\n        {\r\n            return Assembly.LoadFile(path);\r\n        }\r\n        var result = Assembly.LoadFile(Assembly.Load(assemblyName).Location);\r\n        return result;\r\n    }\r\n``` \r\n\r\nStill I only get ALC call for Main and no calls for Dependency(es)... Is there any workaround that could allow force resolution of all the dependencies using ALC?\r\n\r\n",
                                           "updatedAt":  "2023-01-20T14:15:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TW1SC",
                                           "createdAt":  "2023-01-20T14:48:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC0jDVQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "OlegJakushkin",
                                                                               "createdAt":  "2023-01-20T14:50:54Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "Sorry - I missed one additional problem. Please don\u0027t call `Assembly.LoadFile` it will load into its own ALC. This is somewhat documented, but probably not super clear. Probably the best doc about the various assembly loading APIs is here: https://learn.microsoft.com/en-us/dotnet/core/dependency-loading/loading-managed#when-are-managed-assemblies-loaded (in terms of their interaction with ALCs).\r\n\r\nIf you replace `Assembly.LoadFile` with `this.LoadFromAssemblyPath` it will finally start loading the assemblies into your ALC. You can verify this by calling `AssemblyLoadContext.GetLoadContext(assembly)` which will tell you which ALC any given assembly belongs to.\r\n\r\nNote that the code as above will not work either - it will actually load the `Influence` assembly separately into the plugin\u0027s ALC as well and thus the \"counting\" will happen there and not where the test sees it (two copies of the `Influence` assembly in the process).\r\n\r\nThis is generally why I would recommend that you build the plugin into a separate location (as shown by our sample) and load it from there using the `AssemblyDependencyResolver`. You will avoid problems with having to handle assembly paths and so on yourself.",
                                           "updatedAt":  "2023-01-20T14:48:36Z"
                                       }
                                   ],
                         "totalCount":  12
                     },
        "title":  "AssemblyLoadContext does not provide proper isolation of types",
        "labels":  [
                       "question",
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/42041",
        "createdAt":  "2020-09-09T22:35:35Z",
        "number":  42041,
        "author":  "resc0059",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-10-05T18:20:24Z",
        "body":  "I am using HostFxr to host C# on C++, following the [example](https://docs.microsoft.com/en-us/dotnet/core/tutorials/netcore-hosting). \r\n\r\nIt works fine when hosting a simple C# program. I build the C# project with dotnet, then copy the built dll files to the same location as my C++ host binary. The host can find and successfully call the functions in C#.\r\n\r\nHowever, the C# program requires nuget packages, in this case Microsoft Quantum simulation. Eg, on top of the C# file I open the packages, including\r\n`using Microsoft.Quantum.Simulation.Simulators;`\r\nThe C# code works fine when using dotnet to build or run on its own. \r\n\r\nHowever, when the C++ calls C# which calls functions in the nuget I the following error\r\nUnhandled exception. System.Runtime.Serialization.SerializationException: Unable to find assembly \u0027Microsoft.Quantum.Simulators, Version=0.12.0.0, Culture=neutral, PublicKeyToken=40866b40fd95c7f5\u0027.\r\n\r\nI have verified that the Microsoft.Quantum.Simulators.dll is located in the same directory as the host executable. Additionally, I checked the strace, and see that it finds and opens the dll many times.\r\n\r\nAlso according to the strace, shortly before crashing, it attempts to open a pdb file, Microsoft.Quantum.Simulators.pdb, in the same directory. There are pdb files for the C# files I wrote, but there are none for the included packages. After it fails to find this pdb file, it closes the dll file and exits. \r\n\r\nI have also set the C# to be Release rather than Debug by putting\r\n`\u003cConfiguration\u003eRelease\u003c/Configuration\u003e`\r\n   `\u003cDebugSymbols\u003efalse\u003c/DebugSymbols\u003e\u003cDebugType\u003eNone\u003c/DebugType\u003e`\r\ninside the PropertyGroup of the csproj file\r\n\r\nIs there a way to prevent it searching for .pdb files? Are there additional steps I\u0027m missing to enable hosted C# to use nuget packages?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOKWvrVg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY4OTg1ODQ2OQ==",
                                           "createdAt":  "2020-09-09T22:35:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Dotnet-GitSync-Bot",
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2020-09-09T22:35:37Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5MDMxNDE4MQ==",
                                           "createdAt":  "2020-09-10T14:08:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke\nSee info in area-owners.md if you want to be subscribed.",
                                           "updatedAt":  "2020-09-10T14:08:28Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5MDMyMzEzNg==",
                                           "createdAt":  "2020-09-10T14:22:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "There should be a `.deps.json` file next to your main dll - look into it and\r\n* Verify that the dependency `Microsoft.Quantum.Simulators.dll` is in fact listed there\r\n* Verify that the .pdb is not listed there\r\n\r\nWhich version of .NET Core are you using?\r\nHow do you build the app - \"dotnet build\", or something else?\r\nIf you look at the output directory of the build, does it contain all of the dependencies - including Microsoft.Quantum.Simulators.dll?",
                                           "updatedAt":  "2020-09-10T14:22:48Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5MDMyNDY0Ng==",
                                           "createdAt":  "2020-09-10T14:25:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "(I assume this is on Linux based on your comments) You can also try:\r\n`export COREHOST_TRACE=1` and `export COREHOST_TRACEFILE=host.txt` then run the app to repro the failure.\r\nIt should create `host.txt` in the current directory - open that, the Microsoft.Quantum.Simulators.dll should be listed as resolved dependency.",
                                           "updatedAt":  "2020-09-10T14:25:11Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5MDMyNTE3MQ==",
                                           "createdAt":  "2020-09-10T14:26:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "Actually one other possible problem - can you show the code you\u0027re using to invoke the serialization? This might be a problem with secondary/defaul load contexts.",
                                           "updatedAt":  "2020-09-10T14:26:01Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5MDM5MzQ5Nw==",
                                           "createdAt":  "2020-09-10T15:54:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "resc0059",
                                           "body":  "Thank you for the quick response! I appreciate your help.\r\n\r\nSorry, yes I am running on Linux, Redhat 7.7 and using NetCore 3.1\r\n\r\n\r\nI do have a .deps.json file, and Microsoft.Quantum.Simulators.dll is a listed dependency. \r\nThere are no pdb files listed\r\n\r\nThe host.txt you suggest (from `export COREHOST_TRACE=1` and `export COREHOST_TRACEFILE=host.txt)` does appear to show it being found\r\n    Probed deps dir and matched \u0027\u003cpath\u003e/bin/Microsoft.Quantum.Simulators.dll\u0027\r\nAdding tpa entry: \u003cpath\u003e/bin/Microsoft.Quantum.Simulators.dll, AssemblyVersion: 0.12.0.0, FileVersion: 0.12.0.0\r\n\r\nI use dotnet build to construct the C# code, then I copy the contents of /bin/Release/netcoreapp3.1/ into the same directory as my C++ host. I then compile with g++. The details are below. I am not doing any manual serialization\r\n\r\n\r\nMy .deps.json file\r\n```\r\n{\r\n  \"runtimeTarget\": {\r\n    \"name\": \".NETCoreApp,Version=v3.1\",\r\n    \"signature\": \"\"\r\n  },\r\n  \"compilationOptions\": {},\r\n  \"targets\": {\r\n    \".NETCoreApp,Version=v3.1\": {\r\n      \"\u003cC# Name\u003e/1.0.0\": {\r\n        \"dependencies\": {\r\n          \"Microsoft.Quantum.Simulators\": \"0.12.20082513\"\r\n        },\r\n        \"runtime\": {\r\n          \"\u003cC# Name\u003e.dll\": {}\r\n        }\r\n      },\r\n      \"Microsoft.Quantum.QSharp.Core/0.12.20082513\": {\r\n        \"dependencies\": {\r\n          \"Microsoft.Quantum.Runtime.Core\": \"0.12.20082513\"\r\n        },\r\n        \"runtime\": {\r\n          \"lib/netstandard2.1/Microsoft.Quantum.QSharp.Core.dll\": {\r\n            \"assemblyVersion\": \"0.12.0.0\",\r\n            \"fileVersion\": \"0.12.0.0\"\r\n          }\r\n        }\r\n      },\r\n      \"Microsoft.Quantum.Runtime.Core/0.12.20082513\": {\r\n        \"dependencies\": {\r\n          \"Newtonsoft.Json\": \"12.0.3\"\r\n        },\r\n        \"runtime\": {\r\n          \"lib/netstandard2.1/Microsoft.Quantum.Runtime.Core.dll\": {\r\n            \"assemblyVersion\": \"0.12.0.0\",\r\n            \"fileVersion\": \"0.12.0.0\"\r\n          }\r\n        }\r\n      },\r\n      \"Microsoft.Quantum.Simulators/0.12.20082513\": {\r\n        \"dependencies\": {\r\n          \"Microsoft.Quantum.QSharp.Core\": \"0.12.20082513\",\r\n          \"Microsoft.Quantum.Runtime.Core\": \"0.12.20082513\",\r\n          \"System.Reflection.Metadata\": \"1.7.0\"\r\n        },\r\n        \"runtime\": {\r\n          \"lib/netstandard2.1/Microsoft.Quantum.Simulation.Common.dll\": {\r\n            \"assemblyVersion\": \"0.12.0.0\",\r\n            \"fileVersion\": \"0.12.0.0\"\r\n          },\r\n          \"lib/netstandard2.1/Microsoft.Quantum.Simulation.QCTraceSimulatorRuntime.dll\": {\r\n            \"assemblyVersion\": \"0.12.0.0\",\r\n            \"fileVersion\": \"0.12.0.0\"\r\n          },\r\n          \"lib/netstandard2.1/Microsoft.Quantum.Simulators.dll\": {\r\n            \"assemblyVersion\": \"0.12.0.0\",\r\n            \"fileVersion\": \"0.12.0.0\"\r\n          }\r\n        },\r\n        \"runtimeTargets\": {\r\n          \"runtimes/linux-x64/native/Microsoft.Quantum.Simulator.Runtime.dll\": {\r\n            \"rid\": \"linux-x64\",\r\n            \"assetType\": \"native\",\r\n            \"fileVersion\": \"0.0.0.0\"\r\n          },\r\n          \"runtimes/osx-x64/native/Microsoft.Quantum.Simulator.Runtime.dll\": {\r\n            \"rid\": \"osx-x64\",\r\n            \"assetType\": \"native\",\r\n            \"fileVersion\": \"0.0.0.0\"\r\n          },\r\n          \"runtimes/win-x64/native/Microsoft.Quantum.Simulator.Runtime.dll\": {\r\n            \"rid\": \"win-x64\",\r\n            \"assetType\": \"native\",\r\n            \"fileVersion\": \"0.0.0.0\"\r\n          },\r\n          \"runtimes/win-x64/native/vcomp140.dll\": {\r\n            \"rid\": \"win-x64\",\r\n            \"assetType\": \"native\",\r\n            \"fileVersion\": \"0.0.0.0\"\r\n          }\r\n        }\r\n      },\r\n      \"Newtonsoft.Json/12.0.3\": {\r\n        \"runtime\": {\r\n          \"lib/netstandard2.0/Newtonsoft.Json.dll\": {\r\n            \"assemblyVersion\": \"12.0.0.0\",\r\n            \"fileVersion\": \"12.0.3.23909\"\r\n          }\r\n        }\r\n      },\r\n      \"System.Reflection.Metadata/1.7.0\": {}\r\n    }\r\n  },\r\n  \"libraries\": {\r\n    \"\u003cC# Name\u003e/1.0.0\": {\r\n      \"type\": \"project\",\r\n      \"serviceable\": false,\r\n      \"sha512\": \"\"\r\n    },\r\n    \"Microsoft.Quantum.QSharp.Core/0.12.20082513\": {\r\n      \"type\": \"package\",\r\n      \"serviceable\": true,\r\n      \"sha512\": \"sha512-nu0lxV78PAzYZU29y7X4KbG6t9d+2PoGydUi9kB6frXcVGJDuhU9aV8MJqrOyYjuCMihDwRYI96fbl/LDqroDw==\",\r\n      \"path\": \"microsoft.quantum.qsharp.core/0.12.20082513\",\r\n      \"hashPath\": \"microsoft.quantum.qsharp.core.0.12.20082513.nupkg.sha512\"\r\n    },\r\n    \"Microsoft.Quantum.Runtime.Core/0.12.20082513\": {\r\n      \"type\": \"package\",\r\n      \"serviceable\": true,\r\n      \"sha512\": \"sha512-cfLwaImBg/pWjE69hecnknaZfNYZjdzJ+L7QKGbqw7W/90nxZ7GoqFQAQEjj2JbMAjjJ0HPSwEtTzxIZPziuZQ==\",\r\n      \"path\": \"microsoft.quantum.runtime.core/0.12.20082513\",\r\n      \"hashPath\": \"microsoft.quantum.runtime.core.0.12.20082513.nupkg.sha512\"\r\n    },\r\n    \"Microsoft.Quantum.Simulators/0.12.20082513\": {\r\n      \"type\": \"package\",\r\n      \"serviceable\": true,\r\n      \"sha512\": \"sha512-EUkHkkQmrkgCKNM0yzU2/A3OtoVGWxpHgRB9qOTpSsl7Am+YLjC9CpXuV2GEeo6VqtFHocF18gagvns5u5fwaA==\",\r\n      \"path\": \"microsoft.quantum.simulators/0.12.20082513\",\r\n      \"hashPath\": \"microsoft.quantum.simulators.0.12.20082513.nupkg.sha512\"\r\n    },\r\n    \"Newtonsoft.Json/12.0.3\": {\r\n      \"type\": \"package\",\r\n      \"serviceable\": true,\r\n      \"sha512\": \"sha512-6mgjfnRB4jKMlzHSl+VD+oUc1IebOZabkbyWj2RiTgWwYPPuaK1H97G1sHqGwPlS5npiF5Q0OrxN1wni2n5QWg==\",\r\n      \"path\": \"newtonsoft.json/12.0.3\",\r\n      \"hashPath\": \"newtonsoft.json.12.0.3.nupkg.sha512\"\r\n    },\r\n    \"System.Reflection.Metadata/1.7.0\": {\r\n      \"type\": \"package\",\r\n      \"serviceable\": true,\r\n      \"sha512\": \"sha512-PodRDaRRNI3BcF3zuEsrzn1jm/zws5UevTzIv5FqcOwWB3VPaU4jS6vt0tSxu+i38Wtn9vXFNgDHw09nDv8y5Q==\",\r\n      \"path\": \"system.reflection.metadata/1.7.0\",\r\n      \"hashPath\": \"system.reflection.metadata.1.7.0.nupkg.sha512\"\r\n    }\r\n  }\r\n}\r\n```\r\nThe conents of my local directory are\r\nMicrosoft.Quantum.QSharp.Core.dll\r\nMicrosoft.Quantum.Runtime.Core.dll\r\nMicrosoft.Quantum.Simulation.Common.dll\r\nMicrosoft.Quantum.Simulation.QCTraceSimulatorRuntime.dll\r\nMicrosoft.Quantum.Simulators.dll\r\nNewtonsoft.Json.dll\r\n\u003cC++ binary name\u003e\r\nlibnethost.so\r\n\u003cC# name\u003e\r\n\u003cC# name\u003e.deps.json\r\n\u003cC# name\u003e.dll\r\n\u003cC# name\u003e.runtimeconfig.dev.json\r\n\u003cC# name\u003e.runtimeconfig.json\r\nruntimes/\r\n\r\n\r\nMy g++ compilation commands\r\n```\r\nexport COREHOST_TRACE=1\r\nexport COREHOST_TRACEFILE=host.txt\r\n\r\necho Compiling\r\n#Clear up bin directory\r\nrm ./bin/*\r\n\r\n#Copy over C# files\r\ncp -r ../\u003cC# project\u003e/bin/Release/netcoreapp3.1/* ./bin/\r\n\r\n#Set libhost directory\r\n#apphost, libnethost.so, and nethost.h reside here\r\nNetHostDir=\"\u003cdotnet directory\u003e/packs/Microsoft.NETCore.App.Host.linux-x64/3.1.7/runtimes/linux-x64/native\"\r\n\r\n#Copy over libnethost.so\r\ncp \"$NetHostDir\"/libnethost.so ./bin/\r\n\r\n#Where executable goes\r\nNativeBinDir=\"./bin\"\r\n\r\n#Action! (Compile)\r\ng++ \u003cC++ host name\u003e.cpp -I\"$NetHostDir\" -Iinc -D LINUX -std=c++11 -o \"$NativeBinDir/\u003cC++ host name\u003e\" -ldl -lnethost -L\"$NetHostDir\" -g -Wl,-rpath,\u0027$ORIGIN\u0027,--disable-new-dtags\r\n\r\n#Run!\r\n./bin/\u003cC++ host name\u003e\r\n```\r\n\r\nThe C++ is able to successfully call \"myFunction\" and pure C# works, but on the first line which uses Microsoft.Quantum it fails\r\n```\r\nusing System;\r\nusing System.Threading.Tasks;\r\nusing System.Reflection;\r\nusing System.Runtime.InteropServices;\r\nusing Microsoft.Quantum.Runtime;\r\nusing Microsoft.Quantum.Simulation.Core;\r\nusing Microsoft.Quantum.Simulation.Simulators;\r\nusing Microsoft.Quantum.Simulation.Simulators.QCTraceSimulators;\r\nusing Microsoft.Quantum.Intrinsic;\r\nnamespace \u003cC# name\u003e\r\n{\r\n    class Program\r\n    {\r\n        [StructLayout(LayoutKind.Sequential)]\r\n        public struct LibArgs\r\n        {\r\n            public IntPtr Message;\r\n            public int Number;\r\n        }\r\n\r\n        //Successfully called by C++\r\n        public static int myFunction(IntPtr arg, int argLength){\r\n\t\t\t\r\n            if (argLength \u003c System.Runtime.InteropServices.Marshal.SizeOf(typeof(LibArgs)))\r\n            {\r\n                return 1;\r\n            }\r\n\r\n            LibArgs libArgs = Marshal.PtrToStructure\u003cLibArgs\u003e(arg);\r\n            Console.WriteLine($\"Hello, world! from {nameof(Program)} \");\r\n\r\n            //This works fine\r\n\t    string pathT = @\"\u003cpath to another C# project\u003e/bin/Debug/netstandard2.0/classical.dll\";\r\n            Assembly DA = Assembly.LoadFrom(pathT);\r\n            Type CT = DA.GetType(\"classical.Class1\");\r\n            MethodInfo SM = CT.GetMethod(\"staticLibraryFunction\");\r\n            int R = Convert.ToInt32(SM.Invoke(null, new object[] { 3,5 }));\r\n            Console.WriteLine(R);\r\n            //Last line that works\r\n\r\n            //This line crashes, is first to use anything from the Microsoft.Quantum library\r\n            QCTraceSimulator tsim = new QCTraceSimulator();\r\n \t    \u003cremaining code \u003e\r\n```\r\n\r\n\r\nI went back to HostFxr sample, and just by adding a package reference to the DotNetLib, such as with \r\n```\r\ndotnet add package Microsoft.Quantum.Simulators --version 0.12.20082513\r\n```\r\ncauses the sample to fail. This made me suspect that a different setup was required to include packages\r\n",
                                           "updatedAt":  "2020-09-10T15:54:36Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5MDY5Nzc1Nw==",
                                           "createdAt":  "2020-09-10T20:15:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "resc0059",
                                           "body":  "Apologies, forgot to include full stack error which seems relevant\r\n```\r\nUnhandled exception. System.Runtime.Serialization.SerializationException: Unable to find assembly \u0027Microsoft.Quantum.Simulators, Version=0.12.0.0, Culture=neutral, PublicKeyToken=40866b40fd95c7f5\u0027.\r\n   at System.Runtime.Serialization.Formatters.Binary.BinaryAssemblyInfo.GetAssembly()\r\n   at System.Runtime.Serialization.Formatters.Binary.ObjectReader.GetType(BinaryAssemblyInfo assemblyInfo, String name)\r\n   at System.Runtime.Serialization.Formatters.Binary.ObjectMap..ctor(String objectName, String[] memberNames, BinaryTypeEnum[] binaryTypeEnumA, Object[] typeInformationA, Int32[] memberAssemIds, ObjectReader objectReader, Int32 objectId, BinaryAssemblyInfo assemblyInfo, SizedArray assemIdToAssemblyTable)\r\n   at System.Runtime.Serialization.Formatters.Binary.BinaryParser.ReadObjectWithMapTyped(BinaryObjectWithMapTyped record)\r\n   at System.Runtime.Serialization.Formatters.Binary.BinaryParser.ReadObjectWithMapTyped(BinaryHeaderEnum binaryHeaderEnum)\r\n   at System.Runtime.Serialization.Formatters.Binary.BinaryParser.Run()\r\n   at System.Runtime.Serialization.Formatters.Binary.ObjectReader.Deserialize(BinaryParser serParser, Boolean fCheck)\r\n   at System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Deserialize(Stream serializationStream, Boolean check)\r\n   at System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Deserialize(Stream serializationStream)\r\n   at Microsoft.Quantum.Simulation.QCTraceSimulatorRuntime.Utils.DeepClone[T](T original)\r\n   at Microsoft.Quantum.Simulation.Simulators.QCTraceSimulators.Implementation.QCTraceSimulatorImpl..ctor(QCTraceSimulatorConfiguration config)\r\n   at Microsoft.Quantum.Simulation.Simulators.QCTraceSimulators.QCTraceSimulator..ctor(QCTraceSimulatorConfiguration config)\r\n   at Microsoft.Quantum.Simulation.Simulators.QCTraceSimulators.QCTraceSimulator..ctor()\r\n   at \u003cC# name\u003e.Program.myFunction(IntPtr arg, Int32 argLength)\r\nAbort (core dumped)\r\n```",
                                           "updatedAt":  "2020-09-10T20:15:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5MDc0NTI0Mw==",
                                           "createdAt":  "2020-09-10T21:36:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEU5RXg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "ladenedge",
                                                                               "createdAt":  "2020-09-18T13:20:39Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "SerhiiVodotyka",
                                                                               "createdAt":  "2025-06-02T13:41:25Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "Thanks - the callstack helps.\r\nThe problem is here: https://github.com/dotnet/runtime/blob/e0df256a4458364937e524aeee3f525c71330e0c/src/libraries/System.Runtime.Serialization.Formatters/src/System/Runtime/Serialization/FormatterServices.cs#L308\r\n\r\n`Assembly.Load` will try to load the specified assembly into the callers load context - the caller is `System.Runtime.Serialization.Formatters.dll` in this case, which (being a framework dll) is loaded into the default load context. In the native hosting scenarios the default load context is setup to only resolve frameworks. The application code (which knows about Microsoft.Quantum.Simulation.dll) is loaded into a secondary load context. So the `Assembly.Load` will only ask the default load context, which doesn\u0027t know anything about that assembly and thus it fails.\r\n\r\nTechnically this is a bug in the binary serializer - but since that code is being obsoleted now, it\u0027s unlikely it will get fixed. Side note: Using binary serializer is not a good idea anyway - in this case you\u0027re not in control of that unfortunately, hopefully newer version of the Microsoft.Quantum.Simulation package will replace it with some other serializer.\r\n\r\nIt should be possible to workaround this by using contextual reflection context: https://docs.microsoft.com/en-us/dotnet/api/system.runtime.loader.assemblyloadcontext.currentcontextualreflectioncontext?view=netcore-3.1. You should be able to wrap your code in:\r\n```C#\r\nusing (AssemblyLoadContext.EnterContextualReflection(typeof(Program).Assembly))\r\n{\r\n   // the body of your method called from C++\r\n}\r\n```\r\n\r\nThis basically tells the system to not rely on \"load context of the caller\", but instead use the one specified in the above API.",
                                           "updatedAt":  "2020-09-10T21:36:32Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5MDc0NjU4OQ==",
                                           "createdAt":  "2020-09-10T21:39:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "Looking at the code you shared - there is another potential similar problem. You\u0027re using `Assembly.LoadFrom` which will:\r\n* Always load the specified assembly into the default load context\r\n* Hooks up resolution logic such that assemblies referenced by the loaded assembly will be looked up in the same directory as the loaded assembly\r\n\r\nSo it likely works, but if that assembly loaded via `Assembly.LoadFrom` has any dependencies on code in your app (not just pure frameworks) it will likely also not work in this scenario.\r\n\r\nIn general for assembly loading, it\u0027s a good idea to be very specific in .NET Core and try to avoid using `Assembly.Load*` methods and instead use methods on `AssemblyLoadContext` to load the assemblies. All of the `Assembly.Load*` methods internally call the `AssemblyLoadContext` APIs anyway, they just add a rather specific (and often confusing) behavior on top.",
                                           "updatedAt":  "2020-09-10T21:39:55Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5MjE1MjE0NA==",
                                           "createdAt":  "2020-09-14T15:58:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "resc0059",
                                           "body":  "Thank you so much! That worked, really appreciate your help!\r\n\r\nWe are able to call functions in the nuget package now. We\u0027ll also make the changes you suggested.\r\n\r\n\r\nI have a follow up question regarding loading context from dlls. We are running into another error which appears to be what you are referring to. \r\n\r\nOn functions inside our library file, quantum.dll, we are able to use \"GetMethod\" on the \"Run\" function. This works if done inside the Main function when running with dotnet, but fails when done inside a function hosted by nethostfxr\r\n\r\nThe error it produces is \r\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\r\n\r\nThe library functions also have a dependency on the nuget package, so it seems likely the context is off. Is this something AssemblyLoadContext can fix?\r\n\r\n\r\n```\r\n﻿using System;\r\nusing System.Threading.Tasks;\r\nusing System.Reflection;\r\nusing System.Runtime.InteropServices;\r\nusing System.Runtime.Loader;\r\nusing Microsoft.Quantum.Runtime;\r\nusing Microsoft.Quantum.Simulation.Core;\r\nusing Microsoft.Quantum.Simulation.Simulators;\r\nusing Microsoft.Quantum.Simulation.Simulators.QCTraceSimulators;\r\nusing Microsoft.Quantum.Intrinsic;\r\n\r\nnamespace quantumdevice\r\n{\r\n    class Program\r\n    {\r\n        [StructLayout(LayoutKind.Sequential)]\r\n        public struct LibArgs\r\n        {\r\n            public IntPtr Message;\r\n            public int Number;\r\n        }\r\n\r\n\tpublic static int myFunction(IntPtr arg, int argLength){\r\n\t\tusing (AssemblyLoadContext.EnterContextualReflection(typeof(Program).Assembly))\r\n\t\t{\t\t\r\n\t\t        if (argLength \u003c System.Runtime.InteropServices.Marshal.SizeOf(typeof(LibArgs)))\r\n\t       \t\t{\r\n               \t\t\treturn 1;\r\n\t            \t}\r\n\r\n\t         \tLibArgs libArgs = Marshal.PtrToStructure\u003cLibArgs\u003e(arg);\r\n        \t        Console.WriteLine($\"Hello, world! from {nameof(Program)} \");\r\n\r\n\t\t        var qsim = new QuantumSimulator();\r\n\r\n\t\t\tstring PT = @\"\u003cpath to library\u003e/bin/Debug/netstandard2.1/quantum.dll\";\r\n\t\t        Assembly DA = Assembly.LoadFrom(PT);\r\n\r\n\t\t   \tType CT = DA.GetType(\"quantum.HGates\");\r\n\t\t        MethodInfo SM = CT.GetMethod(\"Run\");\t\t\t//Throws exception\r\n\t\t        var R2 = SM.Invoke(null, new object[] { qsim  });\r\n\t\t}\r\n            return 0;\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n \r\n            var qsim = new QuantumSimulator();\r\n\r\n\r\n            string PT = @\"\u003cpath to library\u003e/bin/Debug/netstandard2.1/quantum.dll\";\r\n            Assembly DA = Assembly.LoadFrom(PT);\r\n\r\n\t\t//Works fine\r\n\t    Type CT = DA.GetType(\"quantum.HGates\");\r\n            MethodInfo SM = CT.GetMethod(\"Run\");\r\n            var R2 = SM.Invoke(null, new object[] { qsim  });\r\n        }\r\n    }\r\n} \r\n```",
                                           "updatedAt":  "2020-09-14T15:58:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5MjI3NTUzNw==",
                                           "createdAt":  "2020-09-14T19:49:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "\u003eType CT = DA.GetType(\"quantum.HGates\");\r\n\u003eMethodInfo SM = CT.GetMethod(\"Run\");\t\t\t//Throws exception\r\n\r\nSince there\u0027s no callstack it\u0027s hard to validate for sure, but if the line above throws NullRef it would mean that CT is null. That in turn would mean the the DA assembly does not define the type \"quantum.HGates\". I don\u0027t know the details to be able to tell if that is right or wrong.\r\n\r\nIn any case, using Assembly.LoadFrom will not work correctly. LoadFrom always loads into the default load context (regardless of any contextual reflection settings). The correct way to load file into a specific load context is to use AssemblyLoadContext.LoadFromAssemblyPath. So in your case something like:\r\n\r\n```C#\r\nAssemblyLoadContext.GetLoadContext(typeof(Program).Assembly).LoadFromAssemblyPath(PT);\r\n```",
                                           "updatedAt":  "2020-09-14T19:49:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5MjI5OTg5NA==",
                                           "createdAt":  "2020-09-14T20:36:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "resc0059",
                                           "body":  "That did the trick, thanks again!",
                                           "updatedAt":  "2020-09-14T20:36:54Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5NDg3NjYyOQ==",
                                           "createdAt":  "2020-09-18T13:44:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ladenedge",
                                           "body":  "Wanted to add a comment that I have been having similar issues with the generic hosting model in a C# app initialized with `hostfxr_initialize_for_runtime_config`.\r\n\r\nInitially, it was unable to find the _current, executing assembly_. Very bizarre!  I thought this was because hostfxr_* wasn\u0027t properly setting `APP_PATHS` and `APP_CONTEXT_BASE_DIRECTORY` properties because setting those properties with `hostfxr_set_runtime_property_value` made the error go away. But then I encountered more strangeness when the ASP.NET code seemed unable to find types that it clearly knew about:\r\n\r\n```\r\nSystem.InvalidCastException: [A]My.Type.HomeController cannot be cast to [B]My.Type.HomeController.\r\n   Type A originates from \u0027My.Assembly, ...\u0027 in the context \u0027Default\u0027 at location \u0027C:\\Source\\My.Assembly.dll\u0027.\r\n   Type B originates from \u0027My.Assembly, ...\u0027 in the context \u0027Default\u0027 at location \u0027C:\\Source\\My.Assembly.dll\u0027.\r\n```\r\n\r\nAdding the `using (AssemblyLoadContext.EnterContextualReflection(typeof(Program).Assembly))` block seems to have fixed that problem, thank goodness.\r\n\r\n```cs\r\nusing (AssemblyLoadContext.EnterContextualReflection(typeof(Program).Assembly))\r\n{\r\n    Host.CreateDefaultBuilder()\r\n        .ConfigureWebHostDefaults(kestrel =\u003e\r\n        {\r\n            kestrel.UseStartup\u003cStartup\u003e();\r\n        }).Start();\r\n}\r\n```\r\n\r\n(I thought perhaps it was the hosting\u0027s [startup assembly loading](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/platform-specific-configuration?view=aspnetcore-3.1#disable-automatic-loading-of-hosting-startup-assemblies), but disabling it didn\u0027t help -- only the `using` block did.)\r\n\r\nAnyway, the upshot is: thank you for the `using` tip! (Is there a good place to read about differences like this between hostfxr_* apps and normally-hosted apps?)\r\n\r\nPS. It seems that hostfxr_*-hosted apps [may not work with **dotnet-counters**](https://github.com/dotnet/diagnostics/issues/1543) -- is there any chance this assembly loading issue is at fault again?",
                                           "updatedAt":  "2020-09-18T13:44:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5NDg4MTI0Mg==",
                                           "createdAt":  "2020-09-18T13:52:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBQ214g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "ladenedge",
                                                                               "createdAt":  "2020-09-18T14:41:56Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "The problem is that lot of code (including frameworks like ASP.NET) is simply not behaving correctly when loaded into a secondary load context (because it uses APIs like `Assembly.Load` or similar). It will take time to fix all these places. I would suggest to log an issue on the ASP.NET failure you\u0027re seeing.\r\n\r\nIn .NET 5 we\u0027ve added a new hosting API for cases where the intent is to not load multiple \"plugins\" into the process, but rather have basically just one managed piece. See https://github.com/dotnet/runtime/blob/master/docs/design/features/native-hosting.md#calling-managed-function-net-5-and-above. The idea here is that you can compile your managed code as a normal app and call `hostfxr_initialize_for_dotnet_command_line` and then use the new `get_function_pointer`. This will load all your code into the default load context (just like running the managed app directly) and all of the problems with secondary load contexts should go away.",
                                           "updatedAt":  "2020-09-18T13:52:33Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5NDkwOTA0Mg==",
                                           "createdAt":  "2020-09-18T14:40:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ladenedge",
                                           "body":  "That sounds very good, because I spoke too soon:\r\n\r\n```\r\nSystem.InvalidOperationException: The model item passed into the ViewDataDictionary is of type \u0027ServerStatus\u0027,\r\n                            but this ViewDataDictionary instance requires a model item of type \u0027ServerStatus\u0027.\r\n```\r\n\r\nI guess it\u0027s a little more complicated than just wrapping Host.Build() in that using block. 😢 \r\n\r\nIt looks like .NET 5 Preview 8 has the new stuff, so I will give `hostfxr_initialize_for_dotnet_command_line` and `get_function_pointer` a try. 🤞 Thank you very much again!",
                                           "updatedAt":  "2020-09-18T14:40:56Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5NDkzNDQ0MA==",
                                           "createdAt":  "2020-09-18T15:28:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ladenedge",
                                           "body":  "It worked, yay!, and switching to the new model was thankfully very easy.\r\n\r\nSorry for all the hijacking here, but thanks _so much_ for the help!",
                                           "updatedAt":  "2020-09-18T15:28:15Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5NDkzODQ1NA==",
                                           "createdAt":  "2020-09-18T15:36:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "Glad it helped. Thanks for reporting your issues - it should help us get the right priority on some things 😉 ",
                                           "updatedAt":  "2020-09-18T15:36:07Z"
                                       }
                                   ],
                         "totalCount":  17
                     },
        "title":  "Hosting C# and using Nuget Packages with HostFxr",
        "labels":  [
                       "question",
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/45030",
        "createdAt":  "2020-11-20T21:50:50Z",
        "number":  45030,
        "author":  "CoffeeFlux",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-07-28T17:48:57Z",
        "body":  "This is most easily illustrated with a sample:\r\n```c#\r\nusing System;\r\nusing System.Reflection;\r\n\r\nnamespace HelloWorld\r\n{\r\n    internal class Program\r\n    {\r\n        private static void Main(string[] args)\r\n        {\r\n            string test_type = \"Some.Assembly.FakeType\";\r\n            string test_assembly = \"Some.Assembly, Version=4.0.0.0\";\r\n\r\n            string event_name = \"\";\r\n            ResolveEventHandler handler = (sender, args) =\u003e\r\n            {\r\n                event_name = args.Name;\r\n                return null;\r\n            };\r\n\r\n            AppDomain.CurrentDomain.AssemblyResolve += handler;\r\n\r\n            var t = Type.GetType(test_type + \", \" + test_assembly);\r\n            var asm_name = new AssemblyName(test_assembly);\r\n\r\n            Console.WriteLine(event_name);\r\n            Console.WriteLine(asm_name);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nOutput under CoreCLR:\r\n```\r\nSome.Assembly, Version=4.0.0.0, Culture=neutral, PublicKeyToken=null\r\nSome.Assembly, Version=4.0.0.0\r\n```\r\n\r\nWhile this has been the behavior in .NET Core for a while, I really think this is just a bug we should fix to make behavior consistent throughout the framework, especially given this appears to be a stringification difference rather than a parsing difference.\r\n\r\nIf we want to leave the stringification for events as-is we really need to get test coverage there, because it _is_ substantially different from both framework and `AssemblyName.FullName`. We have significant documentation around the `AssemblyName` behavior, and again a bunch of it no longer applies here and we should note that somewhere.\r\n\r\nAs far as I can tell, the reason `ResolveEventHandler` and associated events were reintroduced in identical form to framework was to ease migrations and more modern APIs like the `AssemblyLoadContext.Resolving` event just pass the `AssemblyName` directly. It\u0027s unfortunate that for `AppDomain.AssemblyResolve` we can\u0027t just pass the `AssemblyName` instead and avoid the stringification concern altogether. However, having this API reintroduced but having the stringification differ from both framework and `AssemblyName.FullName` seems like it helps no one.\r\n\r\nRegardless of how we choose to deal with this, we need test coverage in this area. https://github.com/dotnet/runtime/pull/43913 is a start, but needs work to be fully fleshed out and adjusted to what we decide on for the behavior going forward.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOK5irLw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczMTQyNTU4Mw==",
                                           "createdAt":  "2020-11-20T21:50:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @coffeeflux\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThis is most easily illustrated with a sample:\r\n```c#\r\nusing System;\r\nusing System.Reflection;\r\n\r\nnamespace HelloWorld\r\n{\r\n    internal class Program\r\n    {\r\n        private static void Main(string[] args)\r\n        {\r\n            string test_type = \"Some.Assembly.FakeType\";\r\n            string test_assembly = \"Some.Assembly, Version=4.0.0.0\";\r\n\r\n            string event_name = \"\";\r\n            ResolveEventHandler handler = (sender, args) =\u003e\r\n            {\r\n                event_name = args.Name;\r\n                return null;\r\n            };\r\n\r\n            AppDomain.CurrentDomain.AssemblyResolve += handler;\r\n\r\n            var t = Type.GetType(test_type + \", \" + test_assembly);\r\n            var asm_name = new AssemblyName(test_assembly);\r\n\r\n            Console.WriteLine(event_name);\r\n            Console.WriteLine(asm_name);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nOutput under CoreCLR:\r\n```\r\nSome.Assembly, Version=4.0.0.0, Culture=neutral, PublicKeyToken=null\r\nSome.Assembly, Version=4.0.0.0\r\n```\r\n\r\nWhile this has been the behavior in .NET Core for a while, I really think this is just a bug we should fix to make behavior consistent throughout the framework, especially given this appears to be a stringification difference rather than a parsing difference.\r\n\r\nIf we want to leave the stringification for events as-is we really need to get test coverage there, because it _is_ substantially different from both framework and `AssemblyName.FullName`. We have significant documentation around the `AssemblyName` behavior, and again a bunch of it no longer applies here and we should note that somewhere.\r\n\r\nAs far as I can tell, the reason `ResolveEventHandler` and associated events were reintroduced in identical form to framework was to ease migrations and more modern APIs like the `AssemblyLoadContext.Resolving` event just pass the `AssemblyName` directly. It\u0027s unfortunate that for `AppDomain.AssemblyResolve` we can\u0027t just pass the `AssemblyName` instead and avoid the stringification concern altogether. However, having this API reintroduced but having the stringification differ from both framework and `AssemblyName.FullName` seems like it helps no one.\r\n\r\nSee also: https://github.com/dotnet/runtime/pull/43913\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eCoffeeFlux\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e6.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2020-11-20T21:50:53Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "AssemblyName stringification inside ResolveEventHandler is different from AssemblyName.ToString()",
        "labels":  [
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/45031",
        "createdAt":  "2020-11-20T21:52:59Z",
        "number":  45031,
        "author":  "CoffeeFlux",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOBXjyXQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jkotas",
                                            "createdAt":  "2020-11-20T23:59:33Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2021-07-08T18:33:51Z",
        "body":  "I think we should be using a managed formatter here instead of having the runtime do the stringification. If we match the behavior of `AssemblyName.FullName`, we could just have the runtime pass up the `AssemblyName` and then use the existing shared formatter (`AssemblyNameFormatter`), but otherwise we would have to write a second one to match the different behavior. From the Mono side, I would definitely love to get rid of calls to `mono_stringify_assembly_name` outside of error paths.\r\n\r\nSee also: https://github.com/dotnet/runtime/issues/45030 https://github.com/dotnet/runtime/pull/43913",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOK5iucg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczMTQyNjQxOA==",
                                           "createdAt":  "2020-11-20T21:53:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @coffeeflux\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nI think we should be using a managed formatter here instead of having the runtime do the stringification. If we match the behavior of `AssemblyName.FullName`, we could just have the runtime pass up the `AssemblyName` and then use the existing shared formatter (`AssemblyNameFormatter`), but otherwise we would have to write a second one to match the different behavior. From the Mono side, I would definitely love to get rid of calls to `mono_stringify_assembly_name` outside of error paths.\r\n\r\nSee also: https://github.com/dotnet/runtime/issues/45030 https://github.com/dotnet/runtime/pull/43913\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eCoffeeFlux\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003eFuture\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2020-11-20T21:53:03Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "AssemblyName stringification for ResolveEventHandler should happen in managed",
        "labels":  [
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/45264",
        "createdAt":  "2020-11-26T15:56:10Z",
        "number":  45264,
        "author":  "vitek-karas",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC7mB2Q==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MarioGruda",
                                            "createdAt":  "2022-05-17T15:14:58Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aloksharma1",
                                            "createdAt":  "2024-10-06T05:24:47Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2024-10-06T07:30:44Z",
        "body":  "The unloading support in .NET Core is reliant on GC and very \"asynchronous\". The app typically only asks for unload by calling `ALC.Unload` but then has to wait across multiple GC runs until the unload actually happens. There\u0027s also not a simple way to get notified that unload actually happened. (One can poll using a weak ref though).\r\n\r\nTo make this process easier to diagnose it would be helpful to have tracing events which can be used to detect the start and end of an unload operation. Maybe we can add some more detail if there are intermediate steps in the process which would make sense as well.\r\n\r\nSee https://github.com/dotnet/runtime/issues/44679 for an example of a discussion on this topic.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOjsXYMA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczNDM3NDg2OQ==",
                                           "createdAt":  "2020-11-26T15:56:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @coffeeflux\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThe unloading support in .NET Core is reliant on GC and very \"asynchronous\". The app typically only asks for unload by calling `ALC.Unload` but then has to wait across multiple GC runs until the unload actually happens. There\u0027s also not a simple way to get notified that unload actually happened. (One can poll using a weak ref though).\r\n\r\nTo make this process easier to diagnose it would be helpful to have tracing events which can be used to detect the start and end of an unload operation. Maybe we can add some more detail if there are intermediate steps in the process which would make sense as well.\r\n\r\nSee https://github.com/dotnet/runtime/issues/44679 for an example of a discussion on this topic.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003evitek-karas\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2020-11-26T15:56:12Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczNDM3NTEzMg==",
                                           "createdAt":  "2020-11-26T15:56:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "/cc @CoffeeFlux  - for mono side of things",
                                           "updatedAt":  "2020-11-26T15:56:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Oxdgw",
                                           "createdAt":  "2024-10-06T07:30:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "aloksharma1",
                                           "body":  "are there any updates on this issue, in one of my projects we are relying on assembly unload to reload fresh assemblies dynamically built by roslyn on runtime. and sometimes it randomly stops refreshing, so in order to find the cause i did some digging and came here btw i\u0027m using dotnet 8.",
                                           "updatedAt":  "2024-10-06T07:30:44Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Add tracing around assembly unload",
        "labels":  [
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/49040",
        "createdAt":  "2021-03-03T01:19:34Z",
        "number":  49040,
        "author":  "AaronRobinsonMSFT",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOBh_6Qg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AArnott",
                                            "createdAt":  "2021-03-03T03:36:56Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2021-05-10T19:52:09Z",
        "body":  "Narrowing the impact of the Linker to a single Assembly to trim would be convenient for scenarios involving large monolithic SDK style assemblies. The scenario would permit consuming one of the assemblies from https://github.com/dotnet/pinvoke and indicating that only the P/Invoke assembly should be trimmed. The Linker would run over the entire application but the trimming operation would be limited to the P/Invoke assembly.\r\n\r\nThis shouldn\u0027t be constrained to a single assembly but rather to a collection that can be impact and all other assemblies just used to determine usage.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOMecrkg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4OTM1MDYyMg==",
                                           "createdAt":  "2021-03-03T01:19:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @coffeeflux\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nNarrowing the impact of the Linker to a single Assembly to trim would be convenient for scenarios involving large monolithic SDK style assemblies. The scenario would permit consuming one of the assemblies from https://github.com/dotnet/pinvoke and indicating that only the P/Invoke assembly should be trimmed. The Linker would run over the entire application but the trimming operation would be limited to the P/Invoke assembly.\r\n\r\nThis shouldn\u0027t be constrained to a single assembly but rather to a collection that can be impact and all other assemblies just used to determine usage.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eAaronRobinsonMSFT\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-03-03T01:19:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4OTM1MDYzNA==",
                                           "createdAt":  "2021-03-03T01:19:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "/cc @agocke @sbomer @vitek-karas @AArnott @tannergooding ",
                                           "updatedAt":  "2021-03-03T01:19:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4OTM2MzA2Mg==",
                                           "createdAt":  "2021-03-03T01:51:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sbomer",
                                           "body":  "There\u0027s an option that tells the linker to trim a particular assembly:\r\n- `--action link PInvokeAssembly` will let it link (remove unused members from) that assembly\r\n\r\nWhatever MSBuild logic adds that assembly to the output could set some [metadata](https://docs.microsoft.com/en-us/dotnet/core/deploying/trimming-options#trimming-granularity) on it to pass the above option to the linker.\r\n\r\nThe current linker defaults will analyze starting from the entry point and any referenced assemblies without [IsTrimmable](https://github.com/mono/linker/blob/main/docs/design/trimmed-assemblies.md#assemblymetadataistrimmable-true) assembly metadata - usually the app and nuget dependencies, since we add this attribute to framework assemblies. If your scenario is compatible with the usual caveats of `PublishTrimmed` I think this is what we want.\r\n\r\n\u003e The Linker would run over the entire application but the trimming operation would be limited to the P/Invoke assembly.\r\n\r\nIf you were specifically looking to avoid trimming any other assemblies (to avoid problems with unanalyzable reflection for example), we could pass\r\n\r\n- `--trim-mode copy`: this will tell it to also consider `IsTrimmable` assemblies as \"roots\" for the analysis\r\n\r\nHowever this is a lot of analysis to do (scanning the entire self-contained app\u0027s IL) if we are only going to optimize that one assembly. In that case it might make more sense to develop a solution particularly for your scenario (maybe there are more efficient ways to only look for references to the generated PInvokes).\r\n\r\nThere\u0027s another important caveat, which is that even with `--trim-mode copy`, the linker may modify the analyzed assemblies by dropping R2R, removing type forwarders, or rewriting type references (though it shouldn\u0027t remove any members). The tracking issue for this is https://github.com/mono/linker/issues/1669, which @mateoatr is looking into.\r\n",
                                           "updatedAt":  "2021-03-03T01:51:13Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4OTY5MjkwOQ==",
                                           "createdAt":  "2021-03-03T12:52:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "Trimming doesn\u0027t happen unless the user specifies `PublishTrimmed` and at that point we\u0027re trimming the entire app (some assemblies more, some less). Is the request that we would run trimming even if the user didn\u0027t specify `PublishTrimmed` in this case?",
                                           "updatedAt":  "2021-03-03T12:52:10Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4OTgxMzUwNA==",
                                           "createdAt":  "2021-03-03T15:49:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AArnott",
                                           "body":  "Trimming can cause runtime malfunction do to removal of private members that are accessed via reflection. Yet some assemblies are relatively safe from such regressions and would greatly benefit from trimming, such as the Win32 p/invoke assemblies mentioned above. So yes, I think the ask is to trim specific assemblies all the time.\r\n\r\nThat said, given trimming requires scanning all assemblies deployed with an app so only APIs unused across the whole app can be removed from the assembly, perhaps that would take an unacceptable toll on build perf, I don\u0027t know.\r\n\r\nCan we limit trimming when the user *does* ask for it to just those assemblies that the app knows are \"safe\" to trim?",
                                           "updatedAt":  "2021-03-03T15:49:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4OTk3NDExMw==",
                                           "createdAt":  "2021-03-03T18:53:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sbomer",
                                           "body":  "\u003e Can we limit trimming when the user _does_ ask for it to just those assemblies that the app knows are \"safe\" to trim?\r\n\r\nWe do limit trimming to assemblies marked `IsTrimmable` or with an `--action` argument, but it doesn\u0027t exactly mean they are \"safe\" to trim, since this depends on the context (for example nothing prevents user code from reflecting over a pinvoke assembly). Instead we try to provide correctness guarantees via [analysis warnings](https://docs.microsoft.com/en-us/dotnet/core/deploying/trimming-options#analysis-warnings).\r\n\r\n\u003e So yes, I think the ask is to trim specific assemblies all the time.\r\n\r\nI think for this we would want to add support for `PublishTrimmed` of framework-dependent apps (or some equivalent option for build), which will also help with the performance. Assuming the framework is correctly annotated this should provide the same correctness guarantees (analysis warnings) - just note that the above caveats still apply for the analyzed assemblies, and you\u0027d also get warnings about unanalyzable reflection that\u0027s unrelated to the pinvoke assemblies.",
                                           "updatedAt":  "2021-03-03T18:53:22Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc5MDA2NTczMA==",
                                           "createdAt":  "2021-03-03T21:25:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBiRp6A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AArnott",
                                                                               "createdAt":  "2021-03-04T17:40:14Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "marek-safar",
                                           "body":  "I think you are asking for exactly what Sven shared earlier. You can mark your assembly as https://github.com/mono/linker/blob/main/docs/design/trimmed-assemblies.md#assemblymetadataistrimmable-true trimmable and that will trim it all the time automatically.",
                                           "updatedAt":  "2021-03-03T21:25:52Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgzNzIzMzU1NA==",
                                           "createdAt":  "2021-05-10T19:52:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to \u0027linkable-framework\u0027: @eerhardt, @vitek-karas, @LakshanF, @sbomer\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nNarrowing the impact of the Linker to a single Assembly to trim would be convenient for scenarios involving large monolithic SDK style assemblies. The scenario would permit consuming one of the assemblies from https://github.com/dotnet/pinvoke and indicating that only the P/Invoke assembly should be trimmed. The Linker would run over the entire application but the trimming operation would be limited to the P/Invoke assembly.\r\n\r\nThis shouldn\u0027t be constrained to a single assembly but rather to a collection that can be impact and all other assemblies just used to determine usage.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eAaronRobinsonMSFT\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`, `linkable-framework`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003eFuture\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-05-10T19:52:08Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "Enable targeted Assembly trimming",
        "labels":  [
                       "area-AssemblyLoader-coreclr",
                       "linkable-framework"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/50920",
        "createdAt":  "2021-04-08T15:40:39Z",
        "number":  50920,
        "author":  "dotfede",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-01-07T13:22:29Z",
        "body":  "Sorry, I\u0027ll start off by saying I feel bad for reporting an issue without a proper repro, but so far I\u0027ve been unable to properly and consistently reproduce this issue outside of production environments and it\u0027s causing us a lot of trouble.\r\n\r\nI\u0027m using `AssemblyLoadContext` to load and execute plugins inside Azure Functions. The DLL and PDB files for the plugins are hosted on Azure Blob, so I\u0027m not using Filesystem-based assembly load or resolution.\r\n\r\nThis is the relevant code:\r\n\r\n```csharp\r\n    internal class InMemoryPluginLoadContext : AssemblyLoadContext\r\n    {\r\n        private static readonly object Lock = new object();\r\n        private readonly Dictionary\u003cstring, PluginAssembly\u003e _pluginAssemblies;\r\n        private readonly Dictionary\u003cstring, Assembly\u003e _loadedAssemblies = new Dictionary\u003cstring, Assembly\u003e();\r\n\r\n        public InMemoryPluginLoadContext(IEnumerable\u003cPluginAssembly\u003e assemblies) : base(isCollectible: true)\r\n        {\r\n            _pluginAssemblies = assemblies.ToDictionary(x =\u003e Path.GetFileNameWithoutExtension(x.FileName), x =\u003e x);\r\n\r\n            var hexaSdkAssembly = typeof(Entity).Assembly;\r\n            _loadedAssemblies[hexaSdkAssembly.GetName().Name] = hexaSdkAssembly;\r\n        }\r\n\r\n        private Assembly Load(PluginAssembly pluginAssembly)\r\n        {\r\n            try\r\n            {\r\n                lock(Lock)\r\n                {\r\n                    using var dll = new MemoryStream(pluginAssembly.AssemblyBytes);\r\n                    using var pdb =\r\n                        pluginAssembly.SymbolBytes != null\r\n                        ? new MemoryStream(pluginAssembly.SymbolBytes)\r\n                        : null;\r\n\r\n                    var assembly = LoadFromStream(dll, pdb);\r\n\r\n                    _loadedAssemblies[pluginAssembly.FileName] = assembly;\r\n\r\n                    return assembly;\r\n                }\r\n            }\r\n            catch(Exception ex)\r\n            {\r\n                throw new Exception($\"An error has ocurred trying to load PluginAssembly: {pluginAssembly.FileName}. DLL: {pluginAssembly.AssemblyBytes?.Length} bytes. PDB: {pluginAssembly.SymbolBytes?.Length} bytes.\", ex);\r\n            }\r\n            \r\n        }\r\n\r\n        protected override Assembly Load(AssemblyName assemblyName) =\u003e\r\n            _loadedAssemblies.TryGetValueOr(assemblyName.Name, (Assembly)null)\r\n            ?? (_pluginAssemblies.TryGetValue(assemblyName.Name, out var pluginAssembly)\r\n            ? Load(_pluginAssemblies[assemblyName.Name])\r\n            : null);\r\n\r\n        public List\u003cPluginBase\u003e GetPlugins()\r\n        {\r\n            return \r\n                _pluginAssemblies\r\n                    .Select(x =\u003e Load(x.Value))\r\n                    .SelectMany(a =\u003e a.GetTypes())\r\n                    .Where(t =\u003e typeof(PluginBase).IsAssignableFrom(t))\r\n                    .Where(t =\u003e !t.IsAbstract)\r\n                    .Select(t =\u003e Activator.CreateInstance(t))\r\n                    .Cast\u003cPluginBase\u003e()\r\n                    .ToList();\r\n        }\r\n    }\r\n\r\n    public class PluginAssembly\r\n    {\r\n        public byte[] AssemblyBytes { get; set; }\r\n\r\n        public byte[] SymbolBytes { get; set; }\r\n\r\n        public string FileName { get; set; }\r\n\r\n        public string AssemblyHash { get; set; }\r\n    }\r\n```\r\n\r\nso I basically provide all the DLLs and PDBs in memory as `byte[]`s to the `AssemblyLoadContext`, and then use `LoadFromStream()` to load them as needed.\r\n\r\nThis works very well for some time, but at unidentified circumstances it will start throwing the following exception:\r\n\r\n```\r\n---\u003e System.UnauthorizedAccessException: Access is denied. (0x80070005 (E_ACCESSDENIED))\r\nat System.Runtime.Loader.AssemblyLoadContext.InternalLoad(ReadOnlySpan`1 arrAssembly, ReadOnlySpan`1 arrSymbols)\r\nat System.Runtime.Loader.AssemblyLoadContext.LoadFromStream(Stream assembly, Stream assemblySymbols)\r\nat Hexa.Api.Management.InMemoryPluginLoadContext.Load(PluginAssembly pluginAssembly)\r\n```\r\n\r\nwhenever this exception happens, it starts happening for ALL assemblies in ALL requests to the Azure Function, so it basically crashes my whole project down and I\u0027m forced to restart the function entirely.\r\n\r\nI\u0027ve tracked the exception down to [this method](https://github.com/dotnet/runtime/blob/49653839ef21f0cd886ee24caaf404ccaa1ac27e/src/coreclr/System.Private.CoreLib/src/System/Runtime/Loader/AssemblyLoadContext.CoreCLR.cs#L61) in the .NET runtime, but I have no idea what might be causing the exception. I\u0027ve also checked that the `byte[]`s are properly loaded with the dll/pdb contents.\r\n\r\nPlease someone give me a clue about how to troubleshoot this and how to properly reproduce and fix this error",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOcA9r_g==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxNTkyNTg2Mg==",
                                           "createdAt":  "2021-04-08T15:40:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-04-08T15:40:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxNjM0OTMzMA==",
                                           "createdAt":  "2021-04-09T02:05:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @coffeeflux, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nSorry, I\u0027ll start off by saying I feel bad for reporting an issue without a proper repro, but so far I\u0027ve been unable to properly and consistently reproduce this issue outside of production environments and it\u0027s causing us a lot of trouble.\r\n\r\nI\u0027m using `AssemblyLoadContext` to load and execute plugins inside Azure Functions. The DLL and PDB files for the plugins are hosted on Azure Blob, so I\u0027m not using Filesystem-based assembly load or resolution.\r\n\r\nThis is the relevant code:\r\n\r\n```csharp\r\n    internal class InMemoryPluginLoadContext : AssemblyLoadContext\r\n    {\r\n        private static readonly object Lock = new object();\r\n        private readonly Dictionary\u003cstring, PluginAssembly\u003e _pluginAssemblies;\r\n        private readonly Dictionary\u003cstring, Assembly\u003e _loadedAssemblies = new Dictionary\u003cstring, Assembly\u003e();\r\n\r\n        public InMemoryPluginLoadContext(IEnumerable\u003cPluginAssembly\u003e assemblies) : base(isCollectible: true)\r\n        {\r\n            _pluginAssemblies = assemblies.ToDictionary(x =\u003e Path.GetFileNameWithoutExtension(x.FileName), x =\u003e x);\r\n\r\n            var hexaSdkAssembly = typeof(Entity).Assembly;\r\n            _loadedAssemblies[hexaSdkAssembly.GetName().Name] = hexaSdkAssembly;\r\n        }\r\n\r\n        private Assembly Load(PluginAssembly pluginAssembly)\r\n        {\r\n            try\r\n            {\r\n                lock(Lock)\r\n                {\r\n                    using var dll = new MemoryStream(pluginAssembly.AssemblyBytes);\r\n                    using var pdb =\r\n                        pluginAssembly.SymbolBytes != null\r\n                        ? new MemoryStream(pluginAssembly.SymbolBytes)\r\n                        : null;\r\n\r\n                    var assembly = LoadFromStream(dll, pdb);\r\n\r\n                    _loadedAssemblies[pluginAssembly.FileName] = assembly;\r\n\r\n                    return assembly;\r\n                }\r\n            }\r\n            catch(Exception ex)\r\n            {\r\n                throw new Exception($\"An error has ocurred trying to load PluginAssembly: {pluginAssembly.FileName}. DLL: {pluginAssembly.AssemblyBytes?.Length} bytes. PDB: {pluginAssembly.SymbolBytes?.Length} bytes.\", ex);\r\n            }\r\n            \r\n        }\r\n\r\n        protected override Assembly Load(AssemblyName assemblyName) =\u003e\r\n            _loadedAssemblies.TryGetValueOr(assemblyName.Name, (Assembly)null)\r\n            ?? (_pluginAssemblies.TryGetValue(assemblyName.Name, out var pluginAssembly)\r\n            ? Load(_pluginAssemblies[assemblyName.Name])\r\n            : null);\r\n\r\n        public List\u003cPluginBase\u003e GetPlugins()\r\n        {\r\n            return \r\n                _pluginAssemblies\r\n                    .Select(x =\u003e Load(x.Value))\r\n                    .SelectMany(a =\u003e a.GetTypes())\r\n                    .Where(t =\u003e typeof(PluginBase).IsAssignableFrom(t))\r\n                    .Where(t =\u003e !t.IsAbstract)\r\n                    .Select(t =\u003e Activator.CreateInstance(t))\r\n                    .Cast\u003cPluginBase\u003e()\r\n                    .ToList();\r\n        }\r\n    }\r\n\r\n    public class PluginAssembly\r\n    {\r\n        public byte[] AssemblyBytes { get; set; }\r\n\r\n        public byte[] SymbolBytes { get; set; }\r\n\r\n        public string FileName { get; set; }\r\n\r\n        public string AssemblyHash { get; set; }\r\n    }\r\n```\r\n\r\nso I basically provide all the DLLs and PDBs in memory as `byte[]`s to the `AssemblyLoadContext`, and then use `LoadFromStream()` to load them as needed.\r\n\r\nThis works very well for some time, but at unidentified circumstances it will start throwing the following exception:\r\n\r\n```\r\n---\u003e System.UnauthorizedAccessException: Access is denied. (0x80070005 (E_ACCESSDENIED))\r\nat System.Runtime.Loader.AssemblyLoadContext.InternalLoad(ReadOnlySpan`1 arrAssembly, ReadOnlySpan`1 arrSymbols)\r\nat System.Runtime.Loader.AssemblyLoadContext.LoadFromStream(Stream assembly, Stream assemblySymbols)\r\nat Hexa.Api.Management.InMemoryPluginLoadContext.Load(PluginAssembly pluginAssembly)\r\n```\r\n\r\nwhenever this exception happens, it starts happening for ALL assemblies in ALL requests to the Azure Function, so it basically crashes my whole project down and I\u0027m forced to restart the function entirely.\r\n\r\nI\u0027ve tracked the exception down to [this method](https://github.com/dotnet/runtime/blob/49653839ef21f0cd886ee24caaf404ccaa1ac27e/src/coreclr/System.Private.CoreLib/src/System/Runtime/Loader/AssemblyLoadContext.CoreCLR.cs#L61) in the .NET runtime, but I have no idea what might be causing the exception. I\u0027ve also checked that the `byte[]`s are properly loaded with the dll/pdb contents.\r\n\r\nPlease someone give me a clue about how to troubleshoot this and how to properly reproduce and fix this error\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003efberasategui\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-04-09T02:05:50Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxNjcxODM2Mw==",
                                           "createdAt":  "2021-04-09T14:21:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "It\u0027s really hard to tell what\u0027s wrong here unfortunately. Couple of things which might help to figure this out:\r\n* Can you try this on .NET 5? Maybe it\u0027s hitting some issue we\u0027ve already fixed since (I know this is tricky if it only happens in production though)\r\n* How many assemblies are you loading this way? The fact that once it happens, then it happens for anything sounds like some process-wide issue. For example out of memory (or out of VM space), or something along those lines. The system should be scalable pretty well, but I don\u0027t think we\u0027ve tested it with tens of thousands of assemblies for example.\r\n  * If you have the ability to print out some additional info when the problem happens, you can try to print out things like `AppDomain.CurrentDomain.GetAssemblies.Length` which is the total number of assemblies in the process.\r\n\r\nAnother alternative is that one of the plugins is doing something bad to the process... but then I don\u0027t know why it would only affect assembly loading... hard to tell.",
                                           "updatedAt":  "2021-04-09T14:21:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxODE0MzQyNg==",
                                           "createdAt":  "2021-04-12T20:11:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotfede",
                                           "body":  "@vitek-karas I tried your suggestion about `AppDomain.CurrentDomain.GetAssemblies.Length` and I got back around 811 assemblies in one of the latest occurrences. I have now added code to print out the assembly names of those 811.\r\n\r\n",
                                           "updatedAt":  "2021-04-12T20:11:46Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxODIxMTIxMw==",
                                           "createdAt":  "2021-04-12T20:44:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "That\u0027s not that much (I mean it\u0027s not small, but nowhere near the number I would expect to start getting issues with)",
                                           "updatedAt":  "2021-04-12T20:44:14Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxODI3OTA2MQ==",
                                           "createdAt":  "2021-04-12T22:17:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotfede",
                                           "body":  "@vitek-karas Do you detect any deficiency or possible issue in my code posted above?",
                                           "updatedAt":  "2021-04-12T22:17:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxODI5MDk2Mg==",
                                           "createdAt":  "2021-04-12T22:44:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "Not really - but at the same time it\u0027s really hard to tell what went wrong. The failure could be coming from the file system/OS/anything really. I quickly scanned through CoreCLR code to see if we use this error code somewhere, but I only found one case which should not run in the scenarios you describe (and not on the callstack you have above).\r\n\r\nWhat throws me off the most is that once it happens, then it sticks. That basically rules out things which would be specific to a given assembly. That might be another interesting data point - if this happens when you load a specific assembly - if it\u0027s always the same assembly, then we have something to look into. If it\u0027s random assembly each time, then it feels like something unrelated to the specific assembly and more of an environment problem.",
                                           "updatedAt":  "2021-04-12T22:44:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wDxv1",
                                           "createdAt":  "2024-01-07T12:00:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "well0549",
                                           "body":  "I have exactly the same issue. I am using a compiled transform. This Compiled transform gets it\u0027s assemblies form Cached entries in a dictionary. So no actual loading from file or share is going oin....... The assemblybytes are cached.\r\n\r\nI have exactly the same function app (but then compiled to the .Net framewrok 4.81, and that runs without any problems.\r\nThe behaviour is quite random and the Azure function  is effectively broken and wil will give back the same error (see below) for each call from that moment on.\r\n\r\nSome backround on this. \r\n\r\nI have two Azure Transformation Functions, I have both a a .net core (6.0) and a .net481 version of this function. (because the compiledtransform of 4.81 is much more capable).\r\n\r\nBoth of these have the exact same piece of code to load the assemblies......\r\n\r\n\r\n````\r\n                // Add an argument for each defined extension object\r\n                foreach (var extension in transformation.Extensions)\r\n                {\r\n                    FileInformation assemblyInfo = new FileInformation();\r\n                    assemblyInfo.FileName = Path.GetFileName(extension.AssemblyFileName);\r\n                    connections.LoadExtensionBinary(transformation.Name, assemblyInfo);\r\n\r\n                    var assembly = Assembly.Load(assemblyInfo.FileBytes);\r\n                    var type = assembly.GetType($\"{extension.Namespace}.{extension.ClassName}\");\r\n                    if (type == null)\r\n                        throw new Exception($\"Cannot get type {extension.AssemblyName}\");\r\n                    string ns = $\"http://schemas.microsoft.com/BizTalk/2003/ScriptNS{counter}\";\r\n                    arguments.AddExtensionObject(ns, Activator.CreateInstance(type)!);\r\n                    counter++;\r\n                }\r\n````\r\n\r\nThe error i get is:\r\n\r\n````\r\nSpaarpuntenTransformSSO.cc0527ef-1876-4ffc-b9a7-7459aafa5dcb Exception during transformation:System.UnauthorizedAccessException: Access is denied. (0x80070005 (E_ACCESSDENIED))\r\n   at System.Runtime.Loader.AssemblyLoadContext.LoadFromStream(IntPtr ptrNativeAssemblyLoadContext, IntPtr ptrAssemblyArray, Int32 iAssemblyArrayLen, IntPtr ptrSymbols, Int32 iSymbolArrayLen, ObjectHandleOnStack retAssembly)\r\n   at System.Runtime.Loader.AssemblyLoadContext.InternalLoad(ReadOnlySpan`1 arrAssembly, ReadOnlySpan`1 arrSymbols)\r\n   at System.Reflection.Assembly.Load(Byte[] rawAssembly, Byte[] rawSymbolStore)\r\n   at HTTPTransformCoreIsolated.Components.TransformationCore.TransformXslt(XmlReader inputDocument, XmlReader stylesheet, Transformation transformation, ILogger _logger, BlobClient blobClientInput, String blobName, ConcurrentDictionary`2 mapCache, BlobContainerClient containerClient, Connections connections)\r\n   at HTTPTransformCoreIsolated.Components.TransformationCore.ExecuteTransform(Stream inputXml, Transformation transformation, ILogger _logger, BlobClient blobClient, String blobName, ConcurrentDictionary`2 mapCache, BlobContainerClient containerClient, Connections connections)\r\n   at HTTPTransformCoreIsolated.TransformCore.ExecuteTransformation(ILogger log, String transformName, String blobName, ConcurrentDictionary`2 mapCache, String storageAccount, String containerName, Connections connections).\r\n````\r\n\r\nNot really sure how to fix this, and any help will be apreciated\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
                                           "updatedAt":  "2024-01-07T12:03:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wD2Ms",
                                           "createdAt":  "2024-01-07T13:12:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "well0549",
                                           "body":  "Tried something else. Copy the array first an then try a load from the copy, The result is unfortunately the same...... Goes ok for 600 times and the starts throwing the same exception over and over again.........\r\n",
                                           "updatedAt":  "2024-01-07T13:12:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wD2v-",
                                           "createdAt":  "2024-01-07T13:21:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "well0549",
                                           "body":  "One other thing i tried, When the error occurred i write data in to a toggle folder. This toggle folder is also in my watchlist.\r\n\r\n````\r\n \"watchDirectories\": [ \"c:\\\\home\\\\logfiles\\\\toggle\" ],\r\n````\r\n\r\nI can see the file is written. But the error even persists afte ar restart ofthe function itself. Only a restart of the host will solve the problem.\r\n\r\nThe function runs as an isolated function in azure",
                                           "updatedAt":  "2024-01-07T13:22:29Z"
                                       }
                                   ],
                         "totalCount":  10
                     },
        "title":  ".NET Core 3.1 - AssemblyLoadContext.LoadFromStream() throwing AccessDeniedException randomly in Azure Function",
        "labels":  [
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/51295",
        "createdAt":  "2021-04-15T05:08:47Z",
        "number":  51295,
        "author":  "lenkasa",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-08-13T15:38:21Z",
        "body":  "I have .NET core project which contains Config.json file where some plugins are specified. I do dotnet store and dotnet publish on this project and I expected that application automatically search and load plugins from runtime package storage, but it doesn´t.\r\nIt works only if I add AssemblyLoadContext.Default.Resolving to my project and specify path to package runtime storage. Why assemblies (which are specified in .json file) aren´t automatically searched and loaded from storage?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOMRoOGw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyMDA5OTQwNg==",
                                           "createdAt":  "2021-04-15T05:08:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @coffeeflux, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nI have .NET core project which contains Config.json file where some plugins are specified. I do dotnet store and dotnet publish on this project and I expected that application automatically search and load plugins from runtime package storage, but it doesn´t.\r\nIt works only if I add AssemblyLoadContext.Default.Resolving to my project and specify path to package runtime storage. Why assemblies (which are specified in .json file) aren´t automatically searched and loaded from storage?\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003elenkasa\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-04-15T05:08:53Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyMzExMDk3Mg==",
                                           "createdAt":  "2021-04-20T09:02:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "Can you please share a sample `config.json` which you\u0027re using (or something similar - replace the assembly names for example, if you need to).",
                                           "updatedAt":  "2021-04-20T09:02:55Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyMzc5MTEzMQ==",
                                           "createdAt":  "2021-04-21T05:38:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lenkasa",
                                           "body":  "My Config.json looks like this:\r\n\r\n```\r\n{\r\n    \"modules\": [\r\n     {\r\n        \"type\": \"TestModule, Test\",\r\n        \"properties\": {\r\n            \"PluginInstanceNames\": [ \"Test\" ]\r\n        }\r\n      }\r\n   ]\r\n}\r\n```",
                                           "updatedAt":  "2021-04-21T05:38:53Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  ".NET cannot search assemblies in package runtime storage",
        "labels":  [
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/51991",
        "createdAt":  "2021-04-28T15:18:09Z",
        "number":  51991,
        "author":  "vitek-karas",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOBo6XDg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sbomer",
                                            "createdAt":  "2021-04-28T15:30:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "eerhardt",
                                            "createdAt":  "2021-04-28T15:40:34Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2022-07-28T17:49:37Z",
        "body":  "There are lot of managed methods in System.Private.CoreLib which are called from the runtime native code. These are dependencies which trimming tools like ILLinker can\u0027t automatically detect. For this purpose CoreLib includes `ILLink.Descriptors.xml` file embedded in it to \"root\" all of these methods (and fields).\r\n\r\nCurrently parts of this file are created manually in [CoreCLR](https://github.com/dotnet/runtime/blob/main/src/coreclr/System.Private.CoreLib/src/ILLink/ILLink.Descriptors.xml) and [Shared](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/ILLink/ILLink.Descriptors.Shared.xml). The rest is generated from C++ header files. The generation happens in a custom [target](https://github.com/dotnet/runtime/blob/main/src/coreclr/System.Private.CoreLib/CreateRuntimeRootILLinkDescriptorFile.targets) which uses a custom [task](https://github.com/mono/linker/blob/main/src/ILLink.Tasks/CreateRuntimeRootDescriptorFile.cs). These parse the [`corelib.h`](https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/corelib.h) and coupe of other headers. \r\n\r\nExisting problems with this approach:\r\n* Relatively hard to maintain - lot of different pieces have to work\r\n* Manual parsing of C++ headers is very limited and can easily break\r\n* Adding new functionality is inconsistent and makes the whole system even more fragile\r\n  * Make the custom parser understand ifdefs\r\n  * Introduce ability to conditionally root things based on feature switches\r\n\r\nPotential improvements\r\n\r\n### Use C++ preprocessor\r\n\r\nInstead of custom parsing the C++ headers, run them through a real C++ preprocessor with custom definitions of the macros. Produce easily parseable output (for example XML) which is then consumed by the custom task to produce the descriptor. This is relatively tricky to implement though:\r\n* We can\u0027t really run it during coreclr build - it would mean that building CoreLib requires output from CoreCLR build - which is a new dependency and the infra team really doesn\u0027t like this (it would also mean that `dotnet build` on CoreLib would basically never work fully).\r\n* Running CMake from CoreLib build is a possibility, but it\u0027s complex and probably slow (we already have 3 places we start native build pipeline in the runtime repo, this would introduce a new one - while we\u0027re trying hard to go down to just 1 place ideally).\r\n* That leaves running the preprocessor directly (without CMake) from the CoreLib build. This is probably not that hard since we have scripts to find the compiler path - [Windows to get cl.exe on PATH](https://github.com/dotnet/runtime/blob/main/eng/native/init-vs-env.cmd), [Linux, macOS to get clang path into CC/CXX](https://github.com/dotnet/runtime/blob/main/eng/native/init-compiler.sh). That said it\u0027s still not exactly easy as we would be adding a new thing into the pipeline for CoreLib - the risk here is that we have to construct the compiler command line by hand - making that work on all the platforms could be time consuming.\r\n  * This also comes with a downside - we would not run it in the same environment as within CoreCLR build, for example we would have to propagate the defines manually.\r\n\r\nIt would remove the custom parser and greatly reduce fragility around C++ headers. It would also make it easier to add new features (like the feature switches)\r\n\r\n### Move away from descriptors and use attributes\r\n\r\nIdeally we should move away from the descriptor XML files. Instead replace them with attributes in managed code. We could use `DynamicDependencyAttribute`, or potentially even introduce a new one.\r\nIf combined with moving some key parts from native to managed it could also make the whole product easier to trim (with greater size wins).\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOMXBGbQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyODU0MjI0OQ==",
                                           "createdAt":  "2021-04-28T15:18:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to \u0027linkable-framework\u0027: @eerhardt, @vitek-karas, @LakshanF, @sbomer\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThere are lot of managed methods in System.Private.CoreLib which are called from the runtime native code. These are dependencies which trimming tools like ILLinker can\u0027t automatically detect. For this purpose CoreLib includes `ILLink.Descriptors.xml` file embedded in it to \"root\" all of these methods (and fields).\r\n\r\nCurrently parts of this file are created manually in [CoreCLR](https://github.com/dotnet/runtime/blob/main/src/coreclr/System.Private.CoreLib/src/ILLink/ILLink.Descriptors.xml) and [Shared](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/ILLink/ILLink.Descriptors.Shared.xml). The rest is generated from C++ header files. The generation happens in a custom [target](https://github.com/dotnet/runtime/blob/main/src/coreclr/System.Private.CoreLib/CreateRuntimeRootILLinkDescriptorFile.targets) which uses a custom [task](https://github.com/mono/linker/blob/main/src/ILLink.Tasks/CreateRuntimeRootDescriptorFile.cs). These parse the [`corelib.h`](https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/corelib.h) and coupe of other headers. \r\n\r\nExisting problems with this approach:\r\n* Relatively hard to maintain - lot of different pieces have to work\r\n* Manual parsing of C++ headers is very limited and can easily break\r\n* Adding new functionality is inconsistent and makes the whole system even more fragile\r\n  * Make the custom parser understand ifdefs\r\n  * Introduce ability to conditionally root things based on feature switches\r\n\r\nPotential improvements\r\n\r\n### Use C++ preprocessor\r\n\r\nInstead of custom parsing the C++ headers, run them through a real C++ preprocessor with custom definitions of the macros. Produce easily parseable output (for example XML) which is then consumed by the custom task to produce the descriptor. This is relatively tricky to implement though:\r\n* We can\u0027t really run it during coreclr build - it would mean that building CoreLib requires output from CoreCLR build - which is a new dependency and the infra team really doesn\u0027t like this (it would also mean that `dotnet build` on CoreLib would basically never work fully).\r\n* Running CMake from CoreLib build is a possibility, but it\u0027s complex and probably slow (we already have 3 places we start native build pipeline in the runtime repo, this would introduce a new one - while we\u0027re trying hard to go down to just 1 place ideally).\r\n* That leaves running the preprocessor directly (without CMake) from the CoreLib build. This is probably not that hard since we have scripts to find the compiler path - [Windows to get cl.exe on PATH](https://github.com/dotnet/runtime/blob/main/eng/native/init-vs-env.cmd), [Linux, macOS to get clang path into CC/CXX](https://github.com/dotnet/runtime/blob/main/eng/native/init-compiler.sh). That said it\u0027s still not exactly easy as we would be adding a new thing into the pipeline for CoreLib - the risk here is that we have to construct the compiler command line by hand - making that work on all the platforms could be time consuming.\r\n  * This also comes with a downside - we would not run it in the same environment as within CoreCLR build, for example we would have to propagate the defines manually.\r\n\r\nIt would remove the custom parser and greatly reduce fragility around C++ headers. It would also make it easier to add new features (like the feature switches)\r\n\r\n### Move away from descriptors and use attributes\r\n\r\nIdeally we should move away from the descriptor XML files. Instead replace them with attributes in managed code. We could use `DynamicDependencyAttribute`, or potentially even introduce a new one.\r\nIf combined with moving some key parts from native to managed it could also make the whole product easier to trim (with greater size wins).\r\n\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003evitek-karas\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`linkable-framework`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-04-28T15:18:12Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyODU0MjI1NQ==",
                                           "createdAt":  "2021-04-28T15:18:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-04-28T15:18:12Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyODU2MjM4MA==",
                                           "createdAt":  "2021-04-28T15:44:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "eerhardt",
                                           "body":  "\u003e Move away from descriptors and use attributes\r\n\r\nI think this makes the most sense, honestly. It also helps document \"this managed code is called from the runtime\". Plus it resolves all the \"this member in the ILLink.Descriptors.xml file doesn\u0027t exist in the x86/Linux/arm/etc version of System.Private.CoreLib\" issues we have. The attribute we use doesn\u0027t even have to be public, as it should only ever be used in CoreLib.",
                                           "updatedAt":  "2021-04-28T15:44:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyODU2Mzk1Mg==",
                                           "createdAt":  "2021-04-28T15:46:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBpN7ug==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2021-04-30T15:37:18Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "eerhardt",
                                           "body":  "Another benefit - it will work for Mono as well (which doesn\u0027t use the C++ header parsing that coreclr does).",
                                           "updatedAt":  "2021-04-28T15:46:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyODU2NTkxMw==",
                                           "createdAt":  "2021-04-28T15:49:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "Yes, Mono is on the `DynamicDependencyAttribute` plan already. I do not see a need for new attribute. The existing attributes should be sufficient.",
                                           "updatedAt":  "2021-04-28T15:49:06Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyODU4MjQzNg==",
                                           "createdAt":  "2021-04-28T16:10:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "Agreed, just for completeness another possibility could have been check in the preprocessed output and compare during the coreclr build, asmmeta style. (No I don\u0027t think that\u0027s a good idea)",
                                           "updatedAt":  "2021-04-28T16:10:33Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTA0ODIwNg==",
                                           "createdAt":  "2021-04-29T08:38:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "\u003e which is a new dependency and the infra team really doesn\u0027t like this\r\n\r\nI think the libraries team would object the most to that - CoreLib is a reference of several assemblies in src/libraries - it would mean one can\u0027t build libraries without building CoreCLR.",
                                           "updatedAt":  "2021-04-29T08:38:31Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTQ0MTY0NQ==",
                                           "createdAt":  "2021-04-29T17:13:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @coffeeflux, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThere are lot of managed methods in System.Private.CoreLib which are called from the runtime native code. These are dependencies which trimming tools like ILLinker can\u0027t automatically detect. For this purpose CoreLib includes `ILLink.Descriptors.xml` file embedded in it to \"root\" all of these methods (and fields).\r\n\r\nCurrently parts of this file are created manually in [CoreCLR](https://github.com/dotnet/runtime/blob/main/src/coreclr/System.Private.CoreLib/src/ILLink/ILLink.Descriptors.xml) and [Shared](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/ILLink/ILLink.Descriptors.Shared.xml). The rest is generated from C++ header files. The generation happens in a custom [target](https://github.com/dotnet/runtime/blob/main/src/coreclr/System.Private.CoreLib/CreateRuntimeRootILLinkDescriptorFile.targets) which uses a custom [task](https://github.com/mono/linker/blob/main/src/ILLink.Tasks/CreateRuntimeRootDescriptorFile.cs). These parse the [`corelib.h`](https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/corelib.h) and coupe of other headers. \r\n\r\nExisting problems with this approach:\r\n* Relatively hard to maintain - lot of different pieces have to work\r\n* Manual parsing of C++ headers is very limited and can easily break\r\n* Adding new functionality is inconsistent and makes the whole system even more fragile\r\n  * Make the custom parser understand ifdefs\r\n  * Introduce ability to conditionally root things based on feature switches\r\n\r\nPotential improvements\r\n\r\n### Use C++ preprocessor\r\n\r\nInstead of custom parsing the C++ headers, run them through a real C++ preprocessor with custom definitions of the macros. Produce easily parseable output (for example XML) which is then consumed by the custom task to produce the descriptor. This is relatively tricky to implement though:\r\n* We can\u0027t really run it during coreclr build - it would mean that building CoreLib requires output from CoreCLR build - which is a new dependency and the infra team really doesn\u0027t like this (it would also mean that `dotnet build` on CoreLib would basically never work fully).\r\n* Running CMake from CoreLib build is a possibility, but it\u0027s complex and probably slow (we already have 3 places we start native build pipeline in the runtime repo, this would introduce a new one - while we\u0027re trying hard to go down to just 1 place ideally).\r\n* That leaves running the preprocessor directly (without CMake) from the CoreLib build. This is probably not that hard since we have scripts to find the compiler path - [Windows to get cl.exe on PATH](https://github.com/dotnet/runtime/blob/main/eng/native/init-vs-env.cmd), [Linux, macOS to get clang path into CC/CXX](https://github.com/dotnet/runtime/blob/main/eng/native/init-compiler.sh). That said it\u0027s still not exactly easy as we would be adding a new thing into the pipeline for CoreLib - the risk here is that we have to construct the compiler command line by hand - making that work on all the platforms could be time consuming.\r\n  * This also comes with a downside - we would not run it in the same environment as within CoreCLR build, for example we would have to propagate the defines manually.\r\n\r\nIt would remove the custom parser and greatly reduce fragility around C++ headers. It would also make it easier to add new features (like the feature switches)\r\n\r\n### Move away from descriptors and use attributes\r\n\r\nIdeally we should move away from the descriptor XML files. Instead replace them with attributes in managed code. We could use `DynamicDependencyAttribute`, or potentially even introduce a new one.\r\nIf combined with moving some key parts from native to managed it could also make the whole product easier to trim (with greater size wins).\r\n\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003evitek-karas\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`, `linkable-framework`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-04-29T17:13:39Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "Improve how trimmer finds out about native-\u003emanaged dependencies in CoreLib",
        "labels":  [
                       "area-AssemblyLoader-coreclr",
                       "linkable-framework"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/52061",
        "createdAt":  "2021-04-29T16:23:00Z",
        "number":  52061,
        "author":  "KevinCathcart",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-29T20:22:33Z",
        "body":  "The following code when run in .NET 5 (adjusting the assembly path if needed), will crash with an AccessViolation.\r\n\r\nSince the user has written no unsafe code here, and is also not using any of the Unsafe equivlent framework methods, like some of the `Marshal` ones or the `Unsafe` class, and the user has not written any PInvokes or similar, it is not supposed to be possible to hit an access violation, meaning we have a \"runtime\" bug. However, the bug here is not in the native code, but actually in a managed code. Explanation will be found below the code. \r\n\r\n```C#\r\nvoid Main()\r\n{\r\n   // This is loosely based on the example code in https://docs.microsoft.com/en-us/dotnet/standard/assembly/unloadability\r\n    \r\n    string assembly = @\"C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App\\5.0.5\\PresentationCore.dll\";\r\n    string basename = \"PresentationCore.g\";\r\n    string resource = \"fonts/globalserif.compositefont\";\r\n    \r\n    var stream = GetResourceAndUnload(assembly, basename, resource, out var alc);\r\n\r\n    // Wait for the load context to get collected (and thus assembly unloaded)\r\n\tfor (int i = 0; alc.IsAlive \u0026\u0026 (i \u003c 10); i++)\r\n\t{\r\n\t\tGC.Collect();\r\n\t\tGC.WaitForPendingFinalizers();\r\n\t}\r\n\t\r\n\tvar test = new byte[10];\r\n\tstream.Read(test); // Reads unmapped memory, and dies.\r\n}\r\n\r\n[MethodImpl(MethodImplOptions.NoInlining)]\r\nstatic Stream GetResourceAndUnload(string assemblyPath, string baseName, string resource, out WeakReference alcWeakRef)\r\n{\r\n\tvar alc = new TestAssemblyLoadContext();\r\n\tAssembly a = alc.LoadFromAssemblyPath(assemblyPath);\r\n\r\n\talcWeakRef = new WeakReference(alc, trackResurrection: true);\r\n    \r\n    ResourceManager rm = new ResourceManager(baseName, a);\r\n\r\n\tvar stream = rm.GetStream(resource);\r\n\r\n\talc.Unload();\r\n\r\n\treturn stream;\r\n}\r\n\r\nclass TestAssemblyLoadContext : AssemblyLoadContext\r\n{\r\n\tpublic TestAssemblyLoadContext() : base(isCollectible: true)\r\n\t{\r\n\t}\r\n\r\n\tprotected override Assembly Load(AssemblyName name)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n}\r\n```\r\n\r\nThe bug here is that an UmanagedMemoryStream pointing into the assembly itself is returned for the Resource, but nothing is keeping the assembly alive, so the assembly is subject to getting collected. Once collected, the file in unmapped, and trying to read from the pointer inside UnmanagedMemoryStream ends up reading unmapped memory, and this explodes.\r\n\r\nThis same basic bug was fixed for the `RuntimeAssembly.GetManifestResourceStream` case back in dotnet/coreclr#22925, but this case was not fixed.\r\n\r\nThe new UmanagedMemoryStream is actually created from the one returned by the previous method, so if it used a subclass that could keep the original stream around (similar to how the previous fix worked) that would prevent the unloading while the stream was still accessible. Or there could be other approaches too.\r\n\r\nNote: I did not stumble upon this organically.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOMZU-_w==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTM4MjI2NA==",
                                           "createdAt":  "2021-04-29T16:23:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @coffeeflux, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThe following code when run in .NET 5 (adjusting the assembly path if needed), will crash with an AccessViolation.\r\n\r\nSince the user has written no unsafe code here, and is also not using any of the Unsafe equivlent framework methods, like some of the `Marshal` ones or the `Unsafe` class, and the user has not written any PInvokes or similar, it is not supposed to be possible to hit an access violation, meaning we have a \"runtime\" bug. However, the bug here is not in the native code, but actually in a managed code. Explanation will be found below the code. \r\n\r\n```C#\r\nvoid Main()\r\n{\r\n   // This is loosely based on the example code in https://docs.microsoft.com/en-us/dotnet/standard/assembly/unloadability\r\n    \r\n    string assembly = @\"C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App\\5.0.5\\PresentationCore.dll\";\r\n    string basename = \"PresentationCore.g\";\r\n    string resource = \"fonts/globalserif.compositefont\";\r\n    \r\n    var stream = GetResourceAndUnload(assembly, basename, resource, out var alc);\r\n\r\n    // Wait for the load context to get collected (and thus assembly unloaded)\r\n\tfor (int i = 0; alc.IsAlive \u0026\u0026 (i \u003c 10); i++)\r\n\t{\r\n\t\tGC.Collect();\r\n\t\tGC.WaitForPendingFinalizers();\r\n\t}\r\n\t\r\n\tvar test = new byte[10];\r\n\tstream.Read(test); // Reads unmapped memory, and dies.\r\n}\r\n\r\n[MethodImpl(MethodImplOptions.NoInlining)]\r\nstatic Stream GetResourceAndUnload(string assemblyPath, string baseName, string resource, out WeakReference alcWeakRef)\r\n{\r\n\tvar alc = new TestAssemblyLoadContext();\r\n\tAssembly a = alc.LoadFromAssemblyPath(assemblyPath);\r\n\r\n\talcWeakRef = new WeakReference(alc, trackResurrection: true);\r\n    \r\n    ResourceManager rm = new ResourceManager(baseName, a);\r\n\r\n\tvar stream = rm.GetStream(resource);\r\n\r\n\talc.Unload();\r\n\r\n\treturn stream;\r\n}\r\n\r\nclass TestAssemblyLoadContext : AssemblyLoadContext\r\n{\r\n\tpublic TestAssemblyLoadContext() : base(isCollectible: true)\r\n\t{\r\n\t}\r\n\r\n\tprotected override Assembly Load(AssemblyName name)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n}\r\n```\r\n\r\nThe bug here is that an UmanagedMemoryStream pointing into the assembly itself is returned for the Resource, but nothing is keeping the assembly alive, so the assembly is subject to getting collected. Once collected, the file in unmapped, and trying to read from the pointer inside UnmanagedMemoryStream ends up reading unmapped memory, and this explodes.\r\n\r\nThis same basic bug was fixed for the `RuntimeAssembly.GetManifestResourceStream` case back in dotnet/coreclr#22925, but this case was not fixed.\r\n\r\nThe new UmanagedMemoryStream is actually created from the one returned by the previous method, so if it used a subclass that could keep the original stream around (similar to how the previous fix worked) that would prevent the unloading while the stream was still accessible. Or there could be other approaches too.\r\n\r\nNote: I did not stumble upon this organically.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eKevinCathcart\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-04-29T16:23:04Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgzMTY1MDQ1OA==",
                                           "createdAt":  "2021-05-04T02:34:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KevinCathcart",
                                           "body":  "This also applies to `DeserializingResourceReader`, which actually has two cases where this can crash the runtime due to assembly unloading. \r\n\r\nLastly I\u0027ve not yet traced out `System.Reflection.TypeLoading.Ecma.EcmaAssemblies` usage of UnmanagedMemoryStream but am concerned that I don\u0027t immediately see anything that would ensure the memory cannot be unloaded while the returned stream lives on. On the other hand it sounds like MetadataLoadContext is known to potentially cause AccessViolations if the context is disposed while other things are trying to read from it.",
                                           "updatedAt":  "2021-05-04T15:11:06Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgzMTg2NDU3NQ==",
                                           "createdAt":  "2021-05-04T11:16:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "@steveharter for the reflection API implications.\r\n@joperezr for the resource API implications.\r\n\r\nI actually don\u0027t know the best area this should belong to... (not that it matters, we should fix this regardless)",
                                           "updatedAt":  "2021-05-04T11:16:13Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "[ResourceLoader] Collected assembly can cause AccessViolationException",
        "labels":  [
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/53268",
        "createdAt":  "2021-05-26T07:40:25Z",
        "number":  53268,
        "author":  "Shyam-Gupta",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-06-14T19:27:39Z",
        "body":  "### Description\r\n`FileLoadException` is thrown during assembly load when in a previous attempt assembly load for a reference assembly has failed with `BadImageFormatException`. Both implementation assembly and reference assemblies have same name.\r\n\r\n**Repro Steps:**\r\nConsider following code snippet:\r\n\r\n```csharp\r\n\r\n        const string userControlDll = \"UserControl11.dll\";\r\n\r\n        var executingAssemblyDirectory = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);\r\n        var refAssemblyPath = Path.Combine(executingAssemblyDirectory, \"ref\", userControlDll);\r\n\r\n        Exception exception = null;\r\n\r\n        Console.WriteLine(\"Loading ref assembly\");\r\n\r\n        try\r\n        {\r\n            AssemblyLoadContext.Default.LoadFromAssemblyPath(refAssemblyPath);\r\n        }\r\n        catch (BadImageFormatException ex)\r\n        {\r\n            // This is expected\r\n            exception = ex;\r\n        }\r\n\r\n        Console.WriteLine(\"Loading implementation assembly\");\r\n\r\n        var implementationAssemblyPath = Path.Combine(executingAssemblyDirectory, userControlDll);\r\n\r\n        try\r\n        {\r\n            AssemblyLoadContext.Default.LoadFromAssemblyPath(implementationAssemblyPath);\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            // Throws \u0027System.IO.FileLoadException\u0027 with error message \"Assembly with same name is already loaded\"\r\n            // This seems unexpected\r\n            exception = ex;\r\n        }\r\n```\r\nBoth the implementation assembly and reference assembly have same name. We first try to load reference assembly which fails with `BadImageFormatException` and is expected. However later when we try to load correct implementation assembly it fails with `System.IO.FileLoadException` message: \"Assembly with same name is already loaded\". Since the ref assembly load failed in previous attempt, it seems weird that implementation assembly load fails with this error.\r\n\r\n### Configuration\r\n\r\n* Which version of .NET is the code running on?\r\n.NET 5.0, .NET 6.0\r\n\r\n### Scenario affected\r\nThis bug is causing issues with WinForms designer, which tries to load project output dlls to resolve custom types. In .NET 5.0 and .NET 6.0, project output folder contains ref binaries. When the designer\u0027s child process tries to load ref binaries, it fails with `BadImageFormatException`. It ignores those exceptions and then tries to load implementation assemblies which also fails.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOMp50Dg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg0ODU0Mzk4Ng==",
                                           "createdAt":  "2021-05-26T07:40:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @coffeeflux, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\n`FileLoadException` is thrown during assembly load when in a previous attempt assembly load for a reference assembly has failed with `BadImageFormatException`. Both implementation assembly and reference assemblies have same name.\r\n\r\n**Repro Steps:**\r\nConsider following code snippet:\r\n\r\n```csharp\r\n\r\n        const string userControlDll = \"UserControl11.dll\";\r\n\r\n        var executingAssemblyDirectory = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);\r\n        var refAssemblyPath = Path.Combine(executingAssemblyDirectory, \"ref\", userControlDll);\r\n\r\n        Exception exception = null;\r\n\r\n        Console.WriteLine(\"Loading ref assembly\");\r\n\r\n        try\r\n        {\r\n            AssemblyLoadContext.Default.LoadFromAssemblyPath(refAssemblyPath);\r\n        }\r\n        catch (BadImageFormatException ex)\r\n        {\r\n            exception = ex;\r\n        }\r\n\r\n        Console.WriteLine(\"Loading implementation assembly\");\r\n\r\n        var implementationAssemblyPath = Path.Combine(executingAssemblyDirectory, userControlDll);\r\n\r\n        try\r\n        {\r\n            AssemblyLoadContext.Default.LoadFromAssemblyPath(implementationAssemblyPath);\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            exception = ex;\r\n        }\r\n```\r\nBoth the implementation assembly and reference assembly have same name. We first try to load reference assembly which fails with `BadImageFormatException` and is expected. However later when we try to load correct implementation assembly it fails with `System.IO.FileLoadException` message: \"Assembly with same name is already loaded\". Since the ref assembly load failed in previous attempt, it seems weird that implementation assembly load fails with this error.\r\n\r\n### Configuration\r\n\r\n* Which version of .NET is the code running on?\r\n.NET 5.0, .NET 6.0\r\n\r\n### Scenario affected\r\nThis bug is causing issues with WinForms designer, which tries to load project output dlls to resolve custom types. In .NET 5.0 and .NET 6.0, project output folder contains ref binaries. When the designer\u0027s child process tries to load ref binaries, it fails with `BadImageFormatException`. It ignores those exceptions and then tries to load implementation assemblies which also fails.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eShyam-Gupta\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-05-26T07:40:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg0ODU0NDMzNw==",
                                           "createdAt":  "2021-05-26T07:41:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBsVIbg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "merriemcgaw",
                                                                               "createdAt":  "2021-05-26T18:36:31Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "Shyam-Gupta",
                                           "body":  "FYI @merriemcgaw ",
                                           "updatedAt":  "2021-05-26T07:41:08Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg0ODk5NzY0OQ==",
                                           "createdAt":  "2021-05-26T17:58:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "agocke",
                                           "body":  "@vitek-karas, could you look at this?",
                                           "updatedAt":  "2021-05-26T17:58:51Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg0OTAyNTcxMA==",
                                           "createdAt":  "2021-05-26T18:37:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "merriemcgaw",
                                           "body":  "Chiming in here to say that this winds up blocking a key scenario in the WinForms designer, something our customers certainly expect to work. We would greatly appreciate the prioritization here 😄 ",
                                           "updatedAt":  "2021-05-26T18:37:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg0OTA0NDgxNQ==",
                                           "createdAt":  "2021-05-26T19:06:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "agocke",
                                           "body":  "Good to know, let\u0027s see if we can get to the bottom of this ASAP. Do you know if you\u0027ll need fixes for .NET 5 or earlier, or just .NET 6?",
                                           "updatedAt":  "2021-05-26T19:06:50Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg0OTA0NjM3NQ==",
                                           "createdAt":  "2021-05-26T19:08:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "I\u0027m looking, but I doubt it\u0027s a recent bug.\r\n\r\nThat said - why do you need to load the ref assembly by the runtime? If it\u0027s only for \"reflection-only-load\" it would be much cleaner to use `MetadataLoadContext` which has no interactions with the runtime and will avoid the issue for sure.",
                                           "updatedAt":  "2021-05-26T19:08:58Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg0OTA2MzE2Mw==",
                                           "createdAt":  "2021-05-26T19:35:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Shyam-Gupta",
                                           "body":  "The WinForms designer needs to load project output assembly to resolve custom user types which show up as controls in the Toolbox. To do this, the designer\u0027s child process (.NET Core process) loads all assemblies present in project output folder.\r\nIn case there is an easy way to differentiate between ref assemblies and implementation assemblies then we can skip loading ref assemblies. Let us know.",
                                           "updatedAt":  "2021-05-26T19:35:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg0OTA2NzEzNw==",
                                           "createdAt":  "2021-05-26T19:42:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "agocke",
                                           "body":  "I believe there\u0027s an attribute, `System.Runtime.CompilerServices.ReferenceAssemblyAttribute`, that should be on every reference assembly.",
                                           "updatedAt":  "2021-05-26T19:42:15Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg0OTA4MjY5OA==",
                                           "createdAt":  "2021-05-26T20:07:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Shyam-Gupta",
                                           "body":  "Is there any way to read assembly attributes without loading the assembly ? Else we will need to load each assembly into `MetadataLoadContext` first which will likely impact perf.",
                                           "updatedAt":  "2021-05-26T20:07:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg0OTA4ODUwOQ==",
                                           "createdAt":  "2021-05-26T20:16:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "MetadataLoadContext should be pretty fast – it’s lazy – meaning that it will only parse the bare headers and almost nothing else. You can go even lower level and use System.Reflection.Metadata and use the low level readers. It should be reasonably easy to read just assembly level attributes with that approach as well.\r\n@MichalStrehovsky for details on the low-level APIs if you\u0027re interested in that approach.\r\n\r\nNote about `MetadataLoadContext` - it\u0027s purely managed code library, it has no interaction with loading in the runtime. So among other things, if you get rid of all managed references to the returned objects, the loaded stuff will simply disappear (via GC, just like any other managed objects).",
                                           "updatedAt":  "2021-05-26T20:16:50Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg0OTEzNTU3OQ==",
                                           "createdAt":  "2021-05-26T21:34:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "I checked what happens in the runtime in this case:\r\n* It goes through assembly resolution and succeeds\r\n* It loads the basics of the assembly successfully\r\n* Then it tried to prepare the assembly for code execution\r\n  * This loads the metadata headers\r\n  * Looks for the `ReferencedAssemblyAttribute` - if it\u0027s there it will fail with the exception you\u0027re seeing\r\n\r\nThe failure happens basically during the \"execution\" phase - so it\u0027s similar to things like corrupted IL and so on. So the runtime treats the assembly as already loaded.\r\n\r\nThat said the runtime does basically the same thing you would do with `MetadataLoadContext` and it you would not be able to unload these, unlike the `MetadataLoadContext` where for assemblies which you don\u0027t want, they will simply go away.",
                                           "updatedAt":  "2021-05-26T21:34:12Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg0OTI0NTE5OA==",
                                           "createdAt":  "2021-05-27T01:29:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBs_GyA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "MichalStrehovsky",
                                                                               "createdAt":  "2021-05-27T07:23:31Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "merriemcgaw",
                                                                               "createdAt":  "2021-06-01T18:10:02Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "agocke",
                                           "body":  "Checking using System.Reflection.Metadata is pretty easy and should be cheap -- I wrote up a quick version here https://gist.github.com/agocke/f6a80c71cc62074379e2c9c4025505b7",
                                           "updatedAt":  "2021-05-27T01:29:43Z"
                                       }
                                   ],
                         "totalCount":  12
                     },
        "title":  "Implementation assembly load fails when ref assembly load has failed in a previous attempt",
        "labels":  [
                       "area-AssemblyLoader-coreclr",
                       "feature-request"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/56510",
        "createdAt":  "2021-07-29T01:39:10Z",
        "number":  56510,
        "author":  "AraHaan",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCEsjYw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Enderlook",
                                            "createdAt":  "2021-07-29T02:01:54Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rgwood",
                                            "createdAt":  "2021-07-29T02:17:32Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "acaly",
                                            "createdAt":  "2021-08-03T08:08:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AraHaan",
                                            "createdAt":  "2021-12-01T04:58:45Z"
                                        }
                                    ],
                          "totalCount":  4
                      },
        "updatedAt":  "2023-07-06T04:39:23Z",
        "body":  "### Background and motivation\r\n\r\nAs mentioned here https://github.com/dotnet/winforms/issues/5368 AssemblyLoadContext lacks an event where you can subscribe too when a type resolution fails (Like for example you try to load an assembly in AssemblyLoadContext that uses a type in ``System.Windows.Forms.dll`` that does not exist anymore on .NET 5 and you then need to reroute it to load a \"fake\" version of those removed types located in another assembly which actually wraps the types that they were replaced with so those old and possibly unmaintained assemblies would work like usual).\r\n\r\n@rickbrew *could* benefit from this in Paint.NET if this was possible in AssemblyLoadContext currently.\r\n\r\n### API Proposal\r\n\r\n```C#\r\nnamespace System.Reflection\r\n{\r\n     public class AssemblyLoadContext     {\r\n         // Unlike AppDomain.TypeResolve have this also trigger\r\n         // the event when trying to resolve types from static assemblies\r\n         // (Like System.Windows.Forms.dll) that no longer exists so one can\r\n         // resolve fake wrapper copies to make old code work.\r\n+        public event ResolveEventHandler? TypeResolve;\r\n     }\r\n}\r\n```     \r\n\r\n\r\n### API Usage\r\n\r\n```C#\r\nnamespace LoadContextExample;\r\n\r\nusing System;\r\nusing System.IO;\r\nusing System.Linq;\r\nusing System.Reflection;\r\nusing System.Runtime.Loader;\r\n\r\n/// \u003cinheritdoc/\u003e\r\npublic class PluginLoadContext : AssemblyLoadContext\r\n{\r\n    private readonly AssemblyDependencyResolver resolver;\r\n\r\n    /// \u003csummary\u003e\r\n    /// Initializes a new instance of the \u003csee cref=\"PluginLoadContext\"/\u003e class.\r\n    /// \u003c/summary\u003e\r\n    /// \u003cparam name=\"name\"\u003eThe name of the load context.\u003c/param\u003e\r\n    /// \u003cparam name=\"pluginPath\"\u003eThe path the the plugins.\u003c/param\u003e\r\n    public PluginLoadContext(string name, string pluginPath)\r\n        : base(name, true)\r\n    {\r\n        this.resolver = new(pluginPath);\r\n        this.TypeResolve += new ResolveEventHandler(HandleTypeResolve);\r\n    }\r\n\r\n    /// \u003cinheritdoc/\u003e\r\n    protected override Assembly? Load(AssemblyName assemblyName)\r\n    {\r\n        var isLoadedToDefaultContext = new Func\u003cstring, bool\u003e(static name =\u003e\r\n        {\r\n            return Default.Assemblies.Any(assembly =\u003e assembly.FullName is not null \u0026\u0026 assembly.FullName.Equals(name, StringComparison.Ordinal));\r\n        });\r\n        var getFromDefaultContext = new Func\u003cstring, Assembly?\u003e(static name =\u003e\r\n        {\r\n            return Default.Assemblies.FirstOrDefault(assembly =\u003e assembly.FullName is not null \u0026\u0026 assembly.FullName.Equals(name, StringComparison.Ordinal));\r\n        });\r\n        if (isLoadedToDefaultContext(assemblyName.FullName))\r\n        {\r\n            // return the assembly from the default context instead of reloading it (is same assembly and version).\r\n            return getFromDefaultContext(assemblyName.FullName);\r\n        }\r\n\r\n        var assemblyPath = this.resolver.ResolveAssemblyToPath(assemblyName);\r\n        return (assemblyPath is not null, !File.Exists($\"{AppContext.BaseDirectory}{assemblyName.Name}.dll\")) switch\r\n        {\r\n            (false, true) =\u003e null,\r\n            (false, false) =\u003e this.LoadFromAssemblyPath($\"{AppContext.BaseDirectory}{assemblyName.Name}.dll\"),\r\n            _ =\u003e this.LoadFromAssemblyPath(assemblyPath),\r\n        };\r\n    }\r\n\r\n    /// \u003cinheritdoc/\u003e\r\n    protected override IntPtr LoadUnmanagedDll(string unmanagedDllName)\r\n    {\r\n        var libraryPath = this.resolver.ResolveUnmanagedDllToPath(unmanagedDllName);\r\n        return (libraryPath is not null, !File.Exists($\"{AppContext.BaseDirectory}{unmanagedDllName}.dll\")) switch\r\n        {\r\n            (false, true) =\u003e IntPtr.Zero,\r\n            (false, false) =\u003e this.LoadUnmanagedDllFromPath($\"{AppContext.BaseDirectory}{unmanagedDllName}.dll\"),\r\n            _ =\u003e this.LoadUnmanagedDllFromPath(libraryPath),\r\n        };\r\n    }\r\n\r\n    static Assembly HandleTypeResolve(object sender, ResolveEventArgs args)\r\n    {\r\n        // In this case they return the entry assembly so the types would\r\n        // be loaded from that if they was removed from BCL code (Example was the\r\n        // removal of old controls in winforms back in .NET Core 3.1).\r\n        // in this case those types in the entry assembly actually are stubs that use\r\n        // the new types that replaced the old and removed ones.\r\n        // from here even if an assembly tried to find a type using a full name (that type\r\n        // later got removed), it would then instead be found and resolved from the entry\r\n        // assembly instead.\r\n        return Assembly.GetEntryAssembly();\r\n    }\r\n}\r\n```\r\n\r\n### Risks\r\n\r\nThis would probably need to be considered for addition in .NET 5.0.x and 6.0 so Paint.NET can use it.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYLx7aA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc40-PuT",
                                           "createdAt":  "2021-07-29T01:39:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nAs mentioned here https://github.com/dotnet/winforms/issues/5368 AssemblyLoadContext lacks an event where you can subscribe too when a type resolution fails (Like for example you try to load an assembly in AssemblyLoadContext that uses a type in ``System.Windows.Forms.dll`` that does not exist anymore on .NET 5 and you then need to reroute it to load a \"fake\" version of those removed types located in another assembly which actually wraps the types that they were replaced with so those old and possibly unmaintained assemblies would work like usual).\r\n\r\n@rickbrew *could* benefit from this in Paint.NET if this was possible in AssemblyLoadContext currently.\n\n### API Proposal\n\n```C#\r\nnamespace System.Reflection\r\n{\r\n     public class AssemblyLoadContext     {\r\n         // Unlike AppDomain.TypeResolve have this also trigger\r\n         // the event when trying to resolve types from static assemblies\r\n         // (Like System.Windows.Forms.dll) that no longer exists so one can\r\n         // resolve fake wrapper copies to make old code work.\r\n+        public event ResolveEventHandler? TypeResolve;\r\n     }\r\n}\r\n```     \r\n\n\n### API Usage\n\n```C#\r\nnamespace LoadContextExample;\r\n\r\n/// \u003cinheritdoc/\u003e\r\npublic class PluginLoadContext : AssemblyLoadContext\r\n{\r\n    private readonly AssemblyDependencyResolver resolver;\r\n\r\n    /// \u003csummary\u003e\r\n    /// Initializes a new instance of the \u003csee cref=\"PluginLoadContext\"/\u003e class.\r\n    /// \u003c/summary\u003e\r\n    /// \u003cparam name=\"name\"\u003eThe name of the load context.\u003c/param\u003e\r\n    /// \u003cparam name=\"pluginPath\"\u003eThe path the the plugins.\u003c/param\u003e\r\n    public PluginLoadContext(string name, string pluginPath)\r\n        : base(name, true)\r\n    {\r\n        this.resolver = new(pluginPath);\r\n        this.TypeResolve += new ResolveEventHandler(HandleTypeResolve);\r\n    }\r\n\r\n    /// \u003cinheritdoc/\u003e\r\n    protected override Assembly? Load(AssemblyName assemblyName)\r\n    {\r\n        var isLoadedToDefaultContext = new Func\u003cstring, bool\u003e(static name =\u003e\r\n        {\r\n            return Default.Assemblies.Any(assembly =\u003e assembly.FullName is not null \u0026\u0026 assembly.FullName.Equals(name, StringComparison.Ordinal));\r\n        });\r\n        var getFromDefaultContext = new Func\u003cstring, Assembly?\u003e(static name =\u003e\r\n        {\r\n            return Default.Assemblies.FirstOrDefault(assembly =\u003e assembly.FullName is not null \u0026\u0026 assembly.FullName.Equals(name, StringComparison.Ordinal));\r\n        });\r\n        if (isLoadedToDefaultContext(assemblyName.FullName))\r\n        {\r\n            // return the assembly from the default context instead of reloading it (is same assembly and version).\r\n            return getFromDefaultContext(assemblyName.FullName);\r\n        }\r\n\r\n        var assemblyPath = this.resolver.ResolveAssemblyToPath(assemblyName);\r\n        return (assemblyPath is not null, !File.Exists($\"{AppContext.BaseDirectory}{assemblyName.Name}.dll\")) switch\r\n        {\r\n            (false, true) =\u003e null,\r\n            (false, false) =\u003e this.LoadFromAssemblyPath($\"{AppContext.BaseDirectory}{assemblyName.Name}.dll\"),\r\n            _ =\u003e this.LoadFromAssemblyPath(assemblyPath),\r\n        };\r\n    }\r\n\r\n    /// \u003cinheritdoc/\u003e\r\n    protected override IntPtr LoadUnmanagedDll(string unmanagedDllName)\r\n    {\r\n        var libraryPath = this.resolver.ResolveUnmanagedDllToPath(unmanagedDllName);\r\n        return libraryPath is not null\r\n            ? this.LoadUnmanagedDllFromPath(libraryPath)\r\n            : !File.Exists($\"{AppContext.BaseDirectory}{unmanagedDllName}.dll\")\r\n            ? IntPtr.Zero\r\n            : this.LoadUnmanagedDllFromPath($\"{AppContext.BaseDirectory}{unmanagedDllName}.dll\");\r\n    }\r\n\r\n    static Assembly HandleTypeResolve(object sender, ResolveEventArgs args)\r\n    {\r\n        // In this case they return the entry assembly so the types would\r\n        // be loaded from that if they was removed from BCL code (Example was the\r\n        // removal of old controls in winforms back in .NET Core 3.1).\r\n        // in this case those types in the entry assembly actually are stubs that use\r\n        // the new types that replaced the old and removed ones.\r\n        // from here even if an assembly tried to find a type using a full name (that type\r\n        // later got removed), it would then instead be found and resolved from the entry\r\n        // assembly instead.\r\n        return Assembly.GetEntryAssembly();\r\n    }\r\n}\r\n```\n\n### Risks\n\nThis would probably need to be considered for addition in .NET 5.0.x and 6.0 so Paint.NET can use it.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eAraHaan\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-AssemblyLoader-coreclr`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-07-29T01:39:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc40-THj",
                                           "createdAt":  "2021-07-29T02:16:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Like for example you try to load an assembly in AssemblyLoadContext that uses a type in System.Windows.Forms.dll that does not exist anymore on .NET 5\r\n\r\nWhy is it not an option to recompile these assemblies for .NET 5? It would be highly preferable to trying to patch things up at runtime.\r\n\r\n\u003e .NET 5.0.x and 6.0\r\n\r\nNot going to happen - too late to consider.",
                                           "updatedAt":  "2021-07-29T02:16:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc40-UKI",
                                           "createdAt":  "2021-07-29T02:28:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AraHaan",
                                           "body":  "\u003e \u003e Like for example you try to load an assembly in AssemblyLoadContext that uses a type in System.Windows.Forms.dll that does not exist anymore on .NET 5\r\n\u003e \r\n\u003e Why is it not an option to recompile these assemblies for .NET 5? It would be highly preferable to trying to patch things up at runtime.\r\n\u003e \r\n\u003e \u003e .NET 5.0.x and 6.0\r\n\u003e \r\n\u003e Not going to happen - too late to consider.\r\n\r\nBecause not always are these assemblies able to be recompiled (in terms of plugins for Paint.NET some of them are covered under their own copyrights), some are unmaintained, and some are outright not open source + has a copyright preventing one from decompiling and recompiling it for .NET 5+ (well in a way that is legal / does not violate it\u0027s EULA that is) + unmaintained.",
                                           "updatedAt":  "2021-07-29T02:28:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc46m9AA",
                                           "createdAt":  "2021-12-01T05:00:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AraHaan",
                                           "body":  "Could this be possibly looked into for .NET 7?",
                                           "updatedAt":  "2021-12-01T05:00:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc46nEg2",
                                           "createdAt":  "2021-12-01T06:09:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "I doubt that we will ever add this feature.\r\n\r\nIt has very complex interactions with many parts of the system, the motivating scenario is very niche, and the feature does not address it completely - there can be also missing methods, missing interfaces, and behavior changes to patch. Patching the IL is the only way reasonable way to shim for all these incompatibilities.",
                                           "updatedAt":  "2021-12-01T06:09:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc46os7i",
                                           "createdAt":  "2021-12-01T15:22:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AraHaan",
                                           "body":  "True, but patching the IL is sometimes impossible if R2R is involved without needing to strip R2R first.\r\n\r\nAs for missing members, one can catch the ``MemberNotFoundException`` and then read the message for the missing \"type\", then load an assembly that stubs those missing members (assuming they are not static ones) from another assembly that adds them back using extension methods, and then retry the call. However doing that properly is almost impossible to do as well on that one so I agree with that part.",
                                           "updatedAt":  "2021-12-01T15:23:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5PBcDg",
                                           "createdAt":  "2022-11-23T23:48:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rickbrew",
                                           "body":  "@AraHaan, collectible `AssemblyLoadContext`s ignore R2R data, https://github.com/dotnet/runtime/blob/main/docs/design/features/unloadability.md (see \"Unsupported Scenarios\")",
                                           "updatedAt":  "2022-11-23T23:48:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5gugrG",
                                           "createdAt":  "2023-07-06T01:51:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wasabii",
                                           "body":  "I want to add something onto this. We (the IKVM project) make great use of AppDomain.TypeResolve to generate types in dynamic assemblies on the fly as required by the runtime. While we don\u0027t do things like patch and rename types: we generate them exactly as requested, it is worrying that the API hasn\u0027t been moved from AppDomain. It speaks to the existing functionality maybe not being something that folks are committed to for the long term.\r\n\r\nThe ability to do this is pretty core to IKVM.\r\n\r\nI would like to see TypeResolve moved off AppDomain some day. It would make me a bit more confident it was something that was going to stick around.",
                                           "updatedAt":  "2023-07-06T01:51:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5gvHto",
                                           "createdAt":  "2023-07-06T04:39:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "The events (including TypeResolve event) on AppDomain type are not going anywhere. We have stopped introducing their duplicates with better names when the AppDomain type was re-introduced with .NET Standard 2.0.\r\n\r\nFor example, see the discussion about UnhandledException at https://github.com/dotnet/runtime/issues/16468#issuecomment-251832080 .\r\n\r\nIf you would like to see the earlier decision re-evaluated and propose duplicates for events on AppDomain type somewhere else, it would be best to start a new discussion issue about it.",
                                           "updatedAt":  "2023-07-06T04:39:23Z"
                                       }
                                   ],
                         "totalCount":  9
                     },
        "title":  "[API Proposal]: Add TypeResolve event to AssemblyLoadContext",
        "labels":  [
                       "api-suggestion",
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/56612",
        "createdAt":  "2021-07-30T09:48:03Z",
        "number":  56612,
        "author":  "TheCakeMonster",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCzHpUw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "charlesroddie",
                                            "createdAt":  "2023-10-07T11:54:35Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2023-10-09T11:24:54Z",
        "body":  "An issue was raised to have DynamicallyAccessedMembersAttribute exposed for use by libraries targeting downlevel runtimes, allowing .NET Standard libraries to have the appropriate behaviours applied by the linker.\r\n\r\nhttps://github.com/dotnet/runtime/issues/36656\r\n\r\nThe decision was that this need not be done. One commenter stated that .NET 5 is the new .NET Standard, but that isn\u0027t true in the wider world - many people have systems that span .NET Framework and .NET Core, and .NET 5 (and even .NET Standard 2.1) ignores the existence of .NET Framework and the legacy world from which our systems are slowly migrating - slowly being the operative word.\r\n\r\nDevelopment teams need their code to be compatible with .NET Framework for some time to come, and the fewer hoops there are to jump through to achieve it, the better. Code in shared libraries that are used on both .NET Framework and .NET Core should continue to compile for .NET Standard 2.0 for an extended period, as we need time to move away from .NET Framework, whilst continuing to add newer features to that code that only impact the behaviour when running on .NET Core.\r\n\r\nThe post says that there is a way to overcome the problem, but it isn\u0027t clear to me exactly what that is. The quotation which suggests this says \"compile internal versions of these attributes into the library\". Can someone help us understand what that means, and indeed whether it is possible to create a .NET Standard library that does this, for everyone to reference and use?\r\n\r\nThere are two possible outcomes of this issue that would resolve the request:\r\n1. A blog post that is easily discoverable, and shows how to overcome this and make .NET Standard 2.0 libraries linker friendly\r\n2. A .NET Standard library package being published that people can reference to achieve the desired result, if this is technically feasible\r\n\r\nThe solution probably lies in the way the attribute is recognised. The text seems to suggest that another attribute could be created and still be recognised as being the same attribute, despite residing in a different assembly. Is that true? That doesn\u0027t feel right somehow; I would have expected an attribute with the same name in a different assembly to be unrecognised by the linker.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOaHoAcg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc41CqHE",
                                           "createdAt":  "2021-07-30T13:20:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nAn issue was raised to have DynamicallyAccessedMembersAttribute exposed for use by libraries targeting downlevel runtimes, allowing .NET Standard libraries to have the appropriate behaviours applied by the linker.\r\n\r\nhttps://github.com/dotnet/runtime/issues/36656\r\n\r\nThe decision was that this need not be done. One commenter stated that .NET 5 is the new .NET Standard, but that isn\u0027t true in the wider world - many people have systems that span .NET Framework and .NET Core, and .NET 5 (and even .NET Standard 2.1) ignores the existence of .NET Framework and the legacy world from which our systems are slowly migrating - slowly being the operative word.\r\n\r\nDevelopment teams need their code to be compatible with .NET Framework for some time to come, and the fewer hoops there are to jump through to achieve it, the better. Code in shared libraries that are used on both .NET Framework and .NET Core should continue to compile for .NET Standard 2.0 for an extended period, as we need time to move away from .NET Framework, whilst continuing to add newer features to that code that only impact the behaviour when running on .NET Core.\r\n\r\nThe post says that there is a way to overcome the problem, but it isn\u0027t clear to me exactly what that is. The quotation which suggests this says \"compile internal versions of these attributes into the library\". Can someone help us understand what that means, and indeed whether it is possible to create a .NET Standard library that does this, for everyone to reference and use?\r\n\r\nThere are two possible outcomes of this issue that would resolve the request:\r\n1. A blog post that is easily discoverable, and shows how to overcome this and make .NET Standard 2.0 libraries linker friendly\r\n2. A .NET Standard library package being published that people can reference to achieve the desired result, if this is technically feasible\r\n\r\nThe solution probably lies in the way the attribute is recognised. The text seems to suggest that another attribute could be created and still be recognised as being the same attribute, despite residing in a different assembly. Is that true? That doesn\u0027t feel right somehow; I would have expected an attribute with the same name in a different assembly to be unrecognised by the linker.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eTheCakeMonster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-07-30T13:20:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41D4Xk",
                                           "createdAt":  "2021-07-30T22:14:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "The tools recognize the attributes only by the namespace + type name - no matter which assembly it came from. \r\nAll you need to do is define the attribute in your assembly.\r\nWe do this for our NuGet packages which target netstandard as well: https://github.com/dotnet/runtime/blob/3bd0acf30587c88a1448a51a852871e3407aff5f/src/libraries/Microsoft.Extensions.Hosting/src/Microsoft.Extensions.Hosting.csproj#L21-L25\r\n\r\nWe do it by compiling the source file for that attribute into the library - you can copy the source file from the github repo and do the same.\r\n\r\n/cc @eerhardt \r\n\r\nYou\u0027re definitely right that this needs some kind of doc or guidance.",
                                           "updatedAt":  "2021-07-30T22:14:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41D4ew",
                                           "createdAt":  "2021-07-30T22:14:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to \u0027linkable-framework\u0027: @eerhardt, @vitek-karas, @LakshanF, @sbomer, @joperezr\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nAn issue was raised to have DynamicallyAccessedMembersAttribute exposed for use by libraries targeting downlevel runtimes, allowing .NET Standard libraries to have the appropriate behaviours applied by the linker.\r\n\r\nhttps://github.com/dotnet/runtime/issues/36656\r\n\r\nThe decision was that this need not be done. One commenter stated that .NET 5 is the new .NET Standard, but that isn\u0027t true in the wider world - many people have systems that span .NET Framework and .NET Core, and .NET 5 (and even .NET Standard 2.1) ignores the existence of .NET Framework and the legacy world from which our systems are slowly migrating - slowly being the operative word.\r\n\r\nDevelopment teams need their code to be compatible with .NET Framework for some time to come, and the fewer hoops there are to jump through to achieve it, the better. Code in shared libraries that are used on both .NET Framework and .NET Core should continue to compile for .NET Standard 2.0 for an extended period, as we need time to move away from .NET Framework, whilst continuing to add newer features to that code that only impact the behaviour when running on .NET Core.\r\n\r\nThe post says that there is a way to overcome the problem, but it isn\u0027t clear to me exactly what that is. The quotation which suggests this says \"compile internal versions of these attributes into the library\". Can someone help us understand what that means, and indeed whether it is possible to create a .NET Standard library that does this, for everyone to reference and use?\r\n\r\nThere are two possible outcomes of this issue that would resolve the request:\r\n1. A blog post that is easily discoverable, and shows how to overcome this and make .NET Standard 2.0 libraries linker friendly\r\n2. A .NET Standard library package being published that people can reference to achieve the desired result, if this is technically feasible\r\n\r\nThe solution probably lies in the way the attribute is recognised. The text seems to suggest that another attribute could be created and still be recognised as being the same attribute, despite residing in a different assembly. Is that true? That doesn\u0027t feel right somehow; I would have expected an attribute with the same name in a different assembly to be unrecognised by the linker.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eTheCakeMonster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`, `linkable-framework`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-07-30T22:14:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41GVev",
                                           "createdAt":  "2021-08-02T08:58:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "TheCakeMonster",
                                           "body":  "@vitek-karas Thank you, that\u0027s very useful information.\r\n\r\nI\u0027m having some difficulty on a theoretical level understanding how this would work at runtime. Is there a danger of a type clash when the .NET Standard library executes within an application that targets .NET 5.0?\r\n\r\nIf there is no danger of a type clash - a duplicate type being detected when the type executes - then is there any reason why the attributes could not be put into .NET Standard 2.0 library and distributed as a Nuget package to be shared by multiple .NET Standard libraries?",
                                           "updatedAt":  "2021-08-02T08:58:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41ID9C",
                                           "createdAt":  "2021-08-02T20:18:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "eerhardt",
                                           "body":  "\u003e Is there a danger of a type clash when the .NET Standard library executes within an application that targets .NET 5.0?\r\n\r\nNo, at runtime they are 2 different types - even though they have the same name. Since they came from 2 different assemblies, they are different types.\r\n\r\n\u003e  then is there any reason why the attributes could not be put into .NET Standard 2.0 library and distributed as a Nuget package to be shared by multiple .NET Standard libraries?\r\n\r\nSee \r\n* https://github.com/dotnet/runtime/issues/36656#issuecomment-630345623\r\n* https://github.com/dotnet/runtime/issues/36656#issuecomment-630385303",
                                           "updatedAt":  "2021-08-02T20:18:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41aTyW",
                                           "createdAt":  "2021-08-10T14:42:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "TheCakeMonster",
                                           "body":  "Thanks for the help everyone. I have it working as described - well, the behaviour is consistent between .NET Standard and .NET 5 libraries anyway. It isn\u0027t quire doing what I expected, but that\u0027s a topic for another issue.\r\n\r\nI\u0027ve left this open solely as there is some opportunity for documentation of this feature in relation to .NET Standard.",
                                           "updatedAt":  "2021-08-10T14:42:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5cRQMi",
                                           "createdAt":  "2023-05-15T14:56:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "weifenluo",
                                           "body":  "There should be packed into a source only package similar to [Nullable](https://github.com/manuelroemer/Nullable), which allows you to use .NET\u0027s nullable attributes in older target frameworks like .NET Standard 2.0 or the \"old\" .NET Framework.",
                                           "updatedAt":  "2023-05-15T14:56:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5cRvtA",
                                           "createdAt":  "2023-05-15T16:12:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC7w8Yw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "weifenluo",
                                                                               "createdAt":  "2023-05-15T23:58:39Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "eerhardt",
                                           "body":  "@weifenluo - https://github.com/Sergio0694/PolySharp has the trimming attributes (and a lot more).",
                                           "updatedAt":  "2023-05-15T16:12:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5cUFNz",
                                           "createdAt":  "2023-05-15T23:55:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "weifenluo",
                                           "body":  "\r\n\r\n\r\n\r\n\u003e @weifenluo - https://github.com/Sergio0694/PolySharp has the trimming attributes (and a lot more).\r\n\r\nCool! using source generator is a brilliant idea compares to source only package - only needed code will be generated.",
                                           "updatedAt":  "2023-05-15T23:55:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5obYwx",
                                           "createdAt":  "2023-10-08T12:00:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEVVxkw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jamiewinder",
                                                                               "createdAt":  "2025-06-04T17:31:20Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "charlesroddie",
                                           "body":  "I\u0027ve pieced together some instructions on how to get these attributes in `netstandard2.0` with the help of this thread and @Sergio0694 .\r\n\r\n- Install the PolySharp package\r\n- Add `\u003cPolySharpIncludeRuntimeSupportedAttributes\u003etrue\u003c/PolySharpIncludeRuntimeSupportedAttributes\u003e` and `\u003cDefineConstants\u003eMULTI_TARGETING_SUPPORT_ATTRIBUTES\u003c/DefineConstants\u003e` to the proj file.\r\n- Create a test app as described in https://learn.microsoft.com/en-us/dotnet/core/deploying/trimming/prepare-libraries-for-trimming#show-all-warnings-with-test-app, ignoring the text `If library targets a TFM that is not trimmable, for example net472 or netstandard2.0, there\u0027s no benefit to creating a trimming test app.`.\r\n\r\nThis is not very hard if these instructions are known. These do need to be added to the various pages. Better would be to have a nuget package to access the attributes.\r\n\r\nThe current state without support and guidance, as decided in https://github.com/dotnet/runtime/issues/36656#issuecomment-662529466, does not make any sense.\r\n\r\nIt\u0027s not valid to say \"`net5.0` is the new `netstandard`\". Many libraries are only now moving to `netstandard2.0`. Anything higher than `netstandard2.0` is not appropriate now for most libraries and would generate a lot of complaints if they did that. This is partly due to consumers taking time to update platfoms, but also the fact that not all platforms support higher than `netstandard2.0`: the only Windows platform supporting AOT and `dotnet5+` is Avalonia and you can\u0027t expect all software to immediately switch to that. You also can\u0027t expect libraries to multitarget to get this feature as that introduces significant extra complexity.\r\n\r\nTrimming is now a standard expectation of libraries, but trimming support is made unnecessarily difficult by the lack of netstandard documentation/nuget package for annotations.",
                                           "updatedAt":  "2023-10-08T12:00:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5obnN_",
                                           "createdAt":  "2023-10-08T15:34:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "Our recommendation is to multi-target the library - so `netstandard2.0` and `net6.0` currently. With that you can choose to use 3 different options how to introduce the attributes to your code:\r\n* Use `#if` defs around the attributes, and only compile them in for `net6.0` target.\r\n* Use a copy of the attribute definitions and ifdef those for `netstadard2.0` and then just use the attributes\r\n* Use PolySharp (or something similar)\r\n\r\nThe multi-targeting has other benefits, it makes lot of libraries much smaller on `net6.0` targets. `netstandard2.0` libraries frequently have lot of dependencies on additional packages which are already part of `net6.0`. So apps using the library even on `net6.0` will keep those dependencies in their dependency graph.\r\n\r\nAlso - you don\u0027t really need the test app, it\u0027s a nice-to-have for lot of libraries. You can just add `IsTrimmable=true` to your project and it will turn on analyzers which will report the trim related warnings as well (but this assumed multi-targeting to `net6.0`, the analyzers won\u0027t work on `netstandard2.0` targets). The test app is useful to validate that your library dependencies are trim compatible (at least the part of them you\u0027re using).",
                                           "updatedAt":  "2023-10-08T15:34:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5oeK7t",
                                           "createdAt":  "2023-10-09T10:21:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "charlesroddie",
                                           "body":  "Adding a net6.0 multitarget without actually releasing it would be a good balance, in combination with polysharp, keeping simplicity of the release and development process while getting trimming annotations. It removes the need for a test library.\n\nLibraries currently moving from earlier frameworks to netstandard2.0-only will see large benefits of removing multitargeting, removing ifdefed code everywhere and only having one compile. Adding ifdefs to a solution means that you cannot see while you are developing whether your code typechecks (beyond the current target) - the greyed out code is not checked. I don\u0027t see how your library size argument applies since all the extras will get trimmed/linked out.",
                                           "updatedAt":  "2023-10-09T10:21:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5oegBy",
                                           "createdAt":  "2023-10-09T11:24:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "Multitargeting a library doesn\u0027t mean one has to add ifdefs to the code (the trim analysis attributes can be done without ifdefs, it\u0027s just one of the options which we\u0027ve seen people to prefer in some cases). I think I don\u0027t understand the second part of your comment...\r\n\r\nLibrary size argument is not for trimmed apps. The reality is that vast majority of apps are not using trimming and are not going to do that anytime soon. If those apps consume `netstandard2.0` libraries they will get all of those dependencies. I\u0027ve seen people \"complain\" about this already.\r\n\r\nAlso of note, this is not a trim-only problem. The nullable reference types feature has a similar problem - the `netstandard2.0` build of your library will see the framework assemblies without any nullable annotations, which typically means the compiler is going to give up on analyzing those parts. The best way to \"fix\" that is to build the code targeting `net6.0` or newer where the compiler will see fully annotated framework assemblies. Trimming is exactly the same problem, we just chose to disable the analyzer if the framework assemblies are not annotated as its value is very low in that case (and it could be \"lying\" in some places).",
                                           "updatedAt":  "2023-10-09T11:24:54Z"
                                       }
                                   ],
                         "totalCount":  13
                     },
        "title":  "Help required on using DynamicallyAccessedMembersAttribute in .NET Standard 2.0 Libraries",
        "labels":  [
                       "documentation",
                       "area-AssemblyLoader-coreclr",
                       "linkable-framework"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/57286",
        "createdAt":  "2021-08-12T14:49:10Z",
        "number":  57286,
        "author":  "jkotas",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-06-12T20:12:32Z",
        "body":  "`FEATURE_CASE_SENSITIVE_FILESYSTEM` is never defined. It means that the assembly loader ends up doing case-insensitive caching even on OSes that are naturally case-insensitive. It leads to odd behaviors like https://github.com/dotnet/runtime/pull/57237#discussion_r687736646 . \r\n\r\nRepro:\r\n1. Create a dummy `TestAssembly.dll` somewhere\r\n2. Run on Linux:\r\n```csharp\r\nAssembly.LoadFrom(@\"/path_to_test_assembly/TestAssembly.dll\");\r\n\r\n// This will succeed by using cached copy of TestAssembly.dll even though testassembly.dll does not actually exist on the case-sensitive filesystem\r\nAssembly.LoadFrom(@\"/path_to_test_assembly/testassembly.dll\");\r\n```\r\n\r\nNote that calling `Assembly.LoadFrom(@\"/path_to_test_assembly/testassembly.dll\");` without the previous LoadFrom call that populates the cache is going to fail.\r\n\r\nWe need to:\r\n- Decide whether whether to fix the current behavior. (Note that Mono does not have this bug, and that fixing it in CoreCLR would be a minor breaking change.)\r\n- Add tests for this scenario.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHONYHg0A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc41geDQ",
                                           "createdAt":  "2021-08-12T14:49:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n`FEATURE_CASE_SENSITIVE_FILESYSTEM` is never defined. It means that the assembly loader ends up doing case-insensitive caching even on OSes that are naturally case-insensitive. It leads to odd behaviors like https://github.com/dotnet/runtime/pull/57237#discussion_r687736646 . \r\n\r\nRepro:\r\n1. Create a dummy `TestAssembly.dll` somewhere\r\n2. Run on Linux:\r\n```csharp\r\nAssembly.LoadFrom(@\"/path_to_test_assembly/TestAssembly.dll\");\r\n\r\n// This will succeed by using cached copy of TestAssembly.dll even though it does not actually exist on the case-sensitive filesystem\r\nAssembly.LoadFrom(@\"/path_to_test_assembly/testassembly.dll\");\r\n```\r\n\r\nNote that calling `Assembly.LoadFrom(@\"/path_to_test_assembly/testassembly.dll\");` without the previous LoadFrom call that populates the cache is going to fail.\r\n\r\nWe need to:\r\n- Decide whether whether to fix the current behavior. (Note that Mono does not have this bug, and that fixing it in CoreCLR would be a minor breaking change.)\r\n- Add tests for this scenario.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejkotas\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-08-12T14:49:15Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Assembly loader cache is case-insensitive even on cache-sensitive file systems",
        "labels":  [
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/57408",
        "createdAt":  "2021-08-14T17:50:32Z",
        "number":  57408,
        "author":  "fschmied",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-06-26T20:26:30Z",
        "body":  "When using `dotnet-trace` to diagnose assembly loading issues, there are two events showing assembly loading extension points, `AssemblyLoadContextResolvingHandlerInvoked` and `AppDomainAssemblyResolveHandlerInvoked`. These events have a `HandlerName` item, which contains (only) the method name of the handler method. ([Docs here](https://docs.microsoft.com/en-us/dotnet/core/dependency-loading/collect-details#extension-points).)\r\n\r\nFor diagnosing why assembly loading behaves in a certain way in conjunction with frameworks, test runners, etc., it would be tremendously helpful if the `HandlerName` item could also include the full name of the type declaring the handler method. (Ideally, the assembly-qualified type name.)\r\n\r\nCould that possibly be added?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHONZSv4A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc41lK_g",
                                           "createdAt":  "2021-08-14T17:50:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nWhen using `dotnet-trace` to diagnose assembly loading issues, there are two events showing assembly loading extension points, `AssemblyLoadContextResolvingHandlerInvoked` and `AppDomainAssemblyResolveHandlerInvoked`. These events have a `HandlerName` item, which contains (only) the method name of the handler method. ([Docs here](https://docs.microsoft.com/en-us/dotnet/core/dependency-loading/collect-details#extension-points).)\r\n\r\nFor diagnosing why assembly loading behaves in a certain way in conjunction with frameworks, test runners, etc., it would be tremendously helpful if the `HandlerName` item could also include the full name of the type declaring the handler method. (Ideally, the assembly-qualified type name.)\r\n\r\nCould that possibly be added?\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003efschmied\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-08-14T17:50:36Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Add handler type name to the tracing events for diagnosing assembly loading extension points",
        "labels":  [
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/57714",
        "createdAt":  "2021-08-19T06:51:42Z",
        "number":  57714,
        "author":  "tedekeroth",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODBP5ww==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Cliabhach",
                                            "createdAt":  "2022-09-27T01:00:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "amyboose",
                                            "createdAt":  "2023-08-02T04:52:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "WeihanLi",
                                            "createdAt":  "2023-08-28T14:43:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "justmine66",
                                            "createdAt":  "2024-03-21T10:43:14Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Walter-Rector",
                                            "createdAt":  "2025-04-16T00:39:34Z"
                                        }
                                    ],
                          "totalCount":  5
                      },
        "updatedAt":  "2023-12-16T13:32:05Z",
        "body":  "### Description\r\nHello! This issue has previously been discussed here on GitHub, on StackOverflow and other sources on the Internet. For example, [on this thread on Github](https://github.com/dotnet/runtime/issues/11430), @jeffschwMSFT talked with the @WeihanLi. The exchange there is from 2018, but I am pretty sure it was incorrect or at least is incorrect today:\r\n\r\n@WeihanLi wrote on Nob 9 2018:\r\n\r\n\u003e I\u0027ve tried Assembly.GetEntryAssembly().GetReferencedAssemblies() and AppDomain.CurrentDomain.GetAssemblies(), but these methods seems to use to get assemblies that had loaded.\r\n\r\nand @jeffschwMSFT  answered:\r\n\r\n\u003e @WeihanLi can you help me understand why GetReferencedAssemblies did not work in your case? This should provide a view into the first level references for an assembly.\r\n\u003e \r\n\u003e If you are looking to get that information for the full assembly graph @steveharter is working on a proposal to view metadata information without loading the assemblies for execution.\r\n\r\nIn the GitHub thread linked above, @steveharter also chimes in, and says:\r\n\r\n\u003e Even if the assemblies have not been used yet, you can still call GetReferencedAssemblies as mentioned above. From those references, you can load the assembly(s) into the default app domain and perform reflection.\r\n\u003e \r\n\u003e If you do not want to load the assembly(s) into the default app domain, you can use the new MetadataLoadContext feature that will be available for 3.0.\r\n\u003e \r\n\r\nThis is in my view, incorrect, and I believe that there are misunderstandings in the discussion in the 2018 thread.\r\n\r\nUsing `GetReferencedAssemblies` does _not_ return the assemblies references in the project. It only returns the assemblies that are loaded, or at least used . If an assemblies is referenced, but no classes inside that assembliy is used, then the `GetReferencedAssemblies` does not return that assembly.\r\n\r\nThis is discussed, among other places, on StackOverflow in several posts, like [this one](https://stackoverflow.com/questions/3433973/getreferencedassemblies-doesnt-return-all-assemblies).\r\n\r\nBased on Jeffs and Steves answer in 2018, this seems like a bug; `GetReferencedAssemblies` should return all of the first-level assemblies referenced, regardless of if classes within them are used, or not, but it doesn\u0027t.\r\n\r\nI have provided [a GitHub repo](https://github.com/tedekeroth/GetRefAssembliesTest) where this problem can be viewed. In short, I have a console app, that references 2 other assemblies, but does not use any classes within those two assemblies. Running this code in the Main method, will _not_ get the referenced, but unused, assemblies:\r\n\r\n```\r\nstatic void Main(string[] args)\r\n{\r\n    var list = Assembly.GetEntryAssembly().GetReferencedAssemblies();\r\n    Console.WriteLine($\"Printing results from GetReferencedAssemblies():{Environment.NewLine}{string.Join(\", \", list.Select(a =\u003e a.Name)) }\");\r\n}\r\n```\r\n\r\nResults:\r\n\r\n```\r\nPrinting results from GetReferencedAssemblies():\r\nSystem.Runtime, System.Linq, System.Console\r\n```\r\nReferences are in place:\r\n![image](https://user-images.githubusercontent.com/10088477/130020986-cac1bb67-c596-4b54-8dc2-c53ac09f9cdc.png)\r\n\r\nIf I add a line so I use one, or both, classes in the ref assemblies, then the GetReferencedAssemblies will return them:\r\n\r\n```\r\nusing AssemblyA;\r\n....\r\nstatic void Main(string[] args)\r\n{\r\n    ClassA classA;\r\n    var list = Assembly.GetEntryAssembly().GetReferencedAssemblies();\r\n    Console.WriteLine($\"Printing results from GetReferencedAssemblies():{Environment.NewLine}{string.Join(\", \", list.Select(a =\u003e a.Name)) }\");\r\n}\r\n```\r\nResults:\r\n\r\n```\r\nPrinting results from GetReferencedAssemblies():\r\nSystem.Runtime, AssemblyA, System.Linq, System.Console\r\n```\r\n### Suggestion\r\nI believe that the function of GetReferencedAssemblies should change, and _always_ return the first-level references, regardless if they are used or not. Perhaps add an optional `bool`, like \r\n```\r\nGetReferencedAssemblies(bool returnReferencesRegardlessOfUsage = false)\r\n```\r\n\r\n;-)\r\n\r\n### Configuration\r\n\r\n.NET 5.0\r\nVisual Studio 2019 (16.11.1)\r\nWindows 10 x64\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHObstWmw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc41vjAS",
                                           "createdAt":  "2021-08-19T06:51:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\nHello! This issue has previously been discussed here on GitHub, on StackOverflow and other sources on the Internet. For example, [on this thread on Github](https://github.com/dotnet/runtime/issues/11430), @jeffschwMSFT talked with the @WeihanLi. The exchange there is from 2018, but I am pretty sure it was incorrect or at least is incorrect today:\r\n\r\n@WeihanLi wrote on Nob 9 2018:\r\n\r\n\u003e I\u0027ve tried Assembly.GetEntryAssembly().GetReferencedAssemblies() and AppDomain.CurrentDomain.GetAssemblies(), but these methods seems to use to get assemblies that had loaded.\r\n\r\nand @jeffschwMSFT  answered:\r\n\r\n\u003e @WeihanLi can you help me understand why GetReferencedAssemblies did not work in your case? This should provide a view into the first level references for an assembly.\r\n\u003e \r\n\u003e If you are looking to get that information for the full assembly graph @steveharter is working on a proposal to view metadata information without loading the assemblies for execution.\r\n\r\nIn the GitHub thread linked above, @steveharter also chimes in, and says:\r\n\r\n\u003e Even if the assemblies have not been used yet, you can still call GetReferencedAssemblies as mentioned above. From those references, you can load the assembly(s) into the default app domain and perform reflection.\r\n\u003e \r\n\u003e If you do not want to load the assembly(s) into the default app domain, you can use the new MetadataLoadContext feature that will be available for 3.0.\r\n\u003e \r\n\r\nThis is in my view, incorrect, and I believe that there are misunderstandings in the discussion in the 2018 thread.\r\n\r\nUsing `GetReferencedAssemblies` does _not_ return the assemblies references in the project. It only returns the assemblies that are loaded, or at least used . If an assemblies is referenced, but no classes inside that assembliy is used, then the `GetReferencedAssemblies` does not return that assembly.\r\n\r\nThis is discussed, among other places, on StackOverflow in several posts, like [this one](https://stackoverflow.com/questions/3433973/getreferencedassemblies-doesnt-return-all-assemblies).\r\n\r\nBased on Jeffs and Steves answer in 2018, this seems like a bug; `GetReferencedAssemblies` should return all of the first-level assemblies referenced, regardless of if classes within them are used, or not, but it doesn\u0027t.\r\n\r\nI have provided [a GitHub repo](https://github.com/tedekeroth/GetRefAssembliesTest) where this problem can be viewed. In short, I have a console app, that references 2 other assemblies, but does not use any classes within those two assemblies. Running this code in the Main method, will _not_ get the referenced, but unused, assemblies:\r\n\r\n```\r\nstatic void Main(string[] args)\r\n{\r\n    var list = Assembly.GetEntryAssembly().GetReferencedAssemblies();\r\n    Console.WriteLine($\"Printing results from GetReferencedAssemblies():{Environment.NewLine}{string.Join(\", \", list.Select(a =\u003e a.Name)) }\");\r\n}\r\n```\r\n\r\nResults:\r\n\r\n```\r\nPrinting results from GetReferencedAssemblies():\r\nSystem.Runtime, System.Linq, System.Console\r\n```\r\nReferences are in place:\r\n![image](https://user-images.githubusercontent.com/10088477/130020986-cac1bb67-c596-4b54-8dc2-c53ac09f9cdc.png)\r\n\r\nIf I add a line so I use one, or both, classes in the ref assemblies, then the GetReferencedAssemblies will return them:\r\n\r\n```\r\nusing AssemblyA;\r\n....\r\nstatic void Main(string[] args)\r\n{\r\n    ClassA classA;\r\n    var list = Assembly.GetEntryAssembly().GetReferencedAssemblies();\r\n    Console.WriteLine($\"Printing results from GetReferencedAssemblies():{Environment.NewLine}{string.Join(\", \", list.Select(a =\u003e a.Name)) }\");\r\n}\r\n```\r\nResults:\r\n\r\n```\r\nPrinting results from GetReferencedAssemblies():\r\nSystem.Runtime, AssemblyA, System.Linq, System.Console\r\n```\r\n### Suggestion\r\nI believe that the function of GetReferencedAssemblies should change, and _always_ return the first-level references, regardless if they are used or not. Perhaps add an optional `bool`, like \r\n```\r\nGetReferencedAssemblies(bool returnReferencesRegardlessOfUsage = false)\r\n```\r\n\r\n;-)\r\n\r\n### Configuration\r\n\r\n.NET 5.0\r\nVisual Studio 2019 (16.11.1)\r\nWindows 10 x64\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003etedekeroth\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-08-19T06:51:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41wO0o",
                                           "createdAt":  "2021-08-19T11:27:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODFXc2w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Tinyakov",
                                                                               "createdAt":  "2023-08-31T09:55:17Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "I think the main confusion comes from terminology.\r\n\r\nFrom the runtime\u0027s perspective \"assembly reference\" is a piece of metadata in the IL of an assembly which declares a reference to another assembly (by name - not path).\r\nFrom the project system\u0027s perspective \"project reference\" is an MSBuild item which tells the build that it should use that project as a dependency and enable the main project to access its code.\r\n\r\nThe project reference does many things, but mostly these are relevant for the discussion:\r\n* It declares a build dependency - so that the referenced project is built before the main project and also (without additional modifiers) the output of the referenced project is made part of the main project\u0027s output (if it\u0027s an app).\r\n* It passes the built assembly from the referenced project as a \"compile time reference\" to the compiler of the main project. This allows the main project to call methods from the referenced project.\r\n\r\nThe compile time reference just tells the compiler to consider a given assembly when it\u0027s resolving symbols. There\u0027s no obligation for the compiler to turn the \"compile time reference\" into an \"assembly reference\" in the output IL. Note that if it did do that, the output of your sample would print out all assemblies in the framework (since all the framework assemblies are by default added as compile time references for you, so that you can call any code from the framework without explicitly declaring a reference to its assembly). The current behavior of the C# compiler is to only output assembly references which are actually used by the code in the output IL (among other things this makes the output smaller and slightly faster to load at runtime).\r\n\r\nIf I understand the request correctly, you\u0027re looking for a way to enumerate all assemblies which are part of the application. It\u0027s possible to use [DependencyContext](https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencymodel.dependencycontext?view=dotnet-plat-ext-5.0) from the `Microsoft.Extensions.DependencyModel` NuGet package. If you access the `Default` property (singleton) it will return the dependency context for the currently running application. I think the `RuntimeLibraries` is basically the list of assemblies in the app (it\u0027s been a while I played with this API).\r\n\r\nNote that this NuGet package has some limitations, for example it doesn\u0027t work in some deployment models like single-file apps, Xamarin or Blazor and potentially others. But it should work for console apps (non-single-file) and similar.",
                                           "updatedAt":  "2021-08-19T11:27:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41ypC1",
                                           "createdAt":  "2021-08-20T06:37:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODNL7_w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "imhmdi",
                                                                               "createdAt":  "2023-11-21T07:57:24Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "tedekeroth",
                                           "body":  "Hello, and thanks for the reply and clarification!\r\n\r\nEven though I (basically) understand the difference you are taking about, I still suggest that the method return the actual references, \"MSBuild items\", and not what the IL knows. This is probably what almost all developers expect and what the name of the method says it will do.\r\n\r\nPerhaps something as simple as:\r\n\r\n`Assembly.GetEntryAssembly().GetReferencedAssemblies();` - Gets the \"MS Build items\", so what the developer has added as references in design time\r\n`Assembly.GetEntryAssembly().GetReferencedAndUsedAssemblies();` - Gets the \"compile time references\"\r\n\r\nNow, this would change the behaviour of `GetReferencedAssemblies()`, so another non-breaking change would be something along the lines of my initial suggestion:\r\n\r\n`GetReferencedAssemblies(bool returnMsBuildReferences = false)` \r\n\r\nthe bool variable name could probably be improved ;-)\r\n\r\n",
                                           "updatedAt":  "2021-08-20T06:38:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41zJeM",
                                           "createdAt":  "2021-08-20T10:34:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODCtDkA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "mariusz96",
                                                                               "createdAt":  "2023-08-04T11:58:28Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "\u003e This is probably what almost all developers expect and what the name of the method says it will do.\r\n\r\nI do understand the potential confusion here, but I think it\u0027s important to note the difference in terminology. MSBuild talks about \"Project Reference\", while this API talks about \"Assembly Reference\". Another reason is that these APIs are in the `System.Reflection` namespace - which is intended to implement behaviors as defined by the IL/runtime. Different compilers and project systems will see things slightly differently - and that\u0027s OK.\r\n\r\nI do agree that there\u0027s a need for an API to enumerate all assemblies which are part of the app (although defining what this actually means is somewhat tricky). I don\u0027t think this API should be associated with `System.Reflection` namespace.",
                                           "updatedAt":  "2021-08-20T10:34:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41zZLg",
                                           "createdAt":  "2021-08-20T12:44:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tedekeroth",
                                           "body":  "I think we are on the same page =) But, the docs are not very clear. Sure, it says \"Gets the AssemblyName objects for all the assemblies referenced by this assembly.\", but it isn\u0027t obvious that it should be interpreted as you describe.\r\n\r\nYou are right - this other form of GetProjectReferences might not belong in the Reflection namespace, but perhaps you can find a suitable location for it, cause I think it is needed, especially for those applications that rely on Reflection, and thus won\u0027t directly use the classes in the references assemblies.\r\n\r\nThanks for your time and input.",
                                           "updatedAt":  "2021-08-20T12:44:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5jCGsC",
                                           "createdAt":  "2023-08-02T04:57:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "amyboose",
                                           "body":  "As Microsoft moves towards the introduction of AOT, this feature becomes even more relevant. I guess DependencyContext won\u0027t work in AOT and another approach is needed to get a list of all libraries",
                                           "updatedAt":  "2023-08-02T04:57:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5lEauN",
                                           "createdAt":  "2023-08-28T12:59:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "emphasis87",
                                           "body":  "Is there a way to enforce inclusion of an assembly in loosely coupled scenarios? I have some metadata which I would like to reference separately, but they do not carry any code and would like to load them at startup. I believe this was possible in .net4x.",
                                           "updatedAt":  "2023-08-28T12:59:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5lfXXZ",
                                           "createdAt":  "2023-09-01T13:06:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "\u003e As Microsoft moves towards the introduction of AOT, this feature becomes even more relevant. I guess DependencyContext won\u0027t work in AOT and another approach is needed to get a list of all libraries\r\n\r\n@amyboose I think the right question here is what is the scenario where this is useful - especially in AOTed application. ALl AOTed applications are also trimmed, and so even if you could enumerate all assemblies in the app, there wouldn\u0027t be much you could do with them. For example, calling `Assembly.GetType` or `Assembly.GetTypes` is VERY trim incompatible and the code is effectively guaranteed to break in trimmed/AOTed application.\r\n\r\nI think the primary scenario where having a new API would be helpful is single-file deployments where all of the typical scenarios for this enumeration (automatic plugin loading, DI services discovery, ...) would still work through reflection. That said, if we defined such API it should work in all targets, I just don\u0027t see AOT as a driving force for it.",
                                           "updatedAt":  "2023-09-01T13:06:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5lfX_2",
                                           "createdAt":  "2023-09-01T13:08:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "\u003e Is there a way to enforce inclusion of an assembly in loosely coupled scenarios? I have some metadata which I would like to reference separately, but they do not carry any code and would like to load them at startup. I believe this was possible in .net4x.\r\n\r\n@emphasis87 I\u0027m sorry, I don\u0027t really understand the scenario/question here. Could you maybe describe this in a short sample or something like that? Specifically, who/what/how are the \"loosely coupled\" assemblies getting added to the app? And then how/when are you accessing them in the app?",
                                           "updatedAt":  "2023-09-01T13:08:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5lgV_0",
                                           "createdAt":  "2023-09-01T16:02:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "emphasis87",
                                           "body":  "\u003e @emphasis87 I\u0027m sorry, I don\u0027t really understand the scenario/question here. Could you maybe describe this in a short sample or something like that? Specifically, who/what/how are the \"loosely coupled\" assemblies getting added to the app? And then how/when are you accessing them in the app?\r\n\r\n@vitek-karas \r\nI have created a small example here:\r\nhttps://github.com/emphasis87/ExampleLooseCouplingAssembly\r\n\r\nThere are two projects:\r\nExample (with project dependency to Example.Data, uses embedded resources)\r\nExample.Data\r\n\r\nOn startup Example assembly does not list Example.Data in GetReferencedAssemblies, so I have to load it manually. Even after that it does not show up there. Which I think is a little bit odd.\r\n\r\nI would like to mark that project reference strongly, so it would not be discarded in this way.\r\n",
                                           "updatedAt":  "2023-09-01T16:02:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5lhKCs",
                                           "createdAt":  "2023-09-01T18:50:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "@emphasis87 the problem is that the C# compiler will not write an assembly reference into the compiled `Example.dll` if there\u0027s no need to have it there (as in, there\u0027s no actual reference to anything from that assembly). The code at runtime (`GetReferenceAssemblies`) simply enumerates what\u0027s in the IL (compiled assembly), and the `Example.Data` isn\u0027t there. You can check by looking at the compiled assemblies in some IL-inspection tool (ILDasm, or ILSpy for example).\r\n\r\nIf you add an actual reference to something from the assembly (like referencing a type, calling a method, ...) the compiler adds the assembly reference and the runtime will report it as expected.\r\n\r\nI don\u0027t know if there\u0027s some way to tell the compiler to include the assembly reference even if it\u0027s not needed.\r\n\r\n*Note: The main reason the compiler does this is the core framework. There are more than 100 assemblies in the framework for an ASP.NET app, without this optimization, each application assembly would have assembly reference to all of those 100+ assemblies. This has impact on size and runtime perf - even though it should be relatively small.*",
                                           "updatedAt":  "2023-09-01T18:50:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5uywFS",
                                           "createdAt":  "2023-12-16T11:44:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "johmarjac",
                                           "body":  "I have a similar issue. I am trying to create a plugin system for my wpf host app. The plugin assemblies are loaded using Assembly.LoadFrom from a different directory.\r\nMy plugins contain wpf user controls that are extending my host Application.\r\n\r\nHowever my plugin also references other libraries which are used in xaml (other user controls). My plugin can only load when I use any type of that plugins other dependency in c# Code. If I have a reference in xaml only, the compiler wont reference the dependency.\r\n\r\nWhy is that? ",
                                           "updatedAt":  "2023-12-16T11:44:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5uy1ab",
                                           "createdAt":  "2023-12-16T13:32:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "xaml uses strings to reference types and resolves these types using reflection at runtime. It is as if your C# code referenced types in other assemblies by calling `Type.GetType(\"TypeInOtherAssembly, OtherAssembly\")`. It is perfectly valid way to referenced types in other assemblies dynamically via reflection. These dynamic references won\u0027t show up in the set returned by `GetReferencedAssemblies()`.\r\n\r\n`GetReferencedAssemblies` is not a good API to base plugin system on.",
                                           "updatedAt":  "2023-12-16T13:32:03Z"
                                       }
                                   ],
                         "totalCount":  13
                     },
        "title":  "Usage of GetReferencedAssemblies does not return assemblies not used/loaded",
        "labels":  [
                       "question",
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/58313",
        "createdAt":  "2021-08-28T12:06:15Z",
        "number":  58313,
        "author":  "spoiledsport",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-09-13T14:10:58Z",
        "body":  "When attempting to instantiate a dynamic type hosted in a dynamic assembly from another type residing in another dynamic assembly, do not fire a TypeResolve event. Trying to create the type  fail with a TypeLoadException.\r\n\r\nThis issue is not present on Mono, and the type can be successfully created.\r\n\r\nA minimal reproduction code has been included which targets both the full framework and .NET Core.\r\n\r\nThis seems to be a bug in every .NET runtime I tried up to now. I see similar closed issue #10237\r\n\r\n* Which version of .NET is the code running on?\r\n\r\nMicrosoft.AspNetCore.All 2.1.29 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\nMicrosoft.AspNetCore.App 2.1.29 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\nMicrosoft.AspNetCore.App 3.1.18 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\nMicrosoft.AspNetCore.App 5.0.9 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\nMicrosoft.NETCore.App 2.1.29 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\nMicrosoft.NETCore.App 3.1.18 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\nMicrosoft.NETCore.App 5.0.9 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\nMicrosoft.WindowsDesktop.App 3.1.18 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\nMicrosoft.WindowsDesktop.App 5.0.9 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n\r\n* What OS and version, and what distro if applicable?\r\nWindows 10, Windows 11\r\n* What is the architecture (x64, x86, ARM, ARM64)?\r\nx64, x86\r\n\r\n[TypeResolveBug.cs.txt](https://github.com/dotnet/runtime/files/7070673/TypeResolveBug.cs.txt)\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHONrsfFg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc42GSSt",
                                           "createdAt":  "2021-08-28T12:06:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-08-28T12:06:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42HIhZ",
                                           "createdAt":  "2021-08-29T18:00:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nWhen attempting to instantiate a dynamic type hosted in a dynamic assembly from another type residing in another dynamic assembly, do not fire a TypeResolve event. Trying to create the type  fail with a TypeLoadException.\r\n\r\nThis issue is not present on Mono, and the type can be successfully created.\r\n\r\nA minimal reproduction code has been included which targets both the full framework and .NET Core.\r\n\r\nThis seems to be a bug in every .NET runtime I tried up to now. I see similar closed issue #10237\r\n\r\n* Which version of .NET is the code running on?\r\n\r\nMicrosoft.AspNetCore.All 2.1.29 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\nMicrosoft.AspNetCore.App 2.1.29 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\nMicrosoft.AspNetCore.App 3.1.18 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\nMicrosoft.AspNetCore.App 5.0.9 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\nMicrosoft.NETCore.App 2.1.29 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\nMicrosoft.NETCore.App 3.1.18 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\nMicrosoft.NETCore.App 5.0.9 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\nMicrosoft.WindowsDesktop.App 3.1.18 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\nMicrosoft.WindowsDesktop.App 5.0.9 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n\r\n* What OS and version, and what distro if applicable?\r\nWindows 10, Windows 11\r\n* What is the architecture (x64, x86, ARM, ARM64)?\r\nx64, x86\r\n\r\n[TypeResolveBug.cs.txt](https://github.com/dotnet/runtime/files/7070673/TypeResolveBug.cs.txt)\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003espoiledsport\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-08-29T18:00:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42ux8W",
                                           "createdAt":  "2021-09-13T14:10:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "I modified the repro to use `AssemblyBuilder.DefineDynamicAssembly` (as the `AppDomain` API is only available on .NET Framework).\r\n\r\nLeaving the repro otherwise as-is I see consistent behavior between both .NET Framework and .NET Core:\r\n* It triggers the `TypeResolve` event handler for `Bar`\r\n* Fails to load `Bar` type\r\n\r\nBut looking at the repro there seems to be a problem - the `Bar` type was never actually created. There\u0027s no call `TypeBuilder.CreateType` for that type. So I added `tb2.CreateType()` after the last line of `ilgen2.Emit...`\r\nWith this change the repro works without any exception (and no event handler is triggered either).\r\n\r\nMy understanding of the `TypeBuilder` API is that one must call `CreateType` before actually using the type at runtime. Mono\u0027s implementation is probably a bit more permissive. @lambdageek for comments on the Mono\u0027s behavior.",
                                           "updatedAt":  "2021-09-13T14:10:42Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "References from one dynamic assembly to another dynamic assembly sometimes do not result in an AppDomain.TypeResolve event",
        "labels":  [
                       "question",
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/58714",
        "createdAt":  "2021-09-06T08:04:35Z",
        "number":  58714,
        "author":  "krwq",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-07-06T17:51:54Z",
        "body":  "Currently when running app from the long path you need to prefix the path with `\\\\?\\` which is causing that `AppDomain.CurrentDomain.BaseDirectory` also starts with that. Some apps might pass the directory into component which doesn\u0027t expect it (in .NET Framework BaseDirectory could be an URI so some apps could have passed it into `Uri` which would throw if it encounters anything starting with `\\\\?\\`).\r\n\r\nSee https://github.com/dotnet/runtime/pull/58627#issuecomment-912630223 and https://github.com/dotnet/runtime/issues/58712 for more context ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHONnHvCQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc42ce8J",
                                           "createdAt":  "2021-09-06T08:04:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-09-06T08:04:38Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Consider stripping \\\\?\\ from AppDomain.CurrentDomain.BaseDirectory",
        "labels":  [
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/59546",
        "createdAt":  "2021-09-23T22:01:45Z",
        "number":  59546,
        "author":  "agocke",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC3QSPA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rgwood",
                                            "createdAt":  "2021-09-24T00:59:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "evorios",
                                            "createdAt":  "2024-04-16T11:06:26Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2023-07-25T17:28:37Z",
        "body":  "Right now there is guidance on how to write a plugin _host_, principally by using [AssemblyDependencyResolver](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.loader.assemblydependencyresolver?view=net-5.0).\r\n\r\nHowever, there is not a canonical solution for loading dependencies as a plugin, namely one which does not see or control the hierarchy of ALCs that may be loaded into the process.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHONzSZOg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc43NJhf",
                                           "createdAt":  "2021-09-23T22:01:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-09-23T22:01:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43NJk6",
                                           "createdAt":  "2021-09-23T22:02:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nRight now there is guidance on how to write a plugin _host_, principally by using [AssemblyDependencyResolver](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.loader.assemblydependencyresolver?view=net-5.0).\r\n\r\nHowever, there is not a canonical solution for loading dependencies as a plugin, namely one which does not see or control the hierarchy of ALCs that may be loaded into the process.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eagocke\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-09-23T22:02:16Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "ALCs are hard to use for plugins which may have extra dependencies.",
        "labels":  [
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/59825",
        "createdAt":  "2021-09-30T20:09:18Z",
        "number":  59825,
        "author":  "VSadov",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCykNag==",
                          "nodes":  [
                                        {
                                            "content":  "EYES",
                                            "user":  "huoyaoyuan",
                                            "createdAt":  "2023-09-13T05:43:36Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2024-05-04T08:29:56Z",
        "body":  "\r\nThe API takes a path to NI image and an optional assembly path.\r\n\r\nTwo issues:\r\n- we do a null-check on NI path, but otherwise ignore it since we can\u0027t do much about it. \r\n- we perform the bind using the optional assembly path, without null check, which might ungracefully fail. \r\n\r\nWe should null-check the assembly path and throw or return null, if throwing is a compat issue.\r\nPerhaps the API should be deprecated as well.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOfNEXQQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc43h4Zt",
                                           "createdAt":  "2021-09-30T20:09:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-09-30T20:09:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43h4c_",
                                           "createdAt":  "2021-09-30T20:09:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n\r\nThe API takes a path to NI image and an optional assembly path.\r\n\r\nTwo issues:\r\n- we do a null-check on NI path, but otherwise ignore it since we can\u0027t do much about it. \r\n- we perform the bind using the optional assembly path, without null check, which might ungracefully fail. \r\n\r\nWe should null-check the assembly path and throw or return null, if throwing is a compat issue.\r\nPerhaps the API should be deprecated as well.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eVSadov\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-09-30T20:09:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5OHxIS",
                                           "createdAt":  "2022-11-10T17:42:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "I was going to open an issue about obsoleting this. Passing `null` to the IL image fails with an `Internal CLR error`. Can we obsolete it?\r\n\r\n```csharp\r\nnamespace System.Runtime.Loader;\r\n\r\npublic class AssemblyLoadContext\r\n{\r\n    [Obsolete(\"Native images are not supported.\", DiagnosticId = \"SYSLIB_NEXT\", UrlFormat = \"https://aka.ms/dotnet-warnings/{0}\")]\r\n    public Assembly LoadFromNativeImagePath(string nativeImagePath, string? assemblyPath);\r\n}\r\n```\r\n\r\nFor compatibility the method would just load `assemblyPath` and fail if it is `null`.",
                                           "updatedAt":  "2022-11-10T17:42:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc580RdB",
                                           "createdAt":  "2024-05-04T08:29:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "Touched and confused about this when implementing managed binder.",
                                           "updatedAt":  "2024-05-04T08:29:55Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "LoadFromNativeImagePath needs adjustment for not supporting NI images",
        "labels":  [
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/62735",
        "createdAt":  "2021-12-13T17:53:08Z",
        "number":  62735,
        "author":  "rolfbjarne",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-06-15T17:16:22Z",
        "body":  "### Description\n\nThe problem occurs with Xamarin.Mac apps, when:\r\n\r\n1. `System.Private.CoreLib.dll` is *not* next to libcoreclr.dylib\r\n2. We use `TRUSTED_PLATFORM_ASSEMBLIES` to tell CoreCLR where to find `System.Private.CoreLib.dll`.\r\n3. An executable (`*.exe`) is listed before `System.Private.CoreLib.dll` in `TRUSTED_PLATFORM_ASSEMBLIES`.\r\n\r\nLooking at the code, this is what I see:\r\n\r\n1. CoreCLR first tries to load System.Private.CoreLib.dll from the directory where libcoreclr.dylib is:\r\n\r\nhttps://github.com/dotnet/runtime/blob/3992fc3841133e15ad322842d35adb8c249a824f/src/coreclr/binder/assemblybinder.cpp#L381-L387\r\n\r\n2. When that fails, CoreCLR looks at `TRUSTED_PLATFORM_ASSEMBLIES`:\r\n\r\nhttps://github.com/dotnet/runtime/blob/3992fc3841133e15ad322842d35adb8c249a824f/src/coreclr/binder/assemblybinder.cpp#L393\r\n\r\niterating over all the paths therein:\r\n\r\nhttps://github.com/dotnet/runtime/blob/3992fc3841133e15ad322842d35adb8c249a824f/src/coreclr/binder/assemblybinder.cpp#L397\r\n\r\nand exiting the loop if something goes wrong:\r\n\r\nhttps://github.com/dotnet/runtime/blob/3992fc3841133e15ad322842d35adb8c249a824f/src/coreclr/binder/assemblybinder.cpp#L403-L407\r\n\r\nthe problem is that `dllOnly=true` is passed to the `GetNextTPAPath` function, and in that case, the `GetNextTPAPath` function returns a failure if it finds anything but a dll (such as an .exe):\r\n\r\nhttps://github.com/dotnet/runtime/blob/3992fc3841133e15ad322842d35adb8c249a824f/src/coreclr/binder/utils.cpp#L246-L247\r\n\r\nI tried looking for any docs specifying whether the entries in `TRUSTED_PLATFORM_ASSEMBLIES` need to be sorted in any way, but I couldn\u0027t find any mention of it.\n\n### Reproduction Steps\n\nI tried creating a repro from a simple console app, but that didn\u0027t work (didn\u0027t look like `TRUSTED_PLATFORM_ASSEMBLIES` is even looked at, but I didn\u0027t investigate much).\r\n\r\nI can create a rather complex test project with a Xamarin.Mac app, but that seems a bit overkill when I believe someone knowledgeable about CoreCLR should be able to create a simple test case pretty fast.\n\n### Expected behavior\n\nThe order of assemblies in `TRUSTED_PLATFORM_ASSEMBLIES` shouldn\u0027t matter.\n\n### Actual behavior\n\nIf exes come before dlls, then those dlls might not be found.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nPut dlls before exes in `TRUSTED_PLATFORM_ASSEMBLIES`.\n\n### Configuration\n\n.NET 6 (currently the 6.0-maui branch) + Xamarin.Mac\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHORPJW7Q==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc47K8Ym",
                                           "createdAt":  "2021-12-13T17:53:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\nThe problem occurs with Xamarin.Mac apps, when:\r\n\r\n1. `System.Private.CoreLib.dll` is *not* next to libcoreclr.dylib\r\n2. We use `TRUSTED_PLATFORM_ASSEMBLIES` to tell CoreCLR where to find `System.Private.CoreLib.dll`.\r\n3. An executable (`*.exe`) is listed before `System.Private.CoreLib.dll` in `TRUSTED_PLATFORM_ASSEMBLIES`.\r\n\r\nLooking at the code, this is what I see:\r\n\r\n1. CoreCLR first tries to load System.Private.CoreLib.dll from the directory where libcoreclr.dylib is:\r\n\r\nhttps://github.com/dotnet/runtime/blob/3992fc3841133e15ad322842d35adb8c249a824f/src/coreclr/binder/assemblybinder.cpp#L381-L387\r\n\r\n2. When that fails, CoreCLR looks at `TRUSTED_PLATFORM_ASSEMBLIES`:\r\n\r\nhttps://github.com/dotnet/runtime/blob/3992fc3841133e15ad322842d35adb8c249a824f/src/coreclr/binder/assemblybinder.cpp#L393\r\n\r\niterating over all the paths therein:\r\n\r\nhttps://github.com/dotnet/runtime/blob/3992fc3841133e15ad322842d35adb8c249a824f/src/coreclr/binder/assemblybinder.cpp#L397\r\n\r\nand exiting the loop if something goes wrong:\r\n\r\nhttps://github.com/dotnet/runtime/blob/3992fc3841133e15ad322842d35adb8c249a824f/src/coreclr/binder/assemblybinder.cpp#L403-L407\r\n\r\nthe problem is that `dllOnly=true` is passed to the `GetNextTPAPath` function, and in that case, the `GetNextTPAPath` function returns a failure if it finds anything but a dll (such as an .exe):\r\n\r\nhttps://github.com/dotnet/runtime/blob/3992fc3841133e15ad322842d35adb8c249a824f/src/coreclr/binder/utils.cpp#L246-L247\r\n\r\nI tried looking for any docs specifying whether the entries in `TRUSTED_PLATFORM_ASSEMBLIES` need to be sorted in any way, but I couldn\u0027t find any mention of it.\n\n### Reproduction Steps\n\nI tried creating a repro from a simple console app, but that didn\u0027t work (didn\u0027t look like `TRUSTED_PLATFORM_ASSEMBLIES` is even looked at, but I didn\u0027t investigate much).\r\n\r\nI can create a rather complex test project with a Xamarin.Mac app, but that seems a bit overkill when I believe someone knowledgeable about CoreCLR should be able to create a simple test case pretty fast.\n\n### Expected behavior\n\nThe order of assemblies in `TRUSTED_PLATFORM_ASSEMBLIES` shouldn\u0027t matter.\n\n### Actual behavior\n\nIf exes come before dlls, then those dlls might not be found.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nPut dlls before exes in `TRUSTED_PLATFORM_ASSEMBLIES`.\n\n### Configuration\n\n.NET 6 (currently the 6.0-maui branch) + Xamarin.Mac\n\n### Other information\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003erolfbjarne\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-12-13T17:53:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5E6A0Q",
                                           "createdAt":  "2022-06-15T06:51:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "agocke",
                                           "body":  "This is currently by-design. `System.Private.CoreLib.dll` must live next to coreclr, it is not intended to be configurable via `TRUSTED_PLATFORM_ASSEMBLIES`.",
                                           "updatedAt":  "2022-06-15T06:51:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5E6x7B",
                                           "createdAt":  "2022-06-15T09:56:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "I agree that SDK will always put CoreLib next to coreclr. But the runtime has code to be able to get the CoreLib path from TPA - and apparently that code gets confused if there\u0027s an .exe in TPA as well. Currently SDK should never get us into this situation, but we want other scenarios to work as well.\r\nI think it\u0027 would be worth it to look into fixing this - but the priority is relatively low (unless this causes problems for Xamarin?)\r\n\r\nJust curious: How did the `.exe` get there? Especially on macOS...",
                                           "updatedAt":  "2022-06-15T09:56:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5E6zUs",
                                           "createdAt":  "2022-06-15T10:01:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rolfbjarne",
                                           "body":  "When we build a universal app bundle, we have two different `System.Private.CoreLib.dll` assembly files (one for `osx-x64` and one for `osx-arm64`), and a single, universal `libcoreclr.dylib`.\r\n\r\nWe can\u0027t put both versions of `System.Private.CoreLib.dll` in the same directory, so we put them in a subdirectory, and use `TRUSTED_PLATFORM_ASSEMBLIES` to tell CoreCLR where to find it depending on the architecture at runtime (x64 or arm64).",
                                           "updatedAt":  "2022-06-15T10:01:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5E60WJ",
                                           "createdAt":  "2022-06-15T10:05:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rolfbjarne",
                                           "body":  "\u003e Just curious: How did the `.exe` get there? Especially on macOS...\r\n\r\nWhy wouldn\u0027t it?\r\n\r\nWe add all the assemblies in the app bundle to `TRUSTED_PLATFORM_ASSEMBLIES`, and .exes are assemblies.",
                                           "updatedAt":  "2022-06-15T10:05:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5E6-14",
                                           "createdAt":  "2022-06-15T10:44:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "\u003e and .exes are assemblies.\r\n\r\nWell - yes, but technically only .NET Framework should produce them. That\u0027s why I\u0027m curious - if this is something specific to some app, or potentially common.",
                                           "updatedAt":  "2022-06-15T10:44:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5E7BPo",
                                           "createdAt":  "2022-06-15T10:56:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rolfbjarne",
                                           "body":  "\u003e \u003e and .exes are assemblies.\r\n\u003e \r\n\u003e Well - yes, but technically only .NET Framework should produce them. That\u0027s why I\u0027m curious - if this is something specific to some app, or potentially common.\r\n\r\nI don\u0027t remember the exact scenario anymore.\r\n\r\nI was able to work around it fairly easy though (make sure any .exes come last in `TRUSTED_PLATFORM_ASSEMBLIES`), so it\u0027s not all that important for us.",
                                           "updatedAt":  "2022-06-15T10:56:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5E8lbt",
                                           "createdAt":  "2022-06-15T17:16:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "agocke",
                                           "body":  "\u003e When we build a universal app bundle,\r\n\r\nI see, if this is for universal binary support that might up the priority. ",
                                           "updatedAt":  "2022-06-15T17:16:22Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "Executables in TRUSTED_PLATFORM_ASSEMBLIES prevents finding any subsequent dlls",
        "labels":  [
                       "area-AssemblyLoader-coreclr",
                       "feature-request"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/64367",
        "createdAt":  "2022-01-27T02:49:43Z",
        "number":  64367,
        "author":  "VSadov",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-27T20:28:35Z",
        "body":  "Multimodule assemblies are not supported in CoreClr. That is a simple statement.\r\n\r\nHowever there are areas, like reflection or emit, where this is observable and we may need to be more detailed regarding the change. There is a possibility that instead of gracefully handling the situation, we may experience crashes or undefined behavior.\r\n\r\nWe need to review scenarios where multimodule assemblies could get involved in .net FX and.\r\n- document the expectations (most likely some kind of error)\r\n- add regression tests for that\r\n- fix bugs that may be discovered\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOPPaemg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc489p6a",
                                           "createdAt":  "2022-01-27T02:49:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nMultimodule assemblies are not supported in CoreClr. That is a simple statement.\r\n\r\nHowever there are areas, like reflection or emit, where this is observable and we may need to be more detailed regarding the change. There is a possibility that instead of gracefully handling the situation, we may experience crashes or undefined behavior.\r\n\r\nWe need to review scenarios where multimodule assemblies could get involved in .net FX and.\r\n- document the expectations (most likely some kind of error)\r\n- add regression tests for that\r\n- fix bugs that may be dioscovered\r\n\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eVSadov\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-01-27T02:49:46Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Review documentation and test coverage for multimodule assemblies",
        "labels":  [
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/66138",
        "createdAt":  "2022-03-03T11:43:06Z",
        "number":  66138,
        "author":  "RassK",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCTdgjA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pellared",
                                            "createdAt":  "2022-03-03T12:20:57Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pjanotti",
                                            "createdAt":  "2022-03-16T23:50:32Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rajkumar-rangaraj",
                                            "createdAt":  "2022-03-17T16:39:46Z"
                                        }
                                    ],
                          "totalCount":  3
                      },
        "updatedAt":  "2022-07-01T20:04:41Z",
        "body":  "We are looking for a way in .NET Core to control a dependency versioning. In previous .NET Framework it was easily possible via binding redirects but in .NET Core there is no way at all.\r\n\r\nOur library ([OpenTelemetry .NET Auto-Instrumentation](https://github.com/open-telemetry/opentelemetry-dotnet-instrumentation)) is attaching to the application. Unfortunately we cannot get away without dependencies. It\u0027s OK to vendor stateless libs but libraries like `System.Diagnostics.DiagnosticSource` contain a state that needs to be the same [instance] all over the boundaries. \r\n\r\nWe do use [AdditonalDeps](https://github.com/dotnet/runtime/blob/main/docs/design/features/additional-deps.md), but unfortunately it doesn\u0027t have priority over application. When dependency is left undefined, we can upgrade it to the necessary version.\r\n\r\nIf it raises performance / security concerns, we\u0027d appreciate if it\u0027s controllable via environment variable. DevOps can choose to opt in to this feature.\r\n\r\n![deps](https://user-images.githubusercontent.com/4929112/156556322-a2b58b85-6eb2-4860-a891-934ee77dee84.png)\r\n\r\n----\r\nCC: @nrcventura @pjanotti @pellared @zacharycmontoya @rajkumar-rangaraj ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOQIRVXA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc4_DzCe",
                                           "createdAt":  "2022-03-03T11:43:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-03-03T11:43:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_EQtj",
                                           "createdAt":  "2022-03-03T14:12:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e In previous .NET Framework it was easily possible via binding redirects but in .NET Core there is no way at all.\r\n\r\nIn .NET Framework, you had to edit the application config files to add the binding redirects. Would a solution that requires editing application config files work for you in .NET Core?",
                                           "updatedAt":  "2022-03-03T14:12:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_EUBw",
                                           "createdAt":  "2022-03-03T14:26:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "RassK",
                                           "body":  "\u003e \u003e In previous .NET Framework it was easily possible via binding redirects but in .NET Core there is no way at all.\r\n\u003e \r\n\u003e In .NET Framework, you had to edit the application config files to add the binding redirects. Would a solution that requires editing application config files work for you in .NET Core?\r\n\r\nThe way that requires editing existing config file isn\u0027t perfect, but definitely one way to do it.\r\nWe need this to be full devops scenario. So overwriting the config file moves some complexity to a client\u0027s CI pipline, which isn\u0027t exactly great, as we need to provide info how to do it exactly and there are loads of different CI systems out there.",
                                           "updatedAt":  "2022-03-03T16:05:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_Eory",
                                           "createdAt":  "2022-03-03T15:48:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nWe are looking for a way in .NET Core to control a dependency versioning. In previous .NET Framework it was easily possible via binding redirects but in .NET Core there is no way at all.\r\n\r\nOur library ([OpenTelemetry .NET Auto-Instrumentation](https://github.com/open-telemetry/opentelemetry-dotnet-instrumentation)) is attaching to the application. Unfortunately we cannot get away without dependencies. It\u0027s OK to vendor stateless libs but libraries like `System.Diagnostics.DiagnosticSource` contain a state that needs to be the same [instance] all over the boundaries. \r\n\r\nWe do use [AdditonalDeps](https://github.com/dotnet/runtime/blob/main/docs/design/features/additional-deps.md), but unfortunately it doesn\u0027t have priority over application. When dependency is left undefined, we can upgrade it to the necessary version.\r\n\r\nIf it raises performance / security concerns, we\u0027d appreciate if it\u0027s controllable via environment variable. DevOps can choose to opt in to this feature.\r\n\r\n![deps](https://user-images.githubusercontent.com/4929112/156556322-a2b58b85-6eb2-4860-a891-934ee77dee84.png)\r\n\r\n----\r\nCC: @nrcventura @pjanotti @pellared @zacharycmontoya @rajkumar-rangaraj \n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eRassK\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-03-03T15:48:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_E6zH",
                                           "createdAt":  "2022-03-03T16:50:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e The way that requires editing existing config file isn\u0027t perfect, but definitely one way to do it.\r\n\r\nI think that is the best way to do it. There is a lot of policy that goes into patching application dependencies. For example, what happens if the application bundles a private build of System.Diagnostics.DiagnosticSource? Editing the application, or even better - telling the application to reference the required version of `System.Diagnostics.DiagnosticSource` in the first place, is the most flexible solution that allows you to deal with all corner cases and produce the right diagnostic for it.",
                                           "updatedAt":  "2022-03-03T16:50:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_FMH1",
                                           "createdAt":  "2022-03-03T17:55:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "RassK",
                                           "body":  "The one option is to reuse additional-deps.json and do merge action with application deps, with highest version win. If that happens early enough, then it should be the same, as modifying application deps directly. This way could also benefit plugin based systems, if there is no need to update core system\u0027s deps. Currently some systems I know are using an extra restart to fix this issue.\r\n\r\nJust from architectural point of view, I would keep dependencies config close to it\u0027s logic. Instead of doing pre merge with main application. \r\n\r\n",
                                           "updatedAt":  "2022-03-03T17:55:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_Fhom",
                                           "createdAt":  "2022-03-03T19:33:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCTUoAQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "RassK",
                                                                               "createdAt":  "2022-03-03T20:16:36Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pellared",
                                                                               "createdAt":  "2022-03-09T10:32:18Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "rajkumar-rangaraj",
                                                                               "createdAt":  "2022-03-14T21:57:54Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pjanotti",
                                                                               "createdAt":  "2022-03-16T23:57:16Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "nrcventura",
                                           "body":  "We haven\u0027t fully explored or tried to address this problem yet, but users of [OpenTelemetry .NET Auto-Instrumentation](https://github.com/open-telemetry/opentelemetry-dotnet-instrumentation) may not always have access to an application config (depending on which type of application config you are referring to). Consider a tool like Sharepoint or SiteCore (ignoring whether it runs on .NET Framework or .NET for now), these tools are installed and are then used to serve up content. Many times the users of these tools are not writing or publishing code. However, it is still desirable to extract the telemetry data of these tools to ensure that they are running in the way the users are expected them to run (which is the purpose of [OpenTelemetry .NET Auto-Instrumentation](https://github.com/open-telemetry/opentelemetry-dotnet-instrumentation)). As a result, someone who maintains the installation of these tools needs a way to configure the system either through environment variables or some sort of config file, so that these dependencies can be managed appropriately without requiring rebuilding the application or updating some CI pipeline.",
                                           "updatedAt":  "2022-03-03T19:33:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_ngCQ",
                                           "createdAt":  "2022-03-14T21:35:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "Performing a silent upgrade of a library in an existing application has a good chance of breaking the application. We do not guarantee dotnet runtime libraries to be bug-for-bug compatibility between major versions. Also, AOT compilation of the application may make assumptions about the exact versions of the libraries used by the app.\r\n\r\nThe high compatible option for auto-instrumentation solutions is to work with the library versions included in the application, without upgrading them. It means that the auto-instrumentation solution may need to have multiple code paths to deal with different library versions included in the application. ",
                                           "updatedAt":  "2022-03-14T21:35:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_rO8r",
                                           "createdAt":  "2022-03-15T18:07:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "RassK",
                                           "body":  "\u003e Performing a silent upgrade of a library in an existing application has a good chance of breaking the application\r\n\r\nBut the silent upgrade is used anyway in the build time?\r\nLooking at the example \u003e\r\nApp -\u003e Library 1 -\u003e Dependency X (Version 1)\r\nApp -\u003e Library 2 -\u003e Dependency X (Version 2)\r\nCustomer\u0027s App takes reference only to the Dependency X Version 2. Meaning Library\u0027s 1 Dependency X is silently upgraded to version 2.\r\n\r\n\u003e Also, AOT compilation of the application may make assumptions about the exact versions of the libraries used by the app.\r\n\r\nI think it doesn\u0027t need to work with AOT at all. If users decide to go with AOT, they can take another path and invest more into taking direct references. \r\n\r\n\u003e The high compatible option for auto-instrumentation solutions is to work with the library versions included in the application, without upgrading them. It means that the auto-instrumentation solution may need to have multiple code paths to deal with different library versions included in the application.\r\n\r\nI\u0027m afraid that creating a managed bridge between 2 different versions of the same dependency (one that is brought by an existing app and another via StartupHook) has much higher chances of breaking the state. I could imagine doing it with stateless libs. This is about logic, but what about performance? - syncing could be very expensive. ",
                                           "updatedAt":  "2022-03-15T18:20:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_rVq3",
                                           "createdAt":  "2022-03-15T18:31:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Customer\u0027s App takes reference only to the Dependency X Version 2. Meaning Library\u0027s 1 Dependency X is silently upgraded to version 2.\r\n\r\nUpgrading and unifying the library versions at application build time is fine. The assumption is that the whole app will get tested before getting deployed and any potential breaks will get addressed before that.\r\n\r\n\u003e I\u0027m afraid that creating a managed bridge between 2 different versions of the same dependency \r\n\r\nThe idea that the auto-instrumentation solution attaches to the library used by the app. It can be done e.g. by auto-instrumentation solution targeting lowest version of the library and lighting up for newer versions using reflection.\r\n\r\nIIRC, it is what some existing auto-instrumentation solutions are doing to deal with this problem.",
                                           "updatedAt":  "2022-03-15T18:31:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_sSwF",
                                           "createdAt":  "2022-03-15T23:49:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "RassK",
                                           "body":  "\u003e Upgrading and unifying the library versions at application build time is fine. The assumption is that the whole app will get tested before getting deployed and any potential breaks will get addressed before that.\r\n\r\nOur approach would be very similar. It\u0027s anyway hard to imagine that hooking a StartupHook would be 100% safe.\r\nThe cycle has to go through the same steps.\r\n\r\n\u003e The idea that the auto-instrumentation solution attaches to the library used by the app. It can be done e.g. by auto-instrumentation solution targeting lowest version of the library and lighting up for newer versions using reflection.\r\n\r\nUnfortunately the OTel SDK targets almost the latest version of `System.Diagnostics.DiagnosticSource` due lacking features in previous versions. Plus it wouldn\u0027t be the only one to be bridged. That could cause dependency proxying hell, if the dependency of dependency needs to be proxied... and so on. \r\n\r\n\u003e IIRC, it is what some existing auto-instrumentation solutions are doing to deal with this problem.\r\n\r\nAs far as I know most of them just avoid taking this kind of dependencies.\r\n",
                                           "updatedAt":  "2022-03-15T23:49:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_sr7W",
                                           "createdAt":  "2022-03-16T02:56:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "reyang",
                                           "body":  "@rajkumar-rangaraj FYI",
                                           "updatedAt":  "2022-03-16T02:56:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_w5aK",
                                           "createdAt":  "2022-03-17T00:42:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pjanotti",
                                           "body":  "As pointed out by @RassK, the main drawback of using the reflection approach is that the Auto-Instrumentation needs to leverage the OTel SDK and related instrumentation packages. While we could do some patching to make it work with whatever version is loaded, it seems a brittle and costly approach. @rajkumar-rangaraj shared a [prototype]( https://github.com/open-telemetry/opentelemetry-dotnet-instrumentation/pull/267) with this approach. An [issue](https://github.com/open-telemetry/opentelemetry-dotnet-instrumentation/issues/260) tracks some of the problems.\r\n\r\n@jkotas\r\n\u003e Would a solution that requires editing application config files work for you in .NET Core?\r\n\r\nIf we could have a dotnet CLI tool to do the equivalent of a package resolution updating the application deps.json, I think we would hit a good 80/20 solution. We wouldn\u0027t cover AOT, but that is a low priority for our project.\r\n\r\n\u003e The assumption is that the whole app will get tested before getting deployed and any potential breaks will get addressed before that.\r\n\r\nOur scenario for this feature is DevOps, in which a rebuild from sources is not possible. Typically the application goes through some staging/testing deployment before reaching production.",
                                           "updatedAt":  "2022-03-17T00:42:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_yNOw",
                                           "createdAt":  "2022-03-17T03:16:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "I understand what you would like to achieve. I have concerns about the consequences of what you are proposing.\r\n\r\nWe have been very intentional in keeping .NET core runtime and libraries major versions to be side-by-side and avoid automatically updating applications to newer major versions by default. It is required to allow us to evolve and innovate that always comes with intentional or unintentional breaking changes.\r\n\r\nIf we start introducing architecture where the new major versions have to be bug-for-bug compatible with previous versions, it will lead to very low tolerance for risks and stifle innovation. It is the place where .NET Framework ended up and we really do not want .NET Core to end up in the same place.\r\n\r\n\u003e Our scenario for this feature is DevOps, in which a rebuild from sources is not possible.\r\n\r\nHow are doing DevOps for statically compiled languages like golang or Rust that are increasing in popularity and where you have to rebuild the app to change it? I would like to see the same or similar approach and architecture to be adopted for .NET.",
                                           "updatedAt":  "2022-03-17T03:16:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_z5Ck",
                                           "createdAt":  "2022-03-17T09:00:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pellared",
                                           "body":  "@jkotas First of all, I want to thank you for your involvement in this thread 👍 \r\n\r\nYour concerns make sense. We do not insist on adding new functionalities to the runtime (we need to support .NET 6.0 anyway). It might be even best if we come up with a solution (it could be a workaround) together. As OTel .NET maintainers, we want to keep in touch with you and have some sort of synergy.\r\n\r\n\u003e How are doing DevOps for statically compiled languages like golang or Rust that are increasing in popularity and where you have to rebuild the app to change it?\r\n\r\nThese are using the [manual instrumentation](https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/glossary.md#manual-instrumentation) approach which requires a lot of developers\u0027 involvement. This approach makes the OTel adoption a lot harder. \r\n\r\n_Side note: I am an OTel Go approver and I help companies adopt it._\r\n\r\n\u003e I would like to see the same or similar approach and architecture to be adopted for .NET.\r\n\r\nMost of the users that we are aware of (at least our customers) are constantly asking for the OTel .NET [auto-instrumentation](https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/glossary.md#automatic-instrumentation). They do not want to touch the production source code like in Go or Rust. They want to use the same (or at least similar) approach as [OTel Java](https://github.com/open-telemetry/opentelemetry-java-instrumentation). Because .NET does not provide an exact equivalent to the Java Agent functionality, most vendors are creating .NET Profiler in order to reJIT the code. \r\n\r\nHowever using .NET Profiler also comes with drawbacks and we were looking for new functionalities like startup hook, additional dependencies, etc. in order to have a path to get away from .NET Profiler. The [Host startup hook doc](https://github.com/dotnet/runtime/blob/main/docs/design/features/host-startup-hook.md) even mentions that it was created for such use case\r\n\r\n\u003e  The hook could be used to set up tracing or telemetry injection [...] . The hook is separate from the entry point, so that user code doesn\u0027t need to be modified. \r\n\r\n\u003e This hook is meant as a low-level, powerful way to inject code into the process at runtime, for use by tool developers who truly have a need for this kind of power. It should only be used in situations where modifying application code is not an option and there is not an existing structured dependency injection framework in place. An example of such a use case is a hook that injects logging, telemetry, or profiling into an existing deployed application at runtime.\r\n\r\nBut it looks like the caveats \"No dependency resolution for non-app assemblies\"  and \"No conflict resolution for dependencies shared by hooks or the app\" is very troublesome for us.\r\n\r\nHere are our current workarounds for these problems https://github.com/open-telemetry/opentelemetry-dotnet-instrumentation/blob/main/docs/troubleshooting.md#handling-of-assembly-version-conflicts\r\n\r\nMaybe you have some better idea? We want to avoid vendoring (copying the code) of all of the dependencies as well as using the .NET Profiler. We would love to have a \"runtime configuration\" solution. However, I understand that it might be impossible (at least for .NET 6.0). I imagine that having some tool that e.g. modifies the .NET binaries or some tool that changes config files (like @pjanotti suggested) could be sometimes an easier solution than e.g. requesting users to add some package references manually. Still, we are open to any advice/suggestions/comments.\r\n\r\n@open-telemetry/dotnet-instrumentation-approvers - Please thumbs up if I am correct. Otherwise, please just make a follow-up comment (or PM me to make an edit)\r\n\r\nFYI @open-telemetry/dotnet-approvers",
                                           "updatedAt":  "2022-03-17T16:51:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_0bRS",
                                           "createdAt":  "2022-03-17T09:59:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCTZM-Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pellared",
                                                                               "createdAt":  "2022-03-17T10:01:18Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "RassK",
                                           "body":  "\u003e I understand what you would like to achieve. I have concerns about the consequences of what you are proposing.\r\n\u003e \r\n\u003e We have been very intentional in keeping .NET core runtime and libraries major versions to be side-by-side and avoid automatically updating applications to newer major versions by default. It is required to allow us to evolve and innovate that always comes with intentional or unintentional breaking changes.\r\n\u003e \r\n\u003e If we start introducing architecture where the new major versions have to be bug-for-bug compatible with previous versions, it will lead to very low tolerance for risks and stifle innovation. It is the place where .NET Framework ended up and we really do not want .NET Core to end up in the same place.\r\n\r\nMost importantly I would not ask this as a default behaviour. The concerns you are referring to are correct and should not be avoided. I\u0027m currently thinking of an advanced dependency control that can be turned on via environment variable. Just like the Native profiler, StartupHook and Shared Dependency Store are advanced features with restrictions, dependency control could also point something like \"you must know what you are doing. There is no bug-to-bug compatibility. etc\".\r\n\r\n\u003e How are doing DevOps for statically compiled languages like golang or Rust that are increasing in popularity and where you have to rebuild the app to change it? I would like to see the same or similar approach and architecture to be adopted for .NET.\r\n\r\nActually I would love to see .NET as more advanced and mature in extendibility, pluging and unpluging modules. Forking and keeping these in sync with upstream is very painful. Specially if you need to do minor modifications and then redo the whole packing.",
                                           "updatedAt":  "2022-03-17T09:59:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_1tmQ",
                                           "createdAt":  "2022-03-17T16:22:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCTdSew==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pellared",
                                                                               "createdAt":  "2022-03-17T16:25:14Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Maybe you have some better idea?\r\n\r\nFor .NET, you should be able to reduce auto-instrumentation of the application during build time into adding a single line (reference to the auto-instrumentation nuget package) to the app .csproj file. Adding a single line to the .csproj does not sound like a lot of developers\u0027 involvement.\r\n\r\nI would update the documentation to strongly encourage dealing with auto-instrumentation and version mismatches during build time and describe the solutions that require editing of already published apps as last resort.\r\n\r\n\u003e We want to avoid vendoring (copying the code) of all of the dependencies as well as using the .NET Profiler\r\n\r\nBundling the dependencies with the telemetry engine and isolating the telemetry engine from the application itself as much as possible is a robust solution for situations where you want to inject itself into the unenlightened app with potentially conflicting dependencies. You can do it by loading the telemetry engine into a its own assembly load context that is going to avoid conflicts with versions used by the application. The startup hook can then be just a simple loader that creates the assembly load context and loads the full engine into it. I understand that this does not work great for cases where you need to share the types or state with the application. You need to use reflection or have multiple versions of your engine compiled against different versions of the dependencies for that.\r\n\r\n\u003e \"No dependency resolution for non-app assemblies\" and \"No conflict resolution for dependencies shared by hooks or the app\" is very troublesome for us.\r\n\r\nThis was intentional design decision for startup hooks. We expect complex startup hooks to use AssemblyLoadContext to isolate their dependencies from the application dependencies.\r\n\r\n\u003e Most importantly I would not ask this as a default behaviour\r\n\r\nIf the popular telemetry solutions start depending on auto-upgrading of app dependencies, it would become de-facto default behavior and we would have to take that into account when evolving the .NET runtime and libraries.",
                                           "updatedAt":  "2022-03-17T16:22:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_5BYp",
                                           "createdAt":  "2022-03-18T00:53:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "notcool11",
                                           "body":  "At my company I built a NuGet package that wrapped a Jaeger implementation about three years ago. To implement, you literally have to install the package and make some web.config changes....and adoption has been terrible.\r\n\r\nThe current version is based on the MS otel package and is optimized for container deployments. Requires a one liner in the `startup.cs` and using an existing pipeline template...yep, adoption still sucks. But I\u0027m okay with that, I\u0027d rather a team plan-fully implement observability and consider the metrics and attributes they care about than spend a bunch of money on licensing to store data no one is using.\r\n\r\nIf teams don\u0027t care enough to spend a sprint of effort adding observability goodness to their app then let them fail.\r\n\r\nIn place tracing without a redeployment smells like a service mesh or a big expensive APM agent. Doesn\u0027t seem to belong here.",
                                           "updatedAt":  "2022-03-18T00:53:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5AhFVc",
                                           "createdAt":  "2022-03-29T22:02:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCVQp9g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "RassK",
                                                                               "createdAt":  "2022-03-29T22:05:07Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "nrcventura",
                                           "body":  "\u003e For .NET, you should be able to reduce auto-instrumentation of the application during build time into adding a single line (reference to the auto-instrumentation nuget package) to the app .csproj file. Adding a single line to the .csproj does not sound like a lot of developers\u0027 involvement.\r\n\u003e \r\n\u003e I would update the documentation to strongly encourage dealing with auto-instrumentation and version mismatches during build time and describe the solutions that require editing of already published apps as last resort.\r\n\r\nEven with the build-time solution in place and being promoted as the highly recommended solution, there are use cases where a build-time solution is just not feasible. For example, when company A purchases software from company B and \"installs\" it in company A\u0027s environment, the software from company B is already built. However, company A still wants to collect telemetry data from that software. In that scenario, I think that it would be acceptable for company A to change some sort of configuration (file or environment) to opt-in to forcing a different dependency to load, and should treat any such opt-in as if it was building a custom version of the software.",
                                           "updatedAt":  "2022-03-29T22:02:17Z"
                                       }
                                   ],
                         "totalCount":  19
                     },
        "title":  "[Feature]: StartupHook dependency resolving",
        "labels":  [
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/66184",
        "createdAt":  "2022-03-04T08:21:08Z",
        "number":  66184,
        "author":  "teo-tsirpanis",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-12-06T14:22:15Z",
        "body":  "Consider the following code snippet:\r\n\r\n``` csharp\r\nusing System.Reflection;\r\nusing System.Runtime.CompilerServices;\r\nusing System.Runtime.Loader;\r\n\r\nvar alcRef = CreateAlc();\r\n\r\nuint i = 10;\r\nwhile (alcRef.IsAlive \u0026\u0026 i \u003e 0)\r\n{\r\n    GC.Collect();\r\n    GC.WaitForPendingFinalizers();\r\n    i--;\r\n}\r\n\r\nConsole.WriteLine(alcRef.IsAlive);\r\n\r\n[MethodImpl(MethodImplOptions.NoInlining)]\r\nstatic WeakReference CreateAlc()\r\n{\r\n    var alc = new TestALC();\r\n    alc.Unload();\r\n    return new(alc);\r\n}\r\n\r\nsealed class TestALC : AssemblyLoadContext\r\n{\r\n    public readonly Assembly TheAssembly;\r\n    \r\n    public TestALC() : base(true)\r\n    {\r\n        TheAssembly = LoadFromAssemblyPath(typeof(TestALC).Assembly.Location);\r\n    }\r\n}\r\n```\r\n\r\nIt will always print `true`; the ALC is never unloaded because a reference cycle is formed between the native and managed sides of the runtime that the GC cannot figure out. While [judging from the unloadability design document](https://github.com/dotnet/runtime/blob/main/docs/design/features/unloadability.md#assemblyloadcontext-unloading-process) this behavior seems by design, it is counter-intuitive because no user code strongly holds the ALC and that reference cycle is not immediately apparent.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOT9aWrg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc4_HiUW",
                                           "createdAt":  "2022-03-04T08:21:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nConsider the following code snippet:\r\n\r\n``` csharp\r\nusing System.Reflection;\r\nusing System.Runtime.CompilerServices;\r\nusing System.Runtime.Loader;\r\n\r\nvar alcRef = CreateAlc();\r\n\r\nuint i = 10;\r\nwhile (alcRef.IsAlive \u0026\u0026 i \u003e 0)\r\n{\r\n    GC.Collect();\r\n    GC.WaitForPendingFinalizers();\r\n    i--;\r\n}\r\n\r\nConsole.WriteLine(alcRef.IsAlive);\r\n\r\n[MethodImpl(MethodImplOptions.NoInlining)]\r\nstatic WeakReference CreateAlc()\r\n{\r\n    var alc = new TestALC();\r\n    alc.Unload();\r\n    return new(alc);\r\n}\r\n\r\nsealed class TestALC : AssemblyLoadContext\r\n{\r\n    public readonly Assembly TheAssembly;\r\n    \r\n    public TestALC() : base(true)\r\n    {\r\n        TheAssembly = alc.LoadFromAssemblyPath(typeof(TestALC).Assembly.Location);\r\n    }\r\n}\r\n```\r\n\r\nIt will always print `true`; the ALC is never unloaded because a reference cycle is formed between the native and managed sides of the runtime that the GC cannot figure out. While [judging from the unloadability design document](https://github.com/dotnet/runtime/blob/main/docs/design/features/unloadability.md#assemblyloadcontext-unloading-process) this behavior seems by design, it is counter-intuitive because no user code strongly holds the ALC and that reference cycle is not immediately apparent.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eteo-tsirpanis\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-03-04T08:21:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_H5qU",
                                           "createdAt":  "2022-03-04T10:27:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "@janvorli  for comment on the design here.",
                                           "updatedAt":  "2022-03-04T10:27:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_Iavd",
                                           "createdAt":  "2022-03-04T13:40:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "The interesting thing is that the problem doesn\u0027t happen if you don\u0027t call the Unload. The unloading then works as expected. Although both the Unload and the finalizer of the ALC ends up calling the same code, the difference is that when the finalizer calls it, the references in the ALC are not considered alive while with the Unload call, they are still fully alive. The unloading needs to keep the ALC alive for an extended time until the native part of the unloading completes, so it creates a strong GC handle to reference it. With the Unload call, it effectively pins the reference cycle in the example above forever. making the unload impossible.\r\nI don\u0027t see a solution for this issue at the moment other than changing the unload method implementation to do nothing and always rely on the GC to initiate the unload. \r\n",
                                           "updatedAt":  "2022-03-04T13:40:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Pi4uf",
                                           "createdAt":  "2022-12-01T22:50:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "@janvorli how about we change `Unload()` to only invoke the `Unloading` event and remove the ALC from `All`, and leave the rest to the GC?",
                                           "updatedAt":  "2022-12-01T22:50:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5P1pau",
                                           "createdAt":  "2022-12-06T14:22:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "@teo-tsirpanis let me think about the consequences of such a change. ",
                                           "updatedAt":  "2022-12-06T14:22:15Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "Storing objects from another `AssemblyLoadContext` inside its own instance inhibits unloadability.",
        "labels":  [
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/66656",
        "createdAt":  "2022-03-15T13:52:31Z",
        "number":  66656,
        "author":  "NightOwl888",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-04-28T20:32:58Z",
        "body":  "### Description\r\n\r\nWe are attempting to use `Assembly.GetSatelliteAssembly(CultureInfo)` followed by `Assembly.GetManfestResourceStream()` as a direct replacement for `Assembly.GetManfestResourceStream()`. We already have a caching and fallback mechanism that we want to re-use, and there seems to be a lot of extra baggage with using `ResourceManager` (namely re-packing the file streams into a `.resources` file instead of using embedded files in the satellite assembly).\r\n\r\nWhile the ideal solution would be for `Assembly.GetSatelliteAssembly(CultureInfo)` to return `null` if the satellite assembly doesn\u0027t exist so we can fall back ourselves, we were expecting a `FileNotFoundException` as per [the documentation](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.getsatelliteassembly?view=net-6.0). However, what we discovered is that it will fall back to invariant culture rather than throwing `FileNotFoundException`.\r\n\r\nBeing that we can simply do a check to see if the culture is correct and return `null` from here, this seems to be a better solution than catching a `FileNotFoundException`. But, being that it is not documented that way, we are hesitant to rely 100% on the observed behavior, especially being that it might not match other platforms that .NET Standard 2.0 supports.\r\n\r\nIt is possible that we have missed a step when packing our embedded resources that is causing it to misbehave. To keep it simple, we left that stage out of the repro project, but you can view the `LinkAssembly` inline task we made here: https://dev.azure.com/shad0962/Experiments/_git/ICU4N?version=GBfeature/resource-automation\u0026path=/src/ICU4N/ICU4N.csproj. However, I presume you can glean enough info about the satellite assemblies by viewing the metadata to ensure they are built correctly.\r\n\r\n## Assembly Metadata\r\n\u003cdetails\u003e\r\n  \u003csummary\u003eClick to expand!\u003c/summary\u003e\r\n\r\n### /en-US/ICU4N.resources.dll\r\n```c#\r\nusing System.Reflection;\r\n\r\n// Assembly ICU4N.resources, Version=60.0.0.0, Culture=en-US, PublicKeyToken=efb17c8e4f0e291b\r\n// MVID: DCBF01E1-8DAC-40A3-A905-D2A61F598974\r\n// Assembly references:\r\n// mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\r\n\r\n[assembly: AssemblyTitle(\"ICU4N\")]\r\n[assembly: AssemblyDescription(\"ICU (International Components for Unicode) is a set of libraries providing Unicode and Globalization support for software applications. It provides Text-boundary analysis (RuleBasedBreakIterator) as well as easy access to all of the many Unicode character properties, Unicode Normalization, Case Folding and other fundamental operations as specified by the Unicode Standard. ICU4N is a .NET port of ICU4J.\")]\r\n[assembly: AssemblyCompany(\"ICU4N\")]\r\n[assembly: AssemblyProduct(\"ICU4N\")]\r\n[assembly: AssemblyInformationalVersion(\"60.1.0-alpha.381+20d113ebd5\")]\r\n[assembly: AssemblyCopyright(\"Copyright © 2019 - 2022 ICU4N\")]\r\n[assembly: AssemblyFileVersion(\"60.1.0\")]\r\n[assembly: AssemblyVersion(\"60.0.0.0\")]\r\n```\r\n\r\n### /en/ICU4N.resources.dll\r\n```c#\r\nusing System.Reflection;\r\n\r\n// Assembly ICU4N.resources, Version=60.0.0.0, Culture=en, PublicKeyToken=efb17c8e4f0e291b\r\n// MVID: 35D07924-AD2A-46BE-BC22-41ABAB6ACED5\r\n// Assembly references:\r\n// mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\r\n\r\n[assembly: AssemblyTitle(\"ICU4N\")]\r\n[assembly: AssemblyDescription(\"ICU (International Components for Unicode) is a set of libraries providing Unicode and Globalization support for software applications. It provides Text-boundary analysis (RuleBasedBreakIterator) as well as easy access to all of the many Unicode character properties, Unicode Normalization, Case Folding and other fundamental operations as specified by the Unicode Standard. ICU4N is a .NET port of ICU4J.\")]\r\n[assembly: AssemblyCompany(\"ICU4N\")]\r\n[assembly: AssemblyProduct(\"ICU4N\")]\r\n[assembly: AssemblyInformationalVersion(\"60.1.0-alpha.381+20d113ebd5\")]\r\n[assembly: AssemblyCopyright(\"Copyright © 2019 - 2022 ICU4N\")]\r\n[assembly: AssemblyFileVersion(\"60.1.0\")]\r\n[assembly: AssemblyVersion(\"60.0.0.0\")]\r\n```\r\n\r\n### /ICU4N.resources.dll\r\n```c#\r\nusing System.Reflection;\r\n\r\n// Assembly ICU4N.resources, Version=60.0.0.0, Culture=neutral, PublicKeyToken=efb17c8e4f0e291b\r\n// MVID: 7CE159F0-78E8-4245-8B2C-81B1F12CB03D\r\n// Assembly references:\r\n// mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\r\n\r\n[assembly: AssemblyTitle(\"ICU4N\")]\r\n[assembly: AssemblyDescription(\"ICU (International Components for Unicode) is a set of libraries providing Unicode and Globalization support for software applications. It provides Text-boundary analysis (RuleBasedBreakIterator) as well as easy access to all of the many Unicode character properties, Unicode Normalization, Case Folding and other fundamental operations as specified by the Unicode Standard. ICU4N is a .NET port of ICU4J.\")]\r\n[assembly: AssemblyCompany(\"ICU4N\")]\r\n[assembly: AssemblyProduct(\"ICU4N\")]\r\n[assembly: AssemblyInformationalVersion(\"60.1.0-alpha.381+20d113ebd5\")]\r\n[assembly: AssemblyCopyright(\"Copyright © 2019 - 2022 ICU4N\")]\r\n[assembly: AssemblyFileVersion(\"60.1.0\")]\r\n[assembly: AssemblyVersion(\"60.0.0.0\")]\r\n```\r\n\r\n### /ICU4N.dll\r\n```c#\r\nusing System.Diagnostics;\r\nusing System.Reflection;\r\nusing System.Runtime.CompilerServices;\r\nusing System.Runtime.Versioning;\r\n\r\n// Assembly ICU4N, Version=60.0.0.0, Culture=neutral, PublicKeyToken=efb17c8e4f0e291b\r\n// MVID: 3A915DD2-2927-4684-9D8C-1FDD4EC46152\r\n// Assembly references:\r\n// netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51\r\n\r\n[assembly: CompilationRelaxations(8)]\r\n[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]\r\n[assembly: Debuggable(DebuggableAttribute.DebuggingModes.Default | DebuggableAttribute.DebuggingModes.DisableOptimizations | DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints | DebuggableAttribute.DebuggingModes.EnableEditAndContinue)]\r\n[assembly: TargetFramework(\".NETStandard,Version=v2.0\", FrameworkDisplayName = \"\")]\r\n[assembly: AssemblyCompany(\"ICU4N\")]\r\n[assembly: AssemblyConfiguration(\"Debug\")]\r\n[assembly: AssemblyCopyright(\"Copyright © 2019 - 2022 ICU4N\")]\r\n[assembly: AssemblyDescription(\"ICU (International Components for Unicode) is a set of libraries providing Unicode and Globalization support for software applications. It provides Text-boundary analysis (RuleBasedBreakIterator) as well as easy access to all of the many Unicode character properties, Unicode Normalization, Case Folding and other fundamental operations as specified by the Unicode Standard. ICU4N is a .NET port of ICU4J.\")]\r\n[assembly: AssemblyFileVersion(\"60.1.0\")]\r\n[assembly: AssemblyInformationalVersion(\"60.1.0-alpha.381+20d113ebd5\")]\r\n[assembly: AssemblyProduct(\"ICU4N\")]\r\n[assembly: AssemblyTitle(\"ICU4N\")]\r\n[assembly: AssemblyVersion(\"60.0.0.0\")]\r\n```\r\n\r\n\u003c/details\u003e\r\n\r\n### Reproduction Steps\r\n\r\nI have created a repro project here: https://github.com/NightOwl888/GetSatelliteAssemblyIssue. Simply clone it and run the tests.\r\n\r\n### Expected behavior\r\n\r\nThe [documentation](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.getsatelliteassembly?view=net-6.0) states that `GetSatelliteAssembly(CultureInfo)` will throw `FileNotFoundException` if \"the assembly cannot be found\".\r\n\r\nIt is not completely clear what that means. I presume that means the assembly was scanned for in all of the normal locations (including the GAC and convention-based directories) and it couldn\u0027t be found. Therefore, when using the `en-CA` culture, and it cannot find an assembly for that culture in either the `\u003cappDir\u003e/en-CA` directory, the GAC, or being provided by the `AssemblyResolve` event, it should throw a `FileNotFoundException`.\r\n\r\n### Actual behavior\r\n\r\nIf the `.resources.dll` file is missing from the `\u003cappDir\u003e/en-CA` directory, no exception is thrown. The assembly returned is the `.resources.dll` file from `\u003cappDir\u003e`.\r\n\r\nThis behavior is illogical, since it neither matches with the docs, nor does it fall back to `en`.\r\n\r\nThat being said, **an acceptable fix for us would be to confirm it works this way on every platform that `.NET Standard` supports and update the documentation** to state it works this way. If we can rely on this contract, it is better than having to deal with exceptions in what can be considered the \"normal\" flow. That is, the end user decided not to distribute the `en-CA\\\u003cAssemblyName\u003e.resources.dll` file with their distribution, which is a \"normal\" use case that would ideally not throw exceptions.\r\n\r\nIf you update the documentation, we need to know what cases (if any) a `FileNotFoundException` will be thrown. It should also clearly state that the neutral language assembly will be returned in the case where the satellite assembly DLL doesn\u0027t exist.\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\nThe behavior appears to be consistent on .NET Framework 4.5.2, .NET Framework 4.6.1, .NET Framework 4.8, .NET Core 3.1, .NET 5, and .NET 6.\r\n\r\nWe have confirmed that the behavior is consistent on Linux, macOS, and Windows in both x86 and x64.\r\n\r\nWe don\u0027t know whether the same behavior exists on other platforms, and can\u0027t be sure it will be consistent because the behavior doesn\u0027t match the docs.\r\n\r\n\r\n\r\n### Other information\r\n\r\nGiven that the `RuntimeAssembly` class is apparently expecting `null` from the native code and will throw `FileNotFoundException` in that case, the native code is what seems to differ from [the docs](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.getsatelliteassembly?view=net-6.0).",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOP6tEsw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc4_qJlz",
                                           "createdAt":  "2022-03-15T13:52:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\nWe are attempting to use `Assembly.GetSatelliteAssembly(CultureInfo)` followed by `Assembly.GetManfestResourceStream()` as a direct replacement for `Assembly.GetManfestResourceStream()`. We already have a caching and fallback mechanism that we want to re-use, and there seems to be a lot of extra baggage with using `ResourceManager` (namely re-packing the file streams into a `.resources` file instead of using embedded files in the satellite assembly).\r\n\r\nWhile the ideal solution would be for `Assembly.GetSatelliteAssembly(CultureInfo)` to return `null` if the satellite assembly doesn\u0027t exist so we can fall back ourselves, we were expecting a `FileNotFoundException` as per [the documentation](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.getsatelliteassembly?view=net-6.0). However, what we discovered is that it will fall back to invariant culture rather than throwing `FileNotFoundException`.\r\n\r\nBeing that we can simply do a check to see if the culture is correct and return `null` from here, this seems to be a better solution than catching a `FileNotFoundException`. But, being that it is not documented that way, we are hesitant to rely 100% on the observed behavior, especially being that it might not match other platforms that .NET Standard 2.0 supports.\r\n\r\nIt is possible that we have missed a step when packing our embedded resources that is causing it to misbehave. To keep it simple, we left that stage out of the repro project, but you can view the `LinkAssembly` inline task we made here: https://dev.azure.com/shad0962/Experiments/_git/ICU4N?version=GBfeature/resource-automation\u0026path=/src/ICU4N/ICU4N.csproj. However, I presume you can glean enough info about the satellite assemblies by viewing the metadata to ensure they are built correctly.\r\n\r\n## Assembly Metadata\r\n\u003cdetails\u003e\r\n  \u003csummary\u003eClick to expand!\u003c/summary\u003e\r\n\r\n### /en-US/ICU4N.resources.dll\r\n```c#\r\nusing System.Reflection;\r\n\r\n// Assembly ICU4N.resources, Version=60.0.0.0, Culture=en-US, PublicKeyToken=efb17c8e4f0e291b\r\n// MVID: DCBF01E1-8DAC-40A3-A905-D2A61F598974\r\n// Assembly references:\r\n// mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\r\n\r\n[assembly: AssemblyTitle(\"ICU4N\")]\r\n[assembly: AssemblyDescription(\"ICU (International Components for Unicode) is a set of libraries providing Unicode and Globalization support for software applications. It provides Text-boundary analysis (RuleBasedBreakIterator) as well as easy access to all of the many Unicode character properties, Unicode Normalization, Case Folding and other fundamental operations as specified by the Unicode Standard. ICU4N is a .NET port of ICU4J.\")]\r\n[assembly: AssemblyCompany(\"ICU4N\")]\r\n[assembly: AssemblyProduct(\"ICU4N\")]\r\n[assembly: AssemblyInformationalVersion(\"60.1.0-alpha.381+20d113ebd5\")]\r\n[assembly: AssemblyCopyright(\"Copyright © 2019 - 2022 ICU4N\")]\r\n[assembly: AssemblyFileVersion(\"60.1.0\")]\r\n[assembly: AssemblyVersion(\"60.0.0.0\")]\r\n```\r\n\r\n### /en/ICU4N.resources.dll\r\n```c#\r\nusing System.Reflection;\r\n\r\n// Assembly ICU4N.resources, Version=60.0.0.0, Culture=en, PublicKeyToken=efb17c8e4f0e291b\r\n// MVID: 35D07924-AD2A-46BE-BC22-41ABAB6ACED5\r\n// Assembly references:\r\n// mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\r\n\r\n[assembly: AssemblyTitle(\"ICU4N\")]\r\n[assembly: AssemblyDescription(\"ICU (International Components for Unicode) is a set of libraries providing Unicode and Globalization support for software applications. It provides Text-boundary analysis (RuleBasedBreakIterator) as well as easy access to all of the many Unicode character properties, Unicode Normalization, Case Folding and other fundamental operations as specified by the Unicode Standard. ICU4N is a .NET port of ICU4J.\")]\r\n[assembly: AssemblyCompany(\"ICU4N\")]\r\n[assembly: AssemblyProduct(\"ICU4N\")]\r\n[assembly: AssemblyInformationalVersion(\"60.1.0-alpha.381+20d113ebd5\")]\r\n[assembly: AssemblyCopyright(\"Copyright © 2019 - 2022 ICU4N\")]\r\n[assembly: AssemblyFileVersion(\"60.1.0\")]\r\n[assembly: AssemblyVersion(\"60.0.0.0\")]\r\n```\r\n\r\n### /ICU4N.resources.dll\r\n```c#\r\nusing System.Reflection;\r\n\r\n// Assembly ICU4N.resources, Version=60.0.0.0, Culture=neutral, PublicKeyToken=efb17c8e4f0e291b\r\n// MVID: 7CE159F0-78E8-4245-8B2C-81B1F12CB03D\r\n// Assembly references:\r\n// mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\r\n\r\n[assembly: AssemblyTitle(\"ICU4N\")]\r\n[assembly: AssemblyDescription(\"ICU (International Components for Unicode) is a set of libraries providing Unicode and Globalization support for software applications. It provides Text-boundary analysis (RuleBasedBreakIterator) as well as easy access to all of the many Unicode character properties, Unicode Normalization, Case Folding and other fundamental operations as specified by the Unicode Standard. ICU4N is a .NET port of ICU4J.\")]\r\n[assembly: AssemblyCompany(\"ICU4N\")]\r\n[assembly: AssemblyProduct(\"ICU4N\")]\r\n[assembly: AssemblyInformationalVersion(\"60.1.0-alpha.381+20d113ebd5\")]\r\n[assembly: AssemblyCopyright(\"Copyright © 2019 - 2022 ICU4N\")]\r\n[assembly: AssemblyFileVersion(\"60.1.0\")]\r\n[assembly: AssemblyVersion(\"60.0.0.0\")]\r\n```\r\n\r\n### /ICU4N.dll\r\n```c#\r\nusing System.Diagnostics;\r\nusing System.Reflection;\r\nusing System.Runtime.CompilerServices;\r\nusing System.Runtime.Versioning;\r\n\r\n// Assembly ICU4N, Version=60.0.0.0, Culture=neutral, PublicKeyToken=efb17c8e4f0e291b\r\n// MVID: 3A915DD2-2927-4684-9D8C-1FDD4EC46152\r\n// Assembly references:\r\n// netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51\r\n\r\n[assembly: CompilationRelaxations(8)]\r\n[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]\r\n[assembly: Debuggable(DebuggableAttribute.DebuggingModes.Default | DebuggableAttribute.DebuggingModes.DisableOptimizations | DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints | DebuggableAttribute.DebuggingModes.EnableEditAndContinue)]\r\n[assembly: TargetFramework(\".NETStandard,Version=v2.0\", FrameworkDisplayName = \"\")]\r\n[assembly: AssemblyCompany(\"ICU4N\")]\r\n[assembly: AssemblyConfiguration(\"Debug\")]\r\n[assembly: AssemblyCopyright(\"Copyright © 2019 - 2022 ICU4N\")]\r\n[assembly: AssemblyDescription(\"ICU (International Components for Unicode) is a set of libraries providing Unicode and Globalization support for software applications. It provides Text-boundary analysis (RuleBasedBreakIterator) as well as easy access to all of the many Unicode character properties, Unicode Normalization, Case Folding and other fundamental operations as specified by the Unicode Standard. ICU4N is a .NET port of ICU4J.\")]\r\n[assembly: AssemblyFileVersion(\"60.1.0\")]\r\n[assembly: AssemblyInformationalVersion(\"60.1.0-alpha.381+20d113ebd5\")]\r\n[assembly: AssemblyProduct(\"ICU4N\")]\r\n[assembly: AssemblyTitle(\"ICU4N\")]\r\n[assembly: AssemblyVersion(\"60.0.0.0\")]\r\n```\r\n\r\n\u003c/details\u003e\n\n### Reproduction Steps\n\nI have created a repro project here: https://github.com/NightOwl888/GetSatelliteAssemblyIssue. Simply clone it and run the tests.\n\n### Expected behavior\n\nThe [documentation](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.getsatelliteassembly?view=net-6.0) states that `GetSatelliteAssembly(CultureInfo)` will throw `FileNotFoundException` if \"the assembly cannot be found\".\r\n\r\nIt is not completely clear what that means. I presume that means the assembly was scanned for in all of the normal locations (including the GAC and convention-based directories) and it couldn\u0027t be found. Therefore, when using the `en-CA` culture, and it cannot find an assembly for that culture in either the `\u003cappDir\u003e/en-CA` directory, the GAC, or being provided by the `AssemblyResolve` event, it should throw a `FileNotFoundException`.\n\n### Actual behavior\n\nIf the `.resources.dll` file is missing from the `\u003cappDir\u003e/en-CA` directory, no exception is thrown. The assembly returned is the `.resources.dll` file from `\u003cappDir\u003e`.\r\n\r\nThis behavior is illogical, since it neither matches with the docs, nor does it fall back to `en`.\r\n\r\nThat being said, **an acceptable fix for us would be to confirm it works this way on every platform that `.NET Standard` supports and update the documentation** to state it works this way. If we can rely on this contract, it is better than having to deal with exceptions in what can be considered the \"normal\" flow. That is, the end user decided not to distribute the `en-CA\\\u003cAssemblyName\u003e.resources.dll` file with their distribution, which is a \"normal\" use case that would ideally not throw exceptions.\r\n\r\nIf you update the documentation, we need to know what cases (if any) a `FileNotFoundException` will be thrown. It should also clearly state that the neutral language assembly will be returned in the case where the satellite assembly DLL doesn\u0027t exist.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\nThe behavior appears to be consistent on .NET Framework 4.5.5, .NET Framework 4.6.1, .NET Framework 4.8, .NET Core 3.1, .NET 5, and .NET 6.\r\n\r\nWe have confirmed that the behavior is consistent on Linux, macOS, and Windows in both x86 and x64.\r\n\r\nWe don\u0027t know whether the same behavior exists on other platforms, and can\u0027t be sure it will be consistent because the behavior doesn\u0027t match the docs.\r\n\r\n\n\n### Other information\n\nGiven that the `RuntimeAssembly` class is apparently expecting `null` from the native code and will throw `FileNotFoundException` in that case, the native code is what seems to differ from [the docs](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.getsatelliteassembly?view=net-6.0).\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eNightOwl888\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-03-15T13:52:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_qyjx",
                                           "createdAt":  "2022-03-15T16:18:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-resources\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\n\r\nWe are attempting to use `Assembly.GetSatelliteAssembly(CultureInfo)` followed by `Assembly.GetManfestResourceStream()` as a direct replacement for `Assembly.GetManfestResourceStream()`. We already have a caching and fallback mechanism that we want to re-use, and there seems to be a lot of extra baggage with using `ResourceManager` (namely re-packing the file streams into a `.resources` file instead of using embedded files in the satellite assembly).\r\n\r\nWhile the ideal solution would be for `Assembly.GetSatelliteAssembly(CultureInfo)` to return `null` if the satellite assembly doesn\u0027t exist so we can fall back ourselves, we were expecting a `FileNotFoundException` as per [the documentation](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.getsatelliteassembly?view=net-6.0). However, what we discovered is that it will fall back to invariant culture rather than throwing `FileNotFoundException`.\r\n\r\nBeing that we can simply do a check to see if the culture is correct and return `null` from here, this seems to be a better solution than catching a `FileNotFoundException`. But, being that it is not documented that way, we are hesitant to rely 100% on the observed behavior, especially being that it might not match other platforms that .NET Standard 2.0 supports.\r\n\r\nIt is possible that we have missed a step when packing our embedded resources that is causing it to misbehave. To keep it simple, we left that stage out of the repro project, but you can view the `LinkAssembly` inline task we made here: https://dev.azure.com/shad0962/Experiments/_git/ICU4N?version=GBfeature/resource-automation\u0026path=/src/ICU4N/ICU4N.csproj. However, I presume you can glean enough info about the satellite assemblies by viewing the metadata to ensure they are built correctly.\r\n\r\n## Assembly Metadata\r\n\u003cdetails\u003e\r\n  \u003csummary\u003eClick to expand!\u003c/summary\u003e\r\n\r\n### /en-US/ICU4N.resources.dll\r\n```c#\r\nusing System.Reflection;\r\n\r\n// Assembly ICU4N.resources, Version=60.0.0.0, Culture=en-US, PublicKeyToken=efb17c8e4f0e291b\r\n// MVID: DCBF01E1-8DAC-40A3-A905-D2A61F598974\r\n// Assembly references:\r\n// mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\r\n\r\n[assembly: AssemblyTitle(\"ICU4N\")]\r\n[assembly: AssemblyDescription(\"ICU (International Components for Unicode) is a set of libraries providing Unicode and Globalization support for software applications. It provides Text-boundary analysis (RuleBasedBreakIterator) as well as easy access to all of the many Unicode character properties, Unicode Normalization, Case Folding and other fundamental operations as specified by the Unicode Standard. ICU4N is a .NET port of ICU4J.\")]\r\n[assembly: AssemblyCompany(\"ICU4N\")]\r\n[assembly: AssemblyProduct(\"ICU4N\")]\r\n[assembly: AssemblyInformationalVersion(\"60.1.0-alpha.381+20d113ebd5\")]\r\n[assembly: AssemblyCopyright(\"Copyright © 2019 - 2022 ICU4N\")]\r\n[assembly: AssemblyFileVersion(\"60.1.0\")]\r\n[assembly: AssemblyVersion(\"60.0.0.0\")]\r\n```\r\n\r\n### /en/ICU4N.resources.dll\r\n```c#\r\nusing System.Reflection;\r\n\r\n// Assembly ICU4N.resources, Version=60.0.0.0, Culture=en, PublicKeyToken=efb17c8e4f0e291b\r\n// MVID: 35D07924-AD2A-46BE-BC22-41ABAB6ACED5\r\n// Assembly references:\r\n// mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\r\n\r\n[assembly: AssemblyTitle(\"ICU4N\")]\r\n[assembly: AssemblyDescription(\"ICU (International Components for Unicode) is a set of libraries providing Unicode and Globalization support for software applications. It provides Text-boundary analysis (RuleBasedBreakIterator) as well as easy access to all of the many Unicode character properties, Unicode Normalization, Case Folding and other fundamental operations as specified by the Unicode Standard. ICU4N is a .NET port of ICU4J.\")]\r\n[assembly: AssemblyCompany(\"ICU4N\")]\r\n[assembly: AssemblyProduct(\"ICU4N\")]\r\n[assembly: AssemblyInformationalVersion(\"60.1.0-alpha.381+20d113ebd5\")]\r\n[assembly: AssemblyCopyright(\"Copyright © 2019 - 2022 ICU4N\")]\r\n[assembly: AssemblyFileVersion(\"60.1.0\")]\r\n[assembly: AssemblyVersion(\"60.0.0.0\")]\r\n```\r\n\r\n### /ICU4N.resources.dll\r\n```c#\r\nusing System.Reflection;\r\n\r\n// Assembly ICU4N.resources, Version=60.0.0.0, Culture=neutral, PublicKeyToken=efb17c8e4f0e291b\r\n// MVID: 7CE159F0-78E8-4245-8B2C-81B1F12CB03D\r\n// Assembly references:\r\n// mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\r\n\r\n[assembly: AssemblyTitle(\"ICU4N\")]\r\n[assembly: AssemblyDescription(\"ICU (International Components for Unicode) is a set of libraries providing Unicode and Globalization support for software applications. It provides Text-boundary analysis (RuleBasedBreakIterator) as well as easy access to all of the many Unicode character properties, Unicode Normalization, Case Folding and other fundamental operations as specified by the Unicode Standard. ICU4N is a .NET port of ICU4J.\")]\r\n[assembly: AssemblyCompany(\"ICU4N\")]\r\n[assembly: AssemblyProduct(\"ICU4N\")]\r\n[assembly: AssemblyInformationalVersion(\"60.1.0-alpha.381+20d113ebd5\")]\r\n[assembly: AssemblyCopyright(\"Copyright © 2019 - 2022 ICU4N\")]\r\n[assembly: AssemblyFileVersion(\"60.1.0\")]\r\n[assembly: AssemblyVersion(\"60.0.0.0\")]\r\n```\r\n\r\n### /ICU4N.dll\r\n```c#\r\nusing System.Diagnostics;\r\nusing System.Reflection;\r\nusing System.Runtime.CompilerServices;\r\nusing System.Runtime.Versioning;\r\n\r\n// Assembly ICU4N, Version=60.0.0.0, Culture=neutral, PublicKeyToken=efb17c8e4f0e291b\r\n// MVID: 3A915DD2-2927-4684-9D8C-1FDD4EC46152\r\n// Assembly references:\r\n// netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51\r\n\r\n[assembly: CompilationRelaxations(8)]\r\n[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]\r\n[assembly: Debuggable(DebuggableAttribute.DebuggingModes.Default | DebuggableAttribute.DebuggingModes.DisableOptimizations | DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints | DebuggableAttribute.DebuggingModes.EnableEditAndContinue)]\r\n[assembly: TargetFramework(\".NETStandard,Version=v2.0\", FrameworkDisplayName = \"\")]\r\n[assembly: AssemblyCompany(\"ICU4N\")]\r\n[assembly: AssemblyConfiguration(\"Debug\")]\r\n[assembly: AssemblyCopyright(\"Copyright © 2019 - 2022 ICU4N\")]\r\n[assembly: AssemblyDescription(\"ICU (International Components for Unicode) is a set of libraries providing Unicode and Globalization support for software applications. It provides Text-boundary analysis (RuleBasedBreakIterator) as well as easy access to all of the many Unicode character properties, Unicode Normalization, Case Folding and other fundamental operations as specified by the Unicode Standard. ICU4N is a .NET port of ICU4J.\")]\r\n[assembly: AssemblyFileVersion(\"60.1.0\")]\r\n[assembly: AssemblyInformationalVersion(\"60.1.0-alpha.381+20d113ebd5\")]\r\n[assembly: AssemblyProduct(\"ICU4N\")]\r\n[assembly: AssemblyTitle(\"ICU4N\")]\r\n[assembly: AssemblyVersion(\"60.0.0.0\")]\r\n```\r\n\r\n\u003c/details\u003e\r\n\r\n### Reproduction Steps\r\n\r\nI have created a repro project here: https://github.com/NightOwl888/GetSatelliteAssemblyIssue. Simply clone it and run the tests.\r\n\r\n### Expected behavior\r\n\r\nThe [documentation](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.getsatelliteassembly?view=net-6.0) states that `GetSatelliteAssembly(CultureInfo)` will throw `FileNotFoundException` if \"the assembly cannot be found\".\r\n\r\nIt is not completely clear what that means. I presume that means the assembly was scanned for in all of the normal locations (including the GAC and convention-based directories) and it couldn\u0027t be found. Therefore, when using the `en-CA` culture, and it cannot find an assembly for that culture in either the `\u003cappDir\u003e/en-CA` directory, the GAC, or being provided by the `AssemblyResolve` event, it should throw a `FileNotFoundException`.\r\n\r\n### Actual behavior\r\n\r\nIf the `.resources.dll` file is missing from the `\u003cappDir\u003e/en-CA` directory, no exception is thrown. The assembly returned is the `.resources.dll` file from `\u003cappDir\u003e`.\r\n\r\nThis behavior is illogical, since it neither matches with the docs, nor does it fall back to `en`.\r\n\r\nThat being said, **an acceptable fix for us would be to confirm it works this way on every platform that `.NET Standard` supports and update the documentation** to state it works this way. If we can rely on this contract, it is better than having to deal with exceptions in what can be considered the \"normal\" flow. That is, the end user decided not to distribute the `en-CA\\\u003cAssemblyName\u003e.resources.dll` file with their distribution, which is a \"normal\" use case that would ideally not throw exceptions.\r\n\r\nIf you update the documentation, we need to know what cases (if any) a `FileNotFoundException` will be thrown. It should also clearly state that the neutral language assembly will be returned in the case where the satellite assembly DLL doesn\u0027t exist.\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\nThe behavior appears to be consistent on .NET Framework 4.5.2, .NET Framework 4.6.1, .NET Framework 4.8, .NET Core 3.1, .NET 5, and .NET 6.\r\n\r\nWe have confirmed that the behavior is consistent on Linux, macOS, and Windows in both x86 and x64.\r\n\r\nWe don\u0027t know whether the same behavior exists on other platforms, and can\u0027t be sure it will be consistent because the behavior doesn\u0027t match the docs.\r\n\r\n\r\n\r\n### Other information\r\n\r\nGiven that the `RuntimeAssembly` class is apparently expecting `null` from the native code and will throw `FileNotFoundException` in that case, the native code is what seems to differ from [the docs](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.getsatelliteassembly?view=net-6.0).\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eNightOwl888\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Resources`, `area-AssemblyLoader-coreclr`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-03-15T16:18:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_qza2",
                                           "createdAt":  "2022-03-15T16:21:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\n\r\nWe are attempting to use `Assembly.GetSatelliteAssembly(CultureInfo)` followed by `Assembly.GetManfestResourceStream()` as a direct replacement for `Assembly.GetManfestResourceStream()`. We already have a caching and fallback mechanism that we want to re-use, and there seems to be a lot of extra baggage with using `ResourceManager` (namely re-packing the file streams into a `.resources` file instead of using embedded files in the satellite assembly).\r\n\r\nWhile the ideal solution would be for `Assembly.GetSatelliteAssembly(CultureInfo)` to return `null` if the satellite assembly doesn\u0027t exist so we can fall back ourselves, we were expecting a `FileNotFoundException` as per [the documentation](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.getsatelliteassembly?view=net-6.0). However, what we discovered is that it will fall back to invariant culture rather than throwing `FileNotFoundException`.\r\n\r\nBeing that we can simply do a check to see if the culture is correct and return `null` from here, this seems to be a better solution than catching a `FileNotFoundException`. But, being that it is not documented that way, we are hesitant to rely 100% on the observed behavior, especially being that it might not match other platforms that .NET Standard 2.0 supports.\r\n\r\nIt is possible that we have missed a step when packing our embedded resources that is causing it to misbehave. To keep it simple, we left that stage out of the repro project, but you can view the `LinkAssembly` inline task we made here: https://dev.azure.com/shad0962/Experiments/_git/ICU4N?version=GBfeature/resource-automation\u0026path=/src/ICU4N/ICU4N.csproj. However, I presume you can glean enough info about the satellite assemblies by viewing the metadata to ensure they are built correctly.\r\n\r\n## Assembly Metadata\r\n\u003cdetails\u003e\r\n  \u003csummary\u003eClick to expand!\u003c/summary\u003e\r\n\r\n### /en-US/ICU4N.resources.dll\r\n```c#\r\nusing System.Reflection;\r\n\r\n// Assembly ICU4N.resources, Version=60.0.0.0, Culture=en-US, PublicKeyToken=efb17c8e4f0e291b\r\n// MVID: DCBF01E1-8DAC-40A3-A905-D2A61F598974\r\n// Assembly references:\r\n// mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\r\n\r\n[assembly: AssemblyTitle(\"ICU4N\")]\r\n[assembly: AssemblyDescription(\"ICU (International Components for Unicode) is a set of libraries providing Unicode and Globalization support for software applications. It provides Text-boundary analysis (RuleBasedBreakIterator) as well as easy access to all of the many Unicode character properties, Unicode Normalization, Case Folding and other fundamental operations as specified by the Unicode Standard. ICU4N is a .NET port of ICU4J.\")]\r\n[assembly: AssemblyCompany(\"ICU4N\")]\r\n[assembly: AssemblyProduct(\"ICU4N\")]\r\n[assembly: AssemblyInformationalVersion(\"60.1.0-alpha.381+20d113ebd5\")]\r\n[assembly: AssemblyCopyright(\"Copyright © 2019 - 2022 ICU4N\")]\r\n[assembly: AssemblyFileVersion(\"60.1.0\")]\r\n[assembly: AssemblyVersion(\"60.0.0.0\")]\r\n```\r\n\r\n### /en/ICU4N.resources.dll\r\n```c#\r\nusing System.Reflection;\r\n\r\n// Assembly ICU4N.resources, Version=60.0.0.0, Culture=en, PublicKeyToken=efb17c8e4f0e291b\r\n// MVID: 35D07924-AD2A-46BE-BC22-41ABAB6ACED5\r\n// Assembly references:\r\n// mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\r\n\r\n[assembly: AssemblyTitle(\"ICU4N\")]\r\n[assembly: AssemblyDescription(\"ICU (International Components for Unicode) is a set of libraries providing Unicode and Globalization support for software applications. It provides Text-boundary analysis (RuleBasedBreakIterator) as well as easy access to all of the many Unicode character properties, Unicode Normalization, Case Folding and other fundamental operations as specified by the Unicode Standard. ICU4N is a .NET port of ICU4J.\")]\r\n[assembly: AssemblyCompany(\"ICU4N\")]\r\n[assembly: AssemblyProduct(\"ICU4N\")]\r\n[assembly: AssemblyInformationalVersion(\"60.1.0-alpha.381+20d113ebd5\")]\r\n[assembly: AssemblyCopyright(\"Copyright © 2019 - 2022 ICU4N\")]\r\n[assembly: AssemblyFileVersion(\"60.1.0\")]\r\n[assembly: AssemblyVersion(\"60.0.0.0\")]\r\n```\r\n\r\n### /ICU4N.resources.dll\r\n```c#\r\nusing System.Reflection;\r\n\r\n// Assembly ICU4N.resources, Version=60.0.0.0, Culture=neutral, PublicKeyToken=efb17c8e4f0e291b\r\n// MVID: 7CE159F0-78E8-4245-8B2C-81B1F12CB03D\r\n// Assembly references:\r\n// mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\r\n\r\n[assembly: AssemblyTitle(\"ICU4N\")]\r\n[assembly: AssemblyDescription(\"ICU (International Components for Unicode) is a set of libraries providing Unicode and Globalization support for software applications. It provides Text-boundary analysis (RuleBasedBreakIterator) as well as easy access to all of the many Unicode character properties, Unicode Normalization, Case Folding and other fundamental operations as specified by the Unicode Standard. ICU4N is a .NET port of ICU4J.\")]\r\n[assembly: AssemblyCompany(\"ICU4N\")]\r\n[assembly: AssemblyProduct(\"ICU4N\")]\r\n[assembly: AssemblyInformationalVersion(\"60.1.0-alpha.381+20d113ebd5\")]\r\n[assembly: AssemblyCopyright(\"Copyright © 2019 - 2022 ICU4N\")]\r\n[assembly: AssemblyFileVersion(\"60.1.0\")]\r\n[assembly: AssemblyVersion(\"60.0.0.0\")]\r\n```\r\n\r\n### /ICU4N.dll\r\n```c#\r\nusing System.Diagnostics;\r\nusing System.Reflection;\r\nusing System.Runtime.CompilerServices;\r\nusing System.Runtime.Versioning;\r\n\r\n// Assembly ICU4N, Version=60.0.0.0, Culture=neutral, PublicKeyToken=efb17c8e4f0e291b\r\n// MVID: 3A915DD2-2927-4684-9D8C-1FDD4EC46152\r\n// Assembly references:\r\n// netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51\r\n\r\n[assembly: CompilationRelaxations(8)]\r\n[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]\r\n[assembly: Debuggable(DebuggableAttribute.DebuggingModes.Default | DebuggableAttribute.DebuggingModes.DisableOptimizations | DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints | DebuggableAttribute.DebuggingModes.EnableEditAndContinue)]\r\n[assembly: TargetFramework(\".NETStandard,Version=v2.0\", FrameworkDisplayName = \"\")]\r\n[assembly: AssemblyCompany(\"ICU4N\")]\r\n[assembly: AssemblyConfiguration(\"Debug\")]\r\n[assembly: AssemblyCopyright(\"Copyright © 2019 - 2022 ICU4N\")]\r\n[assembly: AssemblyDescription(\"ICU (International Components for Unicode) is a set of libraries providing Unicode and Globalization support for software applications. It provides Text-boundary analysis (RuleBasedBreakIterator) as well as easy access to all of the many Unicode character properties, Unicode Normalization, Case Folding and other fundamental operations as specified by the Unicode Standard. ICU4N is a .NET port of ICU4J.\")]\r\n[assembly: AssemblyFileVersion(\"60.1.0\")]\r\n[assembly: AssemblyInformationalVersion(\"60.1.0-alpha.381+20d113ebd5\")]\r\n[assembly: AssemblyProduct(\"ICU4N\")]\r\n[assembly: AssemblyTitle(\"ICU4N\")]\r\n[assembly: AssemblyVersion(\"60.0.0.0\")]\r\n```\r\n\r\n\u003c/details\u003e\r\n\r\n### Reproduction Steps\r\n\r\nI have created a repro project here: https://github.com/NightOwl888/GetSatelliteAssemblyIssue. Simply clone it and run the tests.\r\n\r\n### Expected behavior\r\n\r\nThe [documentation](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.getsatelliteassembly?view=net-6.0) states that `GetSatelliteAssembly(CultureInfo)` will throw `FileNotFoundException` if \"the assembly cannot be found\".\r\n\r\nIt is not completely clear what that means. I presume that means the assembly was scanned for in all of the normal locations (including the GAC and convention-based directories) and it couldn\u0027t be found. Therefore, when using the `en-CA` culture, and it cannot find an assembly for that culture in either the `\u003cappDir\u003e/en-CA` directory, the GAC, or being provided by the `AssemblyResolve` event, it should throw a `FileNotFoundException`.\r\n\r\n### Actual behavior\r\n\r\nIf the `.resources.dll` file is missing from the `\u003cappDir\u003e/en-CA` directory, no exception is thrown. The assembly returned is the `.resources.dll` file from `\u003cappDir\u003e`.\r\n\r\nThis behavior is illogical, since it neither matches with the docs, nor does it fall back to `en`.\r\n\r\nThat being said, **an acceptable fix for us would be to confirm it works this way on every platform that `.NET Standard` supports and update the documentation** to state it works this way. If we can rely on this contract, it is better than having to deal with exceptions in what can be considered the \"normal\" flow. That is, the end user decided not to distribute the `en-CA\\\u003cAssemblyName\u003e.resources.dll` file with their distribution, which is a \"normal\" use case that would ideally not throw exceptions.\r\n\r\nIf you update the documentation, we need to know what cases (if any) a `FileNotFoundException` will be thrown. It should also clearly state that the neutral language assembly will be returned in the case where the satellite assembly DLL doesn\u0027t exist.\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\nThe behavior appears to be consistent on .NET Framework 4.5.2, .NET Framework 4.6.1, .NET Framework 4.8, .NET Core 3.1, .NET 5, and .NET 6.\r\n\r\nWe have confirmed that the behavior is consistent on Linux, macOS, and Windows in both x86 and x64.\r\n\r\nWe don\u0027t know whether the same behavior exists on other platforms, and can\u0027t be sure it will be consistent because the behavior doesn\u0027t match the docs.\r\n\r\n\r\n\r\n### Other information\r\n\r\nGiven that the `RuntimeAssembly` class is apparently expecting `null` from the native code and will throw `FileNotFoundException` in that case, the native code is what seems to differ from [the docs](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.getsatelliteassembly?view=net-6.0).\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eNightOwl888\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Resources`, `area-AssemblyLoader-coreclr`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-03-15T16:21:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_q0Sz",
                                           "createdAt":  "2022-03-15T16:24:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "Linking the relevant docs: https://docs.microsoft.com/en-us/dotnet/core/dependency-loading/loading-resources\r\n\r\nThis will need detailed investigation...",
                                           "updatedAt":  "2022-03-15T16:24:40Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "GetSatelliteAssembly() not throwing FileNotFoundException as documented",
        "labels":  [
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/69466",
        "createdAt":  "2022-04-13T08:02:07Z",
        "number":  69466,
        "author":  "ayankumaar",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-06-27T20:32:43Z",
        "body":  "I have a project which is currently running in .NET 5.0. It is written using C#. I installed .NET SDK 6.0.201 in my machine and have upgraded my project to .NET 6.0. After upgrading I am getting the following runtime exception:\r\n\r\n **System.TypeLoadException Could not load type \u0027System.IO.File\u0027 from assembly System.Runtime Version=6.0.0.0**\r\n\r\nI am running the following in my machine:\r\n\r\n.NET SDK: 6.0.201\r\nIDE: Visual Studio Code 1.66.1\r\nOS: Windows 10\r\n\r\n**Things that I have tried so far:**\r\n\r\n1) Upgrading my project to .NET 7.0 Preview version. But, that didn\u0027t work. However, if I target .NET 5.0 then it works fine.\r\n\r\n2) I have also, tried clearing all the nuget packages from my system using \"dotnet nuget locals all --clear\". That didn\u0027t work.\r\n\r\n3) I have tried upgrading the System.Runtime.CompilerServices.Unsafe package from 6.0.0.0 to 7.0.0-preview.2.22152.2. That didn\u0027t work as well.\r\n\r\n4) I have read that may be it is loading an assembly from the GAC which is in turn overriding my current set up. But, I am unable to understand that how to resolve it.\r\n\r\nI am just wondering that has anything changed in .NET 6.0 in terms of File read/write and directory read/write operations ? Is that causing this issue ? Do I need to change anything in my code ?\r\n\r\nor, this is just a bug in .NET 6.0 ?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOQ15c-g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5DUWv1",
                                           "createdAt":  "2022-05-17T23:18:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "joeloff",
                                           "body":  ".NET Framework contained a global assembly cache. .NET Core / .NET does not have that. [.NET Tracing](https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-environment-variables#corehost_trace) might help shed some light on what\u0027s happening. You can also look at the Windows Event viewer, there might be more information available as to the load failure you\u0027re seeing, likely in the Application or System event logs.\r\n\r\nI\u0027m going to move this to the runtime as this does not appear to be an SDK issue",
                                           "updatedAt":  "2022-05-17T23:18:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DXMO4",
                                           "createdAt":  "2022-05-18T15:17:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffschwMSFT",
                                           "body":  "@ayankumaar can you share your repo with the issue?",
                                           "updatedAt":  "2022-05-18T15:17:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DXMRp",
                                           "createdAt":  "2022-05-18T15:17:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nI have a project which is currently running in .NET 5.0. It is written using C#. I installed .NET SDK 6.0.201 in my machine and have upgraded my project to .NET 6.0. After upgrading I am getting the following runtime exception:\r\n\r\n **System.TypeLoadException Could not load type \u0027System.IO.File\u0027 from assembly System.Runtime Version=6.0.0.0**\r\n\r\nI am running the following in my machine:\r\n\r\n.NET SDK: 6.0.201\r\nIDE: Visual Studio Code 1.66.1\r\nOS: Windows 10\r\n\r\n**Things that I have tried so far:**\r\n\r\n1) Upgrading my project to .NET 7.0 Preview version. But, that didn\u0027t work. However, if I target .NET 5.0 then it works fine.\r\n\r\n2) I have also, tried clearing all the nuget packages from my system using \"dotnet nuget locals all --clear\". That didn\u0027t work.\r\n\r\n3) I have tried upgrading the System.Runtime.CompilerServices.Unsafe package from 6.0.0.0 to 7.0.0-preview.2.22152.2. That didn\u0027t work as well.\r\n\r\n4) I have read that may be it is loading an assembly from the GAC which is in turn overriding my current set up. But, I am unable to understand that how to resolve it.\r\n\r\nI am just wondering that has anything changed in .NET 6.0 in terms of File read/write and directory read/write operations ? Is that causing this issue ? Do I need to change anything in my code ?\r\n\r\nor, this is just a bug in .NET 6.0 ?\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eayankumaar\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003ejoeloff\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-05-18T15:17:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DXlz6",
                                           "createdAt":  "2022-05-18T16:55:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "Additional ideas:\r\n* Could you please share the callstack of the exception (if you can get it)?\r\n* You could try to capture runtime loader traces (on top of the tracing suggested by @joeloff): https://docs.microsoft.com/en-us/dotnet/core/dependency-loading/collect-details\r\n* Do you publish your application as self-contained?\r\n* Anything special about the application? Specifically things like customizations to the build, custom assembly loading logic, ....\r\n\r\nUnless something went horribly wrong the GAC should have no impact on .NET apps - it\u0027s a .NET Framework only concept.",
                                           "updatedAt":  "2022-05-18T16:55:35Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  ".NET 6.0 upgrade gives System.TypeLoadException Could not load type \u0027System.IO.File\u0027 from assembly System.Runtime Version=6.0.0.0",
        "labels":  [
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/68521",
        "createdAt":  "2022-04-25T21:19:06Z",
        "number":  68521,
        "author":  "steveharter",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-01T18:32:46Z",
        "body":  "### Description\r\nThe PR https://github.com/dotnet/runtime/pull/67917 caused the following tests to the tests to fail due to differences between the current Native-based Invoke and the new Emit-based Invoke:\r\n```\r\nAssemblyLoadFromResolveHandler_MissingDependency\r\nFindInLoadContext_CustomALC_IncompatibleVersion\r\nApplicationAssemblies_MismatchedAssemblyName\r\nAssemblyLoadContextResolvingEvent_CustomALC\r\nAssemblyLoadContextResolvingEvent_CustomALC_Exception\r\nAppDomainAssemblyResolveEvent_CustomALC\r\nAppDomainAssemblyResolveEvent_Exception\r\n```\r\n\r\nIt appears extra load event(s) are occurring in some cases such as for a referenced assembly (\"AssemblyToLoad_Subdirectory\") when using the Emit-based Invoke. These are all believed to be natural managed behavior that differs from the native behavior that doesn\u0027t require assembly dependencies to be loaded early.\r\n\r\n### Reproduction Steps\r\n\r\nForce IL.Emit to be used:\r\n- Add the define `#define USE_EMIT_INVOKE` to the top of both files:\r\n`src/libraries/System.Private.CoreLib/src/System/Reflection/ConstructorInvoker.cs` and \r\nand\r\n`src/libraries/System.Private.CoreLib/src/System/Reflection/MethodInvoker.cs`\r\n- Compile the runtime with that. Also verify with a `checked\\debug` build in addition to ` `release` build since there appears to be differences.\r\n\r\n- To run the test on Windows:\r\n```\r\nsrc\\tests\\build.cmd x64 Checked\r\nsrc\\tests\\run.cmd x64 Checked\r\n```\r\n\r\nUseful shortcut example for debugging purposes:\r\n```\r\nset CORE_ROOT=C:\\git\\REPO\\artifacts\\tests\\coreclr\\windows.x64.Checked\\Tests\\Core_Root\r\nC:\\REPO\\artifacts\\tests\\coreclr\\windows.x64.Checked\\Loader\\binding\\tracing\\BinderTracingTest.ResolutionFlow\\BinderTracingTest.ResolutionFlow.dll\r\n```\r\n\r\nThe CI output from the PR above:\r\n```\r\n[12:39:01 AM] Running AssemblyLoadFromResolveHandler_MissingDependency...\r\nTest AssemblyLoadFromResolveHandler_MissingDependency failed: Xunit.Sdk.TrueException: Bind event count for AssemblyToLoadDependency, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null - expected: 1, actual: 2\r\nExpected: True\r\nActual:   False\r\nat Xunit.Assert.True(Nullable`1 condition, String userMessage) in //src/xunit.assert/Asserts/BooleanAsserts.cs:line 132\r\nat Xunit.Assert.True(Boolean condition, String userMessage) in //src/xunit.assert/Asserts/BooleanAsserts.cs:line 116\r\nat BinderTracingTests.BinderTracingTest.ValidateSingleBind(BinderEventListener listener, AssemblyName assemblyName, BindOperation expected)\r\nat BinderTracingTests.BinderTracingTest.RunSingleTest(MethodInfo method)\r\n\r\nExpected: 100\r\nActual: 101\r\nEND EXECUTION - FAILED\r\nFAILED\r\nTest Harness Exitcode is : 1\r\nTo run the test:\r\n\r\nset CORE_ROOT=C:\\h\\w\\AE49091F\\p\r\nC:\\h\\w\\AE49091F\\w\\ABA1097B\\e\\Loader\\binding\\tracing\\BinderTracingTest.ResolutionFlow\\BinderTracingTest.ResolutionFlow.cmd\r\nExpected: True\r\nActual:   False\r\n```\r\n\r\n### Expected behavior\r\n\r\nThe test updated to support both Emit and Native modes.\r\n\r\nIt is also possible we add support to force the invoke call to either go to Emit or Native deterministically and the test split into two to handle each case, such as by using `BindingFlags` options.\r\n\r\n### Actual behavior\r\n\r\nSee the Repro steps; the test fails when Invoke uses the IL Emit path.\r\n\r\n### Regression?\r\n\r\nYes; as mentioned this occurs in the PR above. Note if the test was written to not use reflection, it would have worked as-is. The test appears to be influenced by the managed\\Emit path.\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\n_No response_\r\n\r\n### Other information\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOQhrGFw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5CGsYX",
                                           "createdAt":  "2022-04-25T21:19:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\nThis is a placeholder until https://github.com/dotnet/runtime/pull/67917 is in\r\n\r\nWhile preparing the PR https://github.com/dotnet/runtime/pull/67917 the test `BinderTracingTest.AssemblyLoadContextResolving_ReturnNull` (in `\\src\\tests\\Loader\\binding\\tracing\\BinderTracingTest.EventHandlers.cs`) fails due to differences between the current Native-based Invoke and the new Emit-based Invoke where a managed call is made to the target method.\r\n\r\nAn extra load event for a referenced assembly (\"AssemblyToLoad_Subdirectory\") is performed when using the Emit-based Invoke.\n\n### Reproduction Steps\n\nForce IL.Emit to be used. _Todo: update this once the PR is in._\r\n\r\nTo run the test on Windows:\r\n```\r\nsrc\\tests\\build.cmd x64 Release\r\nsrc\\tests\\run.cmd x64 Release\r\n```\r\n\r\nUseful shortcut for debugging purposes:\r\n```\r\nset CORE_ROOT=C:\\REPO\\artifacts\\tests\\coreclr\\windows.x64.Release\\Tests\\Core_Ro%CORE_ROOT%\\corerun.exe\r\n C:\\REPO\\artifacts\\tests\\coreclr\\windows.x64.Release\\Loader\\binding\\tracing\\BinderTracingTest.ResolutionFlow\\BinderTracingTest.ResolutionFlow.dll\r\n```\r\n\r\nThe CI output from the PR above:\r\n```\r\n[12:39:01 AM] Running AssemblyLoadFromResolveHandler_MissingDependency...\r\nTest AssemblyLoadFromResolveHandler_MissingDependency failed: Xunit.Sdk.TrueException: Bind event count for AssemblyToLoadDependency, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null - expected: 1, actual: 2\r\nExpected: True\r\nActual:   False\r\nat Xunit.Assert.True(Nullable`1 condition, String userMessage) in //src/xunit.assert/Asserts/BooleanAsserts.cs:line 132\r\nat Xunit.Assert.True(Boolean condition, String userMessage) in //src/xunit.assert/Asserts/BooleanAsserts.cs:line 116\r\nat BinderTracingTests.BinderTracingTest.ValidateSingleBind(BinderEventListener listener, AssemblyName assemblyName, BindOperation expected)\r\nat BinderTracingTests.BinderTracingTest.RunSingleTest(MethodInfo method)\r\n\r\nExpected: 100\r\nActual: 101\r\nEND EXECUTION - FAILED\r\nFAILED\r\nTest Harness Exitcode is : 1\r\nTo run the test:\r\n\r\nset CORE_ROOT=C:\\h\\w\\AE49091F\\p\r\nC:\\h\\w\\AE49091F\\w\\ABA1097B\\e\\Loader\\binding\\tracing\\BinderTracingTest.ResolutionFlow\\BinderTracingTest.ResolutionFlow.cmd\r\nExpected: True\r\nActual:   False\r\n```\n\n### Expected behavior\n\nThe test updated to support both Emit and Native modes.\r\n\r\nIt is also possible we add support to force the invoke call to either go to Emit or Native deterministically and the test split into two to handle each case.\n\n### Actual behavior\n\nSee the Repro steps; the test fails when Invoke uses the IL Emit path.\n\n### Regression?\n\nYes; as mentioned this occurs in the PR above. Note if the test was written to not use reflection, it would have worked as-is. The test appears to be influenced by the managed\\Emit path.\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003esteveharter\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`disabled-test`, `area-AssemblyLoader-coreclr`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-04-25T21:19:09Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Update BinderTracingTest.AssemblyLoadContextResolving_ReturnNull to not assume reflection semantics",
        "labels":  [
                       "disabled-test",
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/72718",
        "createdAt":  "2022-07-23T12:23:24Z",
        "number":  72718,
        "author":  "teo-tsirpanis",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-07-26T20:23:36Z",
        "body":  "### Background and motivation\n\nThe `AssemblyLoadContext` class provides two ways to load specific assembly images, from files and from streams. The methods that take streams read their entire content in memory and call an internal `InternalLoad` method that accepts two `ReadOnlySpan\u003cbyte\u003e`s, for the assembly and the debug symbols.\r\n\r\nIt strikes to me that such method is not public; it is much easier to use and avoids unnecessarily copying data if they are already in contiguous memory. For example if we want to load an assembly from a byte array, we will create a `MemoryStream`, pass it to `LoadFromStream`, and _it will create another byte array_.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Runtime.Loader;\r\n\r\npublic class AssemblyLoadContext\r\n{\r\n    [RequiresUnreferencedCode(\"Types and members the loaded assembly depends on might be removed\")]\r\n    public Assembly LoadFromImage(ReadOnlySpan\u003cbyte\u003e assembly, ReadOnlySpan\u003cbyte\u003e symbols = default);\r\n}\r\n```\r\n\r\nIt will be documented that after calling this method, the spans passed to it don\u0027t have to be preserved.\n\n### API Usage\n\n```csharp\r\nReadOnlySpan\u003cbyte\u003e assemblyImage = File.ReadAllBytes(\"MyAssembly.dll\");\r\nReadOnlySpan\u003cbyte\u003e symbolsImage = File.ReadAllBytes(\"MyAssembly.pdb\");\r\n\r\nAssembly assembly = AssemblyLoadContext.Default.LoadFromImage(assemblyImage, symbolsImage);\r\n```\n\n### Alternative Designs\n\nInstead of one overload with the symbols parameter being optional, we could add two overloads, with and without symbols, like `LoadFromStream`.\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOR0iddg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5HHYWW",
                                           "createdAt":  "2022-07-23T12:23:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nThe `AssemblyLoadContext` class provides two ways to load specific assembly images, from files and from streams. The methods that take streams read their entire content in memory and call an internal `InternalLoad` method that accepts two `ReadOnlySpan\u003cbyte\u003e`s, for the assembly and the debug symbols.\r\n\r\nIt strikes to me that such method is not public; it is much easier to use and avoids unnecessarily copying data if they are already in contiguous memory. For example if we want to load an assembly from a byte array, we will create a `MemoryStream`, pass it to `LoadFromStream`, and _it will create another byte array_.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Runtime.Loader;\r\n\r\npublic class AssemblyLoadContext\r\n{\r\n    [RequiresUnreferencedCode(\"Types and members the loaded assembly depends on might be removed\")]\r\n    public Assembly LoadFromImage(ReadOnlySpan\u003cbyte\u003e assembly, ReadOnlySpan\u003cbyte\u003e symbols = default);\r\n}\r\n```\r\n\r\nIt will be documented that after calling this method, the spans passed to it don\u0027t have to be preserved.\n\n### API Usage\n\n```csharp\r\nReadOnlySpan\u003cbyte\u003e assembly = File.ReadAllBytes(\"MyAssembly.dll\");\r\nReadOnlySpan\u003cbyte\u003e symbols = File.ReadAllBytes(\"MyAssembly.pdb\");\r\n\r\nAssembly assembly = AssemblyLoadContext.Default.LoadFromImage(assembly, symbols);\r\n```\n\n### Alternative Designs\n\nInstead of one overload with the symbols parameter being optional, we could add two overloads, with and without symbols, like `LoadFromStream`.\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eteo-tsirpanis\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-AssemblyLoader-coreclr`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-07-23T12:23:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HHZh1",
                                           "createdAt":  "2022-07-23T13:01:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e if we want to load an assembly from a byte array, we will create a MemoryStream, pass it to LoadFromStream, and it will create another byte array.\r\n\r\nAnd then the assembly loader creates the final copy in unmanaged memory. This inefficiency should be fixed independently on the proposed API.\r\n\r\n(I agree that the proposed API may be useful. However, it is less flexible than the stream-based API.)",
                                           "updatedAt":  "2022-07-23T13:01:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HSJ12",
                                           "createdAt":  "2022-07-26T20:23:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "agocke",
                                           "body":  "Hmm ReadOnly doesn\u0027t really promise that the underlying won\u0027t change either. It\u0027s just saying that the reader can\u0027t change it. The only type I can think of where we might be able to avoid a copy would be ImmutableArray, but again if we need the assembly in unmanaged memory then there will always be at least one copy.",
                                           "updatedAt":  "2022-07-26T20:23:29Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "[API Proposal]: Load assemblies from `ReadOnlySpan\u003cbyte\u003e`.",
        "labels":  [
                       "api-suggestion",
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/74068",
        "createdAt":  "2022-08-17T11:37:11Z",
        "number":  74068,
        "author":  "2mik",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-08-24T17:11:38Z",
        "body":  "### Description\r\n\r\nUsing .NET 6, I load DLL dynamically into the default load context by calling Assembly.LoadFrom(fileName)\r\nThe loaded assembly has some dependencies.\r\nUsing AssemblyResolve and AssemblyLoad events I got that \r\n1) AssemblyResolve event shows that resolution of a referenced assembly fails.\r\n2) Right after fail AssemblyLoad event shows that the referenced assembly loaded successfully.\r\n\r\n\r\nPlease give a clue how to research the cause of the problem.\r\n\r\n### Reproduction Steps\r\n\r\n```\r\nAppDomain.CurrentDomain.AssemblyResolve += CurrentDomain_AssemblyResolve;\r\nAppDomain.CurrentDomain.AssemblyLoad += CurrentDomain_AssemblyLoad;\r\n\r\nstring fileName = \"...\";\r\nstring typeName = \"...\";\r\nAssembly assembly = Assembly.LoadFrom(fileName);\r\nType type = assembly.GetType(typeName, true);\r\nobject obj = Activator.CreateInstance(type);\r\n\r\n// ...\r\n\r\nprivate Assembly CurrentDomain_AssemblyResolve(object sender, ResolveEventArgs args)\r\n{\r\n        Console.WriteLine(\"!!! RequestingAssembly = \" + args.RequestingAssembly.CodeBase);\r\n        Console.WriteLine(\"    Item to resolve = \" + args.Name);\r\n        return null;\r\n}\r\n\r\nprivate void CurrentDomain_AssemblyLoad(object sender, AssemblyLoadEventArgs args)\r\n{\r\n        Console.WriteLine(\"!!! LoadedAssembly = \" + args.LoadedAssembly.CodeBase);\r\n}\r\n\r\n```\r\n\r\n\r\n### Expected behavior\r\n\r\nThe assembly is loaded successfully on the 1st attempt.\r\nOr if assembly failed to load, it will not loaded later.\r\n\r\n\r\n### Actual behavior\r\n\r\nAssembly failed to load, then it is loaded successfully.\r\n\r\n### Regression?\r\n\r\nClassic .NET Framework has another assembly loading mechanism, so it\u0027s not applicable. \r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\n.NET 6, console application\r\nWindows 11 x64\r\n\r\n### Other information\r\n\r\nI got in the log\r\n\r\n\u003e !!! RequestingAssembly = file:///C:/SCADA/ScadaServer/Mod/ModArcPostgreSql.Logic.dll\r\n\u003e     Item to resolve = ModArcPostgreSql.Common, Version=6.0.0.0, Culture=neutral, PublicKeyToken=null\r\n\u003e !!! LoadedAssembly = file:///C:/SCADA/ScadaServer/Mod/ModArcPostgreSql.Common.dll\r\n\u003e ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOSRNciA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5Il5Zw",
                                           "createdAt":  "2022-08-17T11:37:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\nUsing .NET 6, I load DLL dynamically into the default load context by calling Assembly.LoadFrom(fileName)\r\nThe loaded assembly have some dependencies.\r\nUsing AssemblyResolve and AssemblyLoad events I got that \r\n1) AssemblyResolve shows that resolution of a referenced assembly fails.\r\n2) Right after fail AssemblyLoad shows that the referenced assembly loaded successfully.\r\n\r\n\r\nPlease give a clue how to research the cause of that problem.\n\n### Reproduction Steps\n\n```\r\nstring fileName = \"...\";\r\nstring typeName = \"...\";\r\nAssembly assembly = Assembly.LoadFrom(fileName);\r\nType type = assembly.GetType(typeName, true);\r\nobject obj = (ModuleLogic)Activator.CreateInstance(type);\r\n\r\nAppDomain.CurrentDomain.AssemblyResolve += CurrentDomain_AssemblyResolve;\r\nAppDomain.CurrentDomain.AssemblyLoad += CurrentDomain_AssemblyLoad;\r\n\r\n// ...\r\n\r\nprivate Assembly CurrentDomain_AssemblyResolve(object sender, ResolveEventArgs args)\r\n{\r\n            Console.WriteLine(\"!!! RequestingAssembly = \" + args.RequestingAssembly.CodeBase);\r\n            Console.WriteLine(\"    Item to resolve = \" + args.Name);\r\n            return null;\r\n}\r\n\r\nprivate void CurrentDomain_AssemblyLoad(object sender, AssemblyLoadEventArgs args)\r\n{\r\n            Console.WriteLine(\"!!! LoadedAssembly = \" + args.LoadedAssembly.CodeBase);\r\n}\r\n\r\n```\r\n\n\n### Expected behavior\n\nThe assembly is loaded successfully on the 1st attempt.\r\nOf if assembly failed to load, it will not loaded later.\r\n\n\n### Actual behavior\n\nAssembly failed to load, then it is loaded successfully.\n\n### Regression?\n\n.NET Framework has another assembly loading mechanism, so it\u0027s not applicable. \n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n.NET 6, console application\r\nWindows 11 x64\n\n### Other information\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003e2mik\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-08-17T11:37:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Il6ci",
                                           "createdAt":  "2022-08-17T11:41:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "2mik",
                                           "body":  "The related issue may be https://github.com/dotnet/runtime/issues/1050",
                                           "updatedAt":  "2022-08-17T11:41:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5InGBU",
                                           "createdAt":  "2022-08-17T15:54:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "elinor-fung",
                                           "body":  "\u003e Assembly failed to load, then it is loaded successfully.\r\n\r\n@2mik do you mean that you have two separate calls to `Assembly.LoadFrom` where the first one fails (throws), but the second one succeeds? The repro code in the description just tries to load once.",
                                           "updatedAt":  "2022-08-17T15:54:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5InJ7_",
                                           "createdAt":  "2022-08-17T16:08:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "elinor-fung",
                                           "body":  "Or is the concern here that your `AssemblyResolve` handler is called (and it returns null) and then your `AssemblyLoad` handler is called?\r\n\r\nOne thing to note with the `Assembly.LoadFrom` API is that it will [add a handler](https://docs.microsoft.com/en-us/dotnet/core/dependency-loading/loading-managed#when-are-managed-assemblies-loaded) that will resolve assembly dependencies from the same directory as the assembly being loaded. If your `AssemblyResolve` handler was added first, it would be called before that handler for the `LoadFrom` (which would, if the dependency is next to the assembly, successfully resolve the dependency, resulting in the `AssemblyLoad` handler being called for it)",
                                           "updatedAt":  "2022-08-17T16:08:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Indmf",
                                           "createdAt":  "2022-08-17T17:29:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "2mik",
                                           "body":  "\u003e Or is the concern here that your `AssemblyResolve` handler is called (and it returns null) and then your `AssemblyLoad` handler is called?\r\n\r\nRight. I called Assembly.LoadFrom once, but then get 2 events, AssemblyResolve event and AssemblyLoad event for the same DLL.\r\nI added event handlers to AppDomain.CurrentDomain on application start. Note: I don\u0027t use `AssemblyLoadContext.Resolving` event because I need my code compatible with .NET Standard.\r\nAnyway, AssemblyLoadContext does not provide access to its internal resolvers (handlers). So I expect to handle an aggregated AssemblyResolve event if all built-in resolvers fail. Otherwise, the current behavior seems weird, because the Resolve event is bound to random resolver.",
                                           "updatedAt":  "2022-08-17T17:34:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JDit7",
                                           "createdAt":  "2022-08-24T12:37:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "In your code the `ResolveAssembly` event ends up having two handlers registered to it (in this order):\r\n* Your handler which prints out what it was called for\r\n* The handler from `Assembly.LoadFrom` implementation\r\n\r\nWhen the dependency resolution occurs, the system will invoke all handlers registered for the `ResolveAssembly` event, in the order they were registered. The first one which returns non-null, will end the resolution (if all return null, the resolution continues in this case it would fail).\r\nSo what happens is that your handler is called first, it returns null, so the second handler from `LoadFrom` is called, this will:\r\n* find the dependency next to the first file\r\n* calls `AssemblyLoadContext.Default.LoadFromAssemblyPath` to load the dependency\r\n  * Since this is a successful load, it will trigger the `AssemblyLoad` event - which calls your handler\r\n* returns the loaded assembly as a result of the `ResolveAssembly` event handler, which ends the resolution process successfully\r\n\r\nAll resolvers should be idempotent - meaning they should always behave the same way regardless of the order they\u0027re called in and the state of the app. So if your resolver can resolve the assembly, it should do so, always in the same way. It\u0027s not a good idea to have two different ways to resolve the same assembly with potentially two different results.",
                                           "updatedAt":  "2022-08-24T12:37:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JD5jw",
                                           "createdAt":  "2022-08-24T13:53:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "2mik",
                                           "body":  "@vitek-karas , thank you for the explanation. Now the situation is clear.\r\nMay be if I could see in debugger all the handlers which are called to resolve an assembly, it would be easy to understand by myself. Do you think it\u0027s possible to make handlers accessible from user\u0027s code in the future versions of .NET?",
                                           "updatedAt":  "2022-08-24T13:53:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JEYFS",
                                           "createdAt":  "2022-08-24T15:30:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "The resolution algorithm is relatively complicated, so \"handlers\" is not the right way to think about it - you can read more here: https://docs.microsoft.com/en-us/dotnet/core/dependency-loading/overview\r\n\r\nIf you need to diagnose subtle issues in the resolution process, we have tracing for that already: https://docs.microsoft.com/en-us/dotnet/core/dependency-loading/collect-details\r\n\r\nAll of the interesting points (including all the extensions points) in the resolution process trace events, so collecting a trace like above should allow you to understand in detail what happened and when and what was the result of it.\r\n\r\nLast option is - .NET is open source and for example VS can step into .NET source code (it will download the matching sources from github). So in theory you could debug all of it, but it\u0027s relatively tricky to do (the code goes between native and managed couple of times, which makes it difficult to step through).",
                                           "updatedAt":  "2022-08-24T15:30:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JE1yI",
                                           "createdAt":  "2022-08-24T17:11:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "2mik",
                                           "body":  "Thank you. The answer is an important addition to the mentioned documentation.",
                                           "updatedAt":  "2022-08-24T17:11:38Z"
                                       }
                                   ],
                         "totalCount":  9
                     },
        "title":  "Default AssemblyLoadContext resolves assembly on the 2nd attempt",
        "labels":  [
                       "question",
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/74203",
        "createdAt":  "2022-08-19T00:10:08Z",
        "number":  74203,
        "author":  "VSadov",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-08-19T21:37:40Z",
        "body":  "Re: https://github.com/dotnet/runtime/pull/74118\r\n\r\nWith that fix we support loading assemblies with R2R code from byte arrays, however we are not enabling R2R on OSX as that requires further changes, which we are not comfortable with this close to shipping.\r\n\r\nThis issue is to follow up with changes to enable R2R in such scenario.\r\n\r\nEDIT: we ended up disabling R2R on all platforms in this scenario. It may be worth checking if R2R has any benefits in this case.\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOuyhLYw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5IuTSt",
                                           "createdAt":  "2022-08-19T00:10:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nRe: https://github.com/dotnet/runtime/pull/74118\r\n\r\nWith that fix we support loading assemblies with R2R code from byte arrays, however we are not enabling R2R on OSX as that requires further changes, which we are not comfortable with this close to shipping.\r\n\r\nThis issue is to follow up with changes to enable R2R in such scenario.\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eVSadov\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003eVSadov\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e8.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-08-19T00:10:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ieuDd",
                                           "createdAt":  "2023-07-26T17:25:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "agocke",
                                           "body":  "Anything we plan to do here for 8.0? Or should I move this to 9.0?",
                                           "updatedAt":  "2023-07-26T17:25:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ie04N",
                                           "createdAt":  "2023-07-26T17:46:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "I moved it - there was basically no feedback on this either. We should still look into it, but it\u0027s not critical for 8.",
                                           "updatedAt":  "2023-07-26T17:46:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ife0e",
                                           "createdAt":  "2023-07-26T20:05:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "VSadov",
                                           "body":  "Agreed. This seems to be a niche scenario. ",
                                           "updatedAt":  "2023-07-26T20:05:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc67KEtj",
                                           "createdAt":  "2025-07-31T13:28:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "movedoa",
                                           "body":  "@vitek-karas @agocke \n\nPls reconsider enabling r2r when loading an assembly from memory.\nWe would need this on windows.\n\nWe have a plugin scenario where we load assemblies from memory at runtime and we lose considerable startup time to the JIT at the moment.\nR2R would help a lot but this would require us to write the assemblies to disk before loading which mitigates a lot of the speed improvements.\n",
                                           "updatedAt":  "2025-08-11T13:05:20Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "Consider enabling R2R when loading from a byte array on OSX",
        "labels":  [
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/74307",
        "createdAt":  "2022-08-21T14:46:09Z",
        "number":  74307,
        "author":  "hez2010",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCuqTBg==",
                          "nodes":  [
                                        {
                                            "content":  "HEART",
                                            "user":  "Enderlook",
                                            "createdAt":  "2022-12-11T19:10:53Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "maxkatz6",
                                            "createdAt":  "2023-03-02T05:53:14Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2022-09-06T15:35:02Z",
        "body":  "### Background and motivation\r\n\r\nWhile we were working with trimming, we found that we often want to express \"code only needed if a type is preserved\", but currently we do not have such thing in C#.\r\n\r\nFor example, in XAML frameworks, we use URLs to locate resources. With source generator, the code of the resource locator which is generated by a source generator may consist with a method with plenty of if statements, for example:\r\n\r\n```csharp\r\n// auto-generated by a source generator\r\nobject? LoadResource(string path)\r\n{\r\n    if (path == \"ms-appx://MyAssembly/My/Fancy/XamlControl1Style\") return XamlLoader.Load\u003cXamlControl1Style\u003e();\r\n    if (path == \"ms-appx://MyAssembly/Another/XamlControl2Style\") return XamlLoader.Load\u003cXamlControl2Style\u003e();\r\n    return null;\r\n}\r\n```\r\n\r\nWith this source generator approach, we can achieve trimming compatibility. However, this would result in all types referenced in `LoadResource` being preserved even they are not being actually used. In this case, we only want `XamlControl1Style` to be preserved if `XamlControl1` is referenced in other pieces of code. \r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Diagnostics.CodeAnalysis;\r\n\r\npublic class ControlFlow\r\n{\r\n    public static bool MakeWeakTypeReference\u003cT\u003e() =\u003e true;\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\nobject? LoadResource(string path)\r\n{\r\n    if (ControlFlow.MakeWeakTypeReference\u003cXamlControl1\u003e())\r\n        if (path == \"ms-appx://MyAssembly/My/Fancy/XamlControl1Style\")\r\n            return XamlLoader.Load\u003cXamlControl1Style\u003e();\r\n    if (ControlFlow.MakeWeakTypeReference\u003cXamlControl2\u003e())\r\n        if (path == \"ms-appx://MyAssembly/Another/XamlControl2Style\")\r\n            return XamlLoader.Load\u003cXamlControl2Style\u003e();\r\n    return null;\r\n}\r\n```\r\n\r\nIt behaves as a no-op which always returns true, but if there are no other type references to `XamlControl1`, the whole block of the if statement can be safely trimmed, which produces code after trimming like below:\r\n\r\n```csharp\r\nobject? LoadResource(string path)\r\n{\r\n    if (path == \"ms-appx://MyAssembly/Another/XamlControl2Style\")\r\n        return XamlLoader.Load\u003cXamlControl2Style\u003e();\r\n    return null;\r\n}\r\n```\r\n\r\nTherefore, all types related to `XamlControl1` and `XamlControl1Type` can also be trimmed away.\r\n\r\nThis should also support `and` and `or` so that we can express multiple types as a single prerequisite:\r\n\r\n```csharp\r\nif (ControlFlow.MakeWeakTypeReference\u003cFoo\u003e() \u0026\u0026 ControlFlow.MakeWeakTypeReference\u003cBar\u003e())\r\n{\r\n    // only preserved if both Foo and Bar are referenced\r\n}\r\n\r\nif (ControlFlow.MakeWeakTypeReference\u003cFoo\u003e() || ControlFlow.MakeWeakTypeReference\u003cBar\u003e())\r\n{\r\n    // only preserved if either Foo or Bar is referenced\r\n}\r\n\r\n// Bogus\r\nif (!ControlFlow.MakeWeakTypeReference\u003cFoo\u003e())\r\n{\r\n    // no-op, can never reach because `!ControlFlow.MakeWeakTypeReference\u003cFoo\u003e()` is always false, maybe a warning should be emitted by the compiler or illink?\r\n}\r\n```\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOSYGR0g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5Iz4Ww",
                                           "createdAt":  "2022-08-21T14:46:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-08-21T14:46:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Iz7Lk",
                                           "createdAt":  "2022-08-21T15:49:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to \u0027linkable-framework\u0027: @eerhardt, @vitek-karas, @LakshanF, @sbomer, @joperezr\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\r\n\r\nWhile we were working with trimming, we found that we often want to express \"code only needed if a type is preserved\", but currently we do not have such thing in C#.\r\n\r\nFor example, in XAML frameworks, we use URLs to locate resources. With source generator, the code of the resource locator which is generated by a source generator may consist with a method with plenty of if statements, for example:\r\n\r\n```csharp\r\n// auto-generated by a source generator\r\nobject? LoadResource(string path)\r\n{\r\n    if (path == \"ms-appx://MyAssembly/My/Fancy/XamlControl1Style\") return XamlLoader.Load\u003cXamlControl1Style\u003e();\r\n    if (path == \"ms-appx://MyAssembly/Another/XamlControl2Style\") return XamlLoader.Load\u003cXamlControl2Style\u003e();\r\n    return null;\r\n}\r\n```\r\n\r\nWith this source generator approach, we can achieve trimming compatibility. However, this would result in all types referenced in `LoadResource` being preserved even they are not being actually used. In this case, we only want `XamlControl1Style` to be preserved if `XamlControl1` is referenced in other pieces of code. \r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Diagnostics.CodeAnalysis;\r\n\r\npublic class ControlFlow\r\n{\r\n    public static bool MakeWeakTypeReference\u003cT\u003e() =\u003e true;\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\nobject? LoadResource(string path)\r\n{\r\n    if (ControlFlow.MakeWeakTypeReference\u003cXamlControl1\u003e())\r\n        if (path == \"ms-appx://MyAssembly/My/Fancy/XamlControl1Style\")\r\n            return XamlLoader.Load\u003cXamlControl1Style\u003e();\r\n    if (ControlFlow.MakeWeakTypeReference\u003cXamlControl2\u003e())\r\n        if (path == \"ms-appx://MyAssembly/Another/XamlControl2Style\")\r\n            return XamlLoader.Load\u003cXamlControl2Style\u003e();\r\n    return null;\r\n}\r\n```\r\n\r\nIt behaves as a no-op which always returns true, but if there are no other type references to `XamlControl1`, the whole block of the if statement can be safely trimmed, which produces code after trimming like below:\r\n\r\n```csharp\r\nobject? LoadResource(string path)\r\n{\r\n    if (ControlFlow.MakeWeakTypeReference\u003cXamlControl2\u003e())\r\n        if (path == \"ms-appx://MyAssembly/Another/XamlControl2Style\")\r\n            return XamlLoader.Load\u003cXamlControl2Style\u003e();\r\n    return null;\r\n}\r\n```\r\n\r\nTherefore, all types related to `XamlControl1` and `XamlControl1Type` can also be trimmed away.\r\n\r\nThis should also support `and` and `or` so that we can express multiple types as a single prerequisite:\r\n\r\n```csharp\r\nif (ControlFlow.MakeWeakTypeReference\u003cFoo\u003e() \u0026\u0026 ControlFlow.MakeWeakTypeReference\u003cBar\u003e())\r\n{\r\n    // only preserved if both Foo and Bar are referenced\r\n}\r\n\r\nif (ControlFlow.MakeWeakTypeReference\u003cFoo\u003e() || ControlFlow.MakeWeakTypeReference\u003cBar\u003e())\r\n{\r\n    // only preserved if either Foo or Bar is referenced\r\n}\r\n\r\n// Bogus\r\nif (!ControlFlow.MakeWeakTypeReference\u003cFoo\u003e())\r\n{\r\n    // no-op, can never reach because `!ControlFlow.MakeWeakTypeReference\u003cFoo\u003e()` is always false, maybe a warning should be emitted by the compiler or illink?\r\n}\r\n```\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ehez2010\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `untriaged`, `linkable-framework`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-08-21T15:49:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Iz7Mx",
                                           "createdAt":  "2022-08-21T15:49:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "Interesting idea; the name does not sound right to me though.",
                                           "updatedAt":  "2022-08-21T15:49:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Iz9sw",
                                           "createdAt":  "2022-08-21T16:48:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hez2010",
                                           "body":  "\u003e Interesting idea; the name does not sound right to me though.\n\nYes. I did think about the name for a while but didn\u0027t conclude a fancy name :)",
                                           "updatedAt":  "2022-08-21T16:48:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Iz99N",
                                           "createdAt":  "2022-08-21T16:55:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "Maybe `IsTypePresent\u003cT\u003e`?",
                                           "updatedAt":  "2022-08-21T16:55:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Iz-2U",
                                           "createdAt":  "2022-08-21T17:16:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "That\u0027s better, and with that name it fits more on `Type`.",
                                           "updatedAt":  "2022-08-21T17:16:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5I3DHf",
                                           "createdAt":  "2022-08-22T13:48:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCq89mw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "Joe4evr",
                                                                               "createdAt":  "2022-08-22T20:11:45Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "eerhardt",
                                           "body":  "See the following code, which we use in System.Text.Json to do this exact scenario:\r\n\r\nhttps://github.com/dotnet/runtime/blob/e71a9583b4d6c9bd97edd87cda7f98f232f63530/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Collection/IEnumerableConverterFactoryHelpers.cs#L120-L125",
                                           "updatedAt":  "2022-08-22T13:48:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5I3I0h",
                                           "createdAt":  "2022-08-22T14:07:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\r\n\r\nWhile we were working with trimming, we found that we often want to express \"code only needed if a type is preserved\", but currently we do not have such thing in C#.\r\n\r\nFor example, in XAML frameworks, we use URLs to locate resources. With source generator, the code of the resource locator which is generated by a source generator may consist with a method with plenty of if statements, for example:\r\n\r\n```csharp\r\n// auto-generated by a source generator\r\nobject? LoadResource(string path)\r\n{\r\n    if (path == \"ms-appx://MyAssembly/My/Fancy/XamlControl1Style\") return XamlLoader.Load\u003cXamlControl1Style\u003e();\r\n    if (path == \"ms-appx://MyAssembly/Another/XamlControl2Style\") return XamlLoader.Load\u003cXamlControl2Style\u003e();\r\n    return null;\r\n}\r\n```\r\n\r\nWith this source generator approach, we can achieve trimming compatibility. However, this would result in all types referenced in `LoadResource` being preserved even they are not being actually used. In this case, we only want `XamlControl1Style` to be preserved if `XamlControl1` is referenced in other pieces of code. \r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Diagnostics.CodeAnalysis;\r\n\r\npublic class ControlFlow\r\n{\r\n    public static bool MakeWeakTypeReference\u003cT\u003e() =\u003e true;\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\nobject? LoadResource(string path)\r\n{\r\n    if (ControlFlow.MakeWeakTypeReference\u003cXamlControl1\u003e())\r\n        if (path == \"ms-appx://MyAssembly/My/Fancy/XamlControl1Style\")\r\n            return XamlLoader.Load\u003cXamlControl1Style\u003e();\r\n    if (ControlFlow.MakeWeakTypeReference\u003cXamlControl2\u003e())\r\n        if (path == \"ms-appx://MyAssembly/Another/XamlControl2Style\")\r\n            return XamlLoader.Load\u003cXamlControl2Style\u003e();\r\n    return null;\r\n}\r\n```\r\n\r\nIt behaves as a no-op which always returns true, but if there are no other type references to `XamlControl1`, the whole block of the if statement can be safely trimmed, which produces code after trimming like below:\r\n\r\n```csharp\r\nobject? LoadResource(string path)\r\n{\r\n    if (path == \"ms-appx://MyAssembly/Another/XamlControl2Style\")\r\n        return XamlLoader.Load\u003cXamlControl2Style\u003e();\r\n    return null;\r\n}\r\n```\r\n\r\nTherefore, all types related to `XamlControl1` and `XamlControl1Type` can also be trimmed away.\r\n\r\nThis should also support `and` and `or` so that we can express multiple types as a single prerequisite:\r\n\r\n```csharp\r\nif (ControlFlow.MakeWeakTypeReference\u003cFoo\u003e() \u0026\u0026 ControlFlow.MakeWeakTypeReference\u003cBar\u003e())\r\n{\r\n    // only preserved if both Foo and Bar are referenced\r\n}\r\n\r\nif (ControlFlow.MakeWeakTypeReference\u003cFoo\u003e() || ControlFlow.MakeWeakTypeReference\u003cBar\u003e())\r\n{\r\n    // only preserved if either Foo or Bar is referenced\r\n}\r\n\r\n// Bogus\r\nif (!ControlFlow.MakeWeakTypeReference\u003cFoo\u003e())\r\n{\r\n    // no-op, can never reach because `!ControlFlow.MakeWeakTypeReference\u003cFoo\u003e()` is always false, maybe a warning should be emitted by the compiler or illink?\r\n}\r\n```\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ehez2010\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-AssemblyLoader-coreclr`, `untriaged`, `linkable-framework`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-08-22T14:07:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5I4kHR",
                                           "createdAt":  "2022-08-22T18:58:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkoritzinsky",
                                           "body":  "@eerhardt that\u0027s really clever and I think a good example for where an API like this could be useful. I think being able to have a well-known API that would enable this to work while using generics or strongly-typed `System.Type` objects instead of having to round-trip through type name parsing would be quite useful and likely more maintainable than the existing mechanism you shared.",
                                           "updatedAt":  "2022-08-22T18:58:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5I4kV2",
                                           "createdAt":  "2022-08-22T18:59:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "\u003e @eerhardt that\u0027s really clever and I think a good example for where an API like this could be useful. I think being able to have a well-known API that would enable this to work while using generics or strongly-typed `System.Type` objects instead of having to round-trip through type name parsing would be quite useful and likely more maintainable than the existing mechanism you shared.\r\n\r\nAdditionally, it\u0027d be more AOT safe.",
                                           "updatedAt":  "2022-08-22T18:59:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5I4krS",
                                           "createdAt":  "2022-08-22T19:00:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCq_j5A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "hez2010",
                                                                               "createdAt":  "2022-08-23T00:55:44Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_DOWN",
                                                                               "user":  "MichalPetryka",
                                                                               "createdAt":  "2022-08-23T11:50:22Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "```csharp\r\nnamespace System;\r\n\r\npublic abstract partial class Type\r\n{\r\n    public static Type? GetTypeIfExists\u003cT\u003e() =\u003e typeof(T); // would be replaced with null by the trimmer if the type does not exist.\r\n}\r\n```",
                                           "updatedAt":  "2022-08-22T19:00:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5I8-IL",
                                           "createdAt":  "2022-08-23T11:36:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kekekeks",
                                           "body":  "I believe that just getting the `Type` instance conditionally isn\u0027t enough for XAML styles. Not sure how it works in the case of the code generator mentioned in the issue, but with Avalonia XAML Styles will usually reference the properties of the type itself from MSIL.\r\n\r\ne. g. we have something like this (equivalent C# translation, the actual XAML compiler generates msil): \r\n\r\n```cs\r\nApplication.Resources[typeof(Button)] = new ControlTheme(typeof(Button))\r\n{\r\n  new Setter(Button.TemplateProperty, new FuncControlTemplate\u003cButton\u003e(() =\u003e new ContentPresenter\r\n  {\r\n      [ContentPresenter.ContentProperty] = new TemplateBinding(Button.ContentProperty),\r\n      [ContentPresenter.PaddingProperty] = new TemplateBinding(Button.PaddingProperty)\r\n  }));,\r\n  new Setter(Button.PaddingProperty, new Padding(4)),\r\n  ...\r\n}\r\n```\r\n\r\nDuring linking if Button class isn\u0027t used, it\u0027s needed to trim the entire code that constructs the Button\u0027s theme, because everything is strongly typed and liker we\u0027ll see references from MSIL, so the code would have to look like this:\r\n\r\n\r\n```cs\r\nif(Type.Exists\u003cButton\u003e())\r\n{\r\n  Application.Resources[typeof(Button)] = new ControlTheme(typeof(Button))\r\n  {\r\n    new Setter(Button.TemplateProperty, new FuncControlTemplate\u003cButton\u003e(() =\u003e new ContentPresenter\r\n    {\r\n        [ContentPresenter.ContentProperty] = new TemplateBinding(Button.ContentProperty),\r\n        [ContentPresenter.PaddingProperty] = new TemplateBinding(Button.PaddingProperty)\r\n    }));,\r\n    new Setter(Button.PaddingProperty, new Padding(4)),\r\n    ...\r\n  };\r\n}\r\n```\r\n\r\nwith `if` body trimmed away if `Button` class isn\u0027t referenced elsewhere.\r\n\r\n",
                                           "updatedAt":  "2022-08-23T11:43:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5I9MoU",
                                           "createdAt":  "2022-08-23T12:29:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "Working on `Type` would also be less AOT and linker friendly since for example the AOT wouldn\u0027t be able to MakeGenericType with types provided that way.",
                                           "updatedAt":  "2022-08-23T12:29:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5I9NRP",
                                           "createdAt":  "2022-08-23T12:31:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hez2010",
                                           "body":  "\u003e During linking if Button class isn\u0027t used, it\u0027s needed to trim the entire code that constructs the Button\u0027s theme, because everything is strongly typed and liker we\u0027ll see references from MSIL, so the code would have to look like this:\r\n\u003e \r\n\u003e ```cs\r\n\u003e if(Type.Exists\u003cButton\u003e())\r\n\u003e {\r\n\u003e   Application.Resources[typeof(Button)] = new ControlTheme(typeof(Button))\r\n\u003e   {\r\n\u003e     new Setter(Button.TemplateProperty, new FuncControlTemplate\u003cButton\u003e(() =\u003e new ContentPresenter\r\n\u003e     {\r\n\u003e         [ContentPresenter.ContentProperty] = new TemplateBinding(Button.ContentProperty),\r\n\u003e         [ContentPresenter.PaddingProperty] = new TemplateBinding(Button.PaddingProperty)\r\n\u003e     }));,\r\n\u003e     new Setter(Button.PaddingProperty, new Padding(4)),\r\n\u003e     ...\r\n\u003e   };\r\n\u003e }\r\n\u003e ```\r\n\u003e \r\n\u003e with `if` body trimmed away if `Button` class isn\u0027t referenced elsewhere.\r\n\r\nI think `if (Type.GetTypeIfExists\u003cButton\u003e() != null)` is equivalent to `if (Type.Exists\u003cButton\u003e())`.",
                                           "updatedAt":  "2022-08-23T12:31:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JAxs9",
                                           "createdAt":  "2022-08-23T22:10:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "This is another manifestation of a problem which we\u0027ve ran into couple of times already but so far didn\u0027t really tackle. Basically source generators have a hard time attaching the generated code to a \"target\" type. The usual recommendation is to make the target type partial and thus let the source generator adds stuff to it. But that\u0027s not always possible, for example in the above case of `Button` class, there\u0027s no good way to attach anything to it from the app\u0027s code.\r\n\r\nSo people solve this by introducing some types of registration mechanism. System.Text.Json uses the \"context\" for example. If such registration is global, it naturally leads to rooting everything in the registry regardless if it\u0027s needed by the app or not.\r\n\r\nThere was a similar discussion on the topic in this issue https://github.com/dotnet/runtime/issues/50333. The original take is somewhat different, but it discusses basically the same problem space.\r\n\r\nI do like the approach proposed in this issue which uses \"code\", instead of declarative attributes or similar solutions. But as proposed this goes against one of the main design principles of trimming:\r\n\u003e Trimming an app should not change any observable behavior of the code\r\n\r\nThis proposal would explicitly add a public API which changes behavior when trimmed. As used above it\u0027s OK, but one could easily use it to change other types of behavior and thus introduce unpredictability into the development process (debug build should behave the same as published app).\r\n\r\nTrimmer already has a feature which goes into this area:\r\n```C#\r\nvoid Test(object o)\r\n{\r\n    if (o is SpecialType)\r\n        Console.WriteLine(\"Found something special\");\r\n}\r\n```\r\n\r\nIf this is the only reference to `SpecialType` in the app, trimmer will actually remove `SpecialType` and rewrite the condition to `if (false)`. But it keeps the if branch around, along with all of its dependencies. (see [tests](https://github.com/dotnet/linker/blob/main/test/Mono.Linker.Tests.Cases/Advanced/TypeCheckRemoval.cs)).\r\n\r\nIf we extended this to actually remove the if branch it could be used to provide a solution the problem stated in this issue. The advantage of such solution would be that there\u0027s no observable difference when the app is trimmed. If the `SpecialType` is not used anywhere in the app, the if branch would never execute anyway (trimming or not), so it\u0027s effectively dead code and can be removed.\r\n\r\nIt would require a slight design change in the above samples, but it feels possible. I can also imagine supporting the `Type` version of this:\r\n```C#\r\nvoid Test(Type type)\r\n{\r\n    if (type == typeof(SpecialType))\r\n        Console.WriteLine(...);\r\n}\r\n```\r\n\r\nAlthough this might need more thinking if it\u0027s truly correct.\r\n\r\nNote that the \"instance\" version of this check is actually slightly better: If the `SpecialType` is used elsewhere, but it\u0027s never instantiated the condition can still be optimized away (as it will always be false). This is not true for the \"type\" variant.",
                                           "updatedAt":  "2022-08-23T22:10:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JBOX-",
                                           "createdAt":  "2022-08-24T01:14:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCrneLA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "charlesroddie",
                                                                               "createdAt":  "2022-09-03T13:39:48Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "I agree with Vitek that is this proposing an API addition that goes against how we want trimming to work - the trimmed app should behave the same as untrimmed app by default. Whenever there\u0027s a behavior difference, there should be a warning.\r\n\r\nWe would need to immediately tag this API as [`RequiresUnreferencedCode`](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.codeanalysis.requiresunreferencedcodeattribute?view=net-6.0) so that a warning is triggered. Suppressing trimming warnings is a can of worms and we very much recommend against suppressing any warnings. We were not able to get warning suppressions right in this very repo with all the expertise we have. I have zero confidence in third parties to get their suppressions right.\r\n\r\nBesides the philosophical problem above, the problem I have with an API like this is that it relies on branch removal. Branch removal does happen both in IL Linker and Native AOT. It is also done with different algorithms, and I would like to see the NativeAOT one to be replaced with whatever constprop RyuJIT can do, which is yet another algorithm.\r\n\r\nWe didn\u0027t document branch removal rules on purpose. We only test them on the runtime repo. We had to [adjust code](https://github.com/dotnet/runtime/pull/40539) in the runtime repo to fit the envelope of the optimization in the past. This would make relying on the shape of the optimization part of a public API surface (the API by itself has no legitimate use outside of this pattern). There would be no feedback if constprop is not able to kick in and doesn\u0027t eliminate a branch that the user expects. This is hard to debug for end users.\r\n\r\nThe other thing is that \"a type is preserved\" is a very murky concept:\r\n\r\n```csharp\r\nclass Program\r\n{\r\n    static void Do(SomeClass x) { }\r\n\r\n    static void Main()\r\n    {\r\n         // Is SomeClass preserved? Trimming at IL Level would need to preserve it\r\n        // because it’s referenced from the method signature. But it doesn’t exist for NativeAOT purposes\r\n        // except in the PDB.\r\n        Do(null);\r\n\r\n        // Is SomeClass preserved now?\r\n        // Assume SomeSimpleStaticMethod was simple enough that IL Linker inlined it.\r\n        SomeClass.SomeSimpleStaticMethod();\r\n\r\n        // How about now?\r\n        // SomeClass would be reflection visible now when IL trimming. NativeAOT still has leeway.\r\n        SomeClass.OtherSimpleStaticMethod();\r\n    }\r\n}\r\n```\r\n\r\nThis API is basically trying to query at runtime for the result of a compile time optimization that is supposed to be transparent.\r\n\r\n---------\r\n\r\nI would really like to think more in directions that can have the same behavior with/without trimming.\r\n\r\nFor the XAML example, could the Button class in its constructor do a callout that registers the styles? I assume we don\u0027t need styles for a button if no button was created yet.",
                                           "updatedAt":  "2022-08-24T01:14:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JCElG",
                                           "createdAt":  "2022-08-24T06:57:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kekekeks",
                                           "body":  "The problem with XAML styles is that they are completely separate from the control itself. Control does not and should not know anything about its styles, they are essentially user-defined and can be switched to a separate set of styles at runtime during the theme switch. \r\nJust like in WPF, in Avalonia styles are defined in a separate assembly (in case of Avalonia they come in separate nuget packages) and can be replaced for the entire app or a particular control subtree with another set of styles that come from a 3rd party package.",
                                           "updatedAt":  "2022-08-24T06:57:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JOK2Q",
                                           "createdAt":  "2022-08-26T12:52:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kekekeks",
                                           "body":  "Another use case:\r\n\r\nMy [COM interop bindings](https://github.com/kekekeks/MicroCom) generate COM interfaces as normal .NET interfaces.\r\n\r\ne. g. \r\n```\r\n[uuid(ED7F3339-8EB4-4912-9D6F-EC4CDD094164})]\r\ninterface IFoo : IUnknown\r\n{\r\n\tvoid Bar();\r\n}\r\n```\r\n\r\nbecomes\r\n```cs\r\n// IUnknown is defined as a marker interface on top of IDisposable\r\ninterface IFoo : IUnknown\r\n{\r\n    void Bar();\r\n}\r\n```\r\n\r\n\r\n\r\nInterop is handled by separate generated classes `__MicroComIFooProxy` (implements the managed interface and forwards calls to native function pointers) and `__MicroComIFooVTable` (builds a CCW vtable).\r\n\r\nBoth are registered by the module initializer. I\u0027d like to be able to trim unneeded interop types when the interface isn\u0027t used.",
                                           "updatedAt":  "2022-08-26T12:52:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JOXEt",
                                           "createdAt":  "2022-08-26T13:38:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Interop is handled by separate generated classes __MicroComIFooProxy (implements the managed interface and forwards calls to native function pointers) and __MicroComIFooVTable (builds a CCW vtable).\r\n\r\nCsWinRT solved this problem by linking the interop helper types via custom attributes: https://github.com/microsoft/CsWinRT/pull/1224",
                                           "updatedAt":  "2022-08-26T13:38:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JOgXb",
                                           "createdAt":  "2022-08-26T14:10:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kekekeks",
                                           "body":  "I believe such custom attributes require reflection access. MicroCom aims to work with IlcDisableReflection=True",
                                           "updatedAt":  "2022-08-26T14:10:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JOiac",
                                           "createdAt":  "2022-08-26T14:17:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "No, the attributes would be accessed at the time of the source generation, not at runtime.",
                                           "updatedAt":  "2022-08-26T14:17:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JOjFY",
                                           "createdAt":  "2022-08-26T14:19:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kekekeks",
                                           "body":  "`type.GetCustomAttribute` looks like run-time reflection to me: https://github.com/microsoft/CsWinRT/pull/1224/files#diff-2c2d5b5c93b2d4df6db3e983e3ba3126c9de5efa3648d9987c499904a3ea99b2R26-R54\r\nThis code doesn\u0027t seem like it would run with IlcDisableReflection too\r\n```cs\r\n\r\n                var helper = $\"ABI.{fullTypeName}\";\r\n                return type.Assembly.GetType(helper) ?? Type.GetType(helper);\r\n```",
                                           "updatedAt":  "2022-08-26T14:20:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JQgJv",
                                           "createdAt":  "2022-08-27T00:29:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e type.GetCustomAttribute looks like run-time reflection\r\n\r\nYes, custom attributes are accessed via reflection. The key advantage is that the helper type associations via custom attribute can be statically analyzed for correctness and the solution does not have concerns shared by @vitek-karas and @MichalStrehovsky above.\r\n\r\n\u003e  var helper = $\"ABI.{fullTypeName}\";\r\n\u003e return type.Assembly.GetType(helper) ?? Type.GetType(helper);\r\n\r\nThis is temporary fallback path that should go away eventually.",
                                           "updatedAt":  "2022-08-27T00:33:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JSkvs",
                                           "createdAt":  "2022-08-29T00:47:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCrds6w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2022-08-29T00:56:58Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "vitek-karas",
                                                                               "createdAt":  "2022-08-31T17:37:06Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "\u003e I believe such custom attributes require reflection access. MicroCom aims to work with IlcDisableReflection=True\r\n\r\nWorking with IlcDisableReflection is a noble goal but I don\u0027t think the base class libraries will ever be in a position where they work with IlcDisableReflection=true. They likely won\u0027t even work in the more usable future version of it: https://github.com/dotnet/runtime/issues/67193#issuecomment-1214229147. Trimmable reflection is not a problem and would be a good solution for this.\r\n\r\nIlcDisableReflection is a tech demo that was introduced before we had things like IlcTrimMetadata=true (which is now the default). With metadata trimming, I don\u0027t believe you\u0027ll see meaningful size differences with/without reflection for apps that are bigger than a console hello world. IlcDisableReflection produces meaningful savings for hello-world-sized apps because it allows removing the whole reflection stack, but that\u0027s a fixed ~1MB cost that is not worth it for most. We\u0027ll likely do work that will indirectly make this cost smaller over time. The reflection stack in NativeAOT is a bit overengineered.\r\n\r\nIf you still see a _meaningful_ difference for Avalonia-sized apps, please add `\u003cItemGroup\u003e\u003cIlcArg Include=\"--make-repro-path:c:\\some\\path\\where\\a\\zip\\can\\be\\created\" /\u003e\u003c/ItemGroup\u003e` to the project and share the resulting ZIP with me (in a new issue) - it\u0027s likely a bug - IlcDisableReflection has been useful in finding those in the past.",
                                           "updatedAt":  "2022-08-29T00:47:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JgZHS",
                                           "createdAt":  "2022-08-31T17:37:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "\u003e We didn\u0027t document branch removal rules on purpose. We only test them on the runtime repo. We had to https://github.com/dotnet/runtime/pull/40539 in the runtime repo to fit the envelope of the optimization in the past. This would make relying on the shape of the optimization part of a public API surface (the API by itself has no legitimate use outside of this pattern). There would be no feedback if constprop is not able to kick in and doesn\u0027t eliminate a branch that the user expects. This is hard to debug for end users.\r\n\r\nI view this as two separate things:\r\n* Correctness/consistency - the app behaves the same with/without trimming. The idea of branch removal doesn\u0027t violate this in any way. (unlike the proposed API which does)\r\n* Size optimization (trimming) - currently we don\u0027t describe nor make any promises with regard to trimming specific pieces of the app. The tools (trimmer, NativeAOT, ...) may decide to keep code/metadata around without any specific documented reason. This leads to us not making any size guarantees. The branch removal proposed above doesn\u0027t work today, but if it enabled it, it would simple improve size for some apps, but should have no other impact.\r\n\r\nThat said, it would be nice to have some agreed upon way especially for libraries to verify that they can be successfully trimmed to a certain degree - and to enable detection or regressions and such. But that\u0027s sort of outside the scope of this issue.",
                                           "updatedAt":  "2022-08-31T17:37:15Z"
                                       }
                                   ],
                         "totalCount":  25
                     },
        "title":  "[API Proposal]: MakeWeakTypeReference as trimming indicator",
        "labels":  [
                       "api-suggestion",
                       "area-AssemblyLoader-coreclr",
                       "linkable-framework"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/75067",
        "createdAt":  "2022-09-04T08:01:28Z",
        "number":  75067,
        "author":  "Seabizkit",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-10-31T19:54:46Z",
        "body":  "### Description\r\n\r\nMy code **fails** to run when **deployed,** seem to work when running through VS\r\n\r\nDetails I have a plugin which im using AssemblyLoadContext and have marked as `isCollectible: true`\r\nIt all seem to work, but does not work when deployed. \r\n\r\n**every project is on .net 6** to ensure no other variables when trying to debug this AssemblyLoadContext  and usage.\r\n\r\n-Web\r\n ---- Hosts - BackgroundProcessor\r\n-----------Kicks off Plugin code\r\n\r\nOnly code share with plugin is Component.Facade Lib which has no other references.(it works in VS).\r\n\r\nFails when trying to run plugin code.\r\nI deploy this with **self container** and targeting **Arm32** **Release** mode,  a PI4 with raspberry OS (32bit)\r\n\r\n**update: confirmed works in Debug but not Release in VS**\r\n\r\n**Exception message:**\r\nCould not load file or assembly \u0027Microsoft.Extensions.Hosting.Abstractions, Version=6.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\u0027. An operation is not legal in the current state. (0x80131509)\r\n\r\n**Exception inner:** \r\nCould not load file or assembly \u0027Microsoft.Extensions.Hosting.Abstractions, Version=6.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\u0027. **An operation is not legal in the current state. (0x80131509) AssemblyLoadContext is unloading or was already unloaded.** \r\n\r\n\r\nPlugin has:\r\n![image](https://user-images.githubusercontent.com/1920090/188303993-b70335f6-3aea-48d0-971a-61db1d4e74e3.png)\r\n\r\n**my guess the above is this is the issue, but how are you meant to handle this?**\r\n\r\nthe class which kicks off the plugin stuff is TaskComponentProcessor\r\n\r\ninside there I have \r\n```\r\n var pluginInfo = await _taskComponentHelper.EnsureLocalPluginAsync(item.BuilderComponentId.Value);\r\n  var pluginLocation = Path.GetFullPath(Path.Combine(pluginInfo.Path, pluginInfo.Name));\r\n  var loadContext = new PluginLoadContext(pluginLocation);\r\n  var componentUI = loadContext.GetImplementations\u003cBaseComponentUI\u003e().Single();\r\n  var plugin = loadContext.GetImplementations\u003cIParadoxComponent\u003e().Single();\r\n```\r\ni then call \r\n```\r\n var res = await plugin.ExcuteAsync(executingContext, ct);\r\n```\r\n\r\ncode for PluginLoadContext\r\n```\r\npublic class PluginLoadContext : AssemblyLoadContext\r\n  {\r\n      private AssemblyDependencyResolver _resolver;\r\n      private string _path;\r\n      public PluginLoadContext() : base(isCollectible: true)\r\n      { }\r\n\r\n      public PluginLoadContext(string pluginPath) : base(isCollectible: true)\r\n      {\r\n          _path = pluginPath;\r\n          _resolver = new AssemblyDependencyResolver(pluginPath);\r\n      }\r\n\r\n      protected override Assembly Load(AssemblyName assemblyName)\r\n      {\r\n          if (_resolver != null)\r\n          {\r\n              string assemblyPath = _resolver.ResolveAssemblyToPath(assemblyName);\r\n              if (assemblyPath != null)\r\n              {\r\n                  return LoadFromAssemblyPath(assemblyPath);\r\n              }\r\n          }\r\n          return null;\r\n      }\r\n\r\n      protected override IntPtr LoadUnmanagedDll(string unmanagedDllName)\r\n      {\r\n          string libraryPath = _resolver.ResolveUnmanagedDllToPath(unmanagedDllName);\r\n          if (libraryPath != null)\r\n          {\r\n              return LoadUnmanagedDllFromPath(libraryPath);\r\n          }\r\n\r\n          return IntPtr.Zero;\r\n      }\r\n\r\n      public IEnumerable\u003cT\u003e GetImplementations\u003cT\u003e()\r\n      {\r\n          var type = typeof(T);\r\n          var assName = AssemblyName.GetAssemblyName(_path);\r\n          var assembly = LoadFromAssemblyName(assName);\r\n          var types = assembly.GetTypes().ToList();\r\n          var other = new List\u003cType\u003e();\r\n          if (type.IsAbstract \u0026\u0026 !type.IsInterface)\r\n          {\r\n              other = types.Where(m =\u003e m.IsClass \u0026\u0026 !m.IsAbstract\r\n                                      \u0026\u0026 m.IsSubclassOf(type)\r\n                              ).ToList();\r\n          }\r\n          else\r\n          {\r\n              other = types.Where(t =\u003e type.IsAssignableFrom(t)).ToList();\r\n          }\r\n          return other\r\n              .Select(t =\u003e Activator.CreateInstance(t))\r\n              .Cast\u003cT\u003e();\r\n\r\n      }\r\n```\r\nStatcktrace:\r\n\r\n```\r\n at Paradox.Component.FtpDownloadPlugin.DIBuilder.Start(ExecutingContext e, Action`1 configureDelegate) \r\n at Paradox.Component.FtpDownloadPlugin.Plugin.SetupService(ExecutingContext e, IConfiguration configuration) \r\nin :\\Projects\\Paradox.Importer\\src\\ComponentContainer\\ComponentFunctions\\Paradox.Component.FtpDownload\\Plugin.cs:line 31  at Paradox.Component.FtpDownloadPlugin.Plugin.ExcuteAsync(ExecutingContext ec, CancellationToken ct) \r\nin :\\Projects\\Paradox.Importer\\src\\ComponentContainer\\ComponentFunctions\\Paradox.Component.FtpDownload\\Plugin.cs:line 58  at Paradox.Component.FtpDownloadPlugin.Plugin.ExcuteAsync(ExecutingContext ec, CancellationToken ct) \r\nin :\\Projects\\Paradox.Importer\\src\\ComponentContainer\\ComponentFunctions\\Paradox.Component.FtpDownload\\Plugin.cs:line 93  at Paradox.ComponentCode.TaskComponentProcessor.PreformStepPluginAsync(Int32 actionRequestId, BuilderTaskRun taskRun, BuilderTaskRunItem item, ProgressDto progressDto, IArtifactManger storageManger, CancellationToken ct) \r\nin C:\\Projects\\Paradox.Importer\\src\\ComponentContainer\\Paradox.ComponentCode\\TaskComponentProcessor.cs:line 343 \r\nat Paradox.ComponentCode.TaskComponentProcessor.PreformStepPluginAsync(Int32 actionRequestId, BuilderTaskRun taskRun, BuilderTaskRunItem item, ProgressDto progressDto, IArtifactManger storageManger, CancellationToken ct) \r\nin C:\\Projects\\Paradox.Importer\\src\\ComponentContainer\\Paradox.ComponentCode\\TaskComponentProcessor.cs:line 381 \r\n at Paradox.ComponentCode.TaskComponentProcessor.ExecuteAsync(Int32 actionRequestId, Int32 builderTaskRunId, CancellationToken ct) \r\nin C:\\Projects\\Paradox.Importer\\src\\ComponentContainer\\Paradox.ComponentCode\\TaskComponentProcessor.cs:line 164\r\n\r\n```\r\n\r\n\r\n### Reproduction Steps\r\n\r\nIt work when running through VS so, not sure how to debug,\r\nOpen to suggestions.\r\n\r\nin my plugin i have which i used to return a **IServiceProvider** so i can register any service the plugin may need.\r\n\r\n```\r\npublic class DIBuilder\r\n    {\r\n        private const string DefaultEnviroementName = \"Development\";\r\n        public static IServiceProvider Start(ExecutingContext e, Action\u003cIServiceCollection\u003e configureDelegate)\r\n        {\r\n\r\n            var configuration = SetConfigation(e);\r\n            var host = CreateHostBuilder(configuration, e, configureDelegate).Build();\r\n            return host.Services;\r\n        }\r\n\r\n        public static IConfiguration SetConfigation(ExecutingContext e)\r\n        {\r\n            //this should be local to the plugin and not the app: Hack\r\n            var directory = Directory.GetCurrentDirectory();\r\n\r\n            //  e.Logger.LogDebugAsync(directory);\r\n\r\n            var environment = Environment.GetEnvironmentVariable(\"ASPNET_ENVIROMENT\") ??\r\n                      Environment.GetEnvironmentVariable(\"ASPNETCORE_ENVIRONMENT\") ??\r\n                      DefaultEnviroementName;\r\n\r\n            //  e.Logger.LogDebugAsync(environment);\r\n\r\n            var builder = new ConfigurationBuilder()\r\n                .SetBasePath(directory)\r\n                .AddJsonFile($\"appsettings.json\", true, true)\r\n                .AddJsonFile($\"appsettings.{environment}.json\", optional: true, reloadOnChange: true);\r\n\r\n            IConfiguration configuration = builder.Build();\r\n            return configuration;\r\n        }\r\n\r\n        public static IHostBuilder CreateHostBuilder(IConfiguration configuration, ExecutingContext e,\r\n            Action\u003cIServiceCollection\u003e configureDelegate, string[] args = null)\r\n        {\r\n            return Host.CreateDefaultBuilder(args)\r\n                      .ConfigureServices(configureDelegate);\r\n        }\r\n    }\r\n```\r\n\r\n### Expected behavior\r\n\r\nShould not through exception, or at  least help with how to fix it.\r\n\r\n### Actual behavior\r\n\r\nfails when deployed, giving the exception\r\n\r\n**Exception message:**\r\nCould not load file or assembly \u0027Microsoft.Extensions.Hosting.Abstractions, Version=6.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\u0027. An operation is not legal in the current state. (0x80131509)\r\n\r\n**Exception inner:** \r\nCould not load file or assembly \u0027Microsoft.Extensions.Hosting.Abstractions, Version=6.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\u0027. **An operation is not legal in the current state. (0x80131509) AssemblyLoadContext is unloading or was already unloaded.** \r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\n_No response_\r\n\r\n### Other information\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOTVfOgA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5JsDA2",
                                           "createdAt":  "2022-09-04T08:01:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-09-04T08:01:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JsHgT",
                                           "createdAt":  "2022-09-04T09:57:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\n\r\nMy code **fails** to run when **deployed,** seem to work when running through VS\r\n\r\nDetails I have a plugin which im using AssemblyLoadContext and have marked as `isCollectible: true`\r\nIt all seem to work, but does not work when deployed. \r\n\r\n**every project is on .net 6** to ensure no other variables when trying to debug this AssemblyLoadContext  and usage.\r\n\r\n-Web\r\n ---- Hosts - BackgroundProcessor\r\n-----------Kicks off Plugin code\r\n\r\nOnly code share with plugin is Component.Facade Lib which has no other references.(it works in VS).\r\n\r\nFails when trying to run plugin code.\r\nI deploy this with **self container** and targeting **Arm32** **Release** mode,  a PI4 with raspberry OS (32bit)\r\n\r\n**update: confirmed works in Debug but not Release in VS**\r\n\r\n**Exception message:**\r\nCould not load file or assembly \u0027Microsoft.Extensions.Hosting.Abstractions, Version=6.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\u0027. An operation is not legal in the current state. (0x80131509)\r\n\r\n**Exception inner:** \r\nCould not load file or assembly \u0027Microsoft.Extensions.Hosting.Abstractions, Version=6.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\u0027. **An operation is not legal in the current state. (0x80131509) AssemblyLoadContext is unloading or was already unloaded.** \r\n\r\n\r\nPlugin has:\r\n![image](https://user-images.githubusercontent.com/1920090/188303993-b70335f6-3aea-48d0-971a-61db1d4e74e3.png)\r\n\r\n**my guess the above is this is the issue, but how are you mean to handle this?**\r\n\r\nthe class which kicks off the plugin stuff is TaskComponentProcessor\r\n\r\ninside there I have \r\n```\r\n var pluginInfo = await _taskComponentHelper.EnsureLocalPluginAsync(item.BuilderComponentId.Value);\r\n  var pluginLocation = Path.GetFullPath(Path.Combine(pluginInfo.Path, pluginInfo.Name));\r\n  var loadContext = new PluginLoadContext(pluginLocation);\r\n  var componentUI = loadContext.GetImplementations\u003cBaseComponentUI\u003e().Single();\r\n  var plugin = loadContext.GetImplementations\u003cIParadoxComponent\u003e().Single();\r\n```\r\ni then call \r\n```\r\n var res = await plugin.ExcuteAsync(executingContext, ct);\r\n```\r\n\r\ncode for PluginLoadContext\r\n```\r\npublic class PluginLoadContext : AssemblyLoadContext\r\n  {\r\n      private AssemblyDependencyResolver _resolver;\r\n      private string _path;\r\n      public PluginLoadContext() : base(isCollectible: true)\r\n      { }\r\n\r\n      public PluginLoadContext(string pluginPath) : base(isCollectible: true)\r\n      {\r\n          _path = pluginPath;\r\n          _resolver = new AssemblyDependencyResolver(pluginPath);\r\n      }\r\n\r\n      protected override Assembly Load(AssemblyName assemblyName)\r\n      {\r\n          if (_resolver != null)\r\n          {\r\n              string assemblyPath = _resolver.ResolveAssemblyToPath(assemblyName);\r\n              if (assemblyPath != null)\r\n              {\r\n                  return LoadFromAssemblyPath(assemblyPath);\r\n              }\r\n          }\r\n          return null;\r\n      }\r\n\r\n      protected override IntPtr LoadUnmanagedDll(string unmanagedDllName)\r\n      {\r\n          string libraryPath = _resolver.ResolveUnmanagedDllToPath(unmanagedDllName);\r\n          if (libraryPath != null)\r\n          {\r\n              return LoadUnmanagedDllFromPath(libraryPath);\r\n          }\r\n\r\n          return IntPtr.Zero;\r\n      }\r\n\r\n      public IEnumerable\u003cT\u003e GetImplementations\u003cT\u003e()\r\n      {\r\n          var type = typeof(T);\r\n          var assName = AssemblyName.GetAssemblyName(_path);\r\n          var assembly = LoadFromAssemblyName(assName);\r\n          var types = assembly.GetTypes().ToList();\r\n          var other = new List\u003cType\u003e();\r\n          if (type.IsAbstract \u0026\u0026 !type.IsInterface)\r\n          {\r\n              other = types.Where(m =\u003e m.IsClass \u0026\u0026 !m.IsAbstract\r\n                                      \u0026\u0026 m.IsSubclassOf(type)\r\n                              ).ToList();\r\n          }\r\n          else\r\n          {\r\n              other = types.Where(t =\u003e type.IsAssignableFrom(t)).ToList();\r\n          }\r\n          return other\r\n              .Select(t =\u003e Activator.CreateInstance(t))\r\n              .Cast\u003cT\u003e();\r\n\r\n      }\r\n```\r\nStatcktrace:\r\n\r\n```\r\n at Paradox.Component.FtpDownloadPlugin.DIBuilder.Start(ExecutingContext e, Action`1 configureDelegate) \r\n at Paradox.Component.FtpDownloadPlugin.Plugin.SetupService(ExecutingContext e, IConfiguration configuration) \r\nin :\\Projects\\Paradox.Importer\\src\\ComponentContainer\\ComponentFunctions\\Paradox.Component.FtpDownload\\Plugin.cs:line 31  at Paradox.Component.FtpDownloadPlugin.Plugin.ExcuteAsync(ExecutingContext ec, CancellationToken ct) \r\nin :\\Projects\\Paradox.Importer\\src\\ComponentContainer\\ComponentFunctions\\Paradox.Component.FtpDownload\\Plugin.cs:line 58  at Paradox.Component.FtpDownloadPlugin.Plugin.ExcuteAsync(ExecutingContext ec, CancellationToken ct) \r\nin :\\Projects\\Paradox.Importer\\src\\ComponentContainer\\ComponentFunctions\\Paradox.Component.FtpDownload\\Plugin.cs:line 93  at Paradox.ComponentCode.TaskComponentProcessor.PreformStepPluginAsync(Int32 actionRequestId, BuilderTaskRun taskRun, BuilderTaskRunItem item, ProgressDto progressDto, IArtifactManger storageManger, CancellationToken ct) \r\nin C:\\Projects\\Paradox.Importer\\src\\ComponentContainer\\Paradox.ComponentCode\\TaskComponentProcessor.cs:line 343 \r\nat Paradox.ComponentCode.TaskComponentProcessor.PreformStepPluginAsync(Int32 actionRequestId, BuilderTaskRun taskRun, BuilderTaskRunItem item, ProgressDto progressDto, IArtifactManger storageManger, CancellationToken ct) \r\nin C:\\Projects\\Paradox.Importer\\src\\ComponentContainer\\Paradox.ComponentCode\\TaskComponentProcessor.cs:line 381 \r\n at Paradox.ComponentCode.TaskComponentProcessor.ExecuteAsync(Int32 actionRequestId, Int32 builderTaskRunId, CancellationToken ct) \r\nin C:\\Projects\\Paradox.Importer\\src\\ComponentContainer\\Paradox.ComponentCode\\TaskComponentProcessor.cs:line 164\r\n\r\n```\r\n\r\n\r\n### Reproduction Steps\r\n\r\nIt work when running through VS so, not sure how to debug,\r\nOpen to suggestions.\r\n\r\nin my plugin i have which i used to return a **IServiceProvider** so i can register any service the plugin may need.\r\n\r\n```\r\npublic class DIBuilder\r\n    {\r\n        private const string DefaultEnviroementName = \"Development\";\r\n        public static IServiceProvider Start(ExecutingContext e, Action\u003cIServiceCollection\u003e configureDelegate)\r\n        {\r\n\r\n            var configuration = SetConfigation(e);\r\n            var host = CreateHostBuilder(configuration, e, configureDelegate).Build();\r\n            return host.Services;\r\n        }\r\n\r\n        public static IConfiguration SetConfigation(ExecutingContext e)\r\n        {\r\n            //this should be local to the plugin and not the app: Hack\r\n            var directory = Directory.GetCurrentDirectory();\r\n\r\n            //  e.Logger.LogDebugAsync(directory);\r\n\r\n            var environment = Environment.GetEnvironmentVariable(\"ASPNET_ENVIROMENT\") ??\r\n                      Environment.GetEnvironmentVariable(\"ASPNETCORE_ENVIRONMENT\") ??\r\n                      DefaultEnviroementName;\r\n\r\n            //  e.Logger.LogDebugAsync(environment);\r\n\r\n            var builder = new ConfigurationBuilder()\r\n                .SetBasePath(directory)\r\n                .AddJsonFile($\"appsettings.json\", true, true)\r\n                .AddJsonFile($\"appsettings.{environment}.json\", optional: true, reloadOnChange: true);\r\n\r\n            IConfiguration configuration = builder.Build();\r\n            return configuration;\r\n        }\r\n\r\n        public static IHostBuilder CreateHostBuilder(IConfiguration configuration, ExecutingContext e,\r\n            Action\u003cIServiceCollection\u003e configureDelegate, string[] args = null)\r\n        {\r\n            return Host.CreateDefaultBuilder(args)\r\n                      .ConfigureServices(configureDelegate);\r\n        }\r\n    }\r\n```\r\n\r\n### Expected behavior\r\n\r\nShould not through exception, or at  least help with how to fix it.\r\n\r\n### Actual behavior\r\n\r\nfails when deployed, giving the exception\r\n\r\n**Exception message:**\r\nCould not load file or assembly \u0027Microsoft.Extensions.Hosting.Abstractions, Version=6.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\u0027. An operation is not legal in the current state. (0x80131509)\r\n\r\n**Exception inner:** \r\nCould not load file or assembly \u0027Microsoft.Extensions.Hosting.Abstractions, Version=6.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\u0027. **An operation is not legal in the current state. (0x80131509) AssemblyLoadContext is unloading or was already unloaded.** \r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\n_No response_\r\n\r\n### Other information\r\n\r\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eSeabizkit\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-09-04T09:57:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JsKvC",
                                           "createdAt":  "2022-09-04T11:18:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Seabizkit",
                                           "body":  "update i added \r\n\r\n```\r\n   finally {\r\n               loadContext.Unload();\r\n            }\r\n```\r\n\r\nand it appears to be working... like surely not? what is going on here, are some how required to call unload in release..?\r\n\r\nPS - before i was not calling Unload(); at all as i was like when it goes out the scope the GC will handle it\r\n",
                                           "updatedAt":  "2022-09-04T11:22:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Js-Yz",
                                           "createdAt":  "2022-09-05T04:22:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "It\u0027s hard to tell for sure without seeing everything, but based on your description I would guess that it has to do with lifetime of local variables. The runtime is free to unload the context if there are no references to it anywhere. If the only reference is in local variable I could see the JIT releasing the reference at different spots between Debug/Release. It would also explain why adding the finally solves this as that will make sure the local holds onto the context until the end. This is probably a bit more complicated due to the use of async...\r\n\r\nYou could try to gather a loader trace: https://docs.microsoft.com/en-us/dotnet/core/dependency-loading/collect-details - it might have enough detail to tell the order of things.",
                                           "updatedAt":  "2022-09-05T04:22:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5J0DHr",
                                           "createdAt":  "2022-09-06T16:26:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "Moving this to Future for now since for so far this doesn\u0027t look like a bug in the product to me (just complex behavior , which is probably by design for now).",
                                           "updatedAt":  "2022-09-06T16:26:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NG5N3",
                                           "createdAt":  "2022-10-27T14:57:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Seabizkit",
                                           "body":  "@vitek-karas i could you access to my private repo, further to this i have a memory leak, trying to diagnose but quite difficult.\r\n\r\nI believe the memory leek is because unload is not actually unloading. \r\n\r\nwould you mind taking a look?",
                                           "updatedAt":  "2022-10-27T14:57:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NIFuJ",
                                           "createdAt":  "2022-10-27T19:24:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "You can try the debugging guide here: https://learn.microsoft.com/en-us/dotnet/standard/assembly/unloadability#debug-unloading-issues\r\nIt describes some of the tools you can use to figure out what prevents the ALC to unload.",
                                           "updatedAt":  "2022-10-27T19:24:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NU6G2",
                                           "createdAt":  "2022-10-31T16:10:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Seabizkit",
                                           "body":  "Hi @vitek-karas  \r\n\r\nSo been trying to simplify things so i can try see where things are going wrong.\r\n\r\nI have test code ....,to try and test my plugin \u0027Paradox.Component.EmailPlugin\u0027\r\n\r\n```\r\n[TestMethod]\r\npublic async Task TestMethod1Async()\r\n{\r\n\tvar directory = Directory.GetCurrentDirectory();\r\n\tvar scrFolder = \"src\";\r\n\tvar indexOfSrc = directory.IndexOf(scrFolder);\r\n\tvar srcBaseDirectory = directory.Substring(0, indexOfSrc + scrFolder.Length);\r\n\tvar pluginFolder = Path.Combine(srcBaseDirectory, \"_Plugins\");\r\n\tvar plugins = Directory.GetDirectories(pluginFolder);\r\n\tforeach (var item in plugins) \r\n\t{\r\n\t\tvar folderName = Path.GetFileName(item);\r\n\t\tvar fullpath = Path.Combine(item, folderName + \".dll\");\r\n\t\tvar loadContext = new PluginLoadContext(fullpath);\r\n\t\tvar componentUI = loadContext.GetImplementations\u003cBaseComponentUI\u003e().Single();\r\n\t\tvar plugin = loadContext.GetImplementations\u003cIParadoxComponent\u003e().Single();\r\n\t\tawait plugin.ExcuteAsync();\r\n\t}\r\n}\r\n```\r\nParadox.Component.EmailPlugin has no other reference other than the interface project and that project reference no other projects.\r\n\r\nthe plugin code, I\u0027m registering an IHost inside the plugin so I can get services via ServiceProvider \r\n```\r\npublic class Plugin : IParadoxComponent\r\n{\r\n    public Guid IdentifferName =\u003e new Guid(\"0EFC02C1-E923-4183-B98F-1562237BA62B\");\r\n    public string Name =\u003e \"Paradox email\";\r\n    public string ShortName =\u003e \"Email\";\r\n    public string Author =\u003e \"Paradox\";\r\n    public string Description =\u003e \"Create and send basic email.\";\r\n    public string ImageIcon =\u003e \"fa-envelope\";\r\n    public string ImageUrl =\u003e \"\";\r\n\r\n    private Action\u003cHostBuilderContext, IServiceCollection\u003e SetupServiceNew()\r\n    {\r\n        Action\u003cHostBuilderContext, IServiceCollection\u003e configureDelegate = (hostBuilder, services) =\u003e\r\n        {\r\n            var config = hostBuilder.Configuration;\r\n            services.AddScoped\u003cIEmailSender, EmailSender\u003e();\r\n            var provider = new FileExtensionContentTypeProvider();\r\n            services.AddSingleton\u003cIMimeMappingHelper\u003e(new MimeMappingHelper(provider));\r\n        };\r\n        return configureDelegate;\r\n    }\r\n    public async Task ExcuteAsync()\r\n    {\r\n        using (var host = DIBuilder.Start(SetupServiceNew()))\r\n        using (var scope = host.Services.CreateScope())\r\n        {\r\n            var services = scope.ServiceProvider;\r\n            var emailSender = services.GetRequiredService\u003cIEmailSender\u003e();\r\n            var mappingHelper = services.GetRequiredService\u003cIMimeMappingHelper\u003e();\r\n\r\n            var instance = new ComponentProvider(emailSender, mappingHelper);\r\n\r\n        }\r\n    }\r\n}\r\n\r\n```\r\nDIBuilder code\r\n\r\n```\r\n public class DIBuilder\r\n    {\r\n        private const string DefaultEnviroementName = \"Development\";\r\n\r\n        public static IHost Start(Action\u003cHostBuilderContext, IServiceCollection\u003e configureDelegate)\r\n        {\r\n            try\r\n            {\r\n                var host = CreateHostBuilder(configureDelegate).Build();\r\n                return host;\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                throw;\r\n            }\r\n\r\n        }\r\n\r\n        public static IHostBuilder CreateHostBuilder(Action\u003cHostBuilderContext, IServiceCollection\u003e configureDelegate, string[] args = null)\r\n        {\r\n            return Host.CreateDefaultBuilder(args)\r\n                     .ConfigureHostConfiguration(configHost =\u003e\r\n                     {\r\n                         //var global = Directory.GetCurrentDirectory();\r\n                         string LocalPath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);\r\n\r\n                         var environment = Environment.GetEnvironmentVariable(\"ASPNET_ENVIROMENT\") ??\r\n                         Environment.GetEnvironmentVariable(\"ASPNETCORE_ENVIRONMENT\") ??\r\n                         DefaultEnviroementName;\r\n\r\n                         configHost\r\n                             .SetBasePath(LocalPath)\r\n                             .AddJsonFile($\"appsettings.json\", true, reloadOnChange: false)\r\n                             .AddJsonFile($\"appsettings.{environment}.json\", optional: true, reloadOnChange: false);\r\n                         // .AddDatabaseConfiguration();\r\n\r\n                     })\r\n                      .ConfigureServices(configureDelegate);\r\n        }\r\n    }\r\n```\r\n\r\nAn exception is being thrown: \r\nCould not load file or assembly \u0027System.Diagnostics.EventLog, Version=6.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51\u0027. The system cannot find the file specified.\r\n\r\nthis make non sense to me, could you assit\r\nthe files inside of the plugin folder\r\n![image](https://user-images.githubusercontent.com/1920090/199055227-7267f5a9-779a-41de-8097-bc0fd7c4691b.png)\r\n\r\n",
                                           "updatedAt":  "2022-10-31T16:10:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NV86A",
                                           "createdAt":  "2022-10-31T19:54:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "It\u0027s hard to answer this without more details. I would:\r\n* Look at the callstack the exception came from - or even better catch it in the debugger to see exactly where it\u0027s coming from (which instance of the plugin and so on)\r\n* Use the technique described here: https://learn.microsoft.com/en-us/dotnet/core/dependency-loading/collect-details. This will tell you exactly what the runtime did to load the assembly and exactly where it failed.",
                                           "updatedAt":  "2022-10-31T19:54:46Z"
                                       }
                                   ],
                         "totalCount":  9
                     },
        "title":  "AssemblyLoadContext is unloading or was already unloaded.",
        "labels":  [
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/78539",
        "createdAt":  "2022-11-18T05:23:42Z",
        "number":  78539,
        "author":  "jkotas",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-07-25T17:28:24Z",
        "body":  "## Repro\r\n\r\n1. `dotnet new console` in .NET 7 SDK, copy\u0026paste the following program (repro extracted from actual app where the issue was observed) \r\n```\r\nusing System.Diagnostics;\r\n\r\nvar sw = new Stopwatch();\r\nfor (;;)\r\n{\r\n    sw.Restart();\r\n    for (int i = 0; i \u003c 100000; i++) Type.GetType(\"System.String, System.Runtime\");\r\n    Console.WriteLine(sw.ElapsedMilliseconds);\r\n}\r\n```\r\n2. `dotnet run`\r\n3. Download latest [perfview](https://github.com/microsoft/perfview) and start a global collection session with default settings (Select \"Collect / Collect\" from menu and press \"Start Collection\" button)\r\n\r\n## Actual result\r\n\r\nProgram runs more than 10x slower when the perfview collection session is active\r\n\r\n## Expected result\r\n\r\nDefault perfview collection settings should not slow down the program by more than 10%\r\n\r\n----\r\n\r\nThe problem is caused by very slow assembly loader tracing. The fix should be to either make assembly loader tracing a lot faster and lighter weight for cases like this one and/or assembly loader tracing should not be enabled for default (perfview) event collection settings.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOTtTQcQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5OpvLV",
                                           "createdAt":  "2022-11-18T05:23:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-11-18T05:23:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5OpvhS",
                                           "createdAt":  "2022-11-18T05:25:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n## Repro\r\n\r\n1. `dotnet new console` in .NET 7 SDK, copy\u0026paste the following program (repro extracted from actual app where the issue was observed) \r\n```\r\nusing System.Diagnostics;\r\n\r\nvar sw = new Stopwatch();\r\nfor (;;)\r\n{\r\n    sw.Restart();\r\n    for (int i = 0; i \u003c 100000; i++) Type.GetType(\"System.String, System.Runtime\");\r\n    Console.WriteLine(sw.ElapsedMilliseconds);\r\n}\r\n```\r\n2. `dotnet run`\r\n3. Download latest [perfview](https://github.com/microsoft/perfview) and start a global collection session with default settings (Select \"Collect / Collect\" from menu and press \"Start Collection\" button)\r\n\r\n## Actual result\r\n\r\nProgram runs more than 10x slower when the perfview collection session is active\r\n\r\n## Expected result\r\n\r\nDefault perfview collection settings should not slow down the program by more than 10%\r\n\r\n----\r\n\r\nThe problem is caused by very slow assembly loader tracing. The fix should be to either make assembly loader tracing a lot faster and lighter weight for cases like this one and/or assembly loader tracing should not be enabled for default (perfview) event collection settings.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejkotas\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-11-18T05:25:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5OyoBx",
                                           "createdAt":  "2022-11-21T11:16:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "I don\u0027t think detailed assembly load tracing should be enabled by default - it was not designed for that case. We specifically \"Didn\u0027t care much\" about perf since the goal was to provide on demand diagnostic tool.\r\n\r\n@elinor-fung could you please look into disabling this as part of the default collection?",
                                           "updatedAt":  "2022-11-21T11:16:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5O1M7V",
                                           "createdAt":  "2022-11-21T19:53:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "elinor-fung",
                                           "body":  "Agreed - it is intended for targeted assembly loading investigation and should not be enabled by default.\r\n\r\nI\u0027ll look at updating perfview / TraceEvent defaults.",
                                           "updatedAt":  "2022-11-21T19:53:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5O1NBx",
                                           "createdAt":  "2022-11-21T19:53:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "elinor-fung",
                                           "body":  "It looks like some of the VS tools also enable it - I\u0027ll get in contact for those as well.",
                                           "updatedAt":  "2022-11-21T19:53:46Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "Assembly loader event tracing is very expensive (10x application slowdown)",
        "labels":  [
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/78649",
        "createdAt":  "2022-11-21T18:42:21Z",
        "number":  78649,
        "author":  "linkem",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC19z2w==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kl1mm",
                                            "createdAt":  "2024-02-19T15:14:53Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2023-06-26T14:15:04Z",
        "body":  "### Description\n\nApplication loaded by `AssemblyLoadContext` (implementation from [documentation](https://learn.microsoft.com/en-us/dotnet/core/tutorials/creating-app-with-plugin-support#load-plugins)) loads multiple `.dll` files with same `AssemblyName` which leads to exceptions like `System.MissingMethodException Method not found: ...`\n\n### Reproduction Steps\n\nSmall repo with reproduction code [here](https://github.com/linkem/AssemblyLoadContextError)\r\n\r\n### Repro with exception\r\n* Build `PluginApp1` application\r\n* Start `PluginHost`\r\n* Exception is thrown:\r\n    ```\r\n    System.MissingMethodException\r\n        HResult=0x80131513\r\n        Message=Method not found: \u0027System.Threading.Tasks.Task`1\u003c!!0\u003e System.Net.Http.Json.HttpContentJsonExtensions.ReadFromJsonAsync(System.Net.Http.HttpContent, System.Text.Json.JsonSerializerOptions, System.Threading.CancellationToken)\u0027.\r\n        Source=PluginApp1\r\n        StackTrace:\r\n            at PluginApp1.PluginApp1.\u003cExecute\u003ed__0.MoveNext() in C:\\projects\\GitHub\\Github.AssemblyLoadContextError\\PluginApp1\\PluginApp1.cs:line 32\r\n            at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[TStateMachine](TStateMachine\u0026 stateMachine) in /_/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/AsyncMethodBuilderCore.cs:line 38\r\n            at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[TStateMachine](TStateMachine\u0026 stateMachine) in /_/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/AsyncTaskMethodBuilder.cs:line 33\r\n            at PluginApp1.PluginApp1.Execute(CancellationToken cancellationToken) in C:\\projects\\GitHub\\Github.AssemblyLoadContextError\\PluginApp1\\PluginApp1.cs:line 9\r\n            at Program.\u003c\u003cMain\u003e$\u003ed__0.MoveNext() in C:\\projects\\GitHub\\Github.AssemblyLoadContextError\\HostApp\\Program.cs:line 12\r\n            at Program.\u003cMain\u003e(String[] args)\r\n    ```\r\n\r\n### Repro with listed duplicated assemblies\r\n* Comment out `PluginApp1.PluginApp1.cs` line `30`\r\n* Build `PluginApp1` application\r\n* Start `PluginHost`\r\n* Application should print output similar to this one:\r\n    ```\r\n    For Assembly \u0027System.Text.Json\u0027 found multiple instances:\r\n\r\n    System.Text.Json, Version=6.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51; Location: \u003cPROJECT_PATH\u003e\\PluginApp1\\bin\\Debug\\net6.0\\System.Text.Json.dll\r\n\r\n    System.Text.Json, Version=6.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51; Location: C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\6.0.11\\System.Text.Json.dll\r\n    ```\r\n* Output indicates that there were loaded multiple assemblies with same name \u0027System.Text.Json\u0027\n\n### Expected behavior\n\nPlugin application should be started without duplicated assemblies, it should use assembly that is in local folder **or** in `shared\\Microsoft.NETCore.App` but not both.\n\n### Actual behavior\n\nIn some cases duplicated assemblies are loaded.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nFor case presented in repro, in application `PluginApp1` package reference of `System.Text.Json` can be changed from `6.0.7` to `6.0.0`, but this is not applicable in more complex scenarios\n\n### Configuration\n\n```\r\n.NET SDK:\r\nVersion:   7.0.100\r\nCommit:    e12b7af219\r\n\r\nRuntime Environment:\r\nOS Name:     Windows\r\nOS Version:  10.0.19042\r\nOS Platform: Windows\r\nRID:         win10-x64\r\nBase Path:   C:\\Program Files\\dotnet\\sdk\\7.0.100\\\r\n\r\nHost:\r\nVersion:      7.0.0\r\nArchitecture: x64\r\nCommit:       d099f075e4\r\n```\r\nBut it also happens on dotnet 6 runtime\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOT1RiyA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5O064a",
                                           "createdAt":  "2022-11-21T18:42:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-11-21T18:42:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5O50tV",
                                           "createdAt":  "2022-11-22T14:42:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\nApplication loaded by `AssemblyLoadContext` (implementation from [documentation](https://learn.microsoft.com/en-us/dotnet/core/tutorials/creating-app-with-plugin-support#load-plugins)) loads multiple `.dll` files with same `AssemblyName` which leads to exceptions like `System.MissingMethodException Method not found: ...`\n\n### Reproduction Steps\n\nSmall repo with reproduction code [here](https://github.com/linkem/AssemblyLoadContextError)\r\n\r\n### Repro with exception\r\n* Build `PluginApp1` application\r\n* Start `PluginHost`\r\n* Exception is thrown:\r\n    ```\r\n    System.MissingMethodException\r\n        HResult=0x80131513\r\n        Message=Method not found: \u0027System.Threading.Tasks.Task`1\u003c!!0\u003e System.Net.Http.Json.HttpContentJsonExtensions.ReadFromJsonAsync(System.Net.Http.HttpContent, System.Text.Json.JsonSerializerOptions, System.Threading.CancellationToken)\u0027.\r\n        Source=PluginApp1\r\n        StackTrace:\r\n            at PluginApp1.PluginApp1.\u003cExecute\u003ed__0.MoveNext() in C:\\projects\\GitHub\\Github.AssemblyLoadContextError\\PluginApp1\\PluginApp1.cs:line 32\r\n            at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[TStateMachine](TStateMachine\u0026 stateMachine) in /_/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/AsyncMethodBuilderCore.cs:line 38\r\n            at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[TStateMachine](TStateMachine\u0026 stateMachine) in /_/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/AsyncTaskMethodBuilder.cs:line 33\r\n            at PluginApp1.PluginApp1.Execute(CancellationToken cancellationToken) in C:\\projects\\GitHub\\Github.AssemblyLoadContextError\\PluginApp1\\PluginApp1.cs:line 9\r\n            at Program.\u003c\u003cMain\u003e$\u003ed__0.MoveNext() in C:\\projects\\GitHub\\Github.AssemblyLoadContextError\\HostApp\\Program.cs:line 12\r\n            at Program.\u003cMain\u003e(String[] args)\r\n    ```\r\n\r\n### Repro with listed duplicated assemblies\r\n* Comment out `PluginApp1.PluginApp1.cs` line `30`\r\n* Build `PluginApp1` application\r\n* Start `PluginHost`\r\n* Application should print output similar to this one:\r\n    ```\r\n    For Assembly \u0027System.Text.Json\u0027 found multiple instances:\r\n\r\n    System.Text.Json, Version=6.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51; Location: \u003cPROJECT_PATH\u003e\\PluginApp1\\bin\\Debug\\net6.0\\System.Text.Json.dll\r\n\r\n    System.Text.Json, Version=6.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51; Location: C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\6.0.11\\System.Text.Json.dll\r\n    ```\r\n* Output indicates that there were loaded multiple assemblies with same name \u0027System.Text.Json\u0027\n\n### Expected behavior\n\nPlugin application should be started without duplicated assemblies, it should use assembly that is in local folder **or** in `shared\\Microsoft.NETCore.App` but not both.\n\n### Actual behavior\n\nIn some cases duplicated assemblies are loaded.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nFor case presented in repro, in application `PluginApp1` package reference of `System.Text.Json` can be changed from `6.0.7` to `6.0.0`, but this is not applicable in more complex scenarios\n\n### Configuration\n\n```\r\n.NET SDK:\r\nVersion:   7.0.100\r\nCommit:    e12b7af219\r\n\r\nRuntime Environment:\r\nOS Name:     Windows\r\nOS Version:  10.0.19042\r\nOS Platform: Windows\r\nRID:         win10-x64\r\nBase Path:   C:\\Program Files\\dotnet\\sdk\\7.0.100\\\r\n\r\nHost:\r\nVersion:      7.0.0\r\nArchitecture: x64\r\nCommit:       d099f075e4\r\n```\r\nBut it also happens on dotnet 6 runtime\n\n### Other information\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003elinkem\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-11-22T14:42:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5O7TGN",
                                           "createdAt":  "2022-11-22T19:50:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "The problem is that your plugin brings its own version of System.Text.Json while using parts of the shared framework which also reference it. The framework which is loaded into the Default context uses S.T.Json from the Default context. The plugin code references the S.T.Json in the plugin load context. But then it calls code from the framework (`HttpClient` and so on). The problem is not very visible, it\u0027s default parameters. `ReadFromJsonAsync` has several default parameters one of which is `JsonSerializerOptions` which is a type from S.T.Json. The way default parameters work in .NET is that the compiler hardcodes the default at the callsite - so even though the source code looks like:\r\n```C#\r\nReadFromJsonAsync\u003cTodoModel\u003e()\r\n```\r\n\r\nIn reality the runtime sees the call as\r\n```C#\r\nReadFromJsonAsync\u003cTodoModel\u003e((JsonSerializerOptions)null, default(CancellationToken));\r\n```\r\n\r\nThe problem is that the `JsonSerializerOptions` type comes from the plugin - so the version of S.T.Json from the plugin load context. And thus it doesn\u0027t match the method declared in the framework which takes that type from the S.T.Json in the defautl load context.\r\n\r\nIn short - any assembly which is part of the shared framework should not be also carried by the plugins - it will break anytime where the plugin uses APIs which refer to types from such assembly and interoperates with the default framework APIs which do the same.\r\n\r\nSo in this case, remove the PackageReference to System.Text.Json.\r\n\r\nThe reason why it works if the package version is 6.0.0: If the version is 6.0.0 the SDK realizes that the version is available in the framework and won\u0027t actually put the file into the plugin. If the version is 6.0.7 that doesn\u0027t happen and the plugin carries its own copy.\r\n\r\nThere should be no need to have a package reference to System.Text.Json - it\u0027s part of the framework, why would you bring your own copy of it.\r\n\r\nI know this is confusing to debug, because the assemblies/types look identical while the runtime doesn\u0027t see them as the same.",
                                           "updatedAt":  "2022-11-22T19:50:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5O79gy",
                                           "createdAt":  "2022-11-22T22:54:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "linkem",
                                           "body":  "@vitek-karas  Thank you for quick response and very detailed summary of issue. \r\n\r\nI know that referencing S.T.Json in net6 applications is not required and can be easily avoided. My example is intentionally over simplified to reproduce problem. In real life, our net6 applications reference netstandard libraries that reference S.T.Json. In that case net6 application will have S.T.Json .dll in output without referencing it directly(transitive reference). It\u0027s basically impossible to avoid transitive references, especially in case of third party libs and nuget packages.\r\n\r\nI have created repro with netstandard lib [here](https://github.com/linkem/AssemblyLoadContextError/blob/with-netstandard-lib/MyLib/MyLib.csproj). `PluginApp` don\u0027t reference S.T.Json directly but its present in output folder.\r\n\r\nJust for record, this issue is not exclusive for S.T.Json, same thing happend with other libs.\r\n\r\nFew more questions:\r\n1. Is it intended behavior that `AssemblyLoadContext` loads assemblies with duplicated names from framework and local folder at the same time? I thought that the assembly present in the local folder will only be used if the Default context doesn\u0027t have this assembly or has it in older version, but will never load assemblies with same names.\r\n\r\n2. How could we avoid issues like this? What would be best solution if we can\u0027t avoid referencing netstandard packages that have transitive references to packages from framework?",
                                           "updatedAt":  "2022-11-22T22:54:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5O-LH2",
                                           "createdAt":  "2022-11-23T11:37:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODXWhmA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "CNXG",
                                                                               "createdAt":  "2024-01-17T08:43:18Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "kl1mm",
                                                                               "createdAt":  "2024-02-19T15:15:00Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "\r\nThe problem is versioning - the version 6.0.7 of System.Text.Json package contains the assembly with higher version than the one in the framework. This leads the SDK to keep it, instead of relying on the framework.\r\nNote that this has nothing to do with `netstandard` targetting - if you change your project to reference version `6.0.0` the System.Text.Json will not be part of the plugin output even with the netstandard library used.\r\n\r\nI don\u0027t know what are the version resolution rules in the SDK, they seem a bit harsh for this scenario.\r\n\r\n@dsplaisted : If an app targeting `net6.0` has a package reference to System.Text.Json version 6.0.7 (latest) it will get its own private copy of the assembly, even though that version is the same as the version in the latest runtime 6.0.11. Is there some way to tell the SDK to always rely on framework provided assembly even if the versions are a bit off? (I assume the behavior is because the ref package for 6.0.0 has a lower version of the assembly).\r\n\r\n\u003e Is it intended behavior that AssemblyLoadContext loads assemblies with duplicated names from framework and local folder at the same time? I thought that the assembly present in the local folder will only be used if the Default context doesn\u0027t have this assembly or has it in older version, but will never load assemblies with same names.\r\n\r\nEach instance of `AssemblyLoadContext` (ALC) will only load one version of a given assembly. But the important thing to realize is that ALCs are not isolation boundaries. They\u0027re only used when resolving assembly references (or explicit loads). Once assemblies are loaded ALCs are basically ignored. So you can have code which in theory has instances of the same type from two different versions of the assembly (from different ALCs) in one array (for example).\r\n\r\nThe assembly resolution for the Default ALC is governed by the `app.deps.json` which is produced by the SDK. Typically this means that the Default ALC will resolve only assemblies in the main app (and only those which were part of the build of the app).\r\n\r\nThe assembly resolution for the secondary ALCs is driven by the implementation of the `AssemblyLoadContext.Load` method. In your case (and typically for plugins), this uses `AssemblyDependencyResolver`. That class also relies on `plugin.deps.json` which is produced by the SDK. And it behaves similarly - in that it will only resolve assemblies which are part of the build of the plugin.\r\n\r\nThe \"Sharing\" of assemblies (in your case the plugin interface assembly) is done by not including that assembly in the output of the plugin, in which case `AssemblyDependencyResolver` will not resolve it, the `AssemblyLoadContext.Load` will return `null` and it will fall back to the Default ALC, which will resolve it from the main app.\r\n\r\n\u003e How could we avoid issues like this? What would be best solution if we can\u0027t avoid referencing netstandard packages that have transitive references to packages from framework?\r\n\r\nYou could hardcode that you don\u0027t allow your plugins to carry their own version of assemblies provided by the host. In the `AssemblyLoadContext.Load` override call `AssemblyLoadContext.Default.LoadFromAssemblyName(assemblyName)` first and if it doesn\u0027t fail, use the retuned assembly over anything returned by the `AssemblyDependencyResolver`. The downside of this approach is that it requires try/catch as `LoadFromAssemblyName` will throw if it can\u0027t resolve the assembly. But if you\u0027re not loading that many plugins it should not be a big issue.\r\n\r\n/cc @elinor-fung ",
                                           "updatedAt":  "2022-11-23T11:37:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5PFbR4",
                                           "createdAt":  "2022-11-24T20:36:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "linkem",
                                           "body":  "\u003e You could hardcode that you don\u0027t allow your plugins to carry their own version of assemblies provided by the host. In the AssemblyLoadContext.Load override call AssemblyLoadContext.Default.LoadFromAssemblyName(assemblyName) first and if it doesn\u0027t fail, use the retuned assembly over anything returned by the AssemblyDependencyResolver. The downside of this approach is that it requires try/catch as LoadFromAssemblyName will throw if it can\u0027t resolve the assembly. But if you\u0027re not loading that many plugins it should not be a big issue.\r\n\r\nThis approach is something that I consider as last resort, only if we won\u0027t find any better solution.\r\nImplementing it this way, we will lose possibility of loading Assemblies with different version than host already have. For example, if host depends on `MediatR` package in version `10.0.0` and my plugin app depends on version `11.0.0`, then all plugins will be forced to use `10.0.0`, this may break everything.\r\nIn real life scenario we have host application that have a lot of references and whole idea of using ALC was to enable our plugins to use their own versions of assemblies and override ones that host already have. Our approximate number of plugins will be around 10-15.\r\n\r\nIs there any safe way to support scenario where host application has some assembly and plugin brings other version of same assembly?",
                                           "updatedAt":  "2022-11-24T20:36:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5PGner",
                                           "createdAt":  "2022-11-25T08:06:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "\u003e Is there any safe way to support scenario where host application has some assembly and plugin brings other version of same assembly?\r\n\r\nIt should work just fine, the problem only occurs if the code tries to use types from such assembly to communicate across the host boundary. That typically happens for assemblies which are part of the framework (as above) or those used in the plugin \"interface\" - all those should not ship with the plugin, but instead should be provided by the host.",
                                           "updatedAt":  "2022-11-25T08:06:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5PHmud",
                                           "createdAt":  "2022-11-25T12:04:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "linkem",
                                           "body":  "\u003e It should work just fine, the problem only occurs if the code tries to use types from such assembly to communicate across the host boundary. That typically happens for assemblies which are part of the framework (as above) or those used in the plugin \"interface\" - all those should not ship with the plugin, but instead should be provided by the host.\r\n\r\nFor plugin \"interface\" situation is quite easy, we can use construct in csproj file like this\r\n```xml\r\n\u003cProjectReference Include=\"..\\Plugin.Abstraction\\Plugin.Abstraction.csproj\"\u003e\r\n    \u003cPrivate\u003efalse\u003c/Private\u003e\r\n    \u003cExcludeAssets\u003eruntime\u003c/ExcludeAssets\u003e\r\n\u003c/ProjectReference\u003e\r\n```\r\nbut what about all framework assemblies?\r\n\r\nWe have to create hardcoded list of all assemblies that are in `dotnet/shared/6.0.*/Microsoft.NETCore.App` and `dotnet/shared/6.0.*/Microsoft.AspNetCore.App`, then during build/publish plugin app should remove them from output folder? (it would be nice if there was some csproj parameter that could do it).\r\n\r\nAnother way would be to use hardcoded list of assemblies in Loader and use Default context to resolve them.\r\n\r\nAnyway, both solution looks a bit weird, maybe there are some other way to achieve it?",
                                           "updatedAt":  "2022-11-25T12:04:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5PIah-",
                                           "createdAt":  "2022-11-25T15:01:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODXWiww==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "kl1mm",
                                                                               "createdAt":  "2024-02-19T15:17:17Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "I agree it\u0027s not ideal - I honestly would like to see some SDK solution, because typically one would expect the SDK to resolve the framework dependencies to the framework.\r\n\r\nThere\u0027s no good way to tell if assembly belongs to the framework or not (you could use path, but that only works for framework dependent apps, and is still a bit weird) - which is kind of by design, because for self-contained app there\u0027s no \"framework\" really, everything is the \"app\".",
                                           "updatedAt":  "2022-11-25T15:01:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5PNRVf",
                                           "createdAt":  "2022-11-28T10:54:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODXWitw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kl1mm",
                                                                               "createdAt":  "2024-02-19T15:17:11Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "linkem",
                                           "body":  "Thank you for many tips.\r\nFor now we do not consider to use self-contained apps, at least not in terms of plugins. I have created small PoC of the solution that we came up here. It looks like in this simple example its working fine, I need some more time to check it on bigger \"real life\" project.\r\nCould you check if my PoC is something that you had in mind ([PluginLoadContext](https://github.com/linkem/AssemblyLoadContextError/blob/with-assemblies-list/HostApp/PluginLoadContext.cs) and [hardcoded list of assemblies](https://github.com/linkem/AssemblyLoadContextError/blob/with-assemblies-list/HostApp/FrameworkAssemblies.cs))?",
                                           "updatedAt":  "2022-11-28T10:54:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5PNe15",
                                           "createdAt":  "2022-11-28T11:39:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "That should work, it\u0027s obviously fragile - I don\u0027t think new assemblies will be added a patch release, but I wouldn\u0027t be surprised if the list looked different for .NET 7 and so on. That said it\u0027s probably the best/simplest one can do right now.",
                                           "updatedAt":  "2022-11-28T11:39:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5PVGLI",
                                           "createdAt":  "2022-11-29T16:37:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dsplaisted",
                                           "body":  "\u003e The problem is versioning - the version 6.0.7 of System.Text.Json package contains the assembly with higher version than the one in the framework. This leads the SDK to keep it, instead of relying on the framework. Note that this has nothing to do with `netstandard` targetting - if you change your project to reference version `6.0.0` the System.Text.Json will not be part of the plugin output even with the netstandard library used.\r\n\u003e \r\n\u003e I don\u0027t know what are the version resolution rules in the SDK, they seem a bit harsh for this scenario.\r\n\u003e \r\n\u003e @dsplaisted : If an app targeting `net6.0` has a package reference to System.Text.Json version 6.0.7 (latest) it will get its own private copy of the assembly, even though that version is the same as the version in the latest runtime 6.0.11. Is there some way to tell the SDK to always rely on framework provided assembly even if the versions are a bit off? (I assume the behavior is because the ref package for 6.0.0 has a lower version of the assembly).\r\n\r\nNo, there\u0027s not currently a way to do this.  I\u0027ve filed https://github.com/dotnet/sdk/issues/29280 to track adding a way to do so.",
                                           "updatedAt":  "2022-11-29T16:37:31Z"
                                       }
                                   ],
                         "totalCount":  12
                     },
        "title":  "`AssemblyLoadContext` load multiple assemblies with same name",
        "labels":  [
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/80526",
        "createdAt":  "2023-01-11T23:12:04Z",
        "number":  80526,
        "author":  "teo-tsirpanis",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-08-09T16:13:43Z",
        "body":  "I got this error in my build:\r\n\r\n```\r\nSystem.InvalidCastException:\r\n\r\n[A]System.Runtime.CompilerServices.StrongBox`1[Microsoft.Build.Tasks.Git.GitRepository] cannot be cast to [B]System.Runtime.CompilerServices.StrongBox`1[Microsoft.Build.Tasks.Git.GitRepository].\r\n\r\nType A originates from \u0027System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e\u0027 in the context \u0027Default\u0027 at location \u0027C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\7.0.2\\System.Private.CoreLib.dll\u0027.\r\nType B originates from \u0027System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e\u0027 in the context \u0027Default\u0027 at location \u0027C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\7.0.2\\System.Private.CoreLib.dll\u0027.\r\n```\r\n\r\nTypes A and B are the same (and cannot be different since only one SPC can be loaded), which means by process of elimination that the `GitRepository`ies in the generic parameters are from different ALCs. But the error message does not indicate that. It can be improved by more deeply analyzing the types to see what doesn\u0027t fit.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOUmqfeg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5SOwkY",
                                           "createdAt":  "2023-01-11T23:12:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2023-01-11T23:12:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5SQN8n",
                                           "createdAt":  "2023-01-12T08:39:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nI got this error in my build:\r\n\r\n```\r\nSystem.InvalidCastException:\r\n\r\n[A]System.Runtime.CompilerServices.StrongBox`1[Microsoft.Build.Tasks.Git.GitRepository] cannot be cast to [B]System.Runtime.CompilerServices.StrongBox`1[Microsoft.Build.Tasks.Git.GitRepository].\r\n\r\nType A originates from \u0027System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e\u0027 in the context \u0027Default\u0027 at location \u0027C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\7.0.2\\System.Private.CoreLib.dll\u0027.\r\nType B originates from \u0027System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e\u0027 in the context \u0027Default\u0027 at location \u0027C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\7.0.2\\System.Private.CoreLib.dll\u0027.\r\n```\r\n\r\nTypes A and B are the same (and cannot be different since only one SPC can be loaded), which means by process of elimination that the `GitRepository`ies in the generic parameters are from different ALCs. But the error message does not indicate that. It can be improved by more deeply analyzing the types to see what doesn\u0027t fit.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eteo-tsirpanis\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-01-12T08:39:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Sapv5",
                                           "createdAt":  "2023-01-14T11:31:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "Variant generic types will complicate the deeper analysis.",
                                           "updatedAt":  "2023-01-14T11:31:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Sap96",
                                           "createdAt":  "2023-01-14T11:38:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "It might be sufficient and easy to implement if the exception just listed all the unique assemblies from which the types were loaded:\n\n```\nA1::System.Runtime.CompilerServices.StrongBox`1[A2::Microsoft.Build.Tasks.Git.GitRepository] cannot be cast to A1::System.Runtime.CompilerServices.StrongBox`1[A3::Microsoft.Build.Tasks.Git.GitRepository].\n\nAssembly A1 is \u0027System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e\u0027 in the context \u0027Default\u0027 at location \u0027C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\7.0.2\\System.Private.CoreLib.dll\u0027.\nAssembly A2 is …\nAssembly A3 is …\n```",
                                           "updatedAt":  "2023-01-14T11:39:25Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "`InvalidCastException`s on generic types from different ALCs can be unhelpful.",
        "labels":  [
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/81737",
        "createdAt":  "2023-02-07T03:14:13Z",
        "number":  81737,
        "author":  "MaxwellDAssistek",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-08-09T16:04:50Z",
        "body":  "### Description\n\nWhen using `AssemblyLoadContext.LoadFromStream` to load an assembly from a Stream that is returned by [`FileSystem.OpenAppPackageFileAsync`](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.loader.assemblyloadcontext.loadfromstream?view=net-7.0), I end up with a `System.NotSupportedException` on Android. I started with a ticket in Xamarin.Android: https://github.com/xamarin/xamarin-android/issues/7763. However, in the end it was determined that there is no way to reliably get the Length of an Asset Stream in Android.\r\n\r\nI believe that in this function, it might be possible to avoid depending on the Stream.Length.\r\nhttps://github.com/dotnet/runtime/blob/6fecc25b0260b1586305ecefe0cef9a0e22fb66c/src/libraries/System.Private.CoreLib/src/System/Runtime/Loader/AssemblyLoadContext.cs#L397\r\n\n\n### Reproduction Steps\n\n```c#\r\n        using (var resStream = FileSystem.OpenAppPackageFileAsync(\"MyModule.dll\").Result)\r\n        {\r\n            var loadCtx = new AssemblyLoadContext(\"Module\");\r\n\r\n            var assem = loadCtx.LoadFromStream(resStream);\r\n        }\r\n```\r\n\n\n### Expected behavior\n\n`LoadFromStream` should not require knowing the Stream Length.\n\n### Actual behavior\n\n`LoadFromStream` causes an exception due to requiring to get the Stream Length.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nCopy the stream into a MemoryStream first.\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOVLt_mw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5UpZDE",
                                           "createdAt":  "2023-02-07T03:14:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2023-02-07T03:14:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5UpfUC",
                                           "createdAt":  "2023-02-07T03:55:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\nWhen using `AssemblyLoadContext.LoadFromStream` to load an assembly from a Stream that is returned by [`FileSystem.OpenAppPackageFileAsync`](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.loader.assemblyloadcontext.loadfromstream?view=net-7.0), I end up with a `System.NotSupportedException` on Android. I started with a ticket in Xamarin.Android: https://github.com/xamarin/xamarin-android/issues/7763. However, in the end it was determined that there is no way to reliably get the Length of an Asset Stream in Android.\r\n\r\nI believe that in this function, it might be possible to avoid depending on the Stream.Length.\r\nhttps://github.com/dotnet/runtime/blob/6fecc25b0260b1586305ecefe0cef9a0e22fb66c/src/libraries/System.Private.CoreLib/src/System/Runtime/Loader/AssemblyLoadContext.cs#L397\r\n\n\n### Reproduction Steps\n\n```c#\r\n        using (var resStream = FileSystem.OpenAppPackageFileAsync(\"MyModule.dll\").Result)\r\n        {\r\n            var loadCtx = new AssemblyLoadContext(\"Module\");\r\n\r\n            var assem = loadCtx.LoadFromStream(resStream);\r\n        }\r\n```\r\n\n\n### Expected behavior\n\n`LoadFromStream` should not require knowing the Stream Length.\n\n### Actual behavior\n\n`LoadFromStream` causes an exception due to requiring to get the Stream Length.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nCopy the stream into a MemoryStream first.\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eMaxwellDAssistek\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`bug`, `area-AssemblyLoader-coreclr`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-02-07T03:55:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5UqlxM",
                                           "createdAt":  "2023-02-07T09:22:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "/fyi @elinor-fung \r\n\r\nThe problem is that we need to allocate a native memory buffer for the entire assembly. Knowing length means that we can avoid copying the memory twice - we only allocate the native buffer and read directly into it. Without knowing length we would have to read the stream first into some managed memory (I guess it could be a linked list of buffers to avoid reallocations) and then allocate and copy to native memory.\r\n\r\nI think it would make sense to do so if we can detect that the stream doesn\u0027t have length. @grendello is there a way to tell if the  stream from the mono/Android world supports length?\r\n\r\nNote: this is probably not a regression, even before https://github.com/dotnet/runtime/pull/72783 the code asked for length.",
                                           "updatedAt":  "2023-02-07T09:23:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Uqsu6",
                                           "createdAt":  "2023-02-07T09:44:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "grendello",
                                           "body":  "\u003e \r\n\u003e I think it would make sense to do so if we can detect that the stream doesn\u0027t have length. @grendello is there a way to tell if the stream from the mono/Android world supports length?\r\n\u003e \r\nUnfortunately, no :(. We wrap Java streams in a managed Stream and so it always implements the `Length` property, but the underlying stream doesn\u0027t necessarily have one - that\u0027s why we throw the exception. About the only thing\r\nwe can do is to look at the docs and special-case those which support some kind of length information. For instance, we do it for [`FileInputStream`](https://developer.android.com/reference/java/io/FileInputStream) right now, but in a rather roundabout way. `FileInputStream` doesn\u0027t have any method/field which tells us the size, but it owns a [\"channel\"](https://developer.android.com/reference/java/io/FileInputStream#getChannel()) which, in turn, has a [`size()`](https://developer.android.com/reference/java/nio/channels/FileChannel#size()) method. Other `InputStream` derivatives, e.g. [`ByteArrayInputStream`](https://developer.android.com/reference/java/io/ByteArrayInputStream) stream have a field that gives the size, in this case [`count`](https://developer.android.com/reference/java/io/ByteArrayInputStream#count).  So, as you can see, it\u0027s a bit convoluted... :)\r\n\r\nI think we can add some special-cases to our code, but it will just work around some of the cases.  However, perhaps you could catch the `NotSupportedException` (only on Android, there\u0027s no reason to hurt other platforms) and switch to the more expensive way of getting the stream size you described above, if it\u0027s caught?  It\u0027s an expensive way, but it would work with all the unknown streams we don\u0027t special-case and which don\u0027t have the length info. ",
                                           "updatedAt":  "2023-02-07T09:46:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Uq0sr",
                                           "createdAt":  "2023-02-07T10:07:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "How about `CanSeek` would that work as an indicator? The most common case currently I know if is loading assemblies from memory arrays (or resource streams), those will always support seeking, and thus we would use the more optimal code path. Special streams which don\u0027t support seek would go through the slower path.",
                                           "updatedAt":  "2023-02-07T10:07:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5UrBcW",
                                           "createdAt":  "2023-02-07T10:44:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "grendello",
                                           "body":  "@vitek-karas `CanSeek` may be useful, with caveats. `InputStream` has the [`seek()`](https://developer.android.com/reference/java/io/InputStream#skip(long)) method which is the closest equivalent to (unidirectional, it seems) seeking.  But our code in the wrapper has stricter requirements:\r\n\r\n```csharp\r\npublic override bool CanSeek { get { return (BaseFileChannel != null); } }\r\n```\r\n\r\nIt will return only if the underlying stream is `FileInputStream` currently, because its channel has the `Position()` method which is the exact equivalent of `Seek()` in the managed stream.  So even though querying `CanSeek` in to determine whether `Length` works is a bit of an abuse, I think it would work (at least for Android, where we can know this \"convention\" works and how)",
                                           "updatedAt":  "2023-02-07T10:44:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5UrP2n",
                                           "createdAt":  "2023-02-07T11:29:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Maxwell175",
                                           "body":  "Pardon the suggestion, but could it be a valid solution to simply copy the stream to a MemoryStream outright and let it continue into the if that just gets a span from it? (only if the conditions match of course since copying the stream is probably more expensive)",
                                           "updatedAt":  "2023-02-07T11:31:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5UrTUT",
                                           "createdAt":  "2023-02-07T11:41:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "@Maxwell175 that\u0027s the idea, but we want to avoid doing it for the cases where it\u0027s not necessary. It\u0027s also a perfectly valid workaround on the caller side.",
                                           "updatedAt":  "2023-02-07T11:41:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Urv45",
                                           "createdAt":  "2023-02-07T13:13:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC1nkMg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "am11",
                                                                               "createdAt":  "2023-02-07T16:28:51Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "grendello",
                                                                               "createdAt":  "2023-02-07T19:44:58Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e So even though querying CanSeek in to determine whether Length works is a bit of an abuse\r\n\r\nIt\u0027s not an abuse.  CanSeek is documented to govern whether Length, SetLength, Position, and Seek are functional or may throw.\r\n\r\nAs was suggested, the method should use CanSeek.  Basically:\r\n```C#\r\nif (stream.CanSeek)\r\n{\r\n   ... // existing path\r\n   return ...;\r\n}\r\n\r\nvar ms = new MemoryStream();\r\nstream.CopyTo(ms);\r\nms.TryGetBuffer(out ArraySegment\u003cbyte\u003e buffer);\r\nreturn buffer;\r\n```\r\nor alternatively if the current path doesn\u0027t buy much:\r\n```C#\r\nvar ms = new MemoryStream();\r\nif (stream.CanSeek)\r\n{\r\n    ms.Capacity = stream.Length;\r\n}\r\nstream.CopyTo(ms);\r\nms.TryGetBuffer(out ArraySegment\u003cbyte\u003e buffer);\r\nreturn buffer;\r\n```",
                                           "updatedAt":  "2023-02-07T14:13:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5UuS50",
                                           "createdAt":  "2023-02-07T20:45:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "grendello",
                                           "body":  "@stephentoub `CanSeek` as a way to tell whether `Length` works is a bit of an abuse on Android, because we cannot guarantee that `Seek`, `SetLength` and `Position` will also work with Java streams, and that\u0027s contrary to the `CanSeek` docs.",
                                           "updatedAt":  "2023-02-07T20:45:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5UunfY",
                                           "createdAt":  "2023-02-07T21:52:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e CanSeek as a way to tell whether Length works is a bit of an abuse on Android, because we cannot guarantee that Seek, SetLength and Position will also work with Java streams, and that\u0027s contrary to the CanSeek docs.\r\n\r\nI\u0027m not understanding.  CanSeek should only return true if all of Length, SetLength, Position, and Seek work... if any of them might fail, CanSeek should return false.  Are you saying we ship a Stream that violates that?",
                                           "updatedAt":  "2023-02-07T21:52:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Uuqjy",
                                           "createdAt":  "2023-02-07T22:02:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "grendello",
                                           "body":  "\u003e \u003e CanSeek as a way to tell whether Length works is a bit of an abuse on Android, because we cannot guarantee that Seek, SetLength and Position will also work with Java streams, and that\u0027s contrary to the CanSeek docs.\r\n\u003e \r\n\u003e I\u0027m not understanding. CanSeek should only return true if all of Length, SetLength, Position, and Seek work... if any of them might fail, CanSeek should return false. Are you saying we ship a Stream that violates that?\r\n\r\nThat\u0027s why I said it was an abuse :) Java streams do not implement all of those operations. Some implement none of them, some only one etc. We ship a managed wrapper around those streams which does its best to present a \"valid\" managed stream to the user.  @vitek-karas suggested `CanSeek` could be used to detect whether the stream supports `Length` and, indeed, it **could** - but we cannot guarantee the other operations won\u0027t throw `NotSupportedException`. ",
                                           "updatedAt":  "2023-02-07T22:02:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Uur1J",
                                           "createdAt":  "2023-02-07T22:06:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Some implement none of them, some only one etc.\r\n\r\nBut we still return true from CanSeek?",
                                           "updatedAt":  "2023-02-07T22:06:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Uutqw",
                                           "createdAt":  "2023-02-07T22:12:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "grendello",
                                           "body":  "Yes, currently only one Java stream type does that, and it happens to implement all of the methods, but we could add support for `Length` in a few more types (but, perhaps, not for the other operations) in order to avoid the `NotSupportedException` thrown in the context of this issue.",
                                           "updatedAt":  "2023-02-07T22:12:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Uu3-b",
                                           "createdAt":  "2023-02-07T22:45:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e\u003e\u003e Some implement none of them, some only one etc.\r\n\r\n\u003e\u003e But we still return true from CanSeek?\r\n\r\n\u003e Yes, currently only one Java stream type does that\r\n\r\nThanks. If we have a Stream that returns true from CanSeek but fails with Seek, SetLength, Length, or Position, we should either fix it to implement all of those or fix it to have CanSeek return false (even if some but not all of those members are implemented).",
                                           "updatedAt":  "2023-02-07T22:45:51Z"
                                       }
                                   ],
                         "totalCount":  15
                     },
        "title":  "AssemblyLoadContext.LoadFromStream relys on Length being available",
        "labels":  [
                       "bug",
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/83753",
        "createdAt":  "2023-03-21T08:58:27Z",
        "number":  83753,
        "author":  "MandiMan",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-08-15T19:17:46Z",
        "body":  "### .NET version\n\n.NET SDK 8.0.100-preview.3.23165.21\n\n### Did it work in .NET Framework?\n\nYes\n\n### Did it work in any of the earlier releases of .NET Core or .NET 5+?\n\nNo\n\n### Issue description\n\n A .Net8.0 project failing with “System.MissingMethodException: \u0027Method not found” trying to access a DLL that is included as an embedded resource in a 3rd DLL.\r\n\n\n### Steps to reproduce\n\n**Repro Steps:**\r\n1. Unzip and copy the files in [Common.zip](https://github.com/dotnet/winforms/files/11025905/Common.zip) to [VSError.zip](https://github.com/dotnet/winforms/files/11026435/VSError.zip)\r\n2. Then build and run attached project “VSError” \r\n3. Click \"button1\" to have a pop-up box pop-up, then click the “OK” of the pop-up box\r\n\r\n**Actual result:**\r\nproject failing with “System.MissingMethodException: \u0027Method not found” trying to access a DLL\r\n![image](https://user-images.githubusercontent.com/108860782/226538126-13a7c570-2c4f-48da-8a0a-514fc8805c3a.png)\r\n\r\n**Expected result:**\r\nRun successfully without error shows.\r\n\r\n**More info:**\r\n1. Feedback source:https://dev.azure.com/devdiv/DevDiv/_workitems/edit/1775813\r\n2. This issue does not repro on .NET Framework.\r\n3. This issue repro in .NET 8.0, .NET 7.0, .NET 6.0.\r\n4. “WinFormsApp1” is the .Net 6.0 project that has the issue (2nd MessageBox fails).\r\n“WindowsFormApp1” is the .Net Framework 4.7.2 program that works correctly.\r\n“ClassLibrary1” is the DLL with the embedded MySqlConnector that works in both programs\r\n“ClassLibrary2” is the DLL which inherits from Class1 and fails in .Net 6.0 (but works in Framwork 4.7.2)",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOWIzg1g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5YIiB4",
                                           "createdAt":  "2023-03-21T18:37:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "merriemcgaw",
                                           "body":  "@JeremyKuhne will take a look at what they\u0027re doing and see if we can find the root cause to help them.",
                                           "updatedAt":  "2023-03-21T18:37:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5YIiB7",
                                           "createdAt":  "2023-03-21T21:49:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "JeremyKuhne",
                                           "body":  "This is an issue better addressed by the runtime.\r\n\r\nIn Library1 they\u0027re embedding (as a resource) the .NET Standard 2.0 version of MySqlConnector, then using `Assembly.Load` on the resource stream when the assembly comes up via `AppDomain.CurrentDomain.AssemblyResove`.\r\n\r\nLibrary2 does no special handling of `AssemblyResolve`, but calls the same MySqlConnector code.\r\n\r\n",
                                           "updatedAt":  "2023-03-21T21:49:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5YQECu",
                                           "createdAt":  "2023-03-23T05:02:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### .NET version\n\n.NET SDK 8.0.100-preview.3.23165.21\n\n### Did it work in .NET Framework?\n\nYes\n\n### Did it work in any of the earlier releases of .NET Core or .NET 5+?\n\nNo\n\n### Issue description\n\n A .Net8.0 project failing with “System.MissingMethodException: \u0027Method not found” trying to access a DLL that is included as an embedded resource in a 3rd DLL.\r\n\n\n### Steps to reproduce\n\n**Repro Steps:**\r\n1. Unzip and copy the files in [Common.zip](https://github.com/dotnet/winforms/files/11025905/Common.zip) to [VSError.zip](https://github.com/dotnet/winforms/files/11026435/VSError.zip)\r\n2. Then build and run attached project “VSError” \r\n3. Click \"button1\" to have a pop-up box pop-up, then click the “OK” of the pop-up box\r\n\r\n**Actual result:**\r\nproject failing with “System.MissingMethodException: \u0027Method not found” trying to access a DLL\r\n![image](https://user-images.githubusercontent.com/108860782/226538126-13a7c570-2c4f-48da-8a0a-514fc8805c3a.png)\r\n\r\n**Expected result:**\r\nRun successfully without error shows.\r\n\r\n**More info:**\r\n1. Feedback source:https://dev.azure.com/devdiv/DevDiv/_workitems/edit/1775813\r\n2. This issue does not repro on .NET Framework.\r\n3. This issue repro in .NET 8.0, .NET 7.0, .NET 6.0.\r\n4. “WinFormsApp1” is the .Net 6.0 project that has the issue (2nd MessageBox fails).\r\n“WindowsFormApp1” is the .Net Framework 4.7.2 program that works correctly.\r\n“ClassLibrary1” is the DLL with the embedded MySqlConnector that works in both programs\r\n“ClassLibrary2” is the DLL which inherits from Class1 and fails in .Net 6.0 (but works in Framwork 4.7.2)\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eMandiMan\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-03-23T05:02:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5YhDnr",
                                           "createdAt":  "2023-03-27T12:47:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC4pVXg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "JeremyKuhne",
                                                                               "createdAt":  "2023-03-27T19:14:58Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "The reason for this behavior difference is how `AssemblyLoadContext` (ALC) and assembly resolution works in .NET 6.\r\n\r\nThe implementation of `Assembly.Load(byte[], ...)` will create a new ALC every time it\u0027s called (it doesn\u0027t compare that the bytes passed to it are exactly the same as on previous calls) and thus will end up loading the assembly every time creating effectively duplicates in the runtime.\r\n\r\nThe assembly resolution invoked by direct calls to types/methods from the `MySqlConnector` assemblies are invoked on the `Default` ALC (since all of the code in the `Main` and `ClassLibrary*` runs in `Default`).\r\nEvery time such resolution happens the immediate lookup on `Default` will fail, because there\u0027s no `MySqlConnector` assembly loaded into the `Default` ALC. Eventually the AppDomain even handler will be invoked which will call `Assembly.Load(byte[], ...)` which will load a new copy of the assembly and return it.\r\n\r\nThe resolution is invoked twice, once from the code in `ClassLibrary1` and then again for code in `ClassLibrary2`, each will get its own copy of the `MySqlConnector` assembly. When the code in `ClassLibrary2` is invoked, it will end up with copy 2 of `MySqlConnector`, but the method on `ClassLibrary1` it calls uses copy 1 - so they don\u0027t match, and it effectively can\u0027t resolve the method call.\r\n\r\nSo the main difference which causes this is:\r\n* On .NET Frameowrk `Assembly.Load(byte[], ...)` loads into the \"default context\" (although there\u0027s no real ALC in .NET Framework, but the assembly is loaded into the effective \"default\" scope and thus subsequent attempts to resolve it will hit the cache and won\u0027t try to load it again). So in this case the event handler is actually only called once for `MySqlConnector`.\r\n* On .NET 6 `Assembly.Load(byte[], ...) loads into a new separate ALC and even if the resolution event originates in default ALC, the result of such lookup is not cached there. So subsequent attempts to resolve the assembly (like resolving another assembly reference from another assembly) in default ALC will end up calling the event handler repeatedly. And due to this behavior the handle will load multiple copies of the assembly, eventually leading to type identity mismatches.\r\n\r\nAs far as I can tell there\u0027s no way to write this code once for both .NET Framework and .NET 6. In this case the better API to call on .NET 6 is `AssemblyLoadContext.Default.LoadFromStream` which will load into the default ALC, and thus subsequent resolution attempts will be done from the cache - the event handler will only be invoked once.\r\n\r\nSo the code in Class1.cs can look something like:\r\n```C#\r\n                if (stream != null) {\r\n#if NETCOREAPP\r\n                    return System.Runtime.Loader.AssemblyLoadContext.Default.LoadFromStream(stream);\r\n#else\r\n                    byte[] assemblyData = new byte[stream.Length];\r\n                    stream.Read(assemblyData, 0, assemblyData.Length);\r\n                    return Assembly.Load(assemblyData);\r\n#endif\r\n                }\r\n```\r\n\r\nI tested that version in both .NET 6 and .NET Framework and it works.",
                                           "updatedAt":  "2023-03-27T12:47:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5YhEab",
                                           "createdAt":  "2023-03-27T12:52:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "@elinor-fung what do you think about potential improvements to avoid this confusion in the future?\r\n\r\nWe have basically two competing requirements, in .NET Framework `Assembly.Load(byte[], ...)` behaves like:\r\n* It loads a new copy of the assembly every time\r\n* It loads the assembly into the \"default\" load context scope every time (because .NET Framework allows loading multiple versions of the same assembly into the same context).\r\n\r\nIn .NET 6 we can\u0027t do both at the same time, because .NET 6 doesn\u0027t allow loading multiple versions of the same assembly into the same ALC. So apparently the current implementation chose to implement the first behavior (loading new copy every time) while sacrificing the second.\r\n\r\nI don\u0027t see us changing the behavior to favor the second over the first (breaking change). So I guess we can only improve the docs in this case.",
                                           "updatedAt":  "2023-03-27T12:52:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5YiIDD",
                                           "createdAt":  "2023-03-27T15:29:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e It loads the assembly into the \"default\" load context scope every time (because .NET Framework allows loading multiple versions of the same assembly into the same context).\r\n\r\nNit: In .NET Framework, `Assembly.Load(byte[], ...)` typically (but not always) loads the assembly into \"Neither\" context that is not the same as the default context.",
                                           "updatedAt":  "2023-03-27T15:29:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5YjODW",
                                           "createdAt":  "2023-03-27T18:14:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "elinor-fung",
                                           "body":  "Ideally, we could include information in the exception message that would point towards ALC mismatch. I know we detect and do that for the simplest InvalidCast case. I\u0027m not sure how easily we could figure that out for missing method/member like this though, since it is a few layers in rather than such a direct type comparison (I had looked through some of the code a while back, determined it would require more investigation, but haven\u0027t looked again). Maybe even just including the ALC of the assembly where we are looking for the method would be a start.",
                                           "updatedAt":  "2023-03-27T18:14:56Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  ".Net 8.0 fails to resolve method in embedded DLL",
        "labels":  [
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/87185",
        "createdAt":  "2023-06-06T18:25:59Z",
        "number":  87185,
        "author":  "jaredpar",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC-Ix0Q==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "NMSAzulX",
                                            "createdAt":  "2023-06-07T03:19:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hyperion-cs",
                                            "createdAt":  "2023-06-20T08:32:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kg",
                                            "createdAt":  "2025-01-10T18:02:50Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "h3xds1nz",
                                            "createdAt":  "2025-01-14T18:18:05Z"
                                        }
                                    ],
                          "totalCount":  4
                      },
        "updatedAt":  "2025-06-12T20:18:10Z",
        "body":  "### Background and motivation\r\n\r\nThe C# compiler uses `AssemblyLoadContext` to isolate and manage analyzers and generators that plug into the compiler. Analyzers are passed to the compiler as a series of `/analyzer:path/to/analyzer1.dll` arguments. The compiler effectively groups these arguments by directory and creates an `AssemblyLoadContext` per directory. \r\n\r\nThe problem is that due to the nature of build, NuPkg authoring and analyzer detection, the compiler will end up getting passed DLLs that are not a part of the analyzer but instead part of the compiler. For example it\u0027s not uncommon to see `/analyzer:System.Collections.Immutable.dll` or `/analyzer:System.Runtime.CompilerServices.Unsafe.dll` to be passed as arguments. This is problematic because these DLLs contain exchange types. The compiler _owns_ these DLLs and their copy must be used in both the compiler and analyzer for proper functioning. Loading the analyzer copy will lead to API mismatches later on that break the compilation process.\r\n\r\nToday the only way to determine if the compiler owns the DLL is to first attempt to load the DLL into the compiler `AssemblyLoadContext` via `LoadFromAssemblyName` and if that succeeds use that DLL, otherwise load into the analyzer `AssemblyLoadContext`. That approach works great but has the downside that it introduces first chance `FileNotFoundException` instances because `LoadFromAssemblyName` throws on failure hence our core load path is as follows:\r\n\r\n```csharp\r\nprotected override Assembly? Load(AssemblyName assemblyName)\r\n{\r\n    var simpleName = assemblyName.Name!;\r\n    try\r\n    {\r\n        if (_compilerLoadContext.LoadFromAssemblyName(assemblyName) is { } compilerAssembly)\r\n        {\r\n            return compilerAssembly;\r\n        }\r\n    }\r\n    catch\r\n    {\r\n        // Expected to happen when the assembly cannot be resolved in the compiler / host\r\n        // AssemblyLoadContext.\r\n    }\r\n\r\n    // Proceed with loading in the this analyzer AssemblyLoadContext\r\n```\r\n\r\nThe compiler is hosted in a number of applications including Visual Studio. The Visual Studio team keeps tabs on first chance exceptions in core scenarios because it can contribute negatively to startup performance. This means the compiler and Visual Studio are at a tension point when it comes to one of our core scenarios. Every time we add or change analyzers / generators it introduces new first chance exceptions into the product, flags our insertions and requires discussion to resolve.\r\n\r\nThe motivation here is to have an API that does not throw here. Asking an `AssemblyLoadContext` to load an assembly and having it fail is not necessarily an exceptional item.\r\n\r\nNote: happy to elaborate on why these unnecessary DLLs get passed by that is a problem inherent to both our ecosystem as well as other similar .NET plugin situations. Solving that is likely not realistic which is why the request for an API solution (it also seems reasonable by itself). \r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Runtime.Loader\r\n\r\npublic class AssemblyLoadContext\r\n{\r\n    public bool TryLoadFromAssemblyName(AssemblyName assemblyName, [NotNullWhen(true)] out Assembly? assembly)\r\n}\r\n```\r\n\r\nThis API would function exactly as `LoadFromAssemblyName` does today except that it uses a `bool` to express failure instead of an exception. \r\n\r\n### API Usage\r\n\r\nGiven that code paths could change to the following \r\n\r\n```csharp\r\nprotected override Assembly? Load(AssemblyName assemblyName)\r\n{\r\n    var simpleName = assemblyName.Name!;\r\n    if (_compilerLoadContext.TryLoadFromAssemblyName(assemblyName, out var compilerAssembly))\r\n    {\r\n        return compilerAssembly;\r\n    }\r\n\r\n    // Proceed with loading in the this analyzer AssemblyLoadContext\r\n\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\nA potential alternative design is to have an oveload of `LoadFromAssemblyName` which has a `throwOnError` parameter similar to `Type.GetType`. \r\n\r\n```csharp\r\npublic class AssemblyLoadContext\r\n{\r\n    public Assembly? TryLoadFromAssemblyName(AssemblyName assemblyName, bool throwOnError)\r\n}\r\n```\r\n\r\nThat is undesirable for the following reasons:\r\n\r\n1. The API does not work well with nullable reference types. \r\n2. The `Try` pattern generally the standard approach for this style of method. \r\n\r\n### Risks\r\n\r\nNone that I can think of. In discussing with @elinor-fung and @davidwrighton they felt this was a reasonable approach to solving the problem. ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOmm5Neg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5eIYPC",
                                           "createdAt":  "2023-06-06T18:26:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nThe C# compiler uses `AssemblyLoadContext` to isolate and manage analyzers and generators that plug into the compiler. Analyzers are passed to the compiler as a series of `/analyzer:path/to/analyzer1.dll` arguments. The compiler effectively groups these arguments by directory and creates an `AssemblyLoadContext` per directory. \r\n\r\nThe problem is that due to the nature of build, NuPkg authoring and analyzer detection, the compiler will end up getting passed DLLs that are not a part of the analyzer but instead part of the compiler. For example it\u0027s not uncommon to see `/analyzer:System.Collections.Immutable.dll` or `/analyzer:System.Runtime.CompilerServices.Unsafe.dll` to be passed as arguments. This is problematic because these DLLs contain exchange types. The compiler _owns_ these DLLs and their copy must be used in both the compiler and analyzer for proper functioning. Loading the analyzer copy will lead to API mismatches later on that break the compilation process.\r\n\r\nToday the only way to determine if the compiler owns the DLL is to first attempt to load the DLL into the compiler `AssemblyLoadContext` via `LoadFromAssemblyName` and if that succeeds use that DLL, otherwise load into the analyzer `AssemblyLoadContext`. That approach works great but has the downside that it introduces first chance exceptions because `LoadFromAssemblyName` throws on failure hence our core load path is as follows:\r\n\r\n```csharp\r\nprotected override Assembly? Load(AssemblyName assemblyName)\r\n{\r\n    var simpleName = assemblyName.Name!;\r\n    try\r\n    {\r\n        if (_compilerLoadContext.LoadFromAssemblyName(assemblyName) is { } compilerAssembly)\r\n        {\r\n            return compilerAssembly;\r\n        }\r\n    }\r\n    catch\r\n    {\r\n        // Expected to happen when the assembly cannot be resolved in the compiler / host\r\n        // AssemblyLoadContext.\r\n    }\r\n\r\n    // Proceed with loading in the this analyzer AssemblyLoadContext\r\n```\r\n\r\nThe compiler is hosted in a number of applications including Visual Studio. The Visual Studio team keeps tabs on first chance exceptions in core scenarios because it can contribute negatively to startup performance. This means the compiler and Visual Studio are at a tension point when it comes to one of our core scenarios. Every time we add or change analyzers / generators it introduces new first chance exceptions into the product, flags our insertions and requires discussion to resolve.\r\n\r\nThe motivation here is to have an API that does not throw here. Asking an `AssemblyLoadContext` to load an assembly and having it fail is not necessarily an exceptional item.\r\n\r\nNote: happy to elaborate on why these unnecessary DLLs get passed by that is a problem inherent to both our ecosystem as well as other similar .NET plugin situations. Solving that is likely not realistic which is why the request for an API solution (it also seems reasonable by itself). \n\n### API Proposal\n\n```csharp\r\nnamespace System.Runtime.Loader\r\n\r\npublic class AssemblyLoadContext\r\n{\r\n    public bool TryLoadFromAssemblyName(AssemblyName assemblyName, [NotNullWhen(true)] out Assembly? assembly)\r\n}\r\n```\r\n\r\nThis API would function exactly as `LoadFromAssemblyName` does today except that it uses a `bool` to express failure instead of an exception. \n\n### API Usage\n\nGiven that code paths could change to the following \r\n\r\n```csharp\r\nprotected override Assembly? Load(AssemblyName assemblyName)\r\n{\r\n    var simpleName = assemblyName.Name!;\r\n    if (_compilerLoadContext.TryLoadFromAssemblyName(assemblyName, out var compilerAssembly))\r\n    {\r\n        return compilerAssembly;\r\n    }\r\n\r\n    // Proceed with loading in the this analyzer AssemblyLoadContext\r\n\r\n```\r\n\n\n### Alternative Designs\n\nA potential alternative design is to have an oveload of `LoadFromAssemblyName` which has a `throwOnError` parameter similar to `Type.GetType`. \r\n\r\n```csharp\r\npublic class AssemblyLoadContext\r\n{\r\n    public Assembly? TryLoadFromAssemblyName(AssemblyName assemblyName, bool throwOnError)\r\n}\r\n```\r\n\r\nThat is undesirable for the following reasons:\r\n\r\n1. The API does not work well with nullable reference types. \r\n2. The `Try` pattern generally the standard approach for this style of method. \n\n### Risks\n\nNone that I can think of. In discussing with @elinor-fung and @davidwrighton they felt this was a reasonable approach to solving the problem. \n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejaredpar\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-AssemblyLoader-coreclr`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-06-06T18:26:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5eK2gS",
                                           "createdAt":  "2023-06-07T05:08:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "Similar API proposal https://github.com/dotnet/runtime/issues/21785, with similar motivation, has been rejected by API review a few years back.",
                                           "updatedAt":  "2023-06-07T05:08:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5eME26",
                                           "createdAt":  "2023-06-07T08:47:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "The way I view this request is slightly different from #21785. The core question which this wants to answer is: \"Can this ALC resolve this assembly name?\". It doesn\u0027t necessarily need to actually resolve it (it can call the throwing method to do so). And in a way it may not need to be 100% correct (for example the context may know how to resolve it, but the file is missing on disk and the load eventually fails, or something like that).\r\n\r\nAnother way to look at this is that each ALC has a set of assembly names it knows how to resolve. But it never materializes the set - that\u0027s done lazily. The core of the question is \"is my assembly name in that set?\" - but we can\u0027t answer that with a lookup, it has to run the resolution algorithm.\r\n\r\nUltimately this is definitely doable, the problematic areas I can think of right now:\r\n* Defining the desired functionality - if we want to just expose the \"test\" or we want the real \"load but don\u0027t throw\" behavior.\r\n* What should happen if the resolution runs into problems - we\u0027re running potentially lot of custom code during the resolution and it can fail in many different ways - do we propagate the failure as exception even through the `Try` call, or do we swallow it and turn it into a simple `false`? (The answer is probably \"it depends\", so it\u0027s a bit complicated).\r\n* Do we try to make this a true \"Try\" behavior - meaning that calling the method and it returning `false` doesn\u0027t modify any global state (getting a `false` is a non-side-effecting operation) - that is normally what the `Try` methods behave like, but doing this in the assembly resolver would be VERY difficult.",
                                           "updatedAt":  "2023-06-07T08:47:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5eME9N",
                                           "createdAt":  "2023-06-07T08:48:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "/cc @elinor-fung ",
                                           "updatedAt":  "2023-06-07T08:48:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5eNrxC",
                                           "createdAt":  "2023-06-07T11:52:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD0InKw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jaredpar",
                                                                               "createdAt":  "2023-06-07T15:11:39Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "CyrusNajmabadi",
                                                                               "createdAt":  "2024-09-30T18:38:14Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Defining the desired functionality - if we want to just expose the \"test\" or we want the real \"load but don\u0027t throw\" behavior.\r\n\r\nI do not think we would want to be creative with introducing new partial assembly loading models. The behavior of the API should 100% match the following implementation, except that it will try to avoid throwing and catching FileLoadExceptions internally where possible. \r\n\r\n```csharp\r\nbool TryLoadFromAssemblyName(AssemblyName assemblyName, [NotNullWhen(true)] out Assembly? assembly)\r\n{\r\n    try\r\n    {\r\n        assembly = LoadFromAssemblyName(assemblyName(assemblyName);\r\n        return true;\r\n    }\r\n    catch (FileLoadException e)\r\n    {\r\n        assembly = null;\r\n        return false;\r\n    }\r\n}\r\n```",
                                           "updatedAt":  "2023-06-07T11:52:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5eNw2r",
                                           "createdAt":  "2023-06-07T12:01:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e The Visual Studio team keeps tabs on first chance exceptions in core scenarios because it can contribute negatively to startup performance.\r\n\r\nNote that we have work underway to make throwing and catching exceptions a lot cheaper. It would be useful to measure the cost of throwing and catching exception (after the perf improvements) and compare it with the total cost of analyzer assembly load in Roslyn scenarios. It is quite possible that this API would not actually result in any meaningful perf improvement.",
                                           "updatedAt":  "2023-06-07T12:01:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6OF4ra",
                                           "createdAt":  "2024-09-30T18:38:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CyrusNajmabadi",
                                           "body":  "Note: this issue is currently impeding getting in SG reloading in VS :) \n\nSpecifically, all the exceptions thrown now by this helper are triggering the gates in speedometer: https://dev.azure.com/devdiv/DevDiv/_git/VS/pullrequest/581245\n\nTo get an idea:\n\n![Image](https://github.com/user-attachments/assets/b9236e02-67a4-4b15-9f58-d0764cbc5c0b)\n\nWould love to get a helper here that allows us to have this functionality without exceptions.  Note that exceptions are also painful for other reasons (like debugging) as they make it seem as if there\u0027s a problem, when really there isn\u0027t.  Would love to see this prioritized.",
                                           "updatedAt":  "2024-09-30T18:38:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6OF7WK",
                                           "createdAt":  "2024-09-30T18:45:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD0JI6Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ryanmolden",
                                                                               "createdAt":  "2024-09-30T19:48:30Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jaredpar",
                                           "body":  "\u003e Note that exceptions are also painful for other reasons (like debugging) as they make it seem as if there\u0027s a problem, when really there isn\u0027t\r\n\r\nIt also just makes debugging harder. Every time I debug the compiler know I know that I\u0027m going to have to step through 5-6 exceptions that I don\u0027t actually care about. They are noise that I cannot disable if I\u0027m digging into loading bugs in the compiler. It\u0027s a persistent negative part of our developer experience. \r\n",
                                           "updatedAt":  "2024-09-30T18:45:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6OGY4S",
                                           "createdAt":  "2024-09-30T19:58:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD0utlw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "CyrusNajmabadi",
                                                                               "createdAt":  "2024-10-03T18:00:27Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "ryanmolden",
                                           "body":  "\u003e \u003e Note that exceptions are also painful for other reasons (like debugging) as they make it seem as if there\u0027s a problem, when really there isn\u0027t\r\n\u003e \r\n\u003e It also just makes debugging harder. Every time I debug the compiler know I know that I\u0027m going to have to step through 5-6 exceptions that I don\u0027t actually care about. They are noise that I cannot disable if I\u0027m digging into loading bugs in the compiler. It\u0027s a persistent negative part of our developer experience.\r\n\r\nI would like to +100 this. As a developer that routinely debugs VS we throw **way** too many exceptions for normal/expected things. As cheap as they may be for an end-user (i.e. the runtime, non-debugger cost of throwing/catching exceptions) they will always be expensive under a debugger as the debugger has to field the FCE notification, pause all threads in the running app, decide if the user has that exception marked for break on FCE, and then do the appropriate thing (which may just be \u0027continue execution\u0027, i.e. a rather expensive NOP).\r\n\r\nOne could certainly argue part of the cost here is in the debugger reaction to the FCE, and I agree, but one could also argue that **not** doing something (i.e. throwing an exception and someone having to deal with it) will always be cheaper than doing that same thing, as far as runtime cost goes.\r\n\r\nAdding cost here via adding more and more \u0027ignorable\u0027 exceptions significantly impacts the dev inner loop and thus makes us less productive in actually developing Visual Studio as it adds friction to a workflow we engage in many, many times a day. It also makes the whole \u0027exceptions are exceptional\u0027 argument a bit less convincing since in this case it seems like these are NOT actually exceptional/unexpected situations.\r\n\r\nA particularly egregious example of this is triage dump debugging wherein Roslyn seems to trigger many thousand exceptions when you start debugging and it literally means for me, that being under a debugger in that scenario takes (no exaggeration) multiple minutes to get debugging started, whereas **not** under a debugger it takes seconds.",
                                           "updatedAt":  "2024-09-30T19:59:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6OkztK",
                                           "createdAt":  "2024-10-03T18:03:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CyrusNajmabadi",
                                           "body":  "\u003e A particularly egregious example of this is triage dump debugging wherein Roslyn seems to trigger many thousand exceptions\n\nAre these cancellation exceptions, or something else.  If something else, let us know what they are so we can resolve.  If they\u0027re cancellation, @jcouv was working on changing compiler code-gen i believe so that async-cancellation doesn\u0027t involve N rethrows of hte CT across each await in an async chain. ",
                                           "updatedAt":  "2024-10-03T18:03:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Z-V04",
                                           "createdAt":  "2025-01-10T16:53:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-reflection\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-01-10T18:29:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Z-g4p",
                                           "createdAt":  "2025-01-10T17:19:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "@bartonjs Was it intentional that you have changed the area to System.Reflection? `AssemblyLoadContext` is not in Reflection namespace and it is not owned by reflection feature team...",
                                           "updatedAt":  "2025-01-10T18:29:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Z_Qgp",
                                           "createdAt":  "2025-01-10T18:26:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bartonjs",
                                           "body":  "@jkotas GitHub presented the issue to me with no labels, so I was moving it from \"none\" to \"some\", and guessed by the issue you linked to.\n\nBut I see that the history claims I removed the previous ones.  I\u0027ll undo that.",
                                           "updatedAt":  "2025-01-10T18:29:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Z_Rs3",
                                           "createdAt":  "2025-01-10T18:27:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-01-10T18:29:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6abk16",
                                           "createdAt":  "2025-01-14T19:18:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "terrajobst",
                                           "body":  "[Video](https://www.youtube.com/watch?v=UB1FXGlxqkA\u0026t=0h0m0s)\n\n* The new method will behave such that it returns `false` if the underlying API returned `null` or threw `FileNotFoundException`\n    - That means it won\u0027t eliminate all exceptions but most\n    - We can try to fix other resolvers to return `null` instead of throwing\n\n```C#\nnamespace System.Runtime.Loader;\n\npublic partial class AssemblyLoadContext\n{\n    public bool TryLoadFromAssemblyName(AssemblyName assemblyName, [NotNullWhen(true)] out Assembly? assembly);\n}\n```",
                                           "updatedAt":  "2025-01-14T20:48:36Z"
                                       }
                                   ],
                         "totalCount":  15
                     },
        "title":  "[API Proposal]: AssemblyLoadContext.TryLoadFromAssemblyName",
        "labels":  [
                       "api-approved",
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/91952",
        "createdAt":  "2023-09-12T17:45:26Z",
        "number":  91952,
        "author":  "Fabi0San",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-05-03T18:58:23Z",
        "body":  "### Description\r\n\r\nWhile trying to resolve an assembly for loading, if one of the stages finds a mismatched version, later resolution stages fail to load good version.\r\n\r\n### Reproduction Steps\r\n\r\nPut an old version of the required assembly in the application process .exe folder, then subscribe an assembly loader that will pick the right version from elsewhere.\r\n\r\nAlternatively, I suspect that attempting to call Assembly.Load(name) with the wrong version beside the .exe and then execute LoadFrom(pathToGoodVersion) will fail as well.\r\n\r\n### Expected behavior\r\n\r\nGood version should always succeed to load.\r\n\r\nHere are traces of what happens if the assembly is not found at stage:ApplicationAssemblies, stage:AppDomainAssemblyResolveEvent succeeds.\r\n\r\n\u003cHTML\u003e\r\n\u003cBODY\u003e\r\n\u003c!--StartFragment--\u003e\u003cTABLE\u003e\u003cTR\u003e\u003cTD\u003eRest\u003c/TD\u003e\u003c/TR\u003e\u003cTR\u003e\u003cTD\u003eHasStack=\u0026quot;True\u0026quot; ThreadID=\u0026quot;55,320\u0026quot; ProcessorNumber=\u0026quot;0\u0026quot; ClrInstanceID=\u0026quot;10\u0026quot; AssemblyName=\u0026quot;FluentAssertions, Version=6.7.0.0, Culture=neutral, PublicKeyToken=33f2691a05b67b6a\u0026quot; Stage=\u0026quot;FindInLoadContext\u0026quot; AssemblyLoadContext=\u0026quot;Default\u0026quot; Result=\u0026quot;AssemblyNotFound\u0026quot; ResultAssemblyName=\u0026quot;\u0026quot; ResultAssemblyPath=\u0026quot;\u0026quot; ErrorMessage=\u0026quot;Could not locate assembly\u0026quot; ActivityID=\u0026quot;/#7520/1/206/\u0026quot; \u003c/TD\u003e\u003c/TR\u003e\u003cTR\u003e\u003cTD\u003eHasStack=\u0026quot;True\u0026quot; ThreadID=\u0026quot;55,320\u0026quot; ProcessorNumber=\u0026quot;0\u0026quot; ClrInstanceID=\u0026quot;10\u0026quot; AssemblyName=\u0026quot;FluentAssertions, Version=6.7.0.0, Culture=neutral, PublicKeyToken=33f2691a05b67b6a\u0026quot; Stage=\u0026quot;ApplicationAssemblies\u0026quot; AssemblyLoadContext=\u0026quot;Default\u0026quot; Result=\u0026quot;AssemblyNotFound\u0026quot; ResultAssemblyName=\u0026quot;\u0026quot; ResultAssemblyPath=\u0026quot;\u0026quot; ErrorMessage=\u0026quot;Could not locate assembly\u0026quot; ActivityID=\u0026quot;/#7520/1/206/\u0026quot; \u003c/TD\u003e\u003c/TR\u003e\u003cTR\u003e\u003cTD\u003eHasStack=\u0026quot;True\u0026quot; ThreadID=\u0026quot;55,320\u0026quot; ProcessorNumber=\u0026quot;0\u0026quot; ClrInstanceID=\u0026quot;10\u0026quot; AssemblyName=\u0026quot;FluentAssertions, Version=6.7.0.0, Culture=neutral, PublicKeyToken=33f2691a05b67b6a\u0026quot; Stage=\u0026quot;AssemblyLoadContextResolvingEvent\u0026quot; AssemblyLoadContext=\u0026quot;Default\u0026quot; Result=\u0026quot;AssemblyNotFound\u0026quot; ResultAssemblyName=\u0026quot;\u0026quot; ResultAssemblyPath=\u0026quot;\u0026quot; ErrorMessage=\u0026quot;Could not locate assembly\u0026quot; ActivityID=\u0026quot;/#7520/1/206/\u0026quot; \u003c/TD\u003e\u003c/TR\u003e\u003cTR\u003e\u003cTD\u003eHasStack=\u0026quot;True\u0026quot; ThreadID=\u0026quot;55,320\u0026quot; ProcessorNumber=\u0026quot;0\u0026quot; ClrInstanceID=\u0026quot;10\u0026quot; AssemblyName=\u0026quot;FluentAssertions, Version=6.7.0.0, Culture=neutral, PublicKeyToken=33f2691a05b67b6a\u0026quot; Stage=\u0026quot;AppDomainAssemblyResolveEvent\u0026quot; AssemblyLoadContext=\u0026quot;Default\u0026quot; Result=\u0026quot;Success\u0026quot; ResultAssemblyName=\u0026quot;FluentAssertions, Version=6.7.0.0, Culture=neutral, PublicKeyToken=33f2691a05b67b6a\u0026quot; ResultAssemblyPath=\u0026quot;D:\\src\\subs\\target\\test\\managedstore\\Internal.Exchange.Test.ManagedStore.QTests.Common\\bin\\Debug\\net6.0\\FluentAssertions.dll\u0026quot; ErrorMessage=\u0026quot;\u0026quot; ActivityID=\u0026quot;/#7520/1/206/\u0026quot; \u003c/TD\u003e\u003c/TR\u003e\u003c/TABLE\u003e\r\n\u003c!--EndFragment--\u003e\r\n\u003c/BODY\u003e\r\n\u003c/HTML\u003e\r\n\r\n### Actual behavior\r\n\r\nIf the mismatched version is ever rejected, no good version can be loaded.\r\n\r\nHere are traces of what happens if the mismatched version is found at stage:ApplicationAssemblies, stage:AppDomainAssemblyResolveEvent succeeds.\r\n\r\n\u003cHTML\u003e\r\n\u003cBODY\u003e\r\n\u003c!--StartFragment--\u003e\u003cTABLE\u003e\u003cTR\u003e\u003cTD\u003eRest\u003c/TD\u003e\u003c/TR\u003e\u003cTR\u003e\u003cTD\u003eHasStack=\u0026quot;True\u0026quot; ThreadID=\u0026quot;60,068\u0026quot; ProcessorNumber=\u0026quot;0\u0026quot; ClrInstanceID=\u0026quot;9\u0026quot; AssemblyName=\u0026quot;FluentAssertions, Version=6.7.0.0, Culture=neutral, PublicKeyToken=33f2691a05b67b6a\u0026quot; Stage=\u0026quot;FindInLoadContext\u0026quot; AssemblyLoadContext=\u0026quot;Default\u0026quot; Result=\u0026quot;AssemblyNotFound\u0026quot; ResultAssemblyName=\u0026quot;\u0026quot; ResultAssemblyPath=\u0026quot;\u0026quot; ErrorMessage=\u0026quot;Could not locate assembly\u0026quot; ActivityID=\u0026quot;/#57240/1/206/\u0026quot; \u003c/TD\u003e\u003c/TR\u003e\u003cTR\u003e\u003cTD\u003eHasStack=\u0026quot;True\u0026quot; ThreadID=\u0026quot;60,068\u0026quot; ProcessorNumber=\u0026quot;0\u0026quot; ClrInstanceID=\u0026quot;9\u0026quot; AssemblyName=\u0026quot;FluentAssertions, Version=6.7.0.0, Culture=neutral, PublicKeyToken=33f2691a05b67b6a\u0026quot; Stage=\u0026quot;ApplicationAssemblies\u0026quot; AssemblyLoadContext=\u0026quot;Default\u0026quot; Result=\u0026quot;MismatchedAssemblyName\u0026quot; ResultAssemblyName=\u0026quot;FluentAssertions, Version=5.6.0.0, Culture=neutral, PublicKeyToken=33f2691a05b67b6a\u0026quot; ResultAssemblyPath=\u0026quot;D:\\src\\subs\\target\\test\\tools\\UniTP\\bin\\Debug\\net6.0\\FluentAssertions.dll\u0026quot; ErrorMessage=\u0026quot;Requested version 6.7.0.0 is incompatible with found version 5.6.0.0\u0026quot; ActivityID=\u0026quot;/#57240/1/206/\u0026quot; \u003c/TD\u003e\u003c/TR\u003e\u003cTR\u003e\u003cTD\u003eHasStack=\u0026quot;True\u0026quot; ThreadID=\u0026quot;60,068\u0026quot; ProcessorNumber=\u0026quot;0\u0026quot; ClrInstanceID=\u0026quot;9\u0026quot; AssemblyName=\u0026quot;FluentAssertions, Version=6.7.0.0, Culture=neutral, PublicKeyToken=33f2691a05b67b6a\u0026quot; Stage=\u0026quot;AssemblyLoadContextResolvingEvent\u0026quot; AssemblyLoadContext=\u0026quot;Default\u0026quot; Result=\u0026quot;AssemblyNotFound\u0026quot; ResultAssemblyName=\u0026quot;\u0026quot; ResultAssemblyPath=\u0026quot;\u0026quot; ErrorMessage=\u0026quot;Could not locate assembly\u0026quot; ActivityID=\u0026quot;/#57240/1/206/\u0026quot; \u003c/TD\u003e\u003c/TR\u003e\u003cTR\u003e\u003cTD\u003eHasStack=\u0026quot;True\u0026quot; ThreadID=\u0026quot;60,068\u0026quot; ProcessorNumber=\u0026quot;0\u0026quot; ClrInstanceID=\u0026quot;9\u0026quot; AssemblyName=\u0026quot;FluentAssertions, Version=6.7.0.0, Culture=neutral, PublicKeyToken=33f2691a05b67b6a\u0026quot; Stage=\u0026quot;AppDomainAssemblyResolveEvent\u0026quot; AssemblyLoadContext=\u0026quot;Default\u0026quot; Result=\u0026quot;Exception\u0026quot; ResultAssemblyName=\u0026quot;\u0026quot; ResultAssemblyPath=\u0026quot;\u0026quot; ErrorMessage=\u0026quot;Could not load file or assembly \u0027FluentAssertions, Version=6.7.0.0, Culture=neutral, PublicKeyToken=33f2691a05b67b6a\u0027.\u0026quot; ActivityID=\u0026quot;/#57240/1/206/\u0026quot; \u003c/TD\u003e\u003c/TR\u003e\u003c/TABLE\u003e\r\n\u003c!--EndFragment--\u003e\r\n\u003c/BODY\u003e\r\n\u003c/HTML\u003e\r\n\r\n### Regression?\r\n\r\nYes,\r\nThis did not happen in net472, but happens in net6.0\r\n\r\n### Known Workarounds\r\n\r\nAvoid bad versions.\r\n\r\n### Configuration\r\n\r\nnet6.0\r\nWindows\r\nx64\r\n\r\n\r\n### Other information\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOZmSHFg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5mZIcW",
                                           "createdAt":  "2023-09-13T15:31:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\n\r\nWhile trying to resolve an assembly for loading, if one of the stages finds a mismatched version, later resolution stages fail to load good version.\r\n\r\n### Reproduction Steps\r\n\r\nPut an old version of the required assembly in the application process .exe folder, then subscribe an assembly loader that will pick the right version from elsewhere.\r\n\r\nAlternatively, I suspect that attempting to call Assembly.Load(name) with the wrong version beside the .exe and then execute LoadFrom(pathToGoodVersion) will fail as well.\r\n\r\n### Expected behavior\r\n\r\nGood version should always succeed to load.\r\n\r\nHere are traces of what happens if the assembly is not found at stage:ApplicationAssemblies, stage:AppDomainAssemblyResolveEvent succeeds.\r\n\r\n\u003cHTML\u003e\r\n\u003cBODY\u003e\r\n\u003c!--StartFragment--\u003e\u003cTABLE\u003e\u003cTR\u003e\u003cTD\u003eRest\u003c/TD\u003e\u003c/TR\u003e\u003cTR\u003e\u003cTD\u003eHasStack=\u0026quot;True\u0026quot; ThreadID=\u0026quot;55,320\u0026quot; ProcessorNumber=\u0026quot;0\u0026quot; ClrInstanceID=\u0026quot;10\u0026quot; AssemblyName=\u0026quot;FluentAssertions, Version=6.7.0.0, Culture=neutral, PublicKeyToken=33f2691a05b67b6a\u0026quot; Stage=\u0026quot;FindInLoadContext\u0026quot; AssemblyLoadContext=\u0026quot;Default\u0026quot; Result=\u0026quot;AssemblyNotFound\u0026quot; ResultAssemblyName=\u0026quot;\u0026quot; ResultAssemblyPath=\u0026quot;\u0026quot; ErrorMessage=\u0026quot;Could not locate assembly\u0026quot; ActivityID=\u0026quot;/#7520/1/206/\u0026quot; \u003c/TD\u003e\u003c/TR\u003e\u003cTR\u003e\u003cTD\u003eHasStack=\u0026quot;True\u0026quot; ThreadID=\u0026quot;55,320\u0026quot; ProcessorNumber=\u0026quot;0\u0026quot; ClrInstanceID=\u0026quot;10\u0026quot; AssemblyName=\u0026quot;FluentAssertions, Version=6.7.0.0, Culture=neutral, PublicKeyToken=33f2691a05b67b6a\u0026quot; Stage=\u0026quot;ApplicationAssemblies\u0026quot; AssemblyLoadContext=\u0026quot;Default\u0026quot; Result=\u0026quot;AssemblyNotFound\u0026quot; ResultAssemblyName=\u0026quot;\u0026quot; ResultAssemblyPath=\u0026quot;\u0026quot; ErrorMessage=\u0026quot;Could not locate assembly\u0026quot; ActivityID=\u0026quot;/#7520/1/206/\u0026quot; \u003c/TD\u003e\u003c/TR\u003e\u003cTR\u003e\u003cTD\u003eHasStack=\u0026quot;True\u0026quot; ThreadID=\u0026quot;55,320\u0026quot; ProcessorNumber=\u0026quot;0\u0026quot; ClrInstanceID=\u0026quot;10\u0026quot; AssemblyName=\u0026quot;FluentAssertions, Version=6.7.0.0, Culture=neutral, PublicKeyToken=33f2691a05b67b6a\u0026quot; Stage=\u0026quot;AssemblyLoadContextResolvingEvent\u0026quot; AssemblyLoadContext=\u0026quot;Default\u0026quot; Result=\u0026quot;AssemblyNotFound\u0026quot; ResultAssemblyName=\u0026quot;\u0026quot; ResultAssemblyPath=\u0026quot;\u0026quot; ErrorMessage=\u0026quot;Could not locate assembly\u0026quot; ActivityID=\u0026quot;/#7520/1/206/\u0026quot; \u003c/TD\u003e\u003c/TR\u003e\u003cTR\u003e\u003cTD\u003eHasStack=\u0026quot;True\u0026quot; ThreadID=\u0026quot;55,320\u0026quot; ProcessorNumber=\u0026quot;0\u0026quot; ClrInstanceID=\u0026quot;10\u0026quot; AssemblyName=\u0026quot;FluentAssertions, Version=6.7.0.0, Culture=neutral, PublicKeyToken=33f2691a05b67b6a\u0026quot; Stage=\u0026quot;AppDomainAssemblyResolveEvent\u0026quot; AssemblyLoadContext=\u0026quot;Default\u0026quot; Result=\u0026quot;Success\u0026quot; ResultAssemblyName=\u0026quot;FluentAssertions, Version=6.7.0.0, Culture=neutral, PublicKeyToken=33f2691a05b67b6a\u0026quot; ResultAssemblyPath=\u0026quot;D:\\src\\subs\\target\\test\\managedstore\\Internal.Exchange.Test.ManagedStore.QTests.Common\\bin\\Debug\\net6.0\\FluentAssertions.dll\u0026quot; ErrorMessage=\u0026quot;\u0026quot; ActivityID=\u0026quot;/#7520/1/206/\u0026quot; \u003c/TD\u003e\u003c/TR\u003e\u003c/TABLE\u003e\r\n\u003c!--EndFragment--\u003e\r\n\u003c/BODY\u003e\r\n\u003c/HTML\u003e\r\n\r\n### Actual behavior\r\n\r\nIf the mismatched version is ever rejected, no good version can be loaded.\r\n\r\nHere are traces of what happens if the mismatched version is found at stage:ApplicationAssemblies, stage:AppDomainAssemblyResolveEvent succeeds.\r\n\r\n\u003cHTML\u003e\r\n\u003cBODY\u003e\r\n\u003c!--StartFragment--\u003e\u003cTABLE\u003e\u003cTR\u003e\u003cTD\u003eRest\u003c/TD\u003e\u003c/TR\u003e\u003cTR\u003e\u003cTD\u003eHasStack=\u0026quot;True\u0026quot; ThreadID=\u0026quot;60,068\u0026quot; ProcessorNumber=\u0026quot;0\u0026quot; ClrInstanceID=\u0026quot;9\u0026quot; AssemblyName=\u0026quot;FluentAssertions, Version=6.7.0.0, Culture=neutral, PublicKeyToken=33f2691a05b67b6a\u0026quot; Stage=\u0026quot;FindInLoadContext\u0026quot; AssemblyLoadContext=\u0026quot;Default\u0026quot; Result=\u0026quot;AssemblyNotFound\u0026quot; ResultAssemblyName=\u0026quot;\u0026quot; ResultAssemblyPath=\u0026quot;\u0026quot; ErrorMessage=\u0026quot;Could not locate assembly\u0026quot; ActivityID=\u0026quot;/#57240/1/206/\u0026quot; \u003c/TD\u003e\u003c/TR\u003e\u003cTR\u003e\u003cTD\u003eHasStack=\u0026quot;True\u0026quot; ThreadID=\u0026quot;60,068\u0026quot; ProcessorNumber=\u0026quot;0\u0026quot; ClrInstanceID=\u0026quot;9\u0026quot; AssemblyName=\u0026quot;FluentAssertions, Version=6.7.0.0, Culture=neutral, PublicKeyToken=33f2691a05b67b6a\u0026quot; Stage=\u0026quot;ApplicationAssemblies\u0026quot; AssemblyLoadContext=\u0026quot;Default\u0026quot; Result=\u0026quot;MismatchedAssemblyName\u0026quot; ResultAssemblyName=\u0026quot;FluentAssertions, Version=5.6.0.0, Culture=neutral, PublicKeyToken=33f2691a05b67b6a\u0026quot; ResultAssemblyPath=\u0026quot;D:\\src\\subs\\target\\test\\tools\\UniTP\\bin\\Debug\\net6.0\\FluentAssertions.dll\u0026quot; ErrorMessage=\u0026quot;Requested version 6.7.0.0 is incompatible with found version 5.6.0.0\u0026quot; ActivityID=\u0026quot;/#57240/1/206/\u0026quot; \u003c/TD\u003e\u003c/TR\u003e\u003cTR\u003e\u003cTD\u003eHasStack=\u0026quot;True\u0026quot; ThreadID=\u0026quot;60,068\u0026quot; ProcessorNumber=\u0026quot;0\u0026quot; ClrInstanceID=\u0026quot;9\u0026quot; AssemblyName=\u0026quot;FluentAssertions, Version=6.7.0.0, Culture=neutral, PublicKeyToken=33f2691a05b67b6a\u0026quot; Stage=\u0026quot;AssemblyLoadContextResolvingEvent\u0026quot; AssemblyLoadContext=\u0026quot;Default\u0026quot; Result=\u0026quot;AssemblyNotFound\u0026quot; ResultAssemblyName=\u0026quot;\u0026quot; ResultAssemblyPath=\u0026quot;\u0026quot; ErrorMessage=\u0026quot;Could not locate assembly\u0026quot; ActivityID=\u0026quot;/#57240/1/206/\u0026quot; \u003c/TD\u003e\u003c/TR\u003e\u003cTR\u003e\u003cTD\u003eHasStack=\u0026quot;True\u0026quot; ThreadID=\u0026quot;60,068\u0026quot; ProcessorNumber=\u0026quot;0\u0026quot; ClrInstanceID=\u0026quot;9\u0026quot; AssemblyName=\u0026quot;FluentAssertions, Version=6.7.0.0, Culture=neutral, PublicKeyToken=33f2691a05b67b6a\u0026quot; Stage=\u0026quot;AppDomainAssemblyResolveEvent\u0026quot; AssemblyLoadContext=\u0026quot;Default\u0026quot; Result=\u0026quot;Exception\u0026quot; ResultAssemblyName=\u0026quot;\u0026quot; ResultAssemblyPath=\u0026quot;\u0026quot; ErrorMessage=\u0026quot;Could not load file or assembly \u0027FluentAssertions, Version=6.7.0.0, Culture=neutral, PublicKeyToken=33f2691a05b67b6a\u0027.\u0026quot; ActivityID=\u0026quot;/#57240/1/206/\u0026quot; \u003c/TD\u003e\u003c/TR\u003e\u003c/TABLE\u003e\r\n\u003c!--EndFragment--\u003e\r\n\u003c/BODY\u003e\r\n\u003c/HTML\u003e\r\n\r\n### Regression?\r\n\r\nYes,\r\nThis did not happen in net472, but happens in net6.0\r\n\r\n### Known Workarounds\r\n\r\nAvoid bad versions.\r\n\r\n### Configuration\r\n\r\nnet6.0\r\nWindows\r\nx64\r\n\r\n\r\n### Other information\r\n\r\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eFabi0San\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`, `untriaged`, `needs-area-label`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-09-13T15:31:39Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Assembly Resolution finding a mismatched version corrupts state and makes loading good version impossible",
        "labels":  [
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/92074",
        "createdAt":  "2023-09-14T17:56:15Z",
        "number":  92074,
        "author":  "SetTrend",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-09-18T15:55:59Z",
        "body":  "### Background and motivation\r\n\r\n# Current Situation\r\n\r\nIt’s such a common case to load a number of assemblies from a different location – in fact, this is the default case for using [`AssemblyLoadContext`](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.loader.assemblyloadcontext).\r\n\r\nYet, for implementing this simple and regular use case, it\u0027s required to manually derive from [`AssemblyLoadContext`](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.loader.assemblyloadcontext) and to create your own implementation that’s doing nothing else than just providing [`AssemblyDependencyResolver`](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.loader.assemblydependencyresolver) with that path, making a mountain out of a molehill.\r\n\r\nSee [Create a .NET Core application with plugins](https://learn.microsoft.com/en-us/dotnet/core/tutorials/creating-app-with-plugin-support#load-plugins) for reference.\r\n\r\n# Desired Situation\r\n\r\nI propose to add a constructor to [`AssemblyLoadContext`](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.loader.assemblyloadcontext) that’s accepting a file system directory path, so we can just use this constructor instead of being required to create a blatantly dispensable new class for this standard use case.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\npublic AssemblyLoadContext(string filePath, string? name = null, bool isCollectible = false) {}\r\n```\r\n\r\n### API Usage\r\n\r\n```csharp\r\nnew AssemblyLoadContext(@\".\\plugIns\").LoadFromAssemblyPath(@\".\\plugIns\\PlugIn1.dll\")\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOZoj4OA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5miPg4",
                                           "createdAt":  "2023-09-14T22:46:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\r\n\r\n# Current Situation\r\n\r\nIt’s such a common case to load a number of assemblies from a different location – in fact, this is the default case for using [`AssemblyLoadContext`](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.loader.assemblyloadcontext).\r\n\r\nYet, for implementing this simple and regular use case, it\u0027s required to manually derive from [`AssemblyLoadContext`](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.loader.assemblyloadcontext) and to create your own implementation that’s doing nothing else than just providing [`AssemblyDependencyResolver`](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.loader.assemblydependencyresolver) with that path, making a mountain out of a molehill.\r\n\r\nSee [Create a .NET Core application with plugins](https://learn.microsoft.com/en-us/dotnet/core/tutorials/creating-app-with-plugin-support#load-plugins) for reference.\r\n\r\n# Desired Situation\r\n\r\nI propose to add a constructor to [`AssemblyLoadContext`](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.loader.assemblyloadcontext) that’s accepting a file system directory path, so we can just use this constructor instead of being required to create a blatantly dispensable new class for this standard use case.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\npublic AssemblyLoadContext(string filePath, string? name = null, bool isCollectible = false) {}\r\n```\r\n\r\n### API Usage\r\n\r\n```csharp\r\nnew AssemblyLoadContext(@\".\\plugIns\").LoadFromAssemblyPath(@\".\\plugIns\\PlugIn1.dll\")\r\n```\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eSetTrend\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-AssemblyLoader-coreclr`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-09-14T22:46:07Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "[API Proposal]: Add constructor to AssemblyLoadContext that\u0027s accepting custom path",
        "labels":  [
                       "api-suggestion",
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/101096",
        "createdAt":  "2024-04-16T00:50:23Z",
        "number":  101096,
        "author":  "jkotas",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-20T03:01:18Z",
        "body":  "```\r\n  Discovering: System.Diagnostics.Debug.Tests (method display = ClassAndMethod, method display options = None)\r\n  Discovered:  System.Diagnostics.Debug.Tests (found 88 test cases)\r\n  Starting:    System.Diagnostics.Debug.Tests (parallel test collections = on [4 threads], stop on fail = off)\r\n\r\nAssert failure(PID 40772 [0x00009f44], Thread: 9204 [0x23f4]): Postcondition failure: FAILED: RETVAL-\u003eGetLoadLevel() \u003e= GetCurrentFileLoadLevel() || RETVAL-\u003eGetLoadLevel() \u003e= targetLevel\r\n\r\nCORECLR! CHECK::Trigger + 0x1E6 (0x00007ff8`947e4eb6)\r\nCORECLR! AppDomain::LoadDomainAssembly + 0x4E5 (0x00007ff8`94023145)\r\nCORECLR! AppDomain::LoadDomainAssembly + 0x1E0 (0x00007ff8`94023a50)\r\nCORECLR! DomainAssembly::EnsureLoadLevel + 0x382 (0x00007ff8`94107242)\r\nCORECLR! Module::EnsureActive + 0xB8 (0x00007ff8`94080e48)\r\nCORECLR! MethodTable::EnsureInstanceActive + 0xC5 (0x00007ff8`9422afb5)\r\nCORECLR! RuntimeTypeHandle_GetActivationInfo + 0x1072 (0x00007ff8`94566642)\r\n```\r\n\r\n## Build Information\r\nBuild: https://dev.azure.com/dnceng-public/cbb18261-c48f-4abb-8651-8cdcb5474649/_build/results?buildId=644554\r\nBuild error leg or test failing: System.Diagnostics.Debug.Tests.WorkItemExecution\r\nPull request: https://github.com/dotnet/runtime/pull/101084\r\n\u003c!-- Error message template  --\u003e\r\n## Error Message\r\n\r\nFill the error message using [step by step known issues guidance](https://github.com/dotnet/arcade/blob/main/Documentation/Projects/Build%20Analysis/KnownIssueJsonStepByStep.md).\r\n\r\n\u003c!-- Use ErrorMessage for String.Contains matches. Use ErrorPattern for regex matches (single line/no backtracking). Set BuildRetry to `true` to retry builds with this error. Set ExcludeConsoleLog to `true` to skip helix logs analysis. --\u003e\r\n\r\n```json\r\n{\r\n  \"ErrorMessage\": \"Postcondition failure: FAILED: RETVAL-\u003eGetLoadLevel() \u003e= GetCurrentFileLoadLevel() || RETVAL-\u003eGetLoadLevel() \u003e= targetLevel\",\r\n  \"ErrorPattern\": \"\",\r\n  \"BuildRetry\": false,\r\n  \"ExcludeConsoleLog\": false\r\n}\r\n```\r\n\r\n\r\n\u003c!-- Known issue validation start --\u003e\r\n ### Known issue validation\r\n**Build: :mag_right:** https://dev.azure.com/dnceng-public/public/_build/results?buildId=644554\r\n**Error message validated:** `[Postcondition failure: FAILED: RETVAL-\u003eGetLoadLevel() \u003e= GetCurrentFileLoadLevel() || RETVAL-\u003eGetLoadLevel() \u003e= targetLevel`]\r\n**Result validation:** :white_check_mark: Known issue matched with the provided build.\r\n**Validation performed at:** 4/16/2024 12:54:51 AM UTC\r\n\u003c!-- Known issue validation end --\u003e\r\n\u003c!--Known issue error report start --\u003e\r\n\r\n### Report\r\n#### Summary\r\n|24-Hour Hit Count|7-Day Hit Count|1-Month Count|\r\n|---|---|---|\r\n|0|0|0|\r\n\u003c!--Known issue error report end --\u003e",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOgbph7w==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc56q1z5",
                                           "createdAt":  "2024-04-16T00:57:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "Managed stack:\r\n```\r\n000000B5ADDBC2E8 00007ff892f1e26c [InlinedCallFrame: 000000b5addbc2e8] \r\n000000B5ADDBC2B0 00007ff892f1e26c System.RuntimeTypeHandle.GetActivationInfo(System.RuntimeType, System.Object (Void*) ByRef, Void* ByRef, Void (System.Object) ByRef, Boolean ByRef) [/_/src/coreclr/System.Private.CoreLib/src/System/RuntimeHandles.cs @ 283]\r\n000000B5ADDBC3C0 00007ff892f2ac2c System.RuntimeType+ActivatorCache..ctor(System.RuntimeType) [/_/src/coreclr/System.Private.CoreLib/src/System/RuntimeType.ActivatorCache.cs @ 49]\r\n000000B5ADDBC410 00007ff892f26c26 System.RuntimeType.CreateInstanceDefaultCtor(Boolean, Boolean) [/_/src/coreclr/System.Private.CoreLib/src/System/RuntimeType.CoreCLR.cs @ 3910]\r\n000000B5ADDBC470 00007ff892f26914 System.RuntimeType.CreateInstanceImpl(System.Reflection.BindingFlags, System.Reflection.Binder, System.Object[], System.Globalization.CultureInfo) [/_/src/coreclr/System.Private.CoreLib/src/System/RuntimeType.CoreCLR.cs @ 3853]\r\n000000B5ADDBC540 00007ff892f3cf92 System.Activator.CreateInstance(System.Type, System.Object[]) [/_/src/libraries/System.Private.CoreLib/src/System/Activator.cs @ 31]\r\n000000B5ADDBC580 00007ff836690764 ReflectionAbstractionExtensions+c__DisplayClass0_0.b__0() [/_/src/xunit.execution/Extensions/ReflectionAbstractionExtensions.cs @ 42]\r\n000000B5ADDBC5B0 00007ff8366906c5 Xunit.Sdk.ExecutionTimer.Aggregate(System.Action) [/_/src/xunit.execution/Sdk/Frameworks/ExecutionTimer.cs @ 31]\r\n000000B5ADDBC600 00007ff836690571 ReflectionAbstractionExtensions.CreateTestClass(Xunit.Abstractions.ITest, System.Type, System.Object[], Xunit.Sdk.IMessageBus, Xunit.Sdk.ExecutionTimer, System.Threading.CancellationTokenSource) [/_/src/xunit.execution/Extensions/ReflectionAbstractionExtensions.cs @ 42]\r\n000000B5ADDBC660 00007ff83669031e Xunit.Sdk.TestInvoker`1[[System.__Canon, System.Private.CoreLib]].CreateTestClass() [/_/src/xunit.execution/Sdk/Frameworks/Runners/TestInvoker.cs @ 125]\r\n000000B5ADDBC6E0 00007ff83668f9d1 Xunit.Sdk.TestInvoker`1+b__47_0\u003ed[[System.__Canon, System.Private.CoreLib]].MoveNext() [/_/src/xunit.execution/Sdk/Frameworks/Runners/TestInvoker.cs @ 194]\r\n000000B5ADDBC820 00007ff83668f7cc System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.TestInvoker`1+b__47_0\u003ed[[System.__Canon, System.Private.CoreLib]], xunit.execution.dotnet]](b__47_0\u003ed ByRef) [/_/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/AsyncMethodBuilderCore.cs @ 38]\r\n000000B5ADDBC8D0 00007ff83668f6f0 System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Decimal, System.Private.CoreLib]].Start[[Xunit.Sdk.TestInvoker`1+b__47_0\u003ed[[System.__Canon, System.Private.CoreLib]], xunit.execution.dotnet]](b__47_0\u003ed ByRef) [/_/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/AsyncTaskMethodBuilderT.cs @ 35]\r\n000000B5ADDBC910 00007ff83668f66a Xunit.Sdk.TestInvoker`1[[System.__Canon, System.Private.CoreLib]].b__47_0()\r\n000000B5ADDBC990 00007ff83668f401 Xunit.Sdk.ExceptionAggregator+d__10`1[[System.Decimal, System.Private.CoreLib]].MoveNext() [/_/src/xunit.core/Sdk/ExceptionAggregator.cs @ 107]\r\n000000B5ADDBCA50 00007ff83668f2e7 System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.ExceptionAggregator+d__10`1[[System.Decimal, System.Private.CoreLib]], xunit.core]](d__10`1 ByRef) [/_/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/AsyncMethodBuilderCore.cs @ 38]\r\n000000B5ADDBCAD0 00007ff83668f25c System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Decimal, System.Private.CoreLib]].Start[[Xunit.Sdk.ExceptionAggregator+d__10`1[[System.Decimal, System.Private.CoreLib]], xunit.core]](d__10`1 ByRef) [/_/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/AsyncTaskMethodBuilderT.cs @ 35]\r\n000000B5ADDBCB00 00007ff83668f1d0 Xunit.Sdk.ExceptionAggregator.RunAsync[[System.Decimal, System.Private.CoreLib]](System.Func`1\u003e)\r\n000000B5ADDBCB60 00007ff83668f131 Xunit.Sdk.TestInvoker`1[[System.__Canon, System.Private.CoreLib]].RunAsync() [/_/src/xunit.execution/Sdk/Frameworks/Runners/TestInvoker.cs @ 190]\r\n000000B5ADDBCBA0 00007ff83668eb05 Xunit.Sdk.XunitTestRunner.InvokeTestMethodAsync(Xunit.Sdk.ExceptionAggregator) [/_/src/xunit.execution/Sdk/Frameworks/Runners/XunitTestRunner.cs @ 84]\r\n000000B5ADDBCC50 00007ff83668e74e Xunit.Sdk.XunitTestRunner+d__4.MoveNext() [/_/src/xunit.execution/Sdk/Frameworks/Runners/XunitTestRunner.cs @ 67]\r\n000000B5ADDBCD80 00007ff83668e484 System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.XunitTestRunner+d__4, xunit.execution.dotnet]](d__4 ByRef) [/_/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/AsyncMethodBuilderCore.cs @ 38]\r\n...\r\n```",
                                           "updatedAt":  "2024-04-16T00:57:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56q15W",
                                           "createdAt":  "2024-04-16T00:57:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-04-16T00:57:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6BumHv",
                                           "createdAt":  "2024-06-18T16:07:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffschwMSFT",
                                           "body":  "removing blocking-clean-ci as it has not failed in 30 days\r\n\r\n24-Hour Hit Count | 7-Day Hit Count | 1-Month Count\r\n-- | -- | --\r\n0 | 0 | 0\r\n",
                                           "updatedAt":  "2024-06-18T16:07:48Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "GetLoadLevel() postcondition failure",
        "labels":  [
                       "area-AssemblyLoader-coreclr",
                       "Known Build Error"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/104587",
        "createdAt":  "2024-07-09T04:28:35Z",
        "number":  104587,
        "author":  "yaakov-h",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-29T17:52:26Z",
        "body":  "### Description\n\nI need to remotely administer an IIS server, and Microsoft.Web.Administration is a long-standing solution which manages this via remote COM APIs.\r\n\r\nThe latest versions of Microsoft.Web.Administration ships for .NET Standard, but these builds have the remote-administration code compiled out, and instead just throw a `NullReferenceException` from `ServerManager.OpenRemote`.\r\n\r\nThe older version 7.0 of Microsoft.Web.Administration only ships for .NET Framework 2.0, but it works on .NET 8 if we supply System.Security.Permissions as well via NuGet.\r\n\r\nHowever, the .NET 8 runtime fails to load System.Security.Permissions when operating inside of another AssemblyLoadContext. It only seems to succeed if the entrypoint project is what takes on the package references.\r\n\r\nWhen debugging this the runtime does not even ask for System.Security.Permissions.dll. I cannot find anything from a `dotnet-trace` to explain why it is failing, and procmon64 suggests that the .NET Runtime does not even look for the file on disk, it just aborts early with an exception.\n\n### Reproduction Steps\n\nOn a Windows machine with IIS and the .NET 8 SDK installed:\r\n1. Clone https://github.com/yaakov-h/dotnet-repro-remote-webadmin\r\n2. Create the folder \u0027bin\u0027\r\n3. `cd bin`\r\n4. `.\\repro.ps1` from PowerShell as Administrator (elevated)\n\n### Expected behavior\n\nThe script displays success in all 5 scenarios:\r\n- Initial build, loading using Assembly.Load\r\n- Initial build, loading using AssemblyLoadContext\r\n- Rebuild with additional reference, loading using Assembly.Load\r\n- Rebuild with additional reference, loading using AssemblyLoadContext\r\n- Rebuild with additional reference, loading using Type.GetType()\n\n### Actual behavior\n\nThe first two scenarios fail, the final three pass:\r\n\r\n\u003cdetails\u003e\r\n\r\n```plain\r\nPS\u003e .\\repro.ps1\r\n\r\nBuilding project...\r\n  Determining projects to restore...\r\n  Restored C:\\git\\GitHub\\yaakov-h\\dotnet-repro-remote-webadmin\\PluginHost\\PluginHost.csproj (in 70 ms).\r\n  2 of 3 projects are up-to-date for restore.\r\n  PluginInterfaces -\u003e C:\\git\\GitHub\\yaakov-h\\dotnet-repro-remote-webadmin\\bin\\PluginInterfaces.dll\r\n  RemoteWebAdministrationPlugin -\u003e C:\\git\\GitHub\\yaakov-h\\dotnet-repro-remote-webadmin\\bin\\plugins\\RemoteWebAdministrationPlugin.dll\r\n  PluginHost -\u003e C:\\git\\GitHub\\yaakov-h\\dotnet-repro-remote-webadmin\\bin\\PluginHost.dll\r\n\r\nBuild succeeded.\r\n    0 Warning(s)\r\n    0 Error(s)\r\n\r\nTime Elapsed 00:00:00.84\r\n\r\nRunning with Assembly.Load...\r\nAppDomain.CurrentDomain.AssemblyResolve: Microsoft.Web.Administration, Version=7.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35\r\nAppDomain.CurrentDomain.AssemblyResolve: System.Security.Permissions, Version=0.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51\r\nUnhandled exception. System.IO.FileNotFoundException: Could not load file or assembly \u0027System.Security.Permissions, Version=0.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51\u0027. The system cannot find the file specified.\r\nFile name: \u0027System.Security.Permissions, Version=0.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51\u0027\r\n   at Microsoft.Web.Administration.Configuration.CheckPermissions(IAppHostElement section)\r\n   at Microsoft.Web.Administration.Configuration.GetSectionInternal(ConfigurationSection section, String sectionPath, String locationPath)\r\n   at Microsoft.Web.Administration.Configuration.GetSection(String sectionPath)\r\n   at Microsoft.Web.Administration.ServerManager.get_SitesSection()\r\n   at Microsoft.Web.Administration.ServerManager.get_Sites()\r\n   at RemoteWebAdministrationPlugin.ListRemoteIisSitesPlugin.DoSomething(String[] args) in C:\\git\\GitHub\\yaakov-h\\dotnet-repro-remote-webadmin\\RemoteWebAdministrationPlugin\\ListRemoteIisSitesPlugin.cs:line 19\r\n   at Program.\u003cMain\u003e$(String[] args) in C:\\git\\GitHub\\yaakov-h\\dotnet-repro-remote-webadmin\\PluginHost\\Program.cs:line 53\r\n\r\nRunning with AssemblyLoadContext...\r\nPluginLoadContext.Load: Loading RemoteWebAdministrationPlugin from C:\\git\\GitHub\\yaakov-h\\dotnet-repro-remote-webadmin\\bin\\plugins\\RemoteWebAdministrationPlugin.dll\r\nPluginLoadContext.Load: System.Runtime failed to resolve to path\r\nPluginLoadContext.Load: PluginInterfaces loading from default context.\r\nPluginLoadContext.Load: Loading Microsoft.Web.Administration from C:\\git\\GitHub\\yaakov-h\\dotnet-repro-remote-webadmin\\bin\\plugins\\Microsoft.Web.Administration.dll\r\nPluginLoadContext.Load: mscorlib failed to resolve to path\r\nPluginLoadContext.Load: System.Console failed to resolve to path\r\nPluginLoadContext.Load: System failed to resolve to path\r\nPluginLoadContext.LoadUnmanagedDll: ole32.dll failed to resolve to path\r\nPluginLoadContext.Load: System.Configuration failed to resolve to path\r\nUnhandled exception. System.IO.FileNotFoundException: Could not load file or assembly \u0027System.Security.Permissions, Version=0.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51\u0027. The system cannot find the file specified.\r\nFile name: \u0027System.Security.Permissions, Version=0.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51\u0027\r\n   at Microsoft.Web.Administration.Configuration.CheckPermissions(IAppHostElement section)\r\n   at Microsoft.Web.Administration.Configuration.GetSectionInternal(ConfigurationSection section, String sectionPath, String locationPath)\r\n   at Microsoft.Web.Administration.Configuration.GetSection(String sectionPath)\r\n   at Microsoft.Web.Administration.ServerManager.get_SitesSection()\r\n   at Microsoft.Web.Administration.ServerManager.get_Sites()\r\n   at RemoteWebAdministrationPlugin.ListRemoteIisSitesPlugin.DoSomething(String[] args) in C:\\git\\GitHub\\yaakov-h\\dotnet-repro-remote-webadmin\\RemoteWebAdministrationPlugin\\ListRemoteIisSitesPlugin.cs:line 19\r\n   at Program.\u003cMain\u003e$(String[] args) in C:\\git\\GitHub\\yaakov-h\\dotnet-repro-remote-webadmin\\PluginHost\\Program.cs:line 53\r\n\r\nRebuilding project with ProjectReference...\r\n  Determining projects to restore...\r\n  Restored C:\\git\\GitHub\\yaakov-h\\dotnet-repro-remote-webadmin\\PluginHost\\PluginHost.csproj (in 201 ms).\r\n  2 of 3 projects are up-to-date for restore.\r\n  PluginInterfaces -\u003e C:\\git\\GitHub\\yaakov-h\\dotnet-repro-remote-webadmin\\bin\\PluginInterfaces.dll\r\n  RemoteWebAdministrationPlugin -\u003e C:\\git\\GitHub\\yaakov-h\\dotnet-repro-remote-webadmin\\bin\\plugins\\RemoteWebAdministrationPlugin.dll\r\n  PluginHost -\u003e C:\\git\\GitHub\\yaakov-h\\dotnet-repro-remote-webadmin\\bin\\PluginHost.dll\r\n\r\nBuild succeeded.\r\n    0 Warning(s)\r\n    0 Error(s)\r\n\r\nTime Elapsed 00:00:00.97\r\n\r\nRunning with Assembly.Load...\r\nServer \u00275FKTZT3\u0027 has 5 sites hosted in IIS.\r\n\r\nRunning with AssemblyLoadContext...\r\nPluginLoadContext.Load: Loading RemoteWebAdministrationPlugin from C:\\git\\GitHub\\yaakov-h\\dotnet-repro-remote-webadmin\\bin\\plugins\\RemoteWebAdministrationPlugin.dll\r\nPluginLoadContext.Load: System.Runtime failed to resolve to path\r\nPluginLoadContext.Load: PluginInterfaces loading from default context.\r\nPluginLoadContext.Load: Loading Microsoft.Web.Administration from C:\\git\\GitHub\\yaakov-h\\dotnet-repro-remote-webadmin\\bin\\plugins\\Microsoft.Web.Administration.dll\r\nPluginLoadContext.Load: mscorlib failed to resolve to path\r\nPluginLoadContext.Load: System.Console failed to resolve to path\r\nPluginLoadContext.Load: System failed to resolve to path\r\nPluginLoadContext.LoadUnmanagedDll: ole32.dll failed to resolve to path\r\nPluginLoadContext.Load: System.Configuration failed to resolve to path\r\nServer \u00275FKTZT3\u0027 has 5 sites hosted in IIS.\r\n\r\nRunning with direct Type.GetType...\r\nServer \u00275FKTZT3\u0027 has 5 sites hosted in IIS.\r\n```\r\n\r\n\u003c/details\u003e\n\n### Regression?\n\nThis worked using Assembly.Load in .NET Framework. likely due to System.Security.Permissions being part of the BCL.\n\n### Known Workarounds\n\nAdding a direct reference from the plugin host to the plugin project seems to work as a workaround, though I have absolutely no idea why. This is also not a viable permanent/long term workaround, more of a strange oddity discovered whilst trying to reproduce the issue.\r\n\r\nAdditionally, using `AppDomain.CurrentDomain.AssemblyResolve` hook [as shown here](https://github.com/yaakov-h/dotnet-repro-remote-webadmin/compare/main...workaround) appears to be a workaround, but this seems to break the purpose and spirit of using `AssemblyLoadContext`.\n\n### Configuration\n\n`dotnet --info`:\r\n\r\n\u003cdetails\u003e\r\n\r\n```\r\n.NET SDK:\r\n Version:           8.0.300\r\n Commit:            326f6e68b2\r\n Workload version:  8.0.300-manifests.9e3391ed\r\n MSBuild version:   17.10.4+10fbfbf2e\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.22631\r\n OS Platform: Windows\r\n RID:         win-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\8.0.300\\\r\n\r\n.NET workloads installed:\r\n [maui-windows]\r\n   Installation Source: VS 17.10.34916.146\r\n   Manifest Version:    8.0.21/8.0.100\r\n   Manifest Path:       C:\\Program Files\\dotnet\\sdk-manifests\\8.0.100\\microsoft.net.sdk.maui\\8.0.21\\WorkloadManifest.json\r\n   Install Type:              Msi\r\n\r\n [ios]\r\n   Installation Source: VS 17.10.34916.146\r\n   Manifest Version:    17.2.8053/8.0.100\r\n   Manifest Path:       C:\\Program Files\\dotnet\\sdk-manifests\\8.0.100\\microsoft.net.sdk.ios\\17.2.8053\\WorkloadManifest.json\r\n   Install Type:              Msi\r\n\r\n [maccatalyst]\r\n   Installation Source: VS 17.10.34916.146\r\n   Manifest Version:    17.2.8053/8.0.100\r\n   Manifest Path:       C:\\Program Files\\dotnet\\sdk-manifests\\8.0.100\\microsoft.net.sdk.maccatalyst\\17.2.8053\\WorkloadManifest.json\r\n   Install Type:              Msi\r\n\r\n [aspire]\r\n   Installation Source: VS 17.10.34916.146\r\n   Manifest Version:    8.0.0/8.0.100\r\n   Manifest Path:       C:\\Program Files\\dotnet\\sdk-manifests\\8.0.100\\microsoft.net.sdk.aspire\\8.0.0\\WorkloadManifest.json\r\n   Install Type:              Msi\r\n\r\n [android]\r\n   Installation Source: VS 17.10.34916.146\r\n   Manifest Version:    34.0.95/8.0.100\r\n   Manifest Path:       C:\\Program Files\\dotnet\\sdk-manifests\\8.0.100\\microsoft.net.sdk.android\\34.0.95\\WorkloadManifest.json\r\n   Install Type:              Msi\r\n\r\n\r\nHost:\r\n  Version:      9.0.0-preview.5.24306.7\r\n  Architecture: x64\r\n  Commit:       a5cc707d97\r\n\r\n.NET SDKs installed:\r\n  6.0.321 [C:\\Program Files\\dotnet\\sdk]\r\n  6.0.423 [C:\\Program Files\\dotnet\\sdk]\r\n  7.0.120 [C:\\Program Files\\dotnet\\sdk]\r\n  7.0.317 [C:\\Program Files\\dotnet\\sdk]\r\n  7.0.410 [C:\\Program Files\\dotnet\\sdk]\r\n  8.0.106 [C:\\Program Files\\dotnet\\sdk]\r\n  8.0.300 [C:\\Program Files\\dotnet\\sdk]\r\n  9.0.100-preview.5.24307.3 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET runtimes installed:\r\n  Microsoft.AspNetCore.App 6.0.26 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 6.0.30 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 6.0.31 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 7.0.19 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 7.0.20 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 8.0.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 8.0.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 9.0.0-preview.5.24306.11 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 6.0.26 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 6.0.30 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 6.0.31 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 7.0.19 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 7.0.20 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 8.0.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 8.0.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 9.0.0-preview.5.24306.7 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.WindowsDesktop.App 6.0.26 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 6.0.30 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 6.0.31 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 7.0.19 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 7.0.20 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 8.0.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 8.0.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 9.0.0-preview.5.24306.8 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n\r\nOther architectures found:\r\n  x86   [C:\\Program Files (x86)\\dotnet]\r\n    registered at [HKLM\\SOFTWARE\\dotnet\\Setup\\InstalledVersions\\x86\\InstallLocation]\r\n\r\nEnvironment variables:\r\n  Not set\r\n\r\nglobal.json file:\r\n  C:\\git\\GitHub\\yaakov-h\\dotnet-repro-remote-webadmin\\global.json\r\n\r\nLearn more:\r\n  https://aka.ms/dotnet/info\r\n\r\nDownload .NET:\r\n  https://aka.ms/dotnet/download\r\n```\r\n\u003c/details\u003e\r\n\r\nN.B. this also fails on machines w/o .NET 9 previews.\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOpi_BpQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6EHSzU",
                                           "createdAt":  "2024-07-09T04:45:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "How about registering `AssemblyLoadContext.Resolving` event?\r\n\r\nSharing the file layout may help diagnosing the issue.",
                                           "updatedAt":  "2024-07-09T04:45:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6EHYGO",
                                           "createdAt":  "2024-07-09T05:00:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "yaakov-h",
                                           "body":  "@huoyaoyuan that doesn\u0027t seem to affect it, I\u0027ve tried using `Load(name)` and `Assembly.LoadFrom(..)` in that event and neither seem to have any effect.\r\n\r\nFor the file layout, in this repro:\r\n\r\n```text\r\nC:\\GIT\\GITHUB\\YAAKOV-H\\DOTNET-REPRO-REMOTE-WEBADMIN\\BIN\r\n│   PluginHost.deps.json\r\n│   PluginHost.dll\r\n│   PluginHost.exe\r\n│   PluginHost.pdb\r\n│   PluginHost.runtimeconfig.json\r\n│   PluginInterfaces.deps.json\r\n│   PluginInterfaces.dll\r\n│   PluginInterfaces.pdb\r\n│\r\n└───plugins\r\n    │   Microsoft.Web.Administration.dll\r\n    │   PluginInterfaces.dll\r\n    │   PluginInterfaces.pdb\r\n    │   RemoteWebAdministrationPlugin.deps.json\r\n    │   RemoteWebAdministrationPlugin.dll\r\n    │   RemoteWebAdministrationPlugin.pdb\r\n    │   RemoteWebAdministrationPlugin.runtimeconfig.json\r\n    │   System.Security.Permissions.dll\r\n    │   System.Windows.Extensions.dll\r\n    │\r\n    └───runtimes\r\n        └───win\r\n            └───lib\r\n                └───net8.0\r\n                        System.Windows.Extensions.dll\r\n```\r\n\r\nIn the real project, the plugin dir is not a subdir of the host program.\r\n\r\n",
                                           "updatedAt":  "2024-07-09T05:01:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6EHYz-",
                                           "createdAt":  "2024-07-09T05:03:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "\u003e I\u0027ve tried using `Load(name)` and `Assembly.LoadFrom(..)` in that event and neither seem to have any effect.\r\n\r\nI believe `AssemblyLoadContext.LoadFromAssemblyPath` is the correct method - loading the assembly from given file, into the given ALC.",
                                           "updatedAt":  "2024-07-09T05:03:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6EHZUM",
                                           "createdAt":  "2024-07-09T05:04:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "yaakov-h",
                                           "body":  "Looking over the output, the `Resolving` event doesn\u0027t even get called in the first place.\r\n\r\n![image](https://github.com/dotnet/runtime/assets/426009/6098c950-6f8f-47f8-b465-3082ad4719c1)\r\n",
                                           "updatedAt":  "2024-07-09T05:04:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6EHxAA",
                                           "createdAt":  "2024-07-09T05:47:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "yaakov-h",
                                           "body":  "This also seems to affect loading `System.ServiceProcess.ServiceController` when touching the Application Pool APIs.",
                                           "updatedAt":  "2024-07-09T05:47:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ETqAT",
                                           "createdAt":  "2024-07-10T07:20:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "yaakov-h",
                                           "body":  "I still don\u0027t understand why this is happening the way that it is, but as someone trying very explicitly to load a .NET Framework into .NET 8 this is the only workaround that seems to do the trick:\r\n\r\n```csharp\r\nstatic MyPlugin()\r\n{\r\n    AppDomain.CurrentDomain.AssemblyResolve += (sender, e) =\u003e\r\n    {\r\n        if (e.Name.StartsWith(\"System.Security.Permissions,\", StringComparison.Ordinal) || e.Name.StartsWith(\"System.ServiceProcess.ServiceController,\", StringComparison.Ordinal))\r\n        {\r\n            var myPath = Path.GetDirectoryName(typeof(MyPlugin).Assembly.Location)!;\r\n            var assemblyPath = Path.Combine(myPath, new AssemblyName(e.Name).Name + \".dll\");\r\n            return Assembly.LoadFrom(assemblyPath);\r\n        }\r\n        return null;\r\n    };\r\n}\r\n```",
                                           "updatedAt":  "2024-07-10T07:20:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GojQ0",
                                           "createdAt":  "2024-07-30T16:42:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "agocke",
                                           "body":  "Hmm, not aware of any known issue that prevents this.\n\n@elinor-fung any ideas?",
                                           "updatedAt":  "2024-07-30T16:42:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mL8Gl",
                                           "createdAt":  "2025-04-09T02:47:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "elinor-fung",
                                           "body":  "Sorry for the late response (completely missed the original notification)\n\nThis looks related to facade/shim assemblies - in this case, specifically `System.Configuration`.\n\nBasic version of what seems to be happening in the `AssemblyLoadContext.LoadFromAssemblyName` scenario:\n1. `Microsoft.Web.Administration` is loaded in `PluginLoadContext` (found via `AssemblyDependencyResolver`)\n2. `Microsoft.Web.Administration` triggers a request to load `System.Configuration`\n    - It is not resolved in the `PluginLoadContext`, so falls back to the `Default` context per the [loading algorithm](https://learn.microsoft.com/dotnet/core/dependency-loading/loading-managed#algorithm)\n3. `System.Configuration` is loaded in `AssemblyLoadContext.Default`\n4. `System.Configuration` triggers a request to load `System.Security.Permissions`\n    - Since `System.Configuration` is in the `Default` context, `PluginLoadContext.Load` is not involved\n5. Error because `System.Security.Permissions` cannot be found\n\nIn the `Assembly.LoadFrom` scenario, these are all happening in the `Default` ALC.\n\nBy either building the app with a direct dependency on `System.Security.Permissions` or registering a handler for `AppDomain.CurrentDomain.AssemblyResolve` (same for `AssemblyLoadContext.Default.Resolving`), the default ALC is able to find `System.Security.Permissions`, so (4) succeeds and there is no error.\n\nWhen a plugin is being loaded in the default ALC, I think it is reasonable to expect having to handle any dependencies it has (that the app does not) via `AssemblyLoadContext.Default.Resolving` and `AssemblyDependencyResolver`.\n\nI think the complication here with loading a plugin in a custom ALC is that the shim assemblies (like `System.Configuration`) are part of runtime libraries, so they will normally be loaded in the default ALC. The assemblies they forward to (like `System.Security.Permissions`) are then also expected to load in the default ALC. I think you could explicitly load those shim assemblies in the custom ALC instead, but I\u0027m not sure if there are hidden complications there.\n\n@ViktorHofer @ericstj Have you seen issues like this with folks trying to rely on facade assemblies in a non-default ALC before? Do we have a general recommendation around the runtime facade assemblies and different ALCs?",
                                           "updatedAt":  "2025-04-09T02:47:35Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  ".NET 8 fails to load System.Security.Permissions when dynamically loading plugin that references Framework",
        "labels":  [
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/104590",
        "createdAt":  "2024-07-09T04:48:30Z",
        "number":  104590,
        "author":  "elinor-fung",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC7AW7A==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "am11",
                                            "createdAt":  "2024-07-09T05:23:45Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AustinWise",
                                            "createdAt":  "2024-08-02T23:32:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2024-09-12T10:14:00Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "lambdageek",
                                            "createdAt":  "2024-09-13T16:58:27Z"
                                        }
                                    ],
                          "totalCount":  4
                      },
        "updatedAt":  "2024-10-10T21:22:43Z",
        "body":  "`DomainAssembly` represented an assembly loaded (or being loaded) into a particular app domain - that is, there was a unique `DomainAssembly` per assembly per app domain. In our one app domain world, `DomainAssembly` versus `Assembly` is a confusing abstraction. We should move things off of `DomainAssembly` and eventually remove it.\r\n\r\nSome things it currently handles:\r\n- Exposed managed object for `Assembly` and `Module` - should be able to move to `Assembly`/`Module`\r\n- Associated with `AssemblyObject` - can probably become `Assembly` \r\n- `FileLoadLevel`, incremental loading based on level, and associated tracking/checks - maybe this - just load tracking - is what it becomes (renamed) or maybe collapse into `Assembly`\r\n- Determining `DebuggerAssemblyControlFlags` for the assembly/module\r\n- Used as main representation of a module in internal debug interfaces\r\n- Tracking of collectible assemblies in the same ALC",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOhB03YA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6EHTdg",
                                           "createdAt":  "2024-07-09T04:48:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-07-09T04:48:45Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Remove `DomainAssembly` concept",
        "labels":  [
                       "area-AssemblyLoader-coreclr",
                       "in-pr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/104670",
        "createdAt":  "2024-07-10T11:13:01Z",
        "number":  104670,
        "author":  "jakobbotsch",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-20T03:01:46Z",
        "body":  "## Build Information\r\nBuild: https://dev.azure.com/dnceng-public/cbb18261-c48f-4abb-8651-8cdcb5474649/_build/results?buildId=735589\r\nBuild error leg or test failing: Loader/binding/tracing/BinderTracingTest.ResolutionFlow/BinderTracingTest.ResolutionFlow.cmd\r\nPull request: https://github.com/dotnet/runtime/pull/104603\r\n\u003c!-- Error message template  --\u003e\r\n## Error Message\r\n\r\nFill the error message using [step by step known issues guidance](https://github.com/dotnet/arcade/blob/main/Documentation/Projects/Build%20Analysis/KnownIssueJsonStepByStep.md).\r\n\r\n\u003c!-- Use ErrorMessage for String.Contains matches. Use ErrorPattern for regex matches (single line/no backtracking). Set BuildRetry to `true` to retry builds with this error. Set ExcludeConsoleLog to `true` to skip helix logs analysis. --\u003e\r\n\r\n```json\r\n{\r\n  \"ErrorMessage\": \"\",\r\n  \"ErrorPattern\": \"BinderTracingTest.ResolutionFlow.* Timed Out\",\r\n  \"BuildRetry\": false,\r\n  \"ExcludeConsoleLog\": false\r\n}\r\n```\r\n\r\n\r\n\u003c!-- Known issue validation start --\u003e\r\n ### Known issue validation\r\n**Build: :mag_right:** https://dev.azure.com/dnceng-public/public/_build/results?buildId=735589\r\n**Error message validated:** `[BinderTracingTest.ResolutionFlow.* Timed Out`]\r\n**Result validation:** :white_check_mark: Known issue matched with the provided build.\r\n**Validation performed at:** 7/10/2024 11:13:33 AM UTC\r\n\u003c!-- Known issue validation end --\u003e\r\n\u003c!--Known issue error report start --\u003e\r\n\r\n### Report\r\n\r\n|Build|Definition|Test|Pull Request|\r\n|---|---|---|---|\r\n|[1150240](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1150240)|dotnet/runtime|[Loader/binding/tracing/BinderTracingTest.ResolutionFlow/BinderTracingTest.ResolutionFlow.cmd](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1150240\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31774718\u0026resultId=117421)|dotnet/runtime#118804|\r\n|[1149887](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1149887)|dotnet/runtime|[Loader/binding/tracing/BinderTracingTest.ResolutionFlow/BinderTracingTest.ResolutionFlow.cmd](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1149887\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31763134\u0026resultId=117421)||\r\n|[1149230](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1149230)|dotnet/runtime|[Loader/binding/tracing/BinderTracingTest.ResolutionFlow/BinderTracingTest.ResolutionFlow.cmd](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1149230\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31743966\u0026resultId=117434)|dotnet/runtime#119743|\r\n|[1138729](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1138729)|dotnet/runtime|[Loader/binding/tracing/BinderTracingTest.ResolutionFlow/BinderTracingTest.ResolutionFlow.cmd](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1138729\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31369128\u0026resultId=117421)|dotnet/runtime#119336|\r\n|[1129153](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1129153)|dotnet/runtime|[Loader/binding/tracing/BinderTracingTest.ResolutionFlow/BinderTracingTest.ResolutionFlow.cmd](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1129153\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31057680\u0026resultId=117419)|dotnet/runtime#118968|\r\n#### Summary\r\n|24-Hour Hit Count|7-Day Hit Count|1-Month Count|\r\n|---|---|---|\r\n|0|3|5|\r\n\u003c!--Known issue error report end --\u003e",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOwIWAJw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6EViPu",
                                           "createdAt":  "2024-07-10T11:13:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-infrastructure-libraries\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-07-10T11:13:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6EViZj",
                                           "createdAt":  "2024-07-10T11:13:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jakobbotsch",
                                           "body":  "cc @davmason ",
                                           "updatedAt":  "2024-07-10T11:13:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6E3dUu",
                                           "createdAt":  "2024-07-15T18:29:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mdh1418",
                                           "body":  "This seems to be a continuation of https://github.com/dotnet/runtime/issues/97735 and https://github.com/dotnet/runtime/issues/94390. Given that the BinderTracingTests are already skipped for [Jitstress](https://github.com/dotnet/runtime/pull/102842) and [GCStress](https://github.com/dotnet/runtime/pull/100798), there is probably another culprit for these tests timing out.\r\n\r\nIt seems flakey given the low hit count, and that previous counterpart #97735 at one point had 0 hit counts in 30 days.\r\n\r\nI haven\u0027t been able to repro the timeout locally, and given how flakey it is on CI, I\u0027m not sure if I\u0027d be able to reliably repro in CI. From this build instance it seems like this is causing the hang\r\nhttps://github.com/dotnet/runtime/blob/ad25cd0126a8d4a060f2039f987bd58e7ca56a1d/src/tests/Loader/binding/tracing/BinderTracingTest.cs#L206\r\nbased off of \r\n```\r\n0:000\u003e !clrstack -f -all\r\nOS Thread Id: 0x23ec\r\nChild SP       IP Call Site\r\n0097E0EC 77B3F3EC ntdll!NtWaitForMultipleObjects + 12\r\n0097E284 72246A85 coreclr!Thread::DoAppropriateAptStateWait + 199\r\n0097E308 72246FB3 coreclr!Thread::DoAppropriateWaitWorker + 998\r\n0097E464 7224D4AD coreclr!`Thread::DoAppropriateWait\u0027::`9\u0027::__Body::Run + 90\r\n0097E4B8 72246B3C coreclr!Thread::DoAppropriateWait + 149\r\n0097E51C 722BEC16 coreclr!WaitHandleNative::CorWaitOneNative + 294\r\n0097E560          [HelperMethodFrame: 0097e560] System.Private.CoreLib.dll!System.Threading.WaitHandle.WaitOneCore(IntPtr, Int32, Boolean)\r\n0097E5F4 71022A5C System_Private_CoreLib!System.Boolean System.Threading.WaitHandle::WaitOneNoCheck(System.Int32, System.Boolean, System.Object, System.Diagnostics.Tracing.NativeRuntimeEventSource+WaitHandleWaitSourceMap)$##6003CB2 + 188\r\n0097E5F8 71022A5C System.Private.CoreLib.dll!System.Threading.WaitHandle.WaitOneNoCheck(Int32, Boolean, System.Object, WaitHandleWaitSourceMap) + 188\r\n0097E630 71022984 System_Private_CoreLib!System.Boolean System.Threading.WaitHandle::WaitOne(System.Int32)$##6003CB1 + 20\r\n0097E63C 71022984 System.Private.CoreLib.dll!System.Threading.WaitHandle.WaitOne(Int32) + 20\r\n0097E644 094C5B7B system.diagnostics.process.dll!System.Diagnostics.Process.WaitForExitCore(Int32) + 123\r\n0097E67C 094C0800 BinderTracingTest.ResolutionFlow.dll!BinderTracingTests.BinderTracingTest.RunTestInSeparateProcess(System.Reflection.MethodInfo) + 816\r\n0097E6DC 0817237E BinderTracingTest.ResolutionFlow.dll!BinderTracingTests.BinderTracingTest.RunAllTests() + 446\r\n0097E704 0817204F BinderTracingTest.ResolutionFlow.dll!BinderTracingTests.BinderTracingTest.Main(System.String[]) + 39\r\n```\r\n\r\n\r\nFrom looking at what BinderTracingTests does, I\u0027m not quite sure what is causing the separate subprocess to hang. Given how this test is still hanging even without GCStress/Jitstress, I would\u0027ve expected for the test to hit the BinderEventListener\u0027s 30s timeout at https://github.com/dotnet/runtime/blob/ad25cd0126a8d4a060f2039f987bd58e7ca56a1d/src/tests/Loader/binding/tracing/BinderEventListener.cs#L177-L178 if the test made it to https://github.com/dotnet/runtime/blob/ad25cd0126a8d4a060f2039f987bd58e7ca56a1d/src/tests/Loader/binding/tracing/BinderTracingTest.cs#L176\r\n\r\n@elinor-fung / @davmason  any other ideas on what might be causing the hang?",
                                           "updatedAt":  "2024-07-15T18:30:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6G7xL0",
                                           "createdAt":  "2024-08-01T19:29:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mdh1418",
                                           "body":  "762118 was from a PR that caused a deadlock, so it isn\u0027t the same cause as the first singluar hit in 735589",
                                           "updatedAt":  "2024-08-01T19:29:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6HOzm7",
                                           "createdAt":  "2024-08-05T11:05:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jakobbotsch",
                                           "body":  "Hit in https://dev.azure.com/dnceng-public/public/_build/results?buildId=765128\u0026view=results",
                                           "updatedAt":  "2024-08-05T11:05:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6HRJwz",
                                           "createdAt":  "2024-08-05T16:05:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODs4_7g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tommcdon",
                                                                               "createdAt":  "2024-08-05T22:19:03Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "mdh1418",
                                           "body":  "\u003e Hit in https://dev.azure.com/dnceng-public/public/_build/results?buildId=765128\u0026view=results\r\n\r\nIsn\u0027t that a jitstress pipeline? Why did the test get run there if it was marked JitOptimizationSensitive=true in https://github.com/dotnet/runtime/pull/102842?\r\n\r\nIn any case, the latest failure [console log](https://gist.github.com/mdh1418/7bb515b3273083e068a4cdb9a085cfc1) shows a hang presumable when waiting for this test https://github.com/dotnet/runtime/blob/ab03e0ffc0281c55cbe4ee02f025591f2fe4bf39/src/tests/Loader/binding/tracing/BinderTracingTest.ResolutionFlow.cs#L131 to [finish running as a separate process](https://github.com/dotnet/runtime/blob/ab03e0ffc0281c55cbe4ee02f025591f2fe4bf39/src/tests/Loader/binding/tracing/BinderTracingTest.cs#L209) (since the tests seem to be ran sequentially + `FindInLoadContext_DefaultALC_IncompatibleVersion` finished + the stack trace has `system.diagnostics.process.dll!System.Diagnostics.Process.WaitForExitCore`).\r\n\r\nI guess the console.writelines from a subprocess don\u0027t actually get written immediately, given that we don\u0027t see either of these https://github.com/dotnet/runtime/blob/ab03e0ffc0281c55cbe4ee02f025591f2fe4bf39/src/tests/Loader/binding/tracing/BinderTracingTest.cs#L199-L202 given that the test hangs afterwards.\r\n\r\nAlso the subprocess dump doesn\u0027t get generated even though we are expecting to [create a dump for all processes related to corerun](https://github.com/dotnet/runtime/blob/ab03e0ffc0281c55cbe4ee02f025591f2fe4bf39/src/tests/Common/Coreclr.TestWrapper/CoreclrTestWrapperLib.cs#L792-L803).\r\n\r\n@hoyosjs any ideas on what to tweak to be able to capture the dump for the hanging subprocess in this case?",
                                           "updatedAt":  "2024-08-05T16:05:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6HRQm_",
                                           "createdAt":  "2024-08-05T16:20:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODs2wQw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "mdh1418",
                                                                               "createdAt":  "2024-08-05T16:23:27Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jakobbotsch",
                                           "body":  "\u003e \u003e Hit in https://dev.azure.com/dnceng-public/public/_build/results?buildId=765128\u0026view=results\r\n\u003e \r\n\u003e Isn\u0027t that a jitstress pipeline? Why did the test get run there if it was marked JitOptimizationSensitive=true in #102842?\r\n\r\nThe jitstress pipelines runs tests under many different configurations. This particular configuration does not set any of the \"jitstress\" environment variables, it only sets the following:\r\n```\r\nset DOTNET_TieredCompilation=0\r\nset DOTNET_EnableAVX=0\r\n```",
                                           "updatedAt":  "2024-08-05T16:20:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6UMOdt",
                                           "createdAt":  "2024-11-19T16:46:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mdh1418",
                                           "body":  "From the latest failure\u0027s console log, the test spins up a subprocess with PID 920\n```\n09:26:42.243 Running test: Loader/binding/tracing/BinderTracingTest.ResolutionFlow/BinderTracingTest.ResolutionFlow.cmd\nAttempting to collect crash dump: C:\\cores\\crashdump_3068.dmp\nCollected crash dump: C:\\cores\\crashdump_3068.dmp\n\n\n\n\n\ncmdLine:C:\\h\\w\\A46C08CB\\w\\BB700A39\\e\\Loader\\Loader\\../binding/tracing/BinderTracingTest.ResolutionFlow/BinderTracingTest.ResolutionFlow.cmd Timed Out (timeout in milliseconds: 600000 from variable __TestTimeout, start: 11/14/2024 9:26:42 AM, end: 11/14/2024 9:36:42 AM)\n\nReturn code:      -100\nRaw output file:      C:\\h\\w\\A46C08CB\\w\\BB700A39\\uploads\\binding\\tracing\\BinderTracingTest.ResolutionFlow\\output.txt\nRaw output:\nBEGIN EXECUTION\n \"C:\\h\\w\\A46C08CB\\p\\corerun.exe\" -p \"System.Reflection.Metadata.MetadataUpdater.IsSupported=false\" -p \"System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization=true\"  BinderTracingTest.ResolutionFlow.dll \n[9:26:43 AM] Running AssemblyLoadContextResolving_ReturnNull...\n[9:26:44 AM] Invoking AssemblyLoadContextResolving_ReturnNull...\n[9:26:44 AM] Validating bind operation for AssemblyToLoad_Subdirectory...\nWaiting for bind events for AssemblyToLoad_Subdirectory (0ms waited) Sleeping for 50ms\nWaiting for bind events for AssemblyToLoad_Subdirectory (50ms waited) Sleeping for 50ms\nValidateBindOperation Started\nValidateBindOperation Finished\nTest AssemblyLoadContextResolving_ReturnNull finished.\n[9:26:45 AM] Running AssemblyLoadContextResolving_LoadAssembly...\n[9:26:45 AM] Invoking AssemblyLoadContextResolving_LoadAssembly...\n[9:26:45 AM] Validating bind operation for AssemblyToLoad_Subdirectory...\nWaiting for bind events for AssemblyToLoad_Subdirectory (0ms waited) Sleeping for 50ms\nValidateBindOperation Started\nValidateBindOperation Started\nValidateBindOperation Finished\nValidateBindOperation Finished\nTest AssemblyLoadContextResolving_LoadAssembly finished.\n[9:26:45 AM] Running AssemblyLoadContextResolving_NameMismatch...\n[9:26:45 AM] Invoking AssemblyLoadContextResolving_NameMismatch...\n[9:26:45 AM] Validating bind operation for AssemblyToLoad_Subdirectory...\nWaiting for bind events for AssemblyToLoad_Subdirectory (0ms waited) Sleeping for 50ms\nValidateBindOperation Started\nValidateBindOperation Started\nValidateBindOperation Finished\nValidateBindOperation Finished\nTest AssemblyLoadContextResolving_NameMismatch finished.\n[9:26:45 AM] Running AssemblyLoadContextResolving_MultipleHandlers...\n[9:26:45 AM] Invoking AssemblyLoadContextResolving_MultipleHandlers...\n[9:26:45 AM] Validating bind operation for AssemblyToLoad_Subdirectory...\nValidateBindOperation Started\nValidateBindOperation Started\nValidateBindOperation Finished\nValidateBindOperation Finished\nTest AssemblyLoadContextResolving_MultipleHandlers finished.\n[9:26:45 AM] Running AppDomainAssemblyResolve_ReturnNull...\n[9:26:45 AM] Invoking AppDomainAssemblyResolve_ReturnNull...\n[9:26:45 AM] Validating bind operation for AssemblyToLoad_Subdirectory...\nWaiting for bind events for AssemblyToLoad_Subdirectory (0ms waited) Sleeping for 50ms\nValidateBindOperation Started\nValidateBindOperation Finished\nTest AppDomainAssemblyResolve_ReturnNull finished.\n[9:26:45 AM] Running AppDomainAssemblyResolve_LoadAssembly...\n[9:26:45 AM] Invoking AppDomainAssemblyResolve_LoadAssembly...\n[9:26:45 AM] Validating bind operation for AssemblyToLoad_Subdirectory...\nWaiting for bind events for AssemblyToLoad_Subdirectory (0ms waited) Sleeping for 50ms\nValidateBindOperation Started\nValidateBindOperation Started\nValidateBindOperation Finished\nValidateBindOperation Finished\nTest AppDomainAssemblyResolve_LoadAssembly finished.\n[9:26:45 AM] Running AppDomainAssemblyResolve_NameMismatch...\n[9:26:45 AM] Invoking AppDomainAssemblyResolve_NameMismatch...\n[9:26:45 AM] Validating bind operation for AssemblyToLoad_Subdirectory...\nWaiting for bind events for AssemblyToLoad_Subdirectory (0ms waited) Sleeping for 50ms\nValidateBindOperation Started\nValidateBindOperation Started\nValidateBindOperation Finished\nValidateBindOperation Finished\nTest AppDomainAssemblyResolve_NameMismatch finished.\n[9:26:45 AM] Running AppDomainAssemblyResolve_MultipleHandlers...\n[9:26:45 AM] Invoking AppDomainAssemblyResolve_MultipleHandlers...\n[9:26:45 AM] Validating bind operation for AssemblyToLoad_Subdirectory...\nWaiting for bind events for AssemblyToLoad_Subdirectory (0ms waited) Sleeping for 50ms\nValidateBindOperation Started\nValidateBindOperation Started\nValidateBindOperation Finished\nValidateBindOperation Finished\nTest AppDomainAssemblyResolve_MultipleHandlers finished.\n[9:26:45 AM] Launching process for AssemblyLoadFromResolveHandler_LoadDependency...\nStarted subprocess 4652 for AssemblyLoadFromResolveHandler_LoadDependency...\n[9:26:47 AM] Running AssemblyLoadFromResolveHandler_LoadDependency...\n[9:26:47 AM] Invoking AssemblyLoadFromResolveHandler_LoadDependency...\n[9:26:48 AM] Validating bind operation for AssemblyToLoadDependency, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null...\nWaiting for bind events for AssemblyToLoadDependency (0ms waited) Sleeping for 50ms\nValidateBindOperation Started\nValidateBindOperation Finished\nTest AssemblyLoadFromResolveHandler_LoadDependency finished.\n\n[9:26:48 AM] Launching process for AssemblyLoadFromResolveHandler_NotTracked...\nStarted subprocess 3304 for AssemblyLoadFromResolveHandler_NotTracked...\n[9:26:49 AM] Running AssemblyLoadFromResolveHandler_NotTracked...\n[9:26:50 AM] Invoking AssemblyLoadFromResolveHandler_NotTracked...\n[9:26:50 AM] Validating bind operation for AssemblyToLoad_Subdirectory...\nWaiting for bind events for AssemblyToLoad_Subdirectory (0ms waited) Sleeping for 50ms\nWaiting for bind events for AssemblyToLoad_Subdirectory (50ms waited) Sleeping for 50ms\nValidateBindOperation Started\nValidateBindOperation Finished\nTest AssemblyLoadFromResolveHandler_NotTracked finished.\n\n[9:26:50 AM] Launching process for FindInLoadContext_CustomALC...\nStarted subprocess 1776 for FindInLoadContext_CustomALC...\n[9:26:51 AM] Running FindInLoadContext_CustomALC...\n[9:26:52 AM] Invoking FindInLoadContext_CustomALC...\n[9:26:52 AM] Validating bind operation for AssemblyToLoad_Subdirectory...\nWaiting for bind events for AssemblyToLoad_Subdirectory (0ms waited) Sleeping for 50ms\nValidateBindOperation Started\nValidateBindOperation Finished\nTest FindInLoadContext_CustomALC finished.\n\n[9:26:53 AM] Launching process for FindInLoadContext_DefaultALC...\nStarted subprocess 5352 for FindInLoadContext_DefaultALC...\n[9:26:54 AM] Running FindInLoadContext_DefaultALC...\n[9:26:55 AM] Invoking FindInLoadContext_DefaultALC...\n[9:26:55 AM] Validating bind operation for AssemblyToLoad...\nWaiting for bind events for AssemblyToLoad (0ms waited) Sleeping for 50ms\nWaiting for bind events for AssemblyToLoad (50ms waited) Sleeping for 50ms\nValidateBindOperation Started\nValidateBindOperation Finished\nTest FindInLoadContext_DefaultALC finished.\n\n[9:26:56 AM] Launching process for FindInLoadContext_DefaultALC_IncompatibleVersion...\nStarted subprocess 920 for FindInLoadContext_DefaultALC_IncompatibleVersion...\n[9:26:57 AM] Running FindInLoadContext_DefaultALC_IncompatibleVersion...\n[9:26:58 AM] Invoking FindInLoadContext_DefaultALC_IncompatibleVersion...\n[9:26:58 AM] Validating bind operation for AssemblyToLoad, Version=4.3.2.1...\nWaiting for bind events for AssemblyToLoad (0ms waited) Sleeping for 50ms\nValidateBindOperation Started\nValidateBindOperation Finished\nTest FindInLoadContext_DefaultALC_IncompatibleVersion finished.\n\ncmdLine:C:\\h\\w\\A46C08CB\\w\\BB700A39\\e\\Loader\\Loader\\../binding/tracing/BinderTracingTest.ResolutionFlow/BinderTracingTest.ResolutionFlow.cmd Timed Out (timeout in milliseconds: 600000 from variable __TestTimeout, start: 11/14/2024 9:26:42 AM, end: 11/14/2024 9:36:42 AM)\nInvoking: C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x64\\cdb.exe -c \"$\u003cC:\\h\\w\\A46C08CB\\t\\tmppytb12.tmp\" -z \"C:\\cores\\crashdump_3068.dmp\"\n```\nand that subprocess appears to complete `RunSingleTest` based on `Test FindInLoadContext_DefaultALC_IncompatibleVersion finished.` \nhttps://github.com/dotnet/runtime/blob/e3b3aaaf21b88b7992cd8a42321e01cf1aa704a2/src/tests/Loader/binding/tracing/BinderTracingTest.cs#L186\n\nMoreover, at the end of the console log, there is \n```\n[XUnitLogChecker]: 09:39:44.85: The full run will be done.\n[XUnitLogChecker]: 09:39:44.85: Item \u0027Loader\u0027 did complete successfully!\nERROR: The process \"corerun.exe\" with PID 920 could not be terminated.\nReason: There is no running instance of the task.\n```\n\nCould this be a bug with [Process.WaitForExit()](https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.process.waitforexit?view=net-8.0) where the subprocess fails to signal to the parent process that it finished? In any case, its not apparent to me that this is a tracing issue. Its odd that our [logic to collect dumps from all childprocesses](https://github.com/dotnet/runtime/blob/e3b3aaaf21b88b7992cd8a42321e01cf1aa704a2/src/tests/Common/Coreclr.TestWrapper/CoreclrTestWrapperLib.cs#L795-L806) isn\u0027t generating a dump for the PID 920 that the test is supposedly stuck on. Until we collect a crashdump from the child process that the test is stuck on, it\u0027ll be hard to figure out what is causing the test to hang.",
                                           "updatedAt":  "2024-11-19T17:26:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6UMQCR",
                                           "createdAt":  "2024-11-19T16:49:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-diagnostics-process\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-11-19T16:49:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6iluCo",
                                           "createdAt":  "2025-03-17T01:22:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "v-wenyuxu",
                                           "body":  "**Failed in:** [runtime-coreclr jitstress-isas-x86 20250315.1](https://dev.azure.com/dnceng-public/public/_build/results?buildId=981786\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=26186684\u0026resultId=122305\u0026paneView=debug)\n\n**Failed tests:**\n```\ncoreclr windows x64 Checked jitstress_isas_x86_noavx @ Windows.10.Amd64.Open\n    - Loader/binding/tracing/BinderTracingTest.ResolutionFlow/BinderTracingTest.ResolutionFlow.cmd\n```\n\n**Error message:**\n```\n \n\n\ncmdLine:C:hwA50B088FwA6100976eLoaderLoader../binding/tracing/BinderTracingTest.ResolutionFlow/BinderTracingTest.ResolutionFlow.cmd Timed Out (timeout in milliseconds: 1800000 from variable __TestTimeout, start: 3/15/2025 11:38:42 PM, end: 3/16/2025 12:08:42 AM)\n\nReturn code:      -100\nRaw output file:      C:hwA50B088FwA6100976uploads\binding\tracingBinderTracingTest.ResolutionFlowoutput.txt\nRaw output:\nBEGIN EXECUTION\n \"C:hwA50B088Fpcorerun.exe\" -p \"System.Reflection.Metadata.MetadataUpdater.IsSupported=false\" -p \"System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization=true\"  BinderTracingTest.ResolutionFlow.dll \n[11:38:44 PM] Running AssemblyLoadContextResolving_ReturnNull...\n[11:38:44 PM] Invoking AssemblyLoadContextResolving_ReturnNull...\n[11:38:45 PM] Validating bind operation for AssemblyToLoad_Subdirectory...\nWaiting for bind events for AssemblyToLoad_Subdirectory (0ms waited) Sleeping for 50ms\nValidateBindOperation Started\nValidateBindOperation Finished\nTest AssemblyLoadContextResolving_ReturnNull finished.\n[11:38:45 PM] Running AssemblyLoadContextResolving_LoadAssembly...\n[11:38:45 PM] Invoking AssemblyLoadContextResolving_LoadAssembly...\n[11:38:45 PM] Validating bind operation for AssemblyToLoad_Subdirectory...\nWaiting for bind events for AssemblyToLoad_Subdirectory (0ms waited) Sleeping for 50ms\nValidateBindOperation Started\nValidateBindOperation Started\nValidateBindOperation Finished\nValidateBindOperation Finished\nTest AssemblyLoadContextResolving_LoadAssembly finished.\n[11:38:45 PM] Running AssemblyLoadContextResolving_NameMismatch...\n[11:38:45 PM] Invoking AssemblyLoadContextResolving_NameMismatch...\n[11:38:45 PM] Validating bind operation for AssemblyToLoad_Subdirectory...\nWaiting for bind events for AssemblyToLoad_Subdirectory (0ms waited) Sleeping for 50ms\nValidateBindOperation Started\nValidateBindOperation Started\nValidateBindOperation Finished\nValidateBindOperation Finished\nTest AssemblyLoadContextResolving_NameMismatch finished.\n[11:38:45 PM] Running AssemblyLoadContextResolving_MultipleHandlers...\n[11:38:45 PM] Invoking AssemblyLoadContextResolving_MultipleHandlers...\n[11:38:45 PM] Validating bind operation for AssemblyToLoad_Subdirectory...\nValidateBindOperation Started\nValidateBindOperation Started\nValidateBindOperation Finished\nValidateBindOperation Finished\nTest AssemblyLoadContextResolving_MultipleHandlers finished.\n[11:38:45 PM] Running AppDomainAssemblyResolve_ReturnNull...\n[11:38:45 PM] Invoking AppDomainAssemblyResolve_ReturnNull...\n[11:38:45 PM] Validating bind operation for AssemblyToLoad_Subdirectory...\nWaiting for bind events for AssemblyToLoad_Subdirectory (0ms waited) Sleeping for 50ms\nValidateBindOperation Started\nValidateBindOperation Finished\nTest AppDomainAssemblyResolve_ReturnNull finished.\n[11:38:45 PM] Running AppDomainAssemblyResolve_LoadAssembly...\n[11:38:45 PM] Invoking AppDomainAssemblyResolve_LoadAssembly...\n[11:38:45 PM] Validating bind operation for AssemblyToLoad_Subdirectory...\nWaiting for bind events for AssemblyToLoad_Subdirectory (0ms waited) Sleeping for 50ms\nValidateBindOperation Started\nValidateBindOperation Started\nValidateBindOperation Finished\nValidateBindOperation Finished\nTest AppDomainAssemblyResolve_LoadAssembly finished.\n[11:38:45 PM] Running AppDomainAssemblyResolve_NameMismatch...\n[11:38:45 PM] Invoking AppDomainAssemblyResolve_NameMismatch...\n[11:38:45 PM] Validating bind operation for AssemblyToLoad_Subdirectory...\nWaiting for bind events for AssemblyToLoad_Subdirectory (0ms waited) Sleeping for 50ms\nValidateBindOperation Started\nValidateBindOperation Started\nValidateBindOperation Finished\nValidateBindOperation Finished\nTest AppDomainAssemblyResolve_NameMismatch finished.\n[11:38:45 PM] Running AppDomainAssemblyResolve_MultipleHandlers...\n[11:38:45 PM] Invoking AppDomainAssemblyResolve_MultipleHandlers...\n[11:38:45 PM] Validating bind operation for AssemblyToLoad_Subdirectory...\nWaiting for bind events for AssemblyToLoad_Subdirectory (0ms waite\n```\n\n**Stack trace:**\n```\n   at Xunit.Assert.True(Nullable`1 condition, String userMessage) in /_/src/Microsoft.DotNet.XUnitAssert/src/BooleanAsserts.cs:line 141\n   at TestLibrary.OutOfProcessTest.RunOutOfProcessTest(String assemblyPath, String testPathPrefix)\n   at Program.\u003c\u003cMain\u003e$\u003eg__TestExecutor111|0_112(StreamWriter tempLogSw, StreamWriter statsCsvSw, \u003c\u003ec__DisplayClass0_0\u0026)\n```",
                                           "updatedAt":  "2025-03-17T01:22:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6juHJQ",
                                           "createdAt":  "2025-03-24T03:13:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "Timed out in #113676 on arm64:\n\n- The main thread of the child process is in the middle of ExitProcess and trying to acquire native heap lock:\n```\nntdll!RtlAcquireSRWLockExclusive+0x34 [minkernel\\ntos\\rtl\\srwlock.c @ 1518] \nntdll!RtlpHpAcquireLockExclusive+0x8 [minkernel\\ntos\\rtl\\heapuserenv.c @ 109] \nntdll!RtlpHpLfhOwnerLock+0x8 [minkernel\\ntos\\rtl\\heaplfh.h @ 3438] \nntdll!RtlpHpLfhOwnerLockUnlock+0x30 [minkernel\\ntos\\rtl\\heaplfh.c @ 2600] \nntdll!RtlpHpLfhContextLockUnlock+0x18 [minkernel\\ntos\\rtl\\heaplfh.c @ 1302] \nntdll!RtlpHpLockHeapForProcessCloneOrTerminate+0x88 [minkernel\\ntos\\rtl\\heapsegshared.c @ 3745] \nntdll!RtlLockProcessHeapOnProcessTerminate+0x38 [minkernel\\ntos\\rtl\\heapdll.c @ 1809] \nntdll!RtlExitUserProcess+0x44 [minkernel\\ldr\\rtlstrt.c @ 1593] \nkernel32!ExitProcessImplementation+0x10 [clientcore\\base\\win32\\client\\process.c @ 2606] \ncorerun!GetCurrentClrDetails+0x4531c\ncorerun!GetCurrentClrDetails+0x452b0\n```\n\n- A bunch of other threads are stuck on the allocation lock too, including eventpipe thread:\n```\nntdll!ZwWaitForAlertByThreadId+0x4 [minkernel\\ntdll\\daytona\\objfre\\arm64\\usrstubs.asm @ 4228] \nntdll!RtlpAcquireSRWLockExclusiveContended+0x3c8 [minkernel\\ntos\\rtl\\srwlock.c @ 1442] \nntdll!RtlpHpAcquireQueuedLockExclusive+0xc [minkernel\\ntos\\rtl\\heapuserenv.c @ 77] \nntdll!RtlpHpVsLock+0x14 [minkernel\\ntos\\rtl\\heapvs.h @ 125] \nntdll!RtlpHpVsContextAllocateInternal+0x78 [minkernel\\ntos\\rtl\\heapvs.c @ 411] \nntdll!RtlpHpVsContextAllocate+0x30 [minkernel\\ntos\\rtl\\heapvs.c @ 1026] \nntdll!RtlpHpAllocateHeapInline+0x654 [minkernel\\ntos\\rtl\\heapsegshared.c @ 1858] \nntdll!RtlpHpAllocateHeap+0x6d4 [minkernel\\ntos\\rtl\\heapsegshared.c @ 1679] \nntdll!RtlpAllocateSegHeapInternal+0x18 [minkernel\\ntos\\rtl\\heap.c @ 2293] \nntdll!RtlpHpHeapAllocateRedirectLayer+0x24 [minkernel\\ntos\\rtl\\heappublic.c @ 109] \nntdll!RtlAllocateHeap+0x94 [minkernel\\ntos\\rtl\\heappublic.c @ 165] \ncoreclr!heap_alloc_dbg_internal+0x22c [minkernel\\crts\\ucrt\\src\\appcrt\\heap\\debug_heap.cpp @ 359] \ncoreclr!heap_alloc_dbg+0x5c [minkernel\\crts\\ucrt\\src\\appcrt\\heap\\debug_heap.cpp @ 450] \ncoreclr!_malloc_dbg+0x30 [minkernel\\crts\\ucrt\\src\\appcrt\\heap\\debug_heap.cpp @ 495] \ncoreclr!malloc+0x24 [minkernel\\crts\\ucrt\\src\\appcrt\\heap\\malloc.cpp @ 23] \ncoreclr!operator new+0x18 [D:\\a\\_work\\1\\s\\src\\vctools\\crt\\vcstartup\\src\\heap\\new_scalar.cpp @ 36] \ncoreclr!operator new+0x24 [D:\\a\\_work\\1\\s\\src\\vctools\\crt\\vcstartup\\src\\heap\\new_scalar_nothrow.cpp @ 31] \ncoreclr!ep_thread_alloc+0x10 [D:\\a\\_work\\1\\s\\src\\native\\eventpipe\\ep-thread.c @ 31] \ncoreclr!thread_holder_alloc_func+0x24 [D:\\a\\_work\\1\\s\\src\\coreclr\\vm\\eventing\\eventpipe\\ep-rt-coreclr.h @ 1554] \ncoreclr!EventPipeCoreCLRThreadHolderTLS::createThreadHolder+0x74 [D:\\a\\_work\\1\\s\\src\\coreclr\\vm\\eventing\\eventpipe\\ep-rt-coreclr.h @ 1604] \ncoreclr!ep_rt_thread_get_or_create+0xa0 [D:\\a\\_work\\1\\s\\src\\coreclr\\vm\\eventing\\eventpipe\\ep-rt-coreclr.h @ 1643] \ncoreclr!ep_thread_get_or_create+0xb0 [D:\\a\\_work\\1\\s\\src\\native\\eventpipe\\ep-thread.c @ 159] \ncoreclr!write_event_2+0x84 [D:\\a\\_work\\1\\s\\src\\native\\eventpipe\\ep.c @ 755] \ncoreclr!write_event+0x58 [D:\\a\\_work\\1\\s\\src\\native\\eventpipe\\ep.c @ 728] \ncoreclr!ep_write_event_2+0xb8 [D:\\a\\_work\\1\\s\\src\\native\\eventpipe\\ep.c @ 1587] \ncoreclr!ep_event_source_send_process_info+0x1d0 [D:\\a\\_work\\1\\s\\src\\native\\eventpipe\\ep-event-source.c @ 234] \ncoreclr!log_process_info_event+0x10 [D:\\a\\_work\\1\\s\\src\\native\\eventpipe\\ep.c @ 576] \ncoreclr!disable_holding_lock+0x280 [D:\\a\\_work\\1\\s\\src\\native\\eventpipe\\ep.c @ 602] \ncoreclr!disable_helper+0x10c [D:\\a\\_work\\1\\s\\src\\native\\eventpipe\\ep.c @ 678] \ncoreclr!ep_disable+0x144 [D:\\a\\_work\\1\\s\\src\\native\\eventpipe\\ep.c @ 1205] \ncoreclr!EventPipeAdapter::Disable+0x8 [D:\\a\\_work\\1\\s\\src\\coreclr\\vm\\eventpipeadapter.h @ 242] \ncoreclr!EventPipeInternal_Disable+0xb0 [D:\\a\\_work\\1\\s\\src\\coreclr\\vm\\eventpipeinternal.cpp @ 64] \n```\n\nIt is not clear which thread is holding the lock.",
                                           "updatedAt":  "2025-03-24T03:14:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6kURVz",
                                           "createdAt":  "2025-03-27T05:50:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "SakeTao",
                                           "body":  "**Failed in:** [runtime-coreclr outerloop 20250326.5](https://dev.azure.com/dnceng-public/public/_build/results?buildId=995286\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=26562492\u0026resultId=123190\u0026paneView=debug)\n\n**Failed tests:**\n```\ncoreclr windows arm64 Checked no_tiered_compilation @ Windows.11.Arm64.Open\n    - Loader/binding/tracing/BinderTracingTest.ResolutionFlow/BinderTracingTest.ResolutionFlow.cmd\n```\n\n**Error message:**\n```\n \n\n\n\n\ncmdLine:C:hwAE4609D0wB8A20A63eLoaderLoader../binding/tracing/BinderTracingTest.ResolutionFlow/BinderTracingTest.ResolutionFlow.cmd Timed Out (timeout in milliseconds: 600000 from variable __TestTimeout, start: 3/27/2025 2:47:28 AM, end: 3/27/2025 2:57:28 AM)\n\nReturn code:      -100\nRaw output file:      C:hwAE4609D0wB8A20A63uploads\binding\tracingBinderTracingTest.ResolutionFlowoutput.txt\nRaw output:\nBEGIN EXECUTION\n \"C:hwAE4609D0pcorerun.exe\" -p \"System.Reflection.Metadata.MetadataUpdater.IsSupported=false\" -p \"System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization=true\"  BinderTracingTest.ResolutionFlow.dll \n[2:47:29 AM] Running AssemblyLoadContextResolving_ReturnNull...\n[2:47:30 AM] Invoking AssemblyLoadContextResolving_ReturnNull...\n[2:47:30 AM] Validating bind operation for AssemblyToLoad_Subdirectory...\nWaiting for bind events for AssemblyToLoad_Subdirectory (0ms waited) Sleeping for 50ms\nValidateBindOperation Started\nValidateBindOperation Finished\nTest AssemblyLoadContextResolving_ReturnNull finished.\n[2:47:30 AM] Running AssemblyLoadContextResolving_LoadAssembly...\n[2:47:30 AM] Invoking AssemblyLoadContextResolving_LoadAssembly...\n[2:47:30 AM] Validating bind operation for AssemblyToLoad_Subdirectory...\nWaiting for bind events for AssemblyToLoad_Subdirectory (0ms waited) Sleeping for 50ms\nValidateBindOperation Started\nValidateBindOperation Started\nValidateBindOperation Finished\nValidateBindOperation Finished\nTest AssemblyLoadContextResolving_LoadAssembly finished.\n[2:47:30 AM] Running AssemblyLoadContextResolving_NameMismatch...\n[2:47:30 AM] Invoking AssemblyLoadContextResolving_NameMismatch...\n[2:47:30 AM] Validating bind operation for AssemblyToLoad_Subdirectory...\nWaiting for bind events for AssemblyToLoad_Subdirectory (0ms waited) Sleeping for 50ms\nValidateBindOperation Started\nValidateBindOperation Started\nValidateBindOperation Finished\nValidateBindOperation Finished\nTest AssemblyLoadContextResolving_NameMismatch finished.\n[2:47:30 AM] Running AssemblyLoadContextResolving_MultipleHandlers...\n[2:47:30 AM] Invoking AssemblyLoadContextResolving_MultipleHandlers...\n[2:47:30 AM] Validating bind operation for AssemblyToLoad_Subdirectory...\nValidateBindOperation Started\nValidateBindOperation Started\nValidateBindOperation Finished\nValidateBindOperation Finished\nTest AssemblyLoadContextResolving_MultipleHandlers finished.\n[2:47:30 AM] Running AppDomainAssemblyResolve_ReturnNull...\n[2:47:30 AM] Invoking AppDomainAssemblyResolve_ReturnNull...\n[2:47:30 AM] Validating bind operation for AssemblyToLoad_Subdirectory...\nWaiting for bind events for AssemblyToLoad_Subdirectory (0ms waited) Sleeping for 50ms\nValidateBindOperation Started\nValidateBindOperation Finished\nTest AppDomainAssemblyResolve_ReturnNull finished.\n[2:47:30 AM] Running AppDomainAssemblyResolve_LoadAssembly...\n[2:47:30 AM] Invoking AppDomainAssemblyResolve_LoadAssembly...\n[2:47:30 AM] Validating bind operation for AssemblyToLoad_Subdirectory...\nWaiting for bind events for AssemblyToLoad_Subdirectory (0ms waited) Sleeping for 50ms\nValidateBindOperation Started\nValidateBindOperation Started\nValidateBindOperation Finished\nValidateBindOperation Finished\nTest AppDomainAssemblyResolve_LoadAssembly finished.\n[2:47:30 AM] Running AppDomainAssemblyResolve_NameMismatch...\n[2:47:30 AM] Invoking AppDomainAssemblyResolve_NameMismatch...\n[2:47:30 AM] Validating bind operation for AssemblyToLoad_Subdirectory...\nWaiting for bind events for AssemblyToLoad_Subdirectory (0ms waited) Sleeping for 50ms\nValidateBindOperation Started\nValidateBindOperation Started\nValidateBindOperation Finished\nValidateBindOperation Finished\nTest AppDomainAssemblyResolve_NameMismatch finished.\n[2:47:30 AM] Running AppDomainAssemblyResolve_MultipleHandlers...\n[2:47:30 AM] Invoking AppDomainAssemblyResolve_MultipleHandlers...\n[2:47:30 AM] Validating bind operation for AssemblyToLoad_Subdirectory...\nWaiting for bind events for AssemblyToLoad_Subdirectory (0ms waited) Sleeping for 50ms\nVali\n```\n\n**Stack trace:**\n```\n   at Xunit.Assert.True(Nullable`1 condition, String userMessage) in /_/src/Microsoft.DotNet.XUnitAssert/src/BooleanAsserts.cs:line 141\n   at Program.\u003c\u003cMain\u003e$\u003eg__TestExecutor111|0_112(StreamWriter tempLogSw, StreamWriter statsCsvSw, \u003c\u003ec__DisplayClass0_0\u0026)\n```",
                                           "updatedAt":  "2025-03-27T05:50:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7AhYAn",
                                           "createdAt":  "2025-08-27T22:44:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "JulieLeeMSFT",
                                           "body":  "Failed in [runtime-jit-experimental](https://dev.azure.com/dnceng-public/public/_build?definitionId=137\u0026_a=summary)/[20250824.1](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1130736)\n\nFailed test: \n```\ncoreclr windows x64 Checked jitobjectstackallocation @ Windows.10.Amd64.Open\n-- Loader/binding/tracing/BinderTracingTest.ResolutionFlow/BinderTracingTest.ResolutionFlow.cmd\n```\n\nError message:\n```\ncmdLine:C:hwA8D20967w98CA0891eLoaderLoader../binding/tracing/BinderTracingTest.ResolutionFlow/BinderTracingTest.ResolutionFlow.cmd Timed Out (timeout in milliseconds: 600000 from variable __TestTimeout, start: 8/24/2025 11:36:17 PM, end: 8/24/2025 11:46:17 PM)\n\n\nReturn code:      -100\nRaw output file:      C:hwA8D20967w98CA0891uploads\binding\tracingBinderTracingTest.ResolutionFlowoutput.txt\nRaw output:\nBEGIN EXECUTION\n\"C:hwA8D20967pcorerun.exe\" -p \"System.Reflection.Metadata.MetadataUpdater.IsSupported=false\" -p \"System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization=true\"  BinderTracingTest.ResolutionFlow.dll\n[11:36:18 PM] Running AssemblyLoadContextResolving_ReturnNull...\n[11:36:19 PM] Invoking AssemblyLoadContextResolving_ReturnNull...\n[11:36:19 PM] Validating bind operation for AssemblyToLoad_Subdirectory...\nWaiting for bind events for AssemblyToLoad_Subdirectory (0ms waited) Sleeping for 50ms\nValidateBindOperation Started\nValidateBindOperation Finished\nTest AssemblyLoadContextResolving_ReturnNull finished.\n[11:36:19 PM] Running AssemblyLoadContextResolving_LoadAssembly...\n[11:36:19 PM] Invoking AssemblyLoadContextResolving_LoadAssembly...\n[11:36:19 PM] Validating bind operation for AssemblyToLoad_Subdirectory...\nWaiting for bind events for AssemblyToLoad_Subdirectory (0ms waited) Sleeping for 50ms\nValidateBindOperation Started\nValidateBindOperation Started\nValidateBindOperation Finished\nValidateBindOperation Finished\nTest AssemblyLoadContextResolving_LoadAssembly finished.\n[11:36:20 PM] Running AssemblyLoadContextResolving_NameMismatch...\n[11:36:20 PM] Invoking AssemblyLoadContextResolving_NameMismatch...\n[11:36:20 PM] Validating bind operation for AssemblyToLoad_Subdirectory...\nWaiting for bind events for AssemblyToLoad_Subdirectory (0ms waited) Sleeping for 50ms\nValidateBindOperation Started\nValidateBindOperation Started\nValidateBindOperation Finished\nValidateBindOperation Finished\nTest AssemblyLoadContextResolving_NameMismatch finished.\n[11:36:20 PM] Running AssemblyLoadContextResolving_MultipleHandlers...\n[11:36:20 PM] Invoking AssemblyLoadContextResolving_MultipleHandlers...\n[11:36:20 PM] Validating bind operation for AssemblyToLoad_Subdirectory...\nValidateBindOperation Started\nValidateBindOperation Started\nValidateBindOperation Finished\nValidateBindOperation Finished\nTest AssemblyLoadContextResolving_MultipleHandlers finished.\n[11:36:20 PM] Running AppDomainAssemblyResolve_ReturnNull...\n[11:36:20 PM] Invoking AppDomainAssemblyResolve_ReturnNull...\n[11:36:20 PM] Validating bind operation for AssemblyToLoad_Subdirectory...\nWaiting for bind events for AssemblyToLoad_Subdirectory (0ms waited) Sleeping for 50ms\nValidateBindOperation Started\nValidateBindOperation Finished\nTest AppDomainAssemblyResolve_ReturnNull finished.\n[11:36:20 PM] Running AppDomainAssemblyResolve_LoadAssembly...\n[11:36:20 PM] Invoking AppDomainAssemblyResolve_LoadAssembly...\n[11:36:20 PM] Validating bind operation for AssemblyToLoad_Subdirectory...\nWaiting for bind events for AssemblyToLoad_Subdirectory (0ms waited) Sleeping for 50ms\nValidateBindOperation Started\nValidateBindOperation Started\nValidateBindOperation Finished\nValidateBindOperation Finished\nTest AppDomainAssemblyResolve_LoadAssembly finished.\n[11:36:20 PM] Running AppDomainAssemblyResolve_NameMismatch...\n[11:36:20 PM] Invoking AppDomainAssemblyResolve_NameMismatch...\n[11:36:20 PM] Validating bind operation for AssemblyToLoad_Subdirectory...\nWaiting for bind events for AssemblyToLoad_Subdirectory (0ms waited) Sleeping for 50ms\nValidateBindOperation Started\nValidateBindOperation Started\nValidateBindOperation Finished\nValidateBindOperation Finished\nTest AppDomainAssemblyResolve_NameMismatch finished.\n[11:36:20 PM] Running AppDomainAssemblyResolve_MultipleHandlers...\n[11:36:20 PM] Invoking AppDomainAssemblyResolve_MultipleHandlers...\n[11:36:20 PM] Validating bind operation for AssemblyToLoad_Subdirectory...\nWaiting for bind events for AssemblyToLoad_Subdirectory\n```\n\nStack trace\n```\n  at Xunit.Assert.True(Nullable`1 condition, String userMessage) in /_/src/arcade/src/Microsoft.DotNet.XUnitAssert/src/BooleanAsserts.cs:line 141\n   at TestLibrary.OutOfProcessTest.RunOutOfProcessTest(String assemblyPath, String testPathPrefix)\n   at Program.\u003c\u003cMain\u003e$\u003eg__TestExecutor113|0_114(StreamWriter tempLogSw, StreamWriter statsCsvSw, \u003c\u003ec__DisplayClass0_0\u0026)\n```\n\n",
                                           "updatedAt":  "2025-08-27T22:44:38Z"
                                       }
                                   ],
                         "totalCount":  13
                     },
        "title":  "BinderTracingTest.ResolutionFlow times out",
        "labels":  [
                       "area-AssemblyLoader-coreclr",
                       "blocking-clean-ci",
                       "Known Build Error"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/112618",
        "createdAt":  "2025-02-17T01:30:39Z",
        "number":  112618,
        "author":  "v-wenyuxu",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-07T14:27:53Z",
        "body":  "**Failed in:** [runtime-coreclr gcstress-extra 20250215.1](https://dev.azure.com/dnceng-public/public/_build/results?buildId=953698\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=25359552\u0026resultId=163200\u0026paneView=debug)\n\n**Failed tests:**\n```\ncoreclr windows x86 Checked gcstress0xc_tailcallstress @ Windows.10.Amd64.Open\n    - Loader/CollectibleAssemblies/ResolvedFromDifferentContext/ResolvedFromDifferentContext/ResolvedFromDifferentContext.cmd\n```\n\n**Error message:**\n```\n \nReturn code:      1\nRaw output file:      C:hwA39F08BEwC5F70AA8uploadsCollectibleAssembliesResolvedFromDifferentContextResolvedFromDifferentContextoutput.txt\nRaw output:\nBEGIN EXECUTION\n \"C:hwA39F08BEpcorerun.exe\" -p \"System.Reflection.Metadata.MetadataUpdater.IsSupported=false\" -p \"System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization=true\"  ResolvedFromDifferentContext.dll \nRunning test case ResolvingEvent\nResolving event by alc \"Dependencies\" System.Runtime.Loader.AssemblyLoadContext #0 for alc \"Test1\" System.Runtime.Loader.AssemblyLoadContext #1\nLoading TestInterface by alc \"Dependencies\" System.Runtime.Loader.AssemblyLoadContext #0 for collectible alc \"Test1\" System.Runtime.Loader.AssemblyLoadContext #1\nType TestClass.Class obtained\nMethod Void MainTest() obtained\nLoad done\nTestInterface.Class.Test\nFailed to unload alc1\nXunit.Sdk.EqualException: Assert.Equal() Failure: Values differ\nExpected: 100\nActual:   103\n   at Xunit.Assert.Equal[T](T expected, T actual, IEqualityComparer`1 comparer) in /_/src/Microsoft.DotNet.XUnitAssert/src/EqualityAsserts.cs:line 174\n   at __GeneratedMainWrapper.Main()\nExpected: 100\nActual: 101\nEND EXECUTION - FAILED\nFAILED\nTest failed. Trying to see if dump file was created in C:cores since 2/15/2025 11:17:32 PM\nTest Harness Exitcode is : 1\nTo run the test:\nSet up CORE_ROOT and run.\n\u003e C:hwA39F08BEwC5F70AA8eLoaderLoader../CollectibleAssemblies/ResolvedFromDifferentContext/ResolvedFromDifferentContext/ResolvedFromDifferentContext.cmd\n```\n\n**Stack trace:**\n```\n   at Xunit.Assert.True(Nullable`1 condition, String userMessage) in /_/src/Microsoft.DotNet.XUnitAssert/src/BooleanAsserts.cs:line 141\n   at Xunit.Assert.True(Boolean condition, String userMessage) in /_/src/Microsoft.DotNet.XUnitAssert/src/BooleanAsserts.cs:line 123\n   at Program.\u003c\u003cMain\u003e$\u003eg__TestExecutor322|0_323(StreamWriter tempLogSw, StreamWriter statsCsvSw, \u003c\u003ec__DisplayClass0_0\u0026)\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOwonWAg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6epzuH",
                                           "createdAt":  "2025-02-17T01:31:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-02-17T01:31:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7CidYC",
                                           "createdAt":  "2025-09-07T14:26:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "Failed again in #119403 on osx arm64 gcstress0xc_tailcallstress:\n\n```\nRunning test case ResolvingEvent\nResolving event by alc \"Dependencies\" System.Runtime.Loader.AssemblyLoadContext #0 for alc \"Test1\" System.Runtime.Loader.AssemblyLoadContext #1\nLoading TestInterface by alc \"Dependencies\" System.Runtime.Loader.AssemblyLoadContext #0 for collectible alc \"Test1\" System.Runtime.Loader.AssemblyLoadContext #1\nType TestClass.Class obtained\nMethod Void MainTest() obtained\nLoad done\nTestInterface.Class.Test\nFailed to unload alc1\nXunit.Sdk.EqualException: Assert.Equal() Failure: Values differ\nExpected: 100\nActual:   103\nat Xunit.Assert.Equal[T](T expected, T actual, IEqualityComparer`1 comparer) in /_/src/arcade/src/Microsoft.DotNet.XUnitAssert/src/EqualityAsserts.cs:line 174\nat __GeneratedMainWrapper.Main()\nExpected: 100\nActual: 101\n```",
                                           "updatedAt":  "2025-09-07T14:27:53Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Test failure: Loader/CollectibleAssemblies/ResolvedFromDifferentContext/ResolvedFromDifferentContext/ResolvedFromDifferentContext.cmd",
        "labels":  [
                       "GCStress",
                       "area-AssemblyLoader-coreclr",
                       "untriaged",
                       "blocking-clean-ci-optional"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/112901",
        "createdAt":  "2025-02-25T09:39:05Z",
        "number":  112901,
        "author":  "t-mustafin",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-03-25T19:21:10Z",
        "body":  "Native images mapped twice as LAYOUT_FLAT and LAYOUT_LOADED on Linux for main:\n```\n7f158e020000-7f158e021000 r--p 00000000 103:01 28346375                  /home/runtime/main_x64_releaseO0/hello/readline.ni.dll\n7f158e030000-7f158e031000 r-xp 00000000 103:01 28346375                  /home/runtime/main_x64_releaseO0/hello/readline.ni.dll\n7f158e051000-7f158e052000 rw-p 00001000 103:01 28346375                  /home/runtime/main_x64_releaseO0/hello/readline.ni.dll\n7f158e071000-7f158e072000 r--p 00001000 103:01 28346375                  /home/runtime/main_x64_releaseO0/hello/readline.ni.dll\n7f1608040000-7f1608042000 r--s 00000000 103:01 28346375                  /home/runtime/main_x64_releaseO0/hello/readline.ni.dll\n```\n\u003cdetails\u003e \u003csummary\u003e Backtrace for LAYOUT_FLAT \u003c/summary\u003e\n\n```c++\n#0  PEImage::GetOrCreateLayoutInternal (this=this@entry=0x556ee6e12c20, imageLayoutMask=imageLayoutMask@entry=15)\n    at /home/runtime/src/coreclr/vm/peimage.cpp:693\n#1  0x00007f160c07c612 in PEImage::GetOrCreateLayout (this=0x556ee6e12c20, imageLayoutMask=imageLayoutMask@entry=15)\n    at /home/runtime/src/coreclr/vm/peimage.cpp:659\n#2  0x00007f160c07c52e in PEImage::CheckILFormat (this=0x556ee6e12c20) at /home/runtime/src/coreclr/vm/peimage.cpp:66\n#3  0x00007f160c0e01f3 in AssemblySpec::LoadAssembly (pFilePath=\u003coptimized out\u003e) at /home/runtime/src/coreclr/vm/assemblyspec.cpp:439\n#4  0x00007f160bfff7f0 in CorHost2::ExecuteAssembly (this=\u003coptimized out\u003e, dwAppDomainId=\u003coptimized out\u003e, \n    pwzAssemblyPath=0x556ee6e08ab0 u\"/home/runtime/main_x64_releaseO0/hello/readline.ni.dll\", argc=0, argv=0x0, pReturnValue=0x7ffe38def880)\n    at /home/runtime/src/coreclr/vm/corhost.cpp:322\n#5  0x00007f160bfc51f8 in coreclr_execute_assembly (hostHandle=0x556ee6e12c20, domainId=1, argc=0, argv=\u003coptimized out\u003e, \n    managedAssemblyPath=\u003coptimized out\u003e, exitCode=0x7ffe38def880) at /home/runtime/src/coreclr/dlls/mscoree/exports.cpp:494\n#6  0x0000556ee6a40036 in run (config=...) at /home/runtime/src/coreclr/hosts/corerun/corerun.cpp:717\n#7  0x0000556ee6a3bd0f in main (argc=\u003coptimized out\u003e, argv=\u003coptimized out\u003e) at /home/runtime/src/coreclr/hosts/corerun/corerun.cpp:967\n```\n\u003c/details\u003e\n\n\u003cdetails\u003e \u003csummary\u003e Backtrace for LAYOUT_LOADED \u003c/summary\u003e\n\n```c++\n#0  PEImage::GetOrCreateLayoutInternal (this=this@entry=0x556ee6e12c20, imageLayoutMask=imageLayoutMask@entry=4)\n    at /home/runtime/src/coreclr/vm/peimage.cpp:693\n#1  0x00007f160c07c612 in PEImage::GetOrCreateLayout (this=0x556ee6e12c20, imageLayoutMask=4) at /home/runtime/src/coreclr/vm/peimage.cpp:659\n#2  0x00007f160c07a3d5 in PEAssembly::EnsureLoaded (this=0x556ee6e0dde0) at /home/runtime/src/coreclr/vm/peassembly.cpp:71\n#3  0x00007f160bfd32de in Assembly::Init (this=0x556ee6e050d0, pamTracker=pamTracker@entry=0x7ffe38dee5f0)\n    at /home/runtime/src/coreclr/vm/assembly.cpp:181\n#4  0x00007f160bfd3d80 in Assembly::Create (pPEAssembly=\u003coptimized out\u003e, pamTracker=0x7ffe38dee5f0, pLoaderAllocator=\u003coptimized out\u003e)\n    at /home/runtime/src/coreclr/vm/assembly.cpp:352\n#5  0x00007f160c007138 in DomainAssembly::DomainAssembly (this=0x556ee6e0dc60, pPEAssembly=0x556ee6e0dde0, \n    pLoaderAllocator=0x7f160c6280c0 \u003cg_pSystemDomainMemory+16\u003e, memTracker=0x7ffe38dee5f0) at /home/runtime/src/coreclr/vm/domainassembly.cpp:35\n#6  0x00007f160bfcb391 in AppDomain::LoadAssemblyInternal (this=this@entry=0x556ee6ddc4d0, pIdentity=pIdentity@entry=0x7ffe38deeb88, \n    pPEAssembly=pPEAssembly@entry=0x556ee6e0dde0, targetLevel=targetLevel@entry=FILE_LOADED) at /home/runtime/src/coreclr/vm/appdomain.cpp:2467\n#7  0x00007f160bfc842e in AppDomain::LoadAssembly (this=0x556ee6ddc4d0, pSpec=0x7ffe38deeb88, pPEAssembly=0x556ee6e0dde0, \n    targetLevel=FILE_LOADED) at /home/runtime/src/coreclr/vm/appdomain.cpp:2378\n#8  0x00007f160c0d8c53 in AssemblyNative::LoadFromPEImage (pBinder=0x556ee6dde9d0, pImage=0x556ee6e12c20, excludeAppPaths=true)\n    at /home/runtime/src/coreclr/vm/assemblynative.cpp:173\n#9  0x00007f160c0e021a in AssemblySpec::LoadAssembly (pFilePath=\u003coptimized out\u003e) at /home/runtime/src/coreclr/vm/assemblyspec.cpp:442\n#10 0x00007f160bfff7f0 in CorHost2::ExecuteAssembly (this=\u003coptimized out\u003e, dwAppDomainId=\u003coptimized out\u003e, \n    pwzAssemblyPath=0x556ee6e08ab0 u\"/home/runtime/main_x64_releaseO0/hello/readline.ni.dll\", argc=0, argv=0x0, pReturnValue=0x7ffe38def880)\n    at /home/runtime/src/coreclr/vm/corhost.cpp:322\n#11 0x00007f160bfc51f8 in coreclr_execute_assembly (hostHandle=0x556ee6e12c20, domainId=1, argc=0, argv=\u003coptimized out\u003e, \n    managedAssemblyPath=\u003coptimized out\u003e, exitCode=0x7ffe38def880) at /home/runtime/src/coreclr/dlls/mscoree/exports.cpp:494\n#12 0x0000556ee6a40036 in run (config=...) at /home/runtime/src/coreclr/hosts/corerun/corerun.cpp:717\n#13 0x0000556ee6a3bd0f in main (argc=\u003coptimized out\u003e, argv=\u003coptimized out\u003e) at /home/runtime/src/coreclr/hosts/corerun/corerun.cpp:967\n```\n\u003c/details\u003e\n\nFor release/6.0 exists only one LAYOUT_MAPPED:\n```\n7fff7dff0000-7fff7dff1000 r--p 00000000 103:01 28345737                  /home/tmustafin/dotnet/another_runtime/6.0_x64_releaseO0/hello/readline.ni.dll\n7fff7e000000-7fff7e001000 r-xp 00000000 103:01 28345737                  /home/tmustafin/dotnet/another_runtime/6.0_x64_releaseO0/hello/readline.ni.dll\n7fff7e011000-7fff7e012000 rw-p 00001000 103:01 28345737                  /home/tmustafin/dotnet/another_runtime/6.0_x64_releaseO0/hello/readline.ni.dll\n7fff7e021000-7fff7e022000 r--p 00001000 103:01 28345737                  /home/tmustafin/dotnet/another_runtime/6.0_x64_releaseO0/hello/readline.ni.dll\n```\n\u003cdetails\u003e \u003csummary\u003e Backtrace for release/6.0 \u003c/summary\u003e\n\n```c++\n#0  PEImage::GetLayoutInternal (this=0x555555685fa0, imageLayoutMask=15, flags=1)\n    at /home/tmustafin/dotnet/another_runtime/src/coreclr/vm/peimage.cpp:969\n#1  0x00007ffff7183ed6 in PEImage::GetLayout (this=0x555555685fa0, imageLayoutMask=15, flags=1)\n    at /home/tmustafin/dotnet/another_runtime/src/coreclr/vm/peimage.cpp:939\n#2  0x00007ffff726746f in BinderAcquireImport (pPEImage=0x555555685fa0, ppIAssemblyMetaDataImport=0x7fffffffb9a0, pdwPAFlags=0x7fffffffb9c0, \n    bNativeImage=0) at /home/tmustafin/dotnet/another_runtime/src/coreclr/vm/coreassemblyspec.cpp:257\n#3  0x00007ffff757d674 in BINDER_SPACE::AssemblyBinder::GetAssembly (assemblyPath=..., fIsInGAC=0, fExplicitBindToNativeImage=0, \n    ppAssembly=0x7fffffffbb28, szMDAssemblyPath=0x0, bundleFileLocation=...)\n    at /home/tmustafin/dotnet/another_runtime/src/coreclr/binder/assemblybinder.cpp:1253\n#4  0x00007ffff757c703 in BINDER_SPACE::AssemblyBinder::BindWhereRef (pApplicationContext=0x55555561fcd8, assemblyPath=..., \n    fNgenExplicitBind=0, fExplicitBindToNativeImage=0, excludeAppPaths=false, pBindResult=0x7fffffffbc68)\n    at /home/tmustafin/dotnet/another_runtime/src/coreclr/binder/assemblybinder.cpp:597\n#5  0x00007ffff757bd00 in BINDER_SPACE::AssemblyBinder::BindAssembly (pApplicationContext=0x55555561fcd8, pAssemblyName=0x0, \n    szCodeBase=0x555555650210 u\"/home/tmustafin/dotnet/another_runtime/6.0_x64_releaseO0/hello/readline.ni.dll\", pParentAssembly=0x0, \n    fNgenExplicitBind=0, fExplicitBindToNativeImage=0, excludeAppPaths=false, ppAssembly=0x7fffffffc0d0)\n    at /home/tmustafin/dotnet/another_runtime/src/coreclr/binder/assemblybinder.cpp:300\n#6  0x00007ffff75894c4 in CLRPrivBinderCoreCLR::Bind (this=0x55555561fc90, \n    wszCodeBase=0x555555650210 u\"/home/tmustafin/dotnet/another_runtime/6.0_x64_releaseO0/hello/readline.ni.dll\", pParentAssembly=0x0, \n    fNgenExplicitBind=0, fExplicitBindToNativeImage=0, ppAssembly=0x7fffffffc2b8)\n    at /home/tmustafin/dotnet/another_runtime/src/coreclr/binder/clrprivbindercoreclr.cpp:238\n#7  0x00007ffff72664d0 in AssemblySpec::Bind (this=0x7fffffffd5a0, pAppDomain=0x5555555f6e30, fThrowOnFileNotFound=0, pResult=0x7fffffffceb8, \n    fNgenExplicitBind=0, fExplicitBindToNativeImage=0) at /home/tmustafin/dotnet/another_runtime/src/coreclr/vm/coreassemblyspec.cpp:137\n#8  0x00007ffff7038daf in AppDomain::BindAssemblySpec (this=0x5555555f6e30, pSpec=0x7fffffffd5a0, fThrowOnFileNotFound=1)\n    at /home/tmustafin/dotnet/another_runtime/src/coreclr/vm/appdomain.cpp:3983\n#9  0x00007ffff7225d9c in AssemblySpec::LoadDomainAssembly (this=0x7fffffffd5a0, targetLevel=FILE_LOADED, fThrowOnFileNotFound=1)\n    at /home/tmustafin/dotnet/another_runtime/src/coreclr/vm/assemblyspec.cpp:812\n#10 0x00007ffff7225c21 in AssemblySpec::LoadAssembly (this=0x7fffffffd5a0, targetLevel=FILE_LOADED, fThrowOnFileNotFound=1)\n    at /home/tmustafin/dotnet/another_runtime/src/coreclr/vm/assemblyspec.cpp:673\n#11 0x00007ffff7226257 in AssemblySpec::LoadAssembly (\n    pFilePath=0x555555650210 u\"/home/tmustafin/dotnet/another_runtime/6.0_x64_releaseO0/hello/readline.ni.dll\")\n    at /home/tmustafin/dotnet/another_runtime/src/coreclr/vm/assemblyspec.cpp:862\n#12 0x00007ffff70badff in CorHost2::ExecuteAssembly (this=0x5555555d29a0, dwAppDomainId=1, \n    pwzAssemblyPath=0x555555650210 u\"/home/tmustafin/dotnet/another_runtime/6.0_x64_releaseO0/hello/readline.ni.dll\", argc=0, argv=0x0, \n    pReturnValue=0x7fffffffdacc) at /home/tmustafin/dotnet/another_runtime/src/coreclr/vm/corhost.cpp:359\n#13 0x00007ffff702fb9d in coreclr_execute_assembly (hostHandle=0x5555555d29a0, domainId=1, argc=0, argv=0x555555585dd0, \n    managedAssemblyPath=0x555555585930 \"/home/tmustafin/dotnet/another_runtime/6.0_x64_releaseO0/hello/readline.ni.dll\", \n    exitCode=0x7fffffffdacc) at /home/tmustafin/dotnet/another_runtime/src/coreclr/dlls/mscoree/unixinterface.cpp:475\n#14 0x000055555555b6fb in run (config=...) at /home/tmustafin/dotnet/another_runtime/src/coreclr/hosts/corerun/corerun.cpp:372\n#15 0x00005555555589ef in main (argc=2, argv=0x7fffffffe218) at /home/tmustafin/dotnet/another_runtime/src/coreclr/hosts/corerun/corerun.cpp:554\n```\n\u003c/details\u003e\n\nDouble mapping for each loaded native image increases of memory consumption.\n@VSadov @jkotas Why native images mapped twice on Linux?\n\ncc @gbalykov ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOn_je-g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6f4D40",
                                           "createdAt":  "2025-02-25T14:57:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-02-25T14:57:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6f4OCY",
                                           "createdAt":  "2025-02-25T15:09:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "filipnavara",
                                           "body":  "Is that from Debug runtime? I think this only affects debug builds.",
                                           "updatedAt":  "2025-02-25T15:09:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6f-N76",
                                           "createdAt":  "2025-02-26T04:49:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "t-mustafin",
                                           "body":  "\u003e Is that from Debug runtime? I think this only affects debug builds.\n\nNo, it is Release build.",
                                           "updatedAt":  "2025-02-26T04:49:16Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Native image double mapping",
        "labels":  [
                       "tenet-performance",
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/112911",
        "createdAt":  "2025-02-25T16:03:12Z",
        "number":  112911,
        "author":  "RomanSoloweow",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-03-01T00:18:21Z",
        "body":  "### Description\n\nHi, my application has a plugin architecture and runs on Linux.\n\nI\u0027ve encountered an issue under the following scenario:\n\n1. Create a new assembly load context: new MyAssemblyLoadContext()\n2. Load an assembly: LoadFromAssemblyPath(\"my.dll\")\n3. Install a new package\n4. Unload() - though it should not matter as contexts are supposed to be independent\n5. Create a new assembly load context: new MyAssemblyLoadContext()\n6. Load the same assembly again: LoadFromAssemblyPath(\"my.dll\")\n \nThe LoadFromAssemblyPath method returns the old version of the assembly, even though the new version is already present on disk.\n\nMy context:\n\n``` c#\ninternal sealed class PluginLoadContext : AssemblyLoadContext\n{\n    private readonly AssemblyDependencyResolver _resolver;\n \n    public PluginLoadContext(string name, assemblyPath)\n        : base(isCollectible: true, name: name)\n    {\n        _resolver = new AssemblyDependencyResolver(assemblyPath);\n    }\n \n    protected override Assembly? Load(AssemblyName assemblyName)\n    {\n        var assemblyPath = _resolver.ResolveAssemblyToPath(assemblyName);\n        var assembly = assemblyPath != null ? LoadFromAssemblyPath(assemblyPath) : null;\n        return assembly;\n    }\n}\n```\n\n### Reproduction Steps\n\n1. Create a new assembly load context: new MyAssemblyLoadContext()\n2. Load an assembly: LoadFromAssemblyPath(\"my.dll\")\n3. Install a new package\n4. Unload() - though it should not matter as contexts are supposed to be independent\n5. Create a new assembly load context: new MyAssemblyLoadContext()\n6. Load the same assembly again: LoadFromAssemblyPath(\"my.dll\")\n\n### Expected behavior\n\nA new Assembly from the current dll will be loaded\n\n### Actual behavior\n\nReturns Assembly loaded by another context\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOoG2wZA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6f478i",
                                           "createdAt":  "2025-02-25T16:03:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-02-25T16:03:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6gFuUj",
                                           "createdAt":  "2025-02-26T18:24:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "RomanSoloweow",
                                           "body":  "Hi, any news?  @vitek-karas @agocke @VSadov ",
                                           "updatedAt":  "2025-02-26T18:24:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6gF3R9",
                                           "createdAt":  "2025-02-26T18:40:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "agocke",
                                           "body":  "+ @elinor-fung ",
                                           "updatedAt":  "2025-02-26T18:40:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6gF9HR",
                                           "createdAt":  "2025-02-26T18:51:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "agocke",
                                           "body":  "@RomanSoloweow In your example, are the original plugin paths different?\n\nThat is, I understand this as having a layout like\n\n/plugin-dir1/mainasm.dll\n/plugin-dir1/secondary.dll\n/plugin-dir2/mainasm.dll\n/plugin-dir2/secondary.dll\n\nAnd when you\u0027re creating `PluginLoadContext(\"plugin1\", \"/plugin-dir1/mainasm.dll\")` and `PluginLoadContext(\"plugin2\", \"/plugin-dir2/mainasm.dll\")`. And you expect that the context (1) and the context (2) will have different copies of `secondary.dll`, right?",
                                           "updatedAt":  "2025-02-26T18:51:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6gF_g1",
                                           "createdAt":  "2025-02-26T18:55:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEHxy-A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "agocke",
                                                                               "createdAt":  "2025-02-26T19:10:16Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "RomanSoloweow",
                                           "body":  "No, i call PluginLoadContext(\"plugin1\", \"/plugin-dir1/mainasm.dll\"), replace dll and call PluginLoadContext(\"plugin1\", \"/plugin-dir1/mainasm.dll\") again\n\n\nAnd i expect that the context (1) and the context (2) will have different copies of mainasm.dll",
                                           "updatedAt":  "2025-02-26T18:55:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6gScnH",
                                           "createdAt":  "2025-02-27T21:52:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "elinor-fung",
                                           "body":  "@RomanSoloweow would it be possible for you to provide a minimal repro?\n\n\u003e 3. Install a new package\n\nIs this equivalent to directly replacing the .dll passed to `LoadFromAssemblyPath` - for example via just a manual copy/overwrite? Or is there more to installing a new package?\n\nI tried a simple version based on the description. Replacing the .dll passed to `LoadFromAssemblyPath` and loading it in a new ALC returns the new/replaced assembly.\n\n```C#\nstring path = Path.Combine(AppContext.BaseDirectory, \"lib.dll\");\nstring v1 = Path.Combine(AppContext.BaseDirectory, \"lib-v1.dll\");\nstring v2 = Path.Combine(AppContext.BaseDirectory, \"lib-v2.dll\");\nFile.Copy(v1, path, overwrite: true);\n\nWeakReference alc1 = LoadAndUnload(\"alc1\", path);\nfor (int i = 0; alc1.IsAlive \u0026\u0026 (i \u003c 10); i++)\n{\n    GC.Collect();\n    GC.WaitForPendingFinalizers();\n}\n\nFile.Copy(v2, path, overwrite: true);\nLoadAndUnload(\"alc2\", path);\n\n[MethodImpl(MethodImplOptions.NoInlining)]\nstatic WeakReference LoadAndUnload(string name, string path)\n{\n    var alc = new AssemblyLoadContext(name, isCollectible: true);\n    Assembly a = alc.LoadFromAssemblyPath(path);\n    Console.WriteLine($\"\"\"\n        {name} : {path}\n            {a}\n        \"\"\");\n    WeakReference weakRef = new WeakReference(alc, trackResurrection: true);\n    alc.Unload();\n    return weakRef;\n}\n```\n\nOutputs:\n```\nalc1 : C:\\issues\\112911\\app\\bin\\Debug\\net9.0\\lib.dll\n    lib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\nalc2 : C:\\issues\\112911\\app\\bin\\Debug\\net9.0\\lib.dll\n    lib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null\n```",
                                           "updatedAt":  "2025-02-27T21:52:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6gS7Lc",
                                           "createdAt":  "2025-02-27T23:09:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  ".NET assembly loader has a cache of loaded assembly files. This cache is indexed by a path. This cache assumes that the files are not changing on the file system. There may be a small delay between the point where assembly is unloaded (e.g. `GC.Collect` that collects the collectible assembly returns) and the point where assembly is released from the cache.\n\nThus, if you load an assembly from a path, unload it, and load a new assembly from the same path immediately after that, you may still get the content of the original assembly if it was not released from the cache.",
                                           "updatedAt":  "2025-02-27T23:09:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6gVyoT",
                                           "createdAt":  "2025-02-28T08:47:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "RomanSoloweow",
                                           "body":  "Is it possible to disable this cache or download bypassing the cache?",
                                           "updatedAt":  "2025-02-28T08:47:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6gafIX",
                                           "createdAt":  "2025-02-28T18:29:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "You can override the cache by reading the file yourself and then using `AssemblyLoadContext.LoadFromStream` API to load it. This workaround comes with performance overhead as you may expect.",
                                           "updatedAt":  "2025-02-28T18:30:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6gbVJ6",
                                           "createdAt":  "2025-02-28T20:47:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "agocke",
                                           "body":  "Separate from the workaround, could we attach this cache to the ALC? It feels like ALC loads should be independent.",
                                           "updatedAt":  "2025-02-28T20:47:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6gbbBk",
                                           "createdAt":  "2025-02-28T21:04:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Separate from the workaround, could we attach this cache to the ALC? It feels like ALC loads should be independent.\n\nIt is hard to do that on Windows. We use OS loader to load PE files on Windows. Windows OS loader cannot load the same binary multiple times into the same address space. Moving away from OS loader on Windows would create a bunch of work to ensure that the virus scanners kick in as expected and that we fallback to using OS loader as necessary (e.g. when loading managed C++ binaries).",
                                           "updatedAt":  "2025-02-28T21:04:24Z"
                                       }
                                   ],
                         "totalCount":  11
                     },
        "title":  "All AssemblyLoadContexts share a file path cache",
        "labels":  [
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/113042",
        "createdAt":  "2025-03-02T11:46:45Z",
        "number":  113042,
        "author":  "huoyaoyuan",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-03-31T16:28:18Z",
        "body":  "### Background and motivation\n\nIn #40622 and #43247, `SuppressIldasmAttribute` and `DisablePrivateReflectionAttribute` were obsoleted because the runtime and toolchain no longer respects them. There are other attributes no longer respected by coreclr for a long time. PRs like #112975 are also removing the runtime definition of them. We may like to obsolete these attributes to provide a clear indication.\n\nThe list of attributes are:\n- DefaultDependencyAttribute\n- DependencyAttribute\n- ~CompilationRelaxationsAttribute~ still emitted by roslyn\n- ~CompilerGlobalScopeAttribute~ still used by VS debugger\n- StringFreezingAttribute\n- LoaderOptimizationAttribute\n\n### API Proposal\n\n```diff\nnamespace System.Runtime.CompilerServices;\n{\n+   [Obsolete(\"LoadHint has no effect on .NET 5+\", Id = ???1)]\n    public partial class DefaultDependencyAttribute {}\n\n+   [Obsolete(\"LoadHint has no effect on .NET 5+\", Id = ???1)]\n    public partial class DependencyAttribute {}\n\n+   [Obsolete(\"LoadHint has no effect on .NET 5+\", Id = ???1)]\n    public enum LoadHint {}\n\n+   [Obsolete(\"StringFreezingAttribute has no effect on .NET 5+\", Id = ???2)]\n    public partial class StringFreezingAttribute{}\n}\n\nnamespace System\n{\n+   [Obsolete(\"LoaderOptimizationAttribute has no effect on .NET 5+\", Id = ???3)]\n    public partial class LoaderOptimizationAttribute {}\n+   [Obsolete(\"LoaderOptimizationAttribute has no effect on .NET 5+\", Id = ???3)]\n    public enum LoaderOptimization {}\n}\n```\n\n\n### API Usage\n\nN/A\n\n### Alternative Designs\n\nHow should the IDs and messages be grouped? Grouping related attributes and enum with a same ID seems reasonable.\n\nShould the message say \".NET 5+\" or \".NET 10+\"? These attributes have not been respected for a long time.\n\n### Risks\n\nWe shouldn\u0027t want to re-introduce these capabilities in the future.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOoQ95_w==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6gfzy-",
                                           "createdAt":  "2025-03-02T11:47:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-runtime-compilerservices\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-03-02T11:47:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6gf4Pi",
                                           "createdAt":  "2025-03-02T12:35:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "Roslyn [emits](https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA+ABATARgLABQGAzAATakDCpA3oaQ+WRiqQLIAUAlLfYwL6F+QA=) `[assembly:CompilationRelaxationsAttribute(CompilationRelaxations.NoStringInterning)]` in all assemblies it compiles. If we want to obsolete this attribute I think we should also update Roslyn to not emit it (maybe by checking if it is obsolete?).",
                                           "updatedAt":  "2025-03-02T12:35:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6gf_X_",
                                           "createdAt":  "2025-03-02T13:44:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "The documentation of CompilerGlobalScopeAttribute says:\n\n\u003e This class is used only for communication with debugger tools.\n\nDo debuggers ignore this attribute nowadays?\n\n",
                                           "updatedAt":  "2025-03-02T13:44:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ggGJC",
                                           "createdAt":  "2025-03-02T14:54:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "\u003e The documentation of CompilerGlobalScopeAttribute says:\n\u003e \n\u003e \u003e This class is used only for communication with debugger tools.\n\nThe code comment says \"VS 7 debugger\":\n\nhttps://github.com/dotnet/runtime/blob/b658cd25af266afbde9f83f77d13519de9f533f0/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/CompilerGlobalScopeAttribute.cs#L6\n\nI searched runtime and diagnostics and didn\u0027t find usage in production code. However, there is some unit test mentioning it:\n\nhttps://github.com/dotnet/runtime/blob/b658cd25af266afbde9f83f77d13519de9f533f0/src/tests/Loader/classloader/regressions/dev11_11333/dev11_11333.il#L30",
                                           "updatedAt":  "2025-03-02T14:54:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ggH78",
                                           "createdAt":  "2025-03-02T15:11:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "Code handling `CompilationRelaxations.NoStringInterning` was deleted in #57693 and #64521. There\u0027s still a piece of comment mentioning it at https://github.com/dotnet/runtime/blob/b658cd25af266afbde9f83f77d13519de9f533f0/src/coreclr/vm/jitinterface.cpp#L13477",
                                           "updatedAt":  "2025-03-02T15:12:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ggLyd",
                                           "createdAt":  "2025-03-02T15:53:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e PRs like #112975 are also removing the runtime definition of them\n\nNit: This PR is deleting unused flags on obsolete hosting API. Some of these flags served similar purpose as some of the attributes, but this PR is not deleting runtime definition of any attributes.\n\nDid you mean to include `LoaderOptimizationAttribute` that was discussed in that PR in this list?\n\nBTW: There is a lot of attributes in the security namespaces that are candidates for obsoletion as well. For example, `SecurityTransparentAttribute`, `SecuritySafeCriticalAttribute`, `SecurityRulesAttribute`, `SuppressUnmanagedCodeSecurityAttribute`, ... .\n\n\u003e CompilerGlobalScopeAttribute\n\u003e This class is used only for communication with debugger tools.\n\u003e I searched runtime and diagnostics and didn\u0027t find usage in production code.\n\nYou would have to search the closed source Visual Studio code that\u0027s the production debugger code. The attribute is used there as you can tell by looking at the binaries:\n\n```\nC:\\Program Files\\Microsoft Visual Studio\\2022\\Enterprise\\Common7\\IDE\\VC\\vcpackages\u003efindstr /M CompilerGlobalScopeAttribute vcpkg.dll\nvcpkg.dll\n```\n\n\u003e The code comment says \"VS 7 debugger\":\n\nYou can delete the version number from the comment so that people are confused by it.\n\n\u003e CompilationRelaxations.NoStringInterning\n\nYes, it was deleted in the runtime. However, the Roslyn still emits it and there may be tools out there that may depend on this attribute. We would have to overall plan for these other places to really obsolete it. I do not think it is worth it to bother with obsoleting this one.",
                                           "updatedAt":  "2025-03-02T15:53:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ggOiH",
                                           "createdAt":  "2025-03-02T16:23:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "Updated original post. I didn\u0027t find other attributes in System namespace that looks obsolete.\n\n\u003e BTW: There is a lot of attributes in the security namespaces that are candidates for obsoletion as well.\n\nShould they be included in one issue? Many of them already have members obsoleted.",
                                           "updatedAt":  "2025-03-02T16:23:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6gh1Al",
                                           "createdAt":  "2025-03-03T04:00:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Should they be included in one issue?\n\nThey can be listed in this issue or in a new issue. It does not matter a whole lot.\n\n\u003e Should the message say \".NET 5+\" or \".NET 10+\"?\n\nVast majority of the obsoletion messages does not mention any version numbers: https://github.com/dotnet/runtime/blob/main/docs/project/list-of-diagnostics.md#obsoletion-diagnostics-syslib0001---syslib0999 . (A few messages do mention a version number. I guess it was an oversight.)",
                                           "updatedAt":  "2025-03-03T04:00:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6hD3n_",
                                           "createdAt":  "2025-03-05T21:43:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-03-05T21:43:22Z"
                                       }
                                   ],
                         "totalCount":  9
                     },
        "title":  "[API Proposal]: Obsolete attributes under S.R.CompilerServices with no effect",
        "labels":  [
                       "api-suggestion",
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/114217",
        "createdAt":  "2025-04-03T15:35:46Z",
        "number":  114217,
        "author":  "lateralusX",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-31T15:13:30Z",
        "body":  "EventPipe events like ModuleDCStop, DomainModuleDCStop, KnownPathProbed, ResolutionAttempted, KnownPathProbed, AssemblyLoaderStop mixes relative and absolute paths for assemblies in fileds like ModuleILPath, FilePath, ResultAssemblyPath etc. On OSX these paths tend to always be absolute. CoreCLR on Android should either use relative or absolute paths for these fields.\n\nData was primarily collected on Android sample HelloWorld in dotnet/runtime repro. In this scenario host extract all assemblies out of APK into internal file system on before running app, so this issue might be related to the host and/or how these paths are resolved when emitting the events. Once figured out on the sample, we should also verify that we get expected behavior when running together with dotnet Android SDK, since they use different solutions depending on how the app gets build. It also utilizes customization to assembly loader that would need to be validated together with above EventPipe events.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOpXpYPQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6leZPm",
                                           "createdAt":  "2025-04-03T15:35:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to \u0027arch-android\u0027: @vitek-karas, @simonrozsival, @steveisok, @akoeplinger\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-04-03T15:35:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6leZYA",
                                           "createdAt":  "2025-04-03T15:36:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @tommcdon\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-04-03T15:36:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6leZYd",
                                           "createdAt":  "2025-04-03T15:36:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-04-03T15:36:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6leZc2",
                                           "createdAt":  "2025-04-03T15:36:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @tommcdon\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-04-03T15:36:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6leZdW",
                                           "createdAt":  "2025-04-03T15:36:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-04-03T15:36:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6lelg9",
                                           "createdAt":  "2025-04-03T15:54:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-04-03T15:54:33Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "[android] EventPipe loader events on CoreCLR Android mixes relative/absolute paths.",
        "labels":  [
                       "area-AssemblyLoader-coreclr",
                       "os-android"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/119647",
        "createdAt":  "2025-09-12T15:36:18Z",
        "number":  119647,
        "author":  "MichaelKetting",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-18T12:05:39Z",
        "body":  "### Description\n\n.NET 10 (at least Preview 6 and RC-1) does not properly release the handle for assemblies loaded via AssemblyLoadContext after the AssemblyLoadContext was unloaded and gargable collected.\n\n### Reproduction Steps\n\nThe attached example contains a console application. The application will copy an assembly (for simplicity\u0027s sake, its own assembly) into sub-folder \"temp\" and then load this assembly into an AssemblyLoadContext. It will then dispose the AssemblyLoadContext and wait until it was garbage collected. Lastly, it will attempt to delete the sub-folder \"temp\" and thus the recently unloaded assembly. \n\nCorrect:\nWhen executed in .net 8 or .net 9, it completes without error and the BIN folder does not contain a sub-folder \"temp\".\n\nIncorrrect:\nWhen executed in .net 10, the delete operation fails because the process still holds a handle on the already unloaded assembly, preventing the deletion.\n\n[AssemblyLoadContextProblem.zip](https://github.com/user-attachments/files/22301106/AssemblyLoadContextProblem.zip)\n\n### Expected behavior\n\nNo particular console ouput after the run has completed in .net 8 or .net 9 and no sub-folder \"temp\".\n\n### Actual behavior\n\nWhen run in .net 10, the sub-folder \"temp\" with the assembly \"Example.dll\" remains behind. The console shows the following output:\n```\nUnhandled exception. System.UnauthorizedAccessException: Access to the path \u0027Example.dll\u0027 is denied.\n   at System.IO.FileSystem.RemoveDirectoryRecursive(String fullPath, WIN32_FIND_DATA\u0026 findData, Boolean topLevel)\n   at System.IO.FileSystem.RemoveDirectory(String fullPath, Boolean recursive)\n   at Example.Program.Main() in C:\\Repros\\AssemblyLoadContextProblem\\Program.cs:line 32\n   at Example.Program.Main()\n```\n\n### Regression?\n\nThis worked in .net 8 and .net 9 but is broken in .net 10 preview.6 and .net 10 rc-1. The exact iteration of .net 10 previews this regression was introduced has not been researched.\n\n### Known Workarounds\n\nnone\n\n### Configuration\n\n.net 8\n.net 9\n.net 10\nWindows x64\nRelease and Debug build\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOxR41tw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc7D2Mdy",
                                           "createdAt":  "2025-09-12T15:37:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-09-12T15:37:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7D2Qot",
                                           "createdAt":  "2025-09-12T15:40:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MihuBot",
                                           "body":  "I\u0027m a bot. Here is a possible related and/or duplicate issue (I may be wrong):\n- https://github.com/dotnet/runtime/issues/39609",
                                           "updatedAt":  "2025-09-12T15:40:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7D53c2",
                                           "createdAt":  "2025-09-12T20:23:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "agocke",
                                           "body":  "@jkoritzinsky Can you take a look at this?",
                                           "updatedAt":  "2025-09-12T20:23:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7EBWMq",
                                           "createdAt":  "2025-09-13T17:57:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Seabizkit",
                                           "body":  "only saw this after and put some some details here\nhttps://github.com/dotnet/runtime/issues/116142?utm_source=chatgpt.com\n\nbut maybe my issue is more linked to this\n",
                                           "updatedAt":  "2025-09-13T17:57:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7EBduX",
                                           "createdAt":  "2025-09-13T18:34:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichaelKetting",
                                           "body":  "Thanks for chiming in @Seabizkit ! Yeah, I found that issue, too, when I checked if mine\u0027s already known and I think that one\u0027s reproducible in .net 8, if I understood the issue author correctly. And yep, your description in the other issue sounds like mine.",
                                           "updatedAt":  "2025-09-13T18:34:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7FAoTQ",
                                           "createdAt":  "2025-09-18T03:22:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEizR9A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "Seabizkit",
                                                                               "createdAt":  "2025-09-18T09:14:18Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "agocke",
                                           "body":  "I can repro this -- it looks like problem is not in unloading itself, but in releasing the file handle. I haven\u0027t yet found what\u0027s keeping the file handle alive.",
                                           "updatedAt":  "2025-09-18T03:22:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7FCUnE",
                                           "createdAt":  "2025-09-18T07:05:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEizR5Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "Seabizkit",
                                                                               "createdAt":  "2025-09-18T09:14:15Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "MichaelKetting",
                                           "body":  "Thank you for the update @agocke!",
                                           "updatedAt":  "2025-09-18T07:05:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7FHBst",
                                           "createdAt":  "2025-09-18T11:30:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "I am not sure what your code looks like, but if you have a weak reference on the AssemblyLoadContext and use that as an indicator of the unload completion, then it is possible that it will become invalid before the assemblies are released. If that\u0027s the case, can you try to use weak references on the assemblies themselves to see if that helps? Also, what kind of a weak reference constructor you are using? Do you pass in the trackResurrection argument set to 1?",
                                           "updatedAt":  "2025-09-18T11:30:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7FHSBR",
                                           "createdAt":  "2025-09-18T11:47:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "Ah, I can see that you have shared a link to a repro that I\u0027ve missed before. I can see you don\u0027t pass in the trackResurrection argument set to true and that\u0027s likely the problem, because the AssemblyLoadContext is actually being resurrected and without this argument, the weak reference would be invalidated at the first time the AssemblyLoadContext finalizer is called, but you really want to keep tracking it until it is really gone.",
                                           "updatedAt":  "2025-09-18T11:47:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7FHZOQ",
                                           "createdAt":  "2025-09-18T11:54:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "Hmm, that actually didn\u0027t help, I\u0027ve tried.",
                                           "updatedAt":  "2025-09-18T11:54:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7FHjW3",
                                           "createdAt":  "2025-09-18T12:05:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichaelKetting",
                                           "body":  "@janvorli Thank you for the updates! I\u0027m happy to repair anything that\u0027s broken with the solution, even if it accidently worked in .net 8 and .net 9 :) Since you already tested it, I won\u0027t repeat that step.",
                                           "updatedAt":  "2025-09-18T12:05:39Z"
                                       }
                                   ],
                         "totalCount":  11
                     },
        "title":  "Regression in AssemblyLoadContext (net10-rc.1)",
        "labels":  [
                       "area-AssemblyLoader-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/119648",
        "createdAt":  "2025-09-12T15:43:14Z",
        "number":  119648,
        "author":  "apilatosba",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-12T19:33:02Z",
        "body":  "### Description\n\nGood morning. I want to reload a dll at runtime but I can\u0027t. I have two programs lets name them host and plugin. Host compiles to an executable and plugin compiles to a dll. Host loads a function from the plugin at runtime and i make changes to the plugin and recompile it. And then in the host i want to reload the plugin dll and want to use the updated function without needing the relaunch the host program. i have created a [small example](https://github.com/apilatosba/dotnet-reload-issue) where this issue exist. For reference here is the code:\n\nHost.cs:\n\n```cs\nusing System;\nusing System.Reflection;\nusing System.Runtime.Loader;\n\nnamespace Host {\n   public class PluginAssemblyLoadContext : AssemblyLoadContext {\n      public PluginAssemblyLoadContext() : base(true) { }\n   }\n\n   public class HostState {\n      public Assembly                  pluginAssembly;\n      public PluginAssemblyLoadContext   loadContext;\n      public Action                    pluginExecute;\n   }\n\n   public static class Host {\n      public const string PLUGIN_PATH = \"../plugin/bin/Debug/net9.0/plugin.dll\";\n\n      public static void Main() {\n         HostState host = new HostState();\n         host.loadContext = new PluginAssemblyLoadContext();\n         ReloadDll(host);\n\n         Console.WriteLine(\"Press E to execute the plugin, R to reload, or Q to quit.\");\n\n         for (;;) {\n            var key = Console.ReadKey(true);\n            if (false) {\n            } else if (key.Key == ConsoleKey.E) {\n               host.pluginExecute.Invoke();\n            } else if (key.Key == ConsoleKey.R) {\n               ReloadDll(host);\n            } else if (key.Key == ConsoleKey.Q) {\n               return;\n            }\n         }\n      }\n\n      public static void ReloadDll(HostState host) {\n         host.pluginAssembly = null;\n         host.pluginExecute = null;\n\n         GC.Collect();\n         GC.WaitForPendingFinalizers();\n\n         host.loadContext?.Unload();\n\n         GC.Collect();\n         GC.WaitForPendingFinalizers();\n\n         host.loadContext = new PluginAssemblyLoadContext();\n         host.pluginAssembly = host.loadContext.LoadFromAssemblyPath(Path.GetFullPath(PLUGIN_PATH));\n\n         Type type = host.pluginAssembly.GetType(\"Plugin\");\n         MethodInfo methodInfo = type.GetMethod(\"Execute\", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static, []);\n\n         if (methodInfo != null) {\n            host.pluginExecute = methodInfo.CreateDelegate\u003cAction\u003e();\n         }\n      }\n   }\n}\n```\n\nPlugin.cs:\n\n```cs\nusing System;\n\npublic static class Plugin {\n   public static void Execute() {\n      Console.WriteLine(\"1\");\n   }\n}\n```\n\n## The Scenario\nI launch the host program. I press E to execute plugin. I got the output \"1\". I go to Plugin.cs. I change Execute() function to output \"2\" instead of \"1\". I go back to the terminal where host program is running. I press R and then I press E.\n\n\n#### What Happens\nI got the output \"1\" again.\n\n#### What should have happened\nI should have got the output \"2\" instead.\n\n#### What I have tried\n- I tried to set every reference to null which i obtained from the PluginAssemblyLoadContext as mentioned in [the third remark of ms docs](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.loader.assemblyloadcontext.unload?view=net-9.0)\n- I tried to change the assembly version when i build the plugin.dll but that didn\u0027t help either.\n- Called `GC.Collect()` and `GC.WaitForPendingFinalizers()` to make sure every reference gets garbage collected.\n\n#### Why I want to do this\nI have a game engine and i want to be able reload the game dll without needing to restart the editor of the engine. So in this case host would be the editor of the engine and plugin would be the game.\n\n#### Specs\n- cpu: x86-64\n- os: debian sid\n- dotnet sdk version: 9.0.305\n\n##### -\n\nAny idea how to reload a dll at runtime? Any help would be appreciated.\n\n\n\n### Reproduction Steps\n\nclone the [repo](https://github.com/apilatosba/dotnet-reload-issue) and then follow the scenario above.\n\n### Expected behavior\n\nto be able to execute the new function in recompled plugin.dll\n\n### Actual behavior\n\nstill old function is being called.\n\n### Regression?\n\nidk\n\n### Known Workarounds\n\ni know no workarounds\n\n### Configuration\n\n1) `dotnet --version`: 9.0.305\n2) os: debian sid\n3) cpu architecture: x86-64\n4) i dont think this problem is specific to this configuration tho i have not tried other configurations.\n\n### Other information\n\ni think the problem is the AssemblyLoadContext.Unload() function doesn\u0027t unload the assembly thats loaded from it.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOw-VUxg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc7D3Bo2",
                                           "createdAt":  "2025-09-12T16:30:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-09-12T16:30:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7D3EM4",
                                           "createdAt":  "2025-09-12T16:32:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "`AssemblyLoadContext.Unload` doesn\u0027t do the unload work. It\u0027s even not necessary for unloading. It just prevents loading more assemblies into it.\n\nThe actual thing to do for unloading is to clear the `loadContext` field. An ALC can only be unloaded if it\u0027s cleared by GC.",
                                           "updatedAt":  "2025-09-12T16:32:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7D4bmL",
                                           "createdAt":  "2025-09-12T18:03:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "apilatosba",
                                           "body":  "what do you mean by clearing the loadContext field and how can i do that? Do you mean setting the loadContext to null or another object? I already set loadContext to a new PluginAssemblyLoadContext in ReloadDll(). or do you mean something else?",
                                           "updatedAt":  "2025-09-12T18:03:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7D5VTG",
                                           "createdAt":  "2025-09-12T19:33:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "See https://learn.microsoft.com/en-us/dotnet/standard/assembly/unloadability\n\nThings which I would definitely try is - isolate the cleanup and unloading of the assembly into its own method which is disabled for inlining - this avoid any potential problems with local keeping the assembly alive on the stack.\nLoop around GC.Collect - it may take several GCs to completely unload the assembly - using the test through a weak ref as shown in the article above is one way to terminate the loop.\n\nIf nothing helps the article has some tips what to look for.",
                                           "updatedAt":  "2025-09-12T19:33:02Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Loaded assemblies from an AssemblyLoadContext not unloaded on AssemblyLoadContext.Unload() call",
        "labels":  [
                       "area-AssemblyLoader-coreclr",
                       "untriaged"
                   ]
    }
]
