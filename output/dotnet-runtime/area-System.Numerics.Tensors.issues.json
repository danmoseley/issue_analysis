[
    {
        "url":  "https://github.com/dotnet/runtime/issues/28867",
        "createdAt":  "2019-03-04T22:10:17Z",
        "number":  28867,
        "author":  "tannergooding",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOBUvoYw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mdabros",
                                            "createdAt":  "2019-03-05T07:22:25Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "ericstj",
                                            "createdAt":  "2019-03-05T19:39:00Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "interesaaat",
                                            "createdAt":  "2019-03-06T21:57:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "alexanderkozlenko",
                                            "createdAt":  "2019-03-13T08:35:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "HurricanKai",
                                            "createdAt":  "2020-06-15T15:25:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "vpenades",
                                            "createdAt":  "2020-10-26T21:16:45Z"
                                        }
                                    ],
                          "totalCount":  6
                      },
        "updatedAt":  "2025-01-07T17:25:21Z",
        "body":  "### Rationale\r\n\r\nWe would like to expose a set of types that  allow exchange and interop between the various tensor frameworks. Today, the types that enable this are a set of classes with an abstract base and were taken from the initial investigations in corefxlab. However, these types put an unnecessary burden on each framework exposing a Tensor type in that they either need to extend these types themselves or they need to expose additional APIs that accept this type for interop/exchange to happen. It also requires that these types be implemented as classes, which may cause a performance hit as the common case is that the frameworks instead often implement these types as structs wrapping some backing memory.\r\n\r\nAfter a number of discussions, it was determined that we should move forward with exposing these types as a set of interfaces instead. This allows the existing frameworks to easily extend their existing types (whether they are classes or structs) to be compatible with the new interface types. It also allows library authors to easily support any tensor type will still allowing them to easily get the framework specific type or to efficiently specialize the handling for specific input types.\r\n\r\n\r\n### Proposed APIs\r\n\r\nThe following is the new proposed surface area. The existing types (which are not listed, for simplicity) would be removed and would no longer be available.\r\n\r\n```csharp\r\n\r\nnamespace System.Numerics.Tensors\r\n{\r\n    public interface ITensor\u003cT\u003e\r\n    {\r\n        ReadOnlySpan\u003cint\u003e Dimensions { get; }\r\n        int Rank { get; }\r\n\r\n        T this[params int[] indices] { get; set; }\r\n        T this[ReadOnlySpan\u003cint\u003e indices] { get; set; }\r\n\r\n        ITensor\u003cT\u003e Slice(int[] startIndices, int[] lengths);\r\n\r\n        ITensor\u003cT\u003e Reshape(ReadOnlySpan\u003cint\u003e dimensions);\r\n    }\r\n\r\n    public interface IDenseTensor\u003cT\u003e : ITensor\u003cT\u003e\r\n    {\r\n        Span\u003cT\u003e Buffer { get; }\r\n        int ElementCount { get; }\r\n        bool IsColumnMajor { get; }\r\n        ReadOnlySpan\u003cint\u003e Strides { get; }\r\n\r\n        void Fill(T value);\r\n        ISparseTensor\u003cT\u003e ToSparseTensor();\r\n    }\r\n\r\n    public interface ISparseTensor\u003cT\u003e : ITensor\u003cT\u003e\r\n    {\r\n        int NonZeroCount { get; }\r\n\r\n        Span\u003cT\u003e GetNonZeroValues();\r\n        Span\u003cint\u003e GetNonZeroIndices();\r\n        IDenseTensor\u003cT\u003e ToDenseTensor();\r\n    }\r\n}\r\n```\r\n\r\n### Additional Details\r\n\r\nSome generale notes:\r\n* We decided that compressed sparse tensors were not worth exposing at this time.\r\n* We are not going to be exposing the `Clone` or `CloneEmpty` methods. This will require users to make clones are create new instances using concrete types.\r\n* We may consider also exposing a primitive struct implementation for these interfaces, but that is a separate proposal.\r\n\r\nSome notes about `ITensor\u003cT\u003e`:\r\n* We determined `ITensor\u003cT\u003e` should not implement `IList\u003cT\u003e` or `ICollection\u003cT\u003e` as they do not properly expose the multi-dimensional concept of a tensor.\r\n* `Rank` is a convenience overload for `Dimensions.Length`. However, many frameworks expose this as a specific concept.\r\n* The indexer that takes a `ROSpan\u003cint\u003e` could be made `params` with the proposed C# Language Feature: https://github.com/dotnet/csharplang/pull/2293\r\n* `Reshape` is exposed here as many other frameworks also expose it as a base method due to it also being applicable to sparse tensors.\r\n\r\nSome notes about `IDenseTensor\u003cT\u003e`:\r\n* `IsColumnMajor` is not the best name since it doesn\u0027t necessarily map cleanly to multiple dimensions. However, `System.Array` already uses the same name.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOmYhgEQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ2OTQ0MjA2OQ==",
                                           "createdAt":  "2019-03-04T22:10:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "### Open Questions\r\n\r\nSome general open questions:\r\n* Should we expose the concept of a `IReadOnlyTensor\u003cT\u003e`?\r\n\r\nSome open questions about `ITensor\u003cT\u003e`:\r\n* Should `ITensor\u003cT\u003e` implement `IEnumerable\u003cT\u003e` and if so, what would it mean for a sparse tensor?\r\n  * If no, should we make `IDenseTensor\u003cT\u003e` implement it instead?\r\n* Should `ITensor.Dimensions` be called `Shape` instead? Other frameworks exposing this as `Shape` often have a concete type and may carry additional information, such as a name.\r\n* Ideally the `ITensor\u003cT\u003e.Slice` method would take `params Range[] ranges`. However, this type will be `netstandard2.1` only. An alternative to the proposed API would be to take a `params (int startIndex, int length)[] ranges` instead.\r\n\r\nSome open questions about `IDenseTensor\u003cT\u003e`:\r\n* Is returning a `Span\u003cT\u003e` for `Buffer` sufficient or should it be `Memory\u003cT\u003e` instead?\r\n  * What if the underlying buffer is larger than `int.MaxValue`?\r\n  * Maybe we should return `Memory\u003cT\u003e` and have some kind of efficient `ref struct TensorView` for the case where you want to materialize and reuse a `Span\u003cT\u003e`. This doesn\u0027t play nicely when the underlying element count can change, however.\r\n* Do we need to expose `ElementCount` for convenience or should we tell users to just get the product of its dimensions?\r\n  * Should `ElementCount` return a long since the combined length of all dimensions could be larger than `int.MaxValue`?\r\n  * Should this be exposed on `ITensor\u003cT\u003e` instead and what would it mean for a sparse tensor if it was (i.e. is it the product of the dimensions or is it the non-zero element count)?\r\n* Should we expose `ToSparseTensor` only here or move it to `ITensor\u003cT\u003e`? The latter would allow users to avoid type checks if they know they need or want a `SparseTensor`. Otherwise, they need to basically do `ISparseTensor\u003cT\u003e sparseTensor = (tensor is IDenseTensor\u003cT\u003e denseTensor) ? denseTensor.ToSparseTensor() : (ISparseTensor\u003cT\u003e)(tensor);`, which would throw if someone inherited from `ITensor` directly/separately.\r\n* Should we expose a mechanism for getting/setting a value using the linear index?\r\n\r\nSome open questions about `ISparseTensor\u003cT\u003e`:\r\n* Should `GetNonZeroValues` and `GetNonZeroIndices` be separate or should we provide a mechanism to get both at once?\r\n* `ToDenseTensor` has the same open question as `IDenseTensor.ToSparseTensor`",
                                           "updatedAt":  "2019-03-04T22:10:22Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ2OTQ0MjI0OA==",
                                           "createdAt":  "2019-03-04T22:10:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "CC. @danmosemsft, @eerhardt.",
                                           "updatedAt":  "2019-03-04T22:10:52Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ2OTQ0MjQ1OQ==",
                                           "createdAt":  "2019-03-04T22:11:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "CC. @terrajobst. This will require a dedicated session to review (after I finish get sign-off from the partner teams on the proposal).",
                                           "updatedAt":  "2019-03-04T22:11:32Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ2OTQ0MzExNQ==",
                                           "createdAt":  "2019-03-04T22:13:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "CC. @interesaaat, @markusweimer, @ericstj",
                                           "updatedAt":  "2019-03-04T22:13:37Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ2OTQ3OTU1MA==",
                                           "createdAt":  "2019-03-05T00:10:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "eerhardt",
                                           "body":  "\u003e `Span\u003cint\u003e GetNonZeroIndices();`\r\n\r\nI assume these are \"linearized\" indices? Do we have any convenience APIs planned to get the index collection in dimensions from a \"linearized\" index?\r\n\r\n\u003e `Span\u003cT\u003e GetNonZeroValues();`\r\n\u003e  `Span\u003cint\u003e GetNonZeroIndices();`\r\n\r\nI wonder if `Span` helps or hurts here. If the values and indices aren\u0027t stored in a contiguous piece of memory for a SparseTensor, it would force implementers to copy the values/indices, right? \r\n\r\n\u003e Should we expose a mechanism for getting/setting a value using the linear index?\r\n\r\nWe do for DenseTensors, right? `IDenseTensor.Buffer[i]` will be the linear index.\r\n\r\n\u003e IsColumnMajor is not the best name since it doesn\u0027t necessarily map cleanly to multiple dimensions. However, System.Array already uses the same name.\r\n\r\nWhere does `System.Array` expose this name? I agree `IsColumnMajor` is the most understandable name for this property, but I am just missing where it is used in System.Array.",
                                           "updatedAt":  "2019-03-05T00:10:00Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ2OTg3MDUyOQ==",
                                           "createdAt":  "2019-03-05T21:46:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "CC. @migueldeicaza ",
                                           "updatedAt":  "2019-03-05T21:46:54Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ3MDI5OTcwNw==",
                                           "createdAt":  "2019-03-06T22:17:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "interesaaat",
                                           "body":  "\u003e \u003e `Span\u003cT\u003e GetNonZeroValues();`\r\n\u003e \u003e `Span\u003cint\u003e GetNonZeroIndices();`\r\n\u003e \r\n\u003e I wonder if `Span` helps or hurts here. If the values and indices aren\u0027t stored in a contiguous piece of memory for a SparseTensor, it would force implementers to copy the values/indices, right?\r\n\r\nThis is a good point. I look at these more as `IEnumerable`s.",
                                           "updatedAt":  "2019-03-06T22:17:46Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ3MDk2NDY3OA==",
                                           "createdAt":  "2019-03-08T15:20:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAk1aUw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "dasMulli",
                                                                               "createdAt":  "2019-03-12T12:34:29Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "eerhardt",
                                           "body":  "\u003e ITensor\u003cT\u003e Slice(int[] startIndices, int[] lengths);\r\n\r\nI wonder if we could instead introduce a `TensorRange` type here. Someday it could maybe be implicitly convertible to/from `System.Range`.",
                                           "updatedAt":  "2019-03-08T15:20:50Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ3MTk4Nzk5Mg==",
                                           "createdAt":  "2019-03-12T12:54:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dasMulli",
                                           "body":  "I like having an abstraction over actual tensor implementations so that in theory one could differentiate between \"views\" onto a tensor and actual \"materialized\" tensors.\r\nAs i explained in https://github.com/dotnet/corefx/issues/34525#issuecomment-470736431, my use case at the moment involves using a lot of operation on matrices and the first perf issues hit occur because of copying that needs to be done when performing operations. Most of them can be done in-place but my goal would be to have abstract views over them that would be materialized when needed - similar to how `IEnumerable\u003cT\u003e` works with LINQ (where materialization is done via `ToList()`/`ToArray()`). This would allow for more composable and reusable implementations for part of algorithms. E.g. I  don\u0027t really need to allocate more than `n*m` memory when calculating `norm(1 - 2*a + b)`, but `2*a` and `b` could be results from other algorithms that i want to reuse.\r\n(btw i keep `IList\u003cMatrix\u003cdouble\u003e\u003e` in a few places so desperately awaiting public tensors and math functions for them ^^)\r\nSo personally I like seing an abstraction over tensors that could internally trigger materialization when needed or hide a mathematical operation / slice behind the indexer while keeping a reference to the source tensor.\r\n\r\nregarding `ISparseTensor\u003cT\u003e ToSparseTensor()` and `IDenseTensor\u003cT\u003e ToDenseTensor()`:\r\nI don\u0027t think that any implementation of a dense or sparse tensor should also be required to implement conversion between dense and sparse tensors. For easy conversion, there should be extension methods that create the default types - similar to how `ToList()` / `ToArray()` / `ToHashSet()` exist on `IEnumerable\u003cT\u003e`. The implementation could then have a few optimizations `tensor is SlicedDenseTensor\u003cT\u003e` for system provided implementations.",
                                           "updatedAt":  "2019-03-12T12:54:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ3MjEyOTE1Mg==",
                                           "createdAt":  "2019-03-12T18:35:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "glebuk",
                                           "body":  "Notes:\r\n1. Currently user does not know if they need to convert dense to sparse.  Moving `int NonZeroCount { get; }` to `Tensor\u003cT\u003e` - that would allow user to decide on whether they need to convert to `SparseTensor\u003cT\u003e`\r\n2. Multi-dimensional sparse tensor:    how is \r\n```\r\n   Span\u003cT\u003e GetNonZeroValues();\r\n   Span\u003cint\u003e GetNonZeroIndices(); \r\n```\r\nusable in multiple dimensions?  Suggest return tensors of values\r\n3. Consider having `ReadOnlyTensor\u003c\u003e` as default type as some native or vbuffer backing types might not allow free modification of underlying data.\r\n ",
                                           "updatedAt":  "2019-03-12T18:35:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ3MjE4MjUwNQ==",
                                           "createdAt":  "2019-03-12T21:10:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "terrajobst",
                                           "body":  "Notes are [here](https://github.com/dotnet/apireviews/pull/93).",
                                           "updatedAt":  "2019-03-12T21:10:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ3Mjk3MTM0OA==",
                                           "createdAt":  "2019-03-14T17:16:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wschin",
                                           "body":  "`IsColumnMajor` doesn\u0027t make a lot of sense to me. Could we remove it? The definition of column is quite clear to a matrix, but what is a column in a tensor? Why is it called column rather than row?",
                                           "updatedAt":  "2019-03-14T17:16:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4NjM5NzgxNQ==",
                                           "createdAt":  "2019-04-24T19:44:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gramalingam",
                                           "body":  "(Repeating a couple of the earlier questions): How are multi-dimensional sparse-tensors handled? Is the index-value a linearized index-value?",
                                           "updatedAt":  "2019-04-24T19:44:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ZiGAR",
                                           "createdAt":  "2025-01-07T17:25:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "terrajobst",
                                           "body":  "@tannergooding should this be closed?",
                                           "updatedAt":  "2025-01-07T17:25:08Z"
                                       }
                                   ],
                         "totalCount":  14
                     },
        "title":  "Expose the System.Numerics.Tensors interchange types as interfaces",
        "labels":  [
                       "api-suggestion",
                       "area-System.Numerics.Tensors"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/93217",
        "createdAt":  "2023-10-09T13:42:32Z",
        "number":  93217,
        "author":  "stephentoub",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC_i5GA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "gfoidl",
                                            "createdAt":  "2023-10-09T14:05:36Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "xoofx",
                                            "createdAt":  "2023-10-14T06:03:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "asmirnov82",
                                            "createdAt":  "2024-01-05T09:23:53Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Daniel-Svensson",
                                            "createdAt":  "2024-02-16T19:51:46Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Windows10CE",
                                            "createdAt":  "2024-05-21T01:42:34Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sunghwan2789",
                                            "createdAt":  "2024-06-29T07:37:36Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "JeffreySax",
                                            "createdAt":  "2024-11-03T00:21:51Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "GGG-KILLER",
                                            "createdAt":  "2025-02-27T15:23:50Z"
                                        }
                                    ],
                          "totalCount":  8
                      },
        "updatedAt":  "2024-02-16T23:32:24Z",
        "body":  "This is more of a tracking issue right now than a proper API proposal.\r\n\r\nIn `TensorPrimitives`, we now have ~40 routines, most of which are vectorized across `Vector128`, `Vector256`, `Vector512`, plus a scalar fallback.  Rather than duplicate all of the boilerplate across them, we employ several helper functions that are parameterized via generic method parameters constrained to specific interfaces, with a caller supplying the kernel of the processing via a struct that implements the relevant interfaces.  For example, `TensorPrimitives.Abs` (which computes the absolute value of each input element and stores the result into the corresponding destination slot) is implemented as:\r\n```C#\r\n        public static void Abs(ReadOnlySpan\u003cfloat\u003e x, Span\u003cfloat\u003e destination) =\u003e\r\n            InvokeSpanIntoSpan\u003cAbsoluteOperator\u003e(x, destination);\r\n```\r\nand `TensorPrimitives.Add` (which adds each pair of elements and stores the result for each into the corresponding destination slot) is implemented as:\r\n```C#\r\n        public static void Add(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cfloat\u003e destination) =\u003e\r\n            InvokeSpanSpanIntoSpan\u003cAddOperator\u003e(x, y, destination);\r\n```\r\nThere are helpers for various shapes of these element-wise operations, as well as helpers for performing various forms of aggregations. For example, `TensorPrimitives.ProductOfSums` (which sums each element-wise pair from the two inputs and multiplies together all of those sums) is implemented as:\r\n```C#\r\n        public static float ProductOfSums(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y)\r\n        {\r\n            ...\r\n            return Aggregate\u003cAddOperator, MultiplyOperator\u003e(x, y);\r\n        }\r\n```\r\nThese \"Operator\"s each implement various interfaces for `IUnaryOperator`, `IBinaryOperator`, etc. For example, the `AddMultipleOperator` (which implements `ITernaryOperator`) is defined as:\r\n```C#\r\n        readonly struct AddMultiplyOperator : ITernaryOperator\r\n        {\r\n            public static float Invoke(float x, float y, float z) =\u003e (x + y) * z;\r\n            public static Vector128\u003cfloat\u003e Invoke(Vector128\u003cfloat\u003e x, Vector128\u003cfloat\u003e y, Vector128\u003cfloat\u003e z) =\u003e (x + y) * z;\r\n            public static Vector256\u003cfloat\u003e Invoke(Vector256\u003cfloat\u003e x, Vector256\u003cfloat\u003e y, Vector256\u003cfloat\u003e z) =\u003e (x + y) * z;\r\n            public static Vector512\u003cfloat\u003e Invoke(Vector512\u003cfloat\u003e x, Vector512\u003cfloat\u003e y, Vector512\u003cfloat\u003e z) =\u003e (x + y) * z;\r\n        }\r\n```\r\n\r\nWe should consider exposing a set of such helpers and interfaces, to enable developers to express efficient vectorized implementations across various shapes without having to write all the boilerplate themselves.  With an `IVector` as proposed in https://github.com/dotnet/runtime/issues/76244 and as prototyped internally in https://github.com/dotnet/runtime/pull/90764, and if we exposed a `Scalar\u003cT\u003e` that also implemented this interface, this could be consolidated down to just a single method and that would also be more future proof for vector types that might be added in the future, e.g.\r\n```C#\r\n        readonly struct AddMultiplyOperator\u003cT\u003e : ITernaryOperator\u003cT\u003e\r\n        {\r\n            public static TVector Invoke\u003cTVector\u003e(TVector x, TVector y, TVector z) where TVector : ISimdVector\u003cTVector, T\u003e =\u003e\r\n                (x + y) * z;\r\n        }\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOdCJhOw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5ofUnG",
                                           "createdAt":  "2023-10-09T13:42:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-numerics-tensors\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThis is more of a tracking issue right now than a proper API proposal.\r\n\r\nIn `TensorPrimitives`, we now have ~40 routines, most of which are vectorized across `Vector128`, `Vector256`, `Vector512`, plus a scalar fallback.  Rather than duplicate all of the boilerplate across them, we employ several helper functions that are parameterized via generic method parameters constrained to specific interfaces, with a caller supplying the kernel of the processing via a struct that implements the relevant interfaces.  For example, `TensorPrimitives.Abs` (which computes the absolute value of each input element and stores the result into the corresponding destination slot) is implemented as:\r\n```C#\r\n        public static void Abs(ReadOnlySpan\u003cfloat\u003e x, Span\u003cfloat\u003e destination) =\u003e\r\n            InvokeSpanIntoSpan\u003cAbsoluteOperator\u003e(x, destination);\r\n```\r\nand `TensorPrimitives.Add` (which adds each pair of elements and stores the result for each into the corresponding destination slot) is implemented as:\r\n```C#\r\n        public static void Add(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cfloat\u003e destination) =\u003e\r\n            InvokeSpanSpanIntoSpan\u003cAddOperator\u003e(x, y, destination);\r\n```\r\nThere are helpers for various shapes of these element-wise operations, as well as helpers for performing various forms of aggregations. For example, `TensorPrimitives.ProductOfSums` (which sums each element-wise pair from the two inputs and multiplies together all of those sums) is implemented as:\r\n```C#\r\n        public static float ProductOfSums(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y)\r\n        {\r\n            ...\r\n            return Aggregate\u003cAddOperator, MultiplyOperator\u003e(x, y);\r\n        }\r\n```\r\nThese \"Operator\"s each implement various interfaces for `IUnaryOperator`, `IBinaryOperator`, etc. For example, the `AddMultipleOperator` (which implements `ITernaryOperator`) is defined as:\r\n```C#\r\n        readonly struct AddMultiplyOperator : ITernaryOperator\r\n        {\r\n            public static float Invoke(float x, float y, float z) =\u003e (x + y) * z;\r\n            public static Vector128\u003cfloat\u003e Invoke(Vector128\u003cfloat\u003e x, Vector128\u003cfloat\u003e y, Vector128\u003cfloat\u003e z) =\u003e (x + y) * z;\r\n            public static Vector256\u003cfloat\u003e Invoke(Vector256\u003cfloat\u003e x, Vector256\u003cfloat\u003e y, Vector256\u003cfloat\u003e z) =\u003e (x + y) * z;\r\n            public static Vector512\u003cfloat\u003e Invoke(Vector512\u003cfloat\u003e x, Vector512\u003cfloat\u003e y, Vector512\u003cfloat\u003e z) =\u003e (x + y) * z;\r\n        }\r\n```\r\n\r\nWe should consider exposing a set of such helpers and interfaces, to enable developers to express efficient vectorized implementations across various shapes without having to write all the boilerplate themselves.  With an `IVector` as proposed in https://github.com/dotnet/runtime/issues/76244 and as prototyped internally in https://github.com/dotnet/runtime/pull/90764, and if we exposed a `Scalar\u003cT\u003e` that also implemented this interface, this could be consolidated down to just a single method and that would also be more future proof for vector types that might be added in the future, e.g.\r\n```C#\r\n        readonly struct AddMultiplyOperator\u003cT\u003e : ITernaryOperator\u003cT\u003e\r\n        {\r\n            public static TVector Invoke\u003cTVector\u003e(TVector x, TVector y, TVector z) where TVector : ISimdVector\u003cTVector, T\u003e =\u003e\r\n                (x + y) * z;\r\n        }\r\n```\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003estephentoub\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Numerics.Tensors`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e9.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-10-09T13:42:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5v9o35",
                                           "createdAt":  "2024-01-05T10:13:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "asmirnov82",
                                           "body":  "It would be very useful to have extended versions of such helpers like InvokeSpanSpanIntoSpan and etc., these methods should allow to effectively work with span of different data types:\r\n\r\n```C#\r\nstatic void InvokeSpanSpanIntoSpan\u003cTResult, TBinaryOperator, T, TConverter\u003e(ReadOnlySpan\u003cTResult\u003e x, ReadOnlySpan\u003cT\u003e y, Span\u003cTResult\u003e destination)\r\n      where TBinaryOperator : struct, IBinaryOperator\u003cTResult\u003e\r\n      where TConverter : struct, IConverter\u003cTResult, T\u003e\r\n```\r\n\r\n```C#\r\nstatic void InvokeSpanSpanIntoSpan\u003cTResult, TBinaryOperator, T, TConverter\u003e(ReadOnlySpan\u003cT\u003e x, ReadOnlySpan\u003cTResult\u003e y, Span\u003cTResult\u003e destination)\r\n      where TBinaryOperator : struct, IBinaryOperator\u003cTResult\u003e\r\n      where TConverter : struct, IConverter\u003cTResult, T\u003e\r\n```\r\nand\r\n\r\n```C#\r\nstatic void InvokeSpanSpanIntoSpan\u003cTResult, TBinaryOperator, TX, TY, TConverterX, TConverterY\u003e(ReadOnlySpan\u003cTX\u003e x, ReadOnlySpan\u003cTY\u003e y, Span\u003cTResult\u003e destination)\r\n      where TBinaryOperator : struct, IBinaryOperator\u003cTResult\u003e\r\n      where TConverterX : struct, IConverter\u003cTResult, TX\u003e\r\n      where TConverterY : struct, IConverter\u003cTResult, TY\u003e\r\n```\r\nwhere `IConverter\u003cTResult,T\u003e` can be defined somewhat like this:\r\n```C#\r\ninterface IConverter\u003cTResult, T\u003e\r\n    where TResult : struct\r\n    where T : struct\r\n{\r\n\r\n    /// \u003csummary\u003e\r\n    /// True if conversion is suitable for low-level optimization using SIMD instructions.\r\n    /// \u003c/summary\u003e\r\n    static abstract bool SupportVectorization { get; }\r\n\r\n    /// \u003csummary\u003e\r\n    /// True if vectorized conversion requires widening.\r\n    /// \u003c/summary\u003e\r\n    static abstract bool RequiresWidening { get; }\r\n\r\n    /// \u003csummary\u003e\r\n    /// Performs not-vectorized conversion.\r\n    /// \u003c/summary\u003e\r\n    static abstract TResult Convert(T value);\r\n\r\n    /// \u003csummary\u003e\r\n    /// Performs vectorized conversion.\r\n    /// \u003c/summary\u003e\r\n    static abstract ISimdVector\u003cTResult\u003e Convert(ISimdVector\u003cT\u003e vector);\r\n\r\n    /// \u003csummary\u003e\r\n    /// Performs vectorized conversion, that requires widening.\r\n    /// \u003c/summary\u003e\r\n    static abstract (ISimdVector\u003c\u003cTResult\u003e Lower, ISimdVector\u003c\u003cTResult\u003e Upper) ConvertWithWidening(ISimdVector\u003cT\u003e vector);\r\n```\r\n\r\nThis functionality is required for the DataFrame generic math: https://github.com/dotnet/machinelearning/issues/6905",
                                           "updatedAt":  "2024-01-05T10:13:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wA5pI",
                                           "createdAt":  "2024-01-05T21:36:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "Why would the `IConverter` be required here? You could always define a TBinaryOperator that takes a `T`, returns a `TResult`, and does the conversion itself directly?",
                                           "updatedAt":  "2024-01-05T21:36:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wBMID",
                                           "createdAt":  "2024-01-05T23:01:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "asmirnov82",
                                           "body":  "Sorry, I don\u0027t get your idea. Seems we may talk about different things. Let me try to explain the issue that I faced and would like to solve with new TensorPrimitive API. The main idea of my proposal was to reuse existing generic binary operators and helper methods like InvokeSpanSpanIntoSpan for vectorized operation on arguments of different type. As DataFrame allow user to do math operations with every column inside it, different combination of input types should be supported, like:\r\n\r\n| Input types       | Output type  |\r\n|-------------------|----------------------|\r\n| int64, int64      | int64                |\r\n| int64, int32      | int64                |\r\n| int64, int16      | int64                |\r\n| int32, int32      | int32                |\r\n| int32, uint32     | int64                |\r\n| uint32, int16     | int64                |\r\n| double, int32     | double               |\r\n| double, float     | double               |\r\n| float,  int32     | float                |\r\n| float, double     | double               |\r\n| float, float      | float                |\r\n\r\nand etc.\r\n\r\nI just don\u0027t see how this conversion can be defined in TBinaryOperator using generic math, especially for vectors. The only way I see is to have concreate implementations for each operator for all existing type combinations (like AddOperator_IntLong, AddOperator_DoubleFloat and etc) - the resulting amount of operators will be huge. My thought was to have generic operators that operate with arguments, having both the same type, like we have now. And separate convertes for each type. In this case all conversions are defined only once. \r\n\r\nConverters know type details, like that converting float to double or int to double requires vector widening, vectorized conversion of long or ulong to double can be performed directly and byte to double or byte to long can\u0027t be vectorized.\r\n\r\nFor conversition that requires widening InvokeSpanSpanIntoSpan of course should have different implementation as it requires to read pair of vectors for one side for each vector from another side, but this can be hidded from public API.\r\n\r\nDo I miss something?\r\n",
                                           "updatedAt":  "2024-01-05T23:03:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc50ImE7",
                                           "createdAt":  "2024-02-16T13:43:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEJGs7A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "ROCKET",
                                                                               "user":  "asmirnov82",
                                                                               "createdAt":  "2024-02-17T05:24:19Z"
                                                                           },
                                                                           {
                                                                               "content":  "ROCKET",
                                                                               "user":  "GGG-KILLER",
                                                                               "createdAt":  "2025-03-10T02:37:26Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "aalmada",
                                           "body":  "I\u0027ve been working on an open-source geometry library that relies on generic math principles, aiming to enhance performance using SIMD technology. One specific area I\u0027ve been focusing on is optimizing the processing of collections of geometric entities. After experimenting with various concept prototypes and consulting with @tannergooding, I delved into exploring `System.Numerics.Tensors`. However, it didn\u0027t fulfill my needs at the time, so I decided to develop my own version of the library based on `Vector\u003cT\u003e` instead. Although it shares similarities with `System.Numerics.Tensors`, there are notable distinctions.\r\n\r\nA significant difference lies in the fact that my implementation handles all the same operations with fewer special cases, resulting in a more concise interface surface. I\u0027ve implemented all operators using the following interfaces:\r\n\r\n```csharp\r\npublic interface IOperator\r\n{\r\n    static virtual bool IsVectorizable =\u003e true;\r\n}\r\n\r\npublic interface IUnaryOperator\u003cT, TResult\u003e \r\n    : IOperator\r\n    where T : struct\r\n    where TResult : struct\r\n{\r\n    static abstract TResult Invoke(T x);\r\n    static abstract Vector\u003cTResult\u003e Invoke(ref readonly Vector\u003cT\u003e x);\r\n}\r\n\r\npublic interface IBinaryOperator\u003cT1, T2, TResult\u003e \r\n    : IOperator\r\n    where T1 : struct\r\n    where T2 : struct\r\n    where TResult : struct\r\n{\r\n    static abstract TResult Invoke(T1 x, T2 y);\r\n    static abstract Vector\u003cTResult\u003e Invoke(ref readonly Vector\u003cT1\u003e x, ref readonly Vector\u003cT2\u003e y);\r\n}\r\n\r\npublic interface IBinaryScalarOperator\u003cT1, T2, TResult\u003e \r\n    : IOperator\r\n    where T1 : struct\r\n    where TResult : struct\r\n{\r\n    static abstract TResult Invoke(T1 x, T2 y);\r\n    static abstract Vector\u003cTResult\u003e Invoke(ref readonly Vector\u003cT1\u003e x, T2 y);\r\n}\r\n\r\npublic interface ITernaryOperator\u003cT1, T2, T3, TResult\u003e \r\n    : IOperator\r\n    where T1 : struct\r\n    where T2 : struct\r\n    where T3 : struct\r\n    where TResult : struct\r\n{\r\n    static abstract TResult Invoke(T1 x, T2 y, T3 z);\r\n    static abstract Vector\u003cTResult\u003e Invoke(ref readonly Vector\u003cT1\u003e x, ref readonly Vector\u003cT2\u003e y, ref readonly Vector\u003cT3\u003e z);\r\n}\r\n\r\npublic interface IAggregationOperator\u003cT, TResult\u003e \r\n    : IBinaryOperator\u003cTResult, T, TResult\u003e\r\n    where T : struct\r\n    where TResult : struct\r\n{\r\n    static virtual TResult Seed =\u003e Throw.NotSupportedException\u003cTResult\u003e();\r\n    static abstract TResult Invoke(TResult x, TResult y);\r\n}\r\n```\r\n\r\nThe only operations I haven\u0027t implemented yet, which will require another interface, are the `IndexOf` operations.\r\n\r\nIt\u0027s worth mentioning that each parameter in these interfaces employs a different generic type, enabling broader coverage of cases and potentially greater adaptability in the future. This also solves the issues mentioned above by @asmirnov82.\r\n\r\nTo simplify usage, I\u0027ve included multiple overloads for just two methods, `Apply()` and `Aggregate()`, rather than creating unique method names for each parameter combination. This enhances user experience, as users only need to choose whether to apply or aggregate the operator and provide the relevant parameters.\r\n\r\nAn exception to this approach is `AggregatePropagateNan()`, which acts as a generalized version of your `MinMaxCore()`, expanding its usability to other scenarios. Operators must adhere to the existing `IAggregationOperator` interface. Consequently, its property is named `Seed` instead of `Identity`. Also, my implementation is much simpler as you can see [here](https://github.com/NetFabric/NetFabric.Numerics.Tensors/blob/vnext/src/NetFabric.Numerics.Tensors/AggregatePropagateNaN.cs).\r\n\r\nAdditionally, I\u0027ve introduced `Apply2` and `AggregatePropagateNan2()`, which can apply two operators in a single span iteration, facilitating operations like `SinCos()` and `MinMax()` respectively.\r\n\r\nFinally, I\u0027ve introduced the aggregation methods `Aggregate2D()`, `Aggregate3D()`, and `Aggregate4D()`. These methods are designed to aggregate data from spans containing elements with multiple values stored consecutively in memory. They prove particularly useful for managing aggregation operations on value-type vectors with multiple dimensions.\r\n\r\nLastly, I\u0027ve organized my implementation into smaller files for easier navigation. 😅\r\n\r\nComprehensive documentation accompanies my implementation, providing detailed insights into these concepts. Benchmarking data within the documentation suggests that `System.Numerics.Tensors` may not always be the optimal solution across various scenarios. You can find the documentation [here](https://netfabric.github.io/NetFabric.Numerics.Tensors/articles/Extending-the-library.html) and the benchmarking results [here](https://netfabric.github.io/NetFabric.Numerics.Tensors/articles/Benchmarks.html). The repository is available [here](https://github.com/NetFabric/NetFabric.Numerics.Tensors).\r\n\r\nIn summary, I pursued this alternative because `System.Numerics.Tensors` didn\u0027t meet my requirements, particularly its lack of extensibility. I\u0027m still open to leveraging `System.Numerics.Tensors` and contributing to its improvement efforts.",
                                           "updatedAt":  "2024-02-16T23:32:24Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "[API Proposal]: Vectorized span-processing helpers",
        "labels":  [
                       "area-System.Numerics.Tensors"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/93286",
        "createdAt":  "2023-10-10T12:56:43Z",
        "number":  93286,
        "author":  "stephentoub",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC-Y-TA==",
                          "nodes":  [
                                        {
                                            "content":  "EYES",
                                            "user":  "aloraman",
                                            "createdAt":  "2023-10-10T14:11:18Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "xoofx",
                                            "createdAt":  "2023-10-14T05:50:44Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "asmirnov82",
                                            "createdAt":  "2023-10-23T20:50:11Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "msedi",
                                            "createdAt":  "2023-11-26T21:25:12Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "asmirnov82",
                                            "createdAt":  "2024-02-03T06:57:46Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "ShreyasJejurkar",
                                            "createdAt":  "2024-02-03T14:17:37Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "ShreyasJejurkar",
                                            "createdAt":  "2024-02-03T14:17:37Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "ShreyasJejurkar",
                                            "createdAt":  "2024-02-03T14:17:41Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "Carl-Hugo",
                                            "createdAt":  "2024-03-27T03:28:08Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2024-08-20T13:13:57Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2024-08-20T13:14:06Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "juharris",
                                            "createdAt":  "2024-10-24T17:18:18Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "marosbeno",
                                            "createdAt":  "2024-12-28T14:56:26Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "tjwald",
                                            "createdAt":  "2025-01-23T08:23:05Z"
                                        }
                                    ],
                          "totalCount":  14
                      },
        "updatedAt":  "2025-07-25T21:05:41Z",
        "body":  "Regardless of any additional types we may want to add to `System.Numerics.Tensors`, we would like to expand the set of APIs exposed on the `TensorPrimitives` static class in a few ways (beyond the work done in .NET 8 in https://github.com/dotnet/runtime/issues/92219):\r\n\r\n- [ ] https://github.com/dotnet/runtime/issues/97193\r\n- [ ] Alignment improvements for `ConvertXx`, `CosineSimilarity`, `IndexOfMin`, `IndexOfMax`, `IndexOfMinMagnitude`, `IndexOfMaxMagnitude`\r\n- [x] https://github.com/dotnet/runtime/issues/98861\r\n- [ ] Additional operations defined in BLAS / LAPACK that don\u0027t currently have representation on `TensorPrimitives`\r\n- [ ] Perform a broader scan of ML.NET APIs, seeking more methods that should be on the post-GA backlog - @michaelgsharp\r\n  - We\u0027ve already covered all of the shared methods, but there are one-off implementations that might be worth productizing into TensorPrimitives\r\n- [ ] Additional operations that would enable completely removing the internal `CpuMath` class from ML.NET, e.g.  `Add` (with indices), `AddScale` (with indices), `DotProductSparse`, `MatrixTimesSource`, `ScaleAdd` improvement via `AddMultiply` or `MultipleAdd` overloads, `SdcaL1UpdateDense`, `SdcaL1UpdateSparse`, and `ZeroMatrixItems` (might exist in System.Memory).\r\n- [ ] Double-check the flow of XML docs -\u003e https://github.com/dotnet/dotnet-api-docs -\u003e docs.microsoft.com/\r\n- [ ] Add conceptual docs for TensorPrimitives, maybe near https://github.com/dotnet/docs/blob/main/docs/standard/numerics.md\r\n- [x] Generic overloads of all relevant methods, constrained to the appropriate numerical types\r\n- [x] [Get benchmarks added into dotnet/performance](https://github.com/dotnet/runtime/issues/98369)\r\n  - Collect baseline results from the time between RC2 and GA right before our alignment improvements went in\r\n  - Collect new results from `main` after all of the alignment \r\n- [x] Improve performance of `Min`, `Max`, `MinMagnitude`, `MaxMagnitude` with relation to NaN handling\r\n- [x] Determine for lengths of `0` if we want to throw or return `NaN` (we consistently throw today when non-0 is required; ML.NET apparently returns 0?) - @tannergooding\r\n  - We currently throw; if we decide not to throw, this could be changed in a minor release in a non-breaking way.\r\n- [x] Additional operations from `Math{F}` that don\u0027t currently have representation on `TensorPrimitives`, e.g. `CopySign`, `Reciprocal{Sqrt}{Estimate}`, `Sqrt`, `Ceiling`, `Floor`, `Truncate`, `Log10`, `Log(x, y)` (with y as both span and scalar), `Pow(x, y)` (with y as both span and scalar), `Cbrt`, `IEEERemainder`, `Acos`, `Acosh`, `Cos`, `Asin`, `Asinh`, `Sin`, `Atan`. [This unmerged commit](https://github.com/dotnet/runtime/commit/ada9b18f16ab6c248fe10deedb22404802334309) has a sketch, but it\u0027s out-of-date with improvements that have been made to the library since, and all of the operations should be vectorized.\r\n- [x] Refactor the generic TP implementation into multiple source files.\r\n- [x] Additional operations defined in the numerical interfaces that don\u0027t currently have representation on `TensorPrimitives`, e.g. `BitwiseAnd`, `BitwiseOr`, `BitwiseXor`, `Exp10`, `Exp10M1`, `Exp2`, `Exp2M1`, `ExpM1`, `Atan2`, `Atan2Pi`, `ILogB`, `Lerp`, `ScaleB`, `Round`, `Log10P1`, `Log2P1`, `LogP1`, `Hypot`, `RootN`, `AcosPi`, `AsinPi`, `AtanPi`, `CosPi`, `SinPi`, `TanPi`\r\n\r\nWe plan to update the System.Numerics.Tensors package alongside .NET 8 servicing releases. When there are bug fixes and performance improvements only, the patch number part of the version will be incremented. When there are new APIs added, the minor version will be bumped. For guidance on how we bump minor/major package versions, see [this example](https://github.com/dotnet/runtime/blob/c345959e132409b19c692807e313f739bce850ad/src/libraries/Microsoft.VisualBasic.Core/Directory.Build.props#L6-L7).",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOufzcyg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5ooOix",
                                           "createdAt":  "2023-10-10T12:56:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-numerics-tensors\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nRegardless of any additional types we may want to add to `System.Numerics.Tensors`, we would like to expand the set of APIs exposed on the `TensorPrimitives` static class in a few ways:\r\n- Additional operations from `Math{F}` that don\u0027t currently have representation on `TensorPrimitives`, e.g. `CopySign`, `Reciprocal{Sqrt}{Estimate}`, `Sqrt`, `Ceiling`, `Floor`, `Truncate`, `Log10`, `Log(x, y)` (with y as both span and scalar), `Pow(x, y)` (with y as both span and scalar), `Cbrt`, `IEEERemainder`, `Acos`, `Acosh`, `Cos`, `Asin`, `Asinh`, `Sin`, `Atan`. [This unmerged commit](https://github.com/dotnet/runtime/commit/ada9b18f16ab6c248fe10deedb22404802334309) has a sketch, but it\u0027s out-of-date with improvements that have been made to the library since, and all of the operations should be vectorized.\r\n- Additional operations defined in the numerical interfaces that don\u0027t currently have representation on `TensorPrimitives`, e.g. `BitwiseAnd`, `BitwiseOr`, `BitwiseXor`, `Exp10`, `Exp10M1`, `Exp2`, `Exp2M1`, `ExpM1`, `Atan2`, `Atan2Pi`, `ILogB`, `Lerp`, `ScaleB`, `Round`, `Log10P1`, `Log2P1`, `LogP1`, `Hypot`, `RootN`, `AcosPi`, `AsinPi`, `AtanPi`, `CosPi`, `SinPi`, `TanPi`\r\n- Additional operations defined in BLAS / LAPACK that don\u0027t currently have representation on `TensorPrimitives`\r\n- Additional operations that would enable completely removing the internal `CpuMath` class from ML.NET, e.g.  `Add` (with indices), `AddScale` (with indices), `DotProductSparse`, `MatrixTimesSource`, `ScaleAdd` improvement via `AddMultiply` or `MultipleAdd` overloads, `SdcaL1UpdateDense`, `SdcaL1UpdateSparse`, and `ZeroMatrixItems` (might exist in System.Memory).\r\n- Generic overloads of all relevant methods, constrained to the appropriate numerical types\r\n\r\nConcrete proposal to follow.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003estephentoub\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Numerics.Tensors`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e9.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-10-10T12:56:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5oovhb",
                                           "createdAt":  "2023-10-10T14:12:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODuSHDA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "aloraman",
                                                                               "createdAt":  "2023-10-10T14:12:49Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Ilchert",
                                                                               "createdAt":  "2023-10-10T14:13:32Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "zawodskoj",
                                                                               "createdAt":  "2023-10-10T14:14:17Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "vanbukin",
                                                                               "createdAt":  "2023-10-10T14:54:30Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "KeterSCP",
                                                                               "createdAt":  "2023-10-10T15:24:52Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "mahara",
                                                                               "createdAt":  "2024-08-15T14:57:29Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  6
                                                         },
                                           "author":  "Szer",
                                           "body":  "Could you please elaborate on the advantages of having these APIs in a BCL rather than in a specialized NuGet package (like numpy in Python)? This could provide a valuable perspective for further discussion.",
                                           "updatedAt":  "2023-10-10T14:12:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ooxW7",
                                           "createdAt":  "2023-10-10T14:16:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Could you please elaborate on the advantages of having these APIs in a BCL rather than in a specialized NuGet package\r\n\r\nIt _is_ a nuget package today. It\u0027s currently not part of netcoreapp. If it were to be pulled into netcoreapp as well, it would be because we\u0027d be using it from elsewhere in netcoreapp, e.g. using it from APIs like Enumerable.Average, BitArray.And, ManagedWebSocket.ApplyMask, etc., which we very well may do in the future (that has no impact on it continuing to be available as a nuget package).",
                                           "updatedAt":  "2023-10-10T15:36:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5pATqc",
                                           "createdAt":  "2023-10-13T15:15:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODnK7nw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "nietras",
                                                                               "createdAt":  "2024-03-03T09:34:09Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "JeffreySax",
                                                                               "createdAt":  "2024-06-26T04:37:00Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "xoofx",
                                           "body":  "Hey @stephentoub,\r\n\r\nWould it be possible to expose the low level parts of the API instead of only providing Span versions?\r\n\r\ne.g \r\n\r\n```c#\r\npublic static Vector128\u003cfloat\u003e Log2(Vector128\u003cfloat\u003e value);\r\npublic static Vector256\u003cfloat\u003e Log2(Vector256\u003cfloat\u003e value);\r\npublic static Vector512\u003cfloat\u003e Log2(Vector512\u003cfloat\u003e value);\r\n//...etc.\r\n```\r\n\r\nI did that for a prototype for a similar API and it\u0027s working great. \r\nOne reason to expose these APIs is that you can actually build higher level functions (e.g for tensors, the zoo of the activation functions) and build Span versions on top of them.\r\n\r\nThese API can then be used for other kind of custom Span batching (not related to tensors), where the packing of the vector is different (e.g 4xfloat chuncked `xxxx, yyyy, zzzz`)\r\n",
                                           "updatedAt":  "2023-10-13T15:15:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5pBWca",
                                           "createdAt":  "2023-10-13T18:05:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODPCJBQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "xoofx",
                                                                               "createdAt":  "2023-10-13T18:06:25Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "asmirnov82",
                                                                               "createdAt":  "2023-12-09T16:00:32Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e Would it be possible to expose the low level parts of the API instead of only providing Span versions?\r\n\r\nYes, but it needs to be its own proposal and cover all 5 vector types (Vector\u003cT\u003e, Vector64/128/256/512\u003cT\u003e) and consider whether its applicable to Vector2/3/4 as well.",
                                           "updatedAt":  "2023-10-13T18:05:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5pBW5D",
                                           "createdAt":  "2023-10-13T18:07:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "xoofx",
                                           "body":  "\u003e Yes, but it needs to be its own proposal and cover all 5 vector types (Vector, Vector64/128/256/512)\r\n\r\nCool, I will try to write something.",
                                           "updatedAt":  "2023-10-13T18:07:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5pEh0Q",
                                           "createdAt":  "2023-10-14T10:24:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "xoofx",
                                           "body":  "\u003e Would it be possible to expose the low level parts of the API instead of only providing Span versions?\r\n\r\nFollow-up, created the proposal #93513",
                                           "updatedAt":  "2023-10-14T10:24:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5s5FSW",
                                           "createdAt":  "2023-11-26T21:33:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "msedi",
                                           "body":  "@stephentoub: \r\n\r\n\u003e If it were to be pulled into netcoreapp as well, it would be because we\u0027d be using it from elsewhere in netcoreapp\r\n\r\nif brought to the BCL wouldn\u0027t it make sense to rename `TensorPrimitives` to lets say `ArrayMath`, `VectorMath` or `VectorPrimitives`. Tensor seems a bit exaggerated for what it does, namely doing some math on arrays. ",
                                           "updatedAt":  "2023-11-26T21:33:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5s5IU9",
                                           "createdAt":  "2023-11-26T22:28:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODNs0uw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "acaly",
                                                                               "createdAt":  "2023-11-27T01:53:49Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "msedi",
                                                                               "createdAt":  "2023-11-27T15:44:10Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "@msedi that would be a breaking change. Additionally, the intent is to expand it to the full set of BLAS support, so Tensor is a very apt and appropriate name that was already scrutinized, reviewed, and approved by API review",
                                           "updatedAt":  "2023-11-26T22:28:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5s9lrB",
                                           "createdAt":  "2023-11-27T15:44:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "msedi",
                                           "body":  "@tannergooding: Sure you right, I was just under the impression that there could be something more primitive. The tensor ist something, lets say higher level whereas the vector/array methods are on a lower level. But I\u0027m completely fine with it whenever I know where to find it,\r\n\r\nBTW. When looking at the code and the effort for the TensorPrimitives are there any efforts the JIT will some day manage to do the SIMD unfolding for us?",
                                           "updatedAt":  "2023-11-27T15:44:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5s9roj",
                                           "createdAt":  "2023-11-27T15:52:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODnLHjA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "xoofx",
                                                                               "createdAt":  "2023-11-27T15:59:32Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "acaly",
                                                                               "createdAt":  "2023-11-28T03:13:28Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "asmirnov82",
                                                                               "createdAt":  "2023-11-28T12:21:43Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-02-23T16:05:25Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "JeffreySax",
                                                                               "createdAt":  "2024-06-26T04:41:20Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  5
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e the JIT will some day manage to do the SIMD unfolding for us?\r\n\r\nThe JIT is unlikely to get auto-vectorization in the near future as such support is complex and quite expensive to do. Additionally, outside of particular domains, such support does not often light up and has measurable impact to real world apps even less frequently. Especially for small workloads it can often have the opposite effect and slow down your code. In the domains where it does light up, and particularly where it would be beneficial to do, you are often going to get better perf by writing your own SIMD code directly.\r\n\r\nIt is therefore my opinion that our efforts would be better spent providing APIs from the BCL that provide this acceleration for you. Such as all the APIs on `Span\u003cT\u003e`, accelerating LINQ, the new APIs on `TensorPrimitives`, etc. It may likewise be beneficial to expose some SIMD infrastructure helpers like we\u0027ve defined internally for `TensorPrimitives`; that is expose some public form of `InvokeSpanSpanIntoSpan` and friends, which would allow developers to only worry about providing the inner kernel and to have the rest of the SIMD logic (leading/trailing elements, alignment, unrolling, etc) handled internally. Efforts like `ISimdVector\u003cTSelf, T\u003e` also fit the bill of making it simpler for devs to write SIMD code.",
                                           "updatedAt":  "2023-11-27T15:52:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5s9ula",
                                           "createdAt":  "2023-11-27T15:57:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "msedi",
                                           "body":  "@tannergooding : Thanks for the info. That makes sense For our case we wrote source generators to generate all the array primitives, currently with Vector\u003cT\u003e but I wanted to benchmark against your implementations. I assume yours is better ;-)",
                                           "updatedAt":  "2023-11-27T15:58:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Ikzgw",
                                           "createdAt":  "2024-08-15T14:15:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "Remaining work is for .NET 10",
                                           "updatedAt":  "2024-08-15T14:15:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6w9x-8",
                                           "createdAt":  "2025-06-13T04:25:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ds5678",
                                           "body":  "`BitwiseXor` seems to be marked above as implemented, but it doesn\u0027t show up in the code search.\n\nhttps://github.com/search?q=repo%3Adotnet%2Fruntime+BitwiseXor\u0026type=code",
                                           "updatedAt":  "2025-06-13T04:25:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6xFPAj",
                                           "createdAt":  "2025-06-13T16:45:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "~~BitwiseXor wasn\u0027t in https://github.com/dotnet/runtime/issues/96451, which is why it\u0027s not in the source. @tannergooding, do you remember if there was a reason we didn\u0027t include it?~~",
                                           "updatedAt":  "2025-06-13T16:47:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6xFPcv",
                                           "createdAt":  "2025-06-13T16:45:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Oh, wait, no, it is there, we just called it Xor rather than BitwiseXor. I know we discussed the naming but I don\u0027t remember why we chose to name this one differently.\n\nhttps://github.com/dotnet/runtime/blob/83ffb89afaf1b3eb0a2557fde76faffb00f1ef0f/src/libraries/System.Numerics.Tensors/ref/System.Numerics.Tensors.netcore.cs#L788-L789",
                                           "updatedAt":  "2025-06-13T16:47:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6xFWAn",
                                           "createdAt":  "2025-06-13T16:58:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "Because it matches the official alternative names: https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca2225\n\nI personally would prefer if they were just And, Or, and xor because it better matches the flow for names like AndNot or Xnor and other common combinations. But it\u0027s an existing convention",
                                           "updatedAt":  "2025-06-13T16:58:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc65_NzK",
                                           "createdAt":  "2025-07-25T21:05:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEiyRhA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "PaulusParssinen",
                                                                               "createdAt":  "2025-09-18T07:30:50Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "Carrying this epic forward into .NET 11 for the items that remain open.",
                                           "updatedAt":  "2025-07-25T21:05:41Z"
                                       }
                                   ],
                         "totalCount":  18
                     },
        "title":  "TensorPrimitives improvements",
        "labels":  [
                       "Epic",
                       "area-System.Numerics.Tensors"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/93474",
        "createdAt":  "2023-10-13T14:02:46Z",
        "number":  93474,
        "author":  "asmirnov82",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-20T17:33:53Z",
        "body":  "### Background and motivation\n\nWith the implementation of #89639 a new non-generic static API for the main arithmetic and conversion operators was added into the `System.Numerics.Tensors` namespace. This API provides hardware accelerated math on `Span\u003cfloat\u003e` type of data. While `float` is very often used in AI, other primitive types are also widely used in many areas (for example for data wrangling).  Microsoft.Data.Analysis is one of the packages that will benefit from the hardware accelerated math for other primitive types.\n\n### API Proposal\n\n1) Extend basic element-wise Arithmetic from existing API to support `double`,  `sbyte` , `byte` , `short` , `ushort` , `int` , `uint` , `long`  and `ulong` types.\r\n\r\nMethods affected:\r\n\r\n```csharp\r\nnamespace System.Numerics.Tensors;\r\n\r\npublic static partial class TensorPrimitives\r\n{\r\n    public static void Abs(ReadOnlySpan\u003cfloat\u003e x, Span\u003cfloat\u003e destination);\r\n\r\n    public static void Add(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cfloat\u003e destination);\r\n    public static void Add(ReadOnlySpan\u003cfloat\u003e x, float y, Span\u003cfloat\u003e destination);\r\n\r\n    public static void Divide(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cfloat\u003e destination);\r\n    public static void Divide(ReadOnlySpan\u003cfloat\u003e x, float y, Span\u003cfloat\u003e destination);\r\n\r\n    public static float Max(ReadOnlySpan\u003cfloat\u003e value);\r\n    public static float Min(ReadOnlySpan\u003cfloat\u003e value);\r\n\r\n    public static void Multiply(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cfloat\u003e destination);\r\n    public static void Multiply(ReadOnlySpan\u003cfloat\u003e x, float y, Span\u003cfloat\u003e destination);\r\n\r\n    public static void Negate(ReadOnlySpan\u003cfloat\u003e values, Span\u003cfloat\u003e destination);\r\n\r\n    public static void Subtract(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cfloat\u003e destination);\r\n    public static void Subtract(ReadOnlySpan\u003cfloat\u003e x, float y, Span\u003cfloat\u003e destination);\r\n}\r\n```\r\n2) Add reverse method for non commutative operations where one of the operands is scalar.\r\n\r\nNew methods (for all primitive types): \r\n\r\n```csharp\r\nnamespace System.Numerics.Tensors;\r\n\r\npublic static partial class TensorPrimitives\r\n{\r\n    public static void Divide(float x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cfloat\u003e destination);\r\n\r\n     public static void Subtract(float x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cfloat\u003e destination);\r\n}\r\n```\r\n\r\n3) Add new operations for hardware accelerated comparison:\r\n\r\nNew methods (for all primitive types): \r\n\r\n```csharp\r\nnamespace System.Numerics.Tensors;\r\n\r\npublic static partial class TensorPrimitives\r\n{\r\n    public static void Equals(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cbool\u003e destination);\r\n\r\n    public static bool EqualsAll(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y);\r\n    public static bool EqualsAny(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y);\r\n\r\n    public static void GreaterThan(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cbool\u003e destination);\r\n    public static void GreaterThanOrEqual(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cbool\u003e destination);\r\n\r\n    public static void LessThan(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cbool\u003e destination);\r\n    public static void LessThanOrEqual(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cbool\u003e destination);\r\n}\r\n```\n\n### API Usage\n\nThe same as for the existing API proposed in #89639\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOcLgpPQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5o_4dD",
                                           "createdAt":  "2023-10-13T14:02:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-numerics\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nWith the implementation of #89639 a new non-generic static API for the main arithmetic and conversion operators was added into the `System.Numerics.Tensors` namespace. This API provides hardware accelerated math on `Span\u003cfloat\u003e` type of data. While `float` is very often used in AI, other primitive types are also widely used in many areas (for example for data wrangling).  Microsoft.Data.Analysis is one of the packages that will benefit from the hardware accelerated math for other primitive types.\n\n### API Proposal\n\n1) Extend basic element-wise Arithmetic from existing API to support `double`,  `sbyte` , `byte` , `short` , `ushort` , `int` , `uint` , `long`  and `ulong` types.\r\n\r\nMethods affected:\r\n\r\n```csharp\r\nnamespace System.Numerics.Tensors;\r\n\r\npublic static partial class TensorPrimitives\r\n{\r\n    public static void Abs(ReadOnlySpan\u003cfloat\u003e x, Span\u003cfloat\u003e destination);\r\n\r\n    public static void Add(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cfloat\u003e destination);\r\n    public static void Add(ReadOnlySpan\u003cfloat\u003e x, float y, Span\u003cfloat\u003e destination);\r\n\r\n    public static void Divide(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cfloat\u003e destination);\r\n    public static void Divide(ReadOnlySpan\u003cfloat\u003e x, float y, Span\u003cfloat\u003e destination);\r\n\r\n    public static float Max(ReadOnlySpan\u003cfloat\u003e value);\r\n    public static float Min(ReadOnlySpan\u003cfloat\u003e value);\r\n\r\n    public static void Multiply(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cfloat\u003e destination);\r\n    public static void Multiply(ReadOnlySpan\u003cfloat\u003e x, float y, Span\u003cfloat\u003e destination);\r\n\r\n    public static void Negate(ReadOnlySpan\u003cfloat\u003e values, Span\u003cfloat\u003e destination);\r\n\r\n    public static void Subtract(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cfloat\u003e destination);\r\n    public static void Subtract(ReadOnlySpan\u003cfloat\u003e x, float y, Span\u003cfloat\u003e destination);\r\n}\r\n```\r\n2) Add reverse method for non commutative operation where one of the operand is scalar.\r\n\r\nNew methods (for all primitive types): \r\n\r\n```csharp\r\nnamespace System.Numerics.Tensors;\r\n\r\npublic static partial class TensorPrimitives\r\n{\r\n    public static void Divide(float x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cfloat\u003e destination);\r\n\r\n     public static void Subtract(float x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cfloat\u003e destination);\r\n}\r\n```\r\n\r\n3) Add new operations for hardware accelerated comparison:\r\n\r\nNew methods (for all primitive types): \r\n\r\n```csharp\r\nnamespace System.Numerics.Tensors;\r\n\r\npublic static partial class TensorPrimitives\r\n{\r\n    public static void Equals(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cbool\u003e destination);\r\n\r\n    public static bool EqualsAll(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y);\r\n    public static bool EqualsAny(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y);\r\n\r\n    public static void GreaterThan(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cbool\u003e destination);\r\n    public static void GreaterThanOrEqual(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cbool\u003e destination);\r\n\r\n    public static void LessThan(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cbool\u003e destination);\r\n    public static void LessThanOrEqual(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cbool\u003e destination);\r\n}\r\n```\n\n### API Usage\n\nThe same as for the existing API proposed in #89639\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003easmirnov82\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Numerics`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-10-13T14:02:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5o_5qV",
                                           "createdAt":  "2023-10-13T14:06:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-numerics-tensors\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nWith the implementation of #89639 a new non-generic static API for the main arithmetic and conversion operators was added into the `System.Numerics.Tensors` namespace. This API provides hardware accelerated math on `Span\u003cfloat\u003e` type of data. While `float` is very often used in AI, other primitive types are also widely used in many areas (for example for data wrangling).  Microsoft.Data.Analysis is one of the packages that will benefit from the hardware accelerated math for other primitive types.\n\n### API Proposal\n\n1) Extend basic element-wise Arithmetic from existing API to support `double`,  `sbyte` , `byte` , `short` , `ushort` , `int` , `uint` , `long`  and `ulong` types.\r\n\r\nMethods affected:\r\n\r\n```csharp\r\nnamespace System.Numerics.Tensors;\r\n\r\npublic static partial class TensorPrimitives\r\n{\r\n    public static void Abs(ReadOnlySpan\u003cfloat\u003e x, Span\u003cfloat\u003e destination);\r\n\r\n    public static void Add(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cfloat\u003e destination);\r\n    public static void Add(ReadOnlySpan\u003cfloat\u003e x, float y, Span\u003cfloat\u003e destination);\r\n\r\n    public static void Divide(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cfloat\u003e destination);\r\n    public static void Divide(ReadOnlySpan\u003cfloat\u003e x, float y, Span\u003cfloat\u003e destination);\r\n\r\n    public static float Max(ReadOnlySpan\u003cfloat\u003e value);\r\n    public static float Min(ReadOnlySpan\u003cfloat\u003e value);\r\n\r\n    public static void Multiply(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cfloat\u003e destination);\r\n    public static void Multiply(ReadOnlySpan\u003cfloat\u003e x, float y, Span\u003cfloat\u003e destination);\r\n\r\n    public static void Negate(ReadOnlySpan\u003cfloat\u003e values, Span\u003cfloat\u003e destination);\r\n\r\n    public static void Subtract(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cfloat\u003e destination);\r\n    public static void Subtract(ReadOnlySpan\u003cfloat\u003e x, float y, Span\u003cfloat\u003e destination);\r\n}\r\n```\r\n2) Add reverse method for non commutative operation where one of the operand is scalar.\r\n\r\nNew methods (for all primitive types): \r\n\r\n```csharp\r\nnamespace System.Numerics.Tensors;\r\n\r\npublic static partial class TensorPrimitives\r\n{\r\n    public static void Divide(float x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cfloat\u003e destination);\r\n\r\n     public static void Subtract(float x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cfloat\u003e destination);\r\n}\r\n```\r\n\r\n3) Add new operations for hardware accelerated comparison:\r\n\r\nNew methods (for all primitive types): \r\n\r\n```csharp\r\nnamespace System.Numerics.Tensors;\r\n\r\npublic static partial class TensorPrimitives\r\n{\r\n    public static void Equals(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cbool\u003e destination);\r\n\r\n    public static bool EqualsAll(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y);\r\n    public static bool EqualsAny(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y);\r\n\r\n    public static void GreaterThan(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cbool\u003e destination);\r\n    public static void GreaterThanOrEqual(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cbool\u003e destination);\r\n\r\n    public static void LessThan(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cbool\u003e destination);\r\n    public static void LessThanOrEqual(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y, Span\u003cbool\u003e destination);\r\n}\r\n```\n\n### API Usage\n\nThe same as for the existing API proposed in #89639\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003easmirnov82\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Numerics.Tensors`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-10-13T14:06:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5o_-E1",
                                           "createdAt":  "2023-10-13T14:17:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "See https://github.com/dotnet/runtime/issues/93286.",
                                           "updatedAt":  "2023-10-13T14:17:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wuCk9",
                                           "createdAt":  "2024-01-14T23:56:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "(1) is handled via the added generic overloads.\r\n\r\n(2) is implemented via https://github.com/dotnet/runtime/issues/96451.\r\n\r\n@tannergooding, do we want (3)? (generic rather than float-specific) ",
                                           "updatedAt":  "2024-02-08T14:59:44Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "[API Proposal]: Extend System.Numerics.Tensors.TensorPrimitives with primitive types other than float",
        "labels":  [
                       "api-suggestion",
                       "area-System.Numerics.Tensors"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/95863",
        "createdAt":  "2023-12-11T15:46:42Z",
        "number":  95863,
        "author":  "shaltielshmid",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC3Ct0A==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "luisquintanilla",
                                            "createdAt":  "2023-12-11T17:14:42Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pedoc",
                                            "createdAt":  "2023-12-12T05:01:13Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "GeorgeS2019",
                                            "createdAt":  "2024-04-06T02:49:26Z"
                                        }
                                    ],
                          "totalCount":  3
                      },
        "updatedAt":  "2024-02-27T20:58:51Z",
        "body":  "### Background and motivation\r\n\r\nRecently there\u0027s been a trend online of developing very minimal but efficient systems for LLM inference. After testing out TensorPrimitives vs the other numerical libraries out there, TensorPrimitives seems to be extremely efficient in comparison and I see an opportunity here to build a system similar to (vllm)[https://github.com/vllm-project/vllm] native to C# which can provide a solid base for LLM inferencing in C#. \r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Numerics.Tensors {\r\n\tpublic static partial class TensorPrimitives {\r\n\t\t// Function for doing a matrix multiply\r\n\t\tpublic static float MatrixMultiply(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y, ReadOnlySpan\u003cfloat\u003e destination);\r\n\t\t// Applying a softmax on a specific dimension, or perhaps the last dimension\r\n\t\tpublic static float Softmax(ReadOnlySpan\u003cfloat\u003e x, int dimension);\r\n\t}\r\n}\r\n```\r\n\r\n### API Usage\r\n\r\nThis can work for Vector / Matrix multiplication as well, by treating vectors as [1,N] matrices. \r\n\r\n```csharp\r\n\r\nfloat[,] matrix1 = new float[M, K];\r\nfloat[,] matrix2 = new float[K, N];\r\nfloat[,] destination = new float[M, N];\r\n\r\nTensorPrimitives.MatrixMultiply(matrix1, matrix2, destination);\r\n// Softmax on the last \"dimension\", to provide probabilities for every prediction in a matrix\r\nTensorPrimitives.Softmax(destination, -1);\r\n```\r\n\r\nThese are the two main operations I can think off the top of my head, but I\u0027ll continue editing as I think of more. \r\n\r\n@luisquintanilla ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHObkveiQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5uS8X_",
                                           "createdAt":  "2023-12-11T16:44:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-numerics-tensors\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\r\n\r\nRecently there\u0027s been a trend online of developing very minimal but efficient systems for LLM inference. After testing out TensorPrimitives vs the other numerical libraries out there, TensorPrimitives seems to be extremely efficient in comparison and I see an opportunity here to build a system similar to (vllm)[https://github.com/vllm-project/vllm] native to C# which can provide a solid base for LLM inferencing in C#. \r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Numerics.Tensors {\r\n\tpublic static partial class TensorPrimitives {\r\n\t\t// Function for doing a matrix multiply\r\n\t\tpublic static float MatrixMultiply(ReadOnlySpan\u003cfloat\u003e x, ReadOnlySpan\u003cfloat\u003e y, ReadOnlySpan\u003cfloat\u003e destination);\r\n\t\t// Applying a softmax on a specific dimension, or perhaps the last dimension\r\n\t\tpublic static float Softmax(ReadOnlySpan\u003cfloat\u003e x, int dimension);\r\n\t}\r\n}\r\n```\r\n\r\n### API Usage\r\n\r\nThis can work for Vector / Matrix multiplication as well, by treating vectors as [1,N] matrices. \r\n\r\n```csharp\r\n\r\nfloat[,] matrix1 = new float[M, K];\r\nfloat[,] matrix2 = new float[K, N];\r\nfloat[,] destination = new float[M, N];\r\n\r\nTensorPrimitives.MatrixMultiply(matrix1, matrix2, destination);\r\n// Softmax on the last \"dimension\", to provide probabilities for every prediction in a matrix\r\nTensorPrimitives.Softmax(destination, -1);\r\n```\r\n\r\nThese are the two main operations I can think off the top of my head, but I\u0027ll continue editing as I think of more. \r\n\r\n@luisquintanilla \n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eshaltielshmid\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Numerics.Tensors`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-12-11T16:44:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5uS96J",
                                           "createdAt":  "2023-12-11T16:47:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODQh9Sw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "luisquintanilla",
                                                                               "createdAt":  "2023-12-11T17:26:35Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "shaltielshmid",
                                                                               "createdAt":  "2023-12-11T17:26:56Z"
                                                                           },
                                                                           {
                                                                               "content":  "ROCKET",
                                                                               "user":  "neon-sunset",
                                                                               "createdAt":  "2023-12-11T22:13:48Z"
                                                                           },
                                                                           {
                                                                               "content":  "ROCKET",
                                                                               "user":  "sperling",
                                                                               "createdAt":  "2023-12-12T14:33:47Z"
                                                                           },
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "sinshu",
                                                                               "createdAt":  "2023-12-12T14:47:58Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2023-12-12T18:23:12Z"
                                                                           },
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "saint4eva",
                                                                               "createdAt":  "2023-12-26T05:39:48Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  7
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "There is a plan to add the full set of BLAS (level 1, 2, and 3) APIs; which would include basic matrix operations.\r\n\r\nDue to the sheer scope of the work, a lot of this is incremental and will be added incrementally to ensure the best experience and API shape can be provided.",
                                           "updatedAt":  "2023-12-11T16:47:49Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[API Proposal]: Adding Matrix operations to `System.Numerics.Tensors.TensorPrimitives`",
        "labels":  [
                       "api-suggestion",
                       "area-System.Numerics.Tensors"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/97193",
        "createdAt":  "2024-01-19T05:05:20Z",
        "number":  97193,
        "author":  "stephentoub",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-25T21:07:36Z",
        "body":  "https://github.com/dotnet/runtime/pull/97192 adds many more operations onto TensorPrimitives. Some are fully vectorized, others currently only have a scalar implementation. The following operations need vectorization:\n- [ ] Acos _(amd lib has vectorized float impl, possible approach in\nhttps://github.com/dotnet/runtime/pull/98302) _\n- [ ] Asin _(amd lib has vectorized float impl, possible approach in\nhttps://github.com/dotnet/runtime/pull/98302) _\n- [ ] Atan _(amd lib has vectorized float impl, possible approach in\nhttps://github.com/dotnet/runtime/pull/98302) _\n- [ ] SinCos _(amd lib has vectorized double impl)_\n- [ ] Acosh\n- [ ] Asinh\n- [ ] Atanh\n- [ ] Atan2\n- [ ] ILogB\n- [ ] SinCosPi\n- [ ] TanPi\n- [ ] ... a bunch more\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOufzwoA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5xPEkh",
                                           "createdAt":  "2024-01-19T05:05:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-numerics-tensors\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nhttps://github.com/dotnet/runtime/pull/97192 adds many more operations onto TensorPrimitives. Some are fully vectorized, others currently only have a scalar implementation. The following operations need vectorization:\r\n- [ ] Exp2\r\n- [ ] Exp10\r\n- [ ] Pow\r\n- [ ] Cbrt\r\n- [ ] Hypot\r\n- [ ] Acos\r\n- [ ] Acosh\r\n- [ ] Asin\r\n- [ ] Asinh\r\n- [ ] Atan\r\n- [ ] Atanh\r\n- [ ] Atan2\r\n- [ ] Cos\r\n- [ ] Sin\r\n- [ ] Tan\r\n- [ ] Log10\r\n- [ ] Log(x,y)\r\n- [ ] PopCount\r\n- [ ] LeadingZeroCount\r\n- [ ] TrailingZeroCount\r\n- [ ] ILogB\r\n- [ ] RootN\r\n- [ ] RotateLeft\r\n- [ ] RotateRight\r\n- [ ] Round\r\n- [ ] ScaleB\r\n- [ ] ShiftLeft\r\n- [ ] ShiftRightArithmetic\r\n- [ ] ShiftRightLogical\r\n- [ ] SinCos\r\n- [ ] SinCosPi\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003estephentoub\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Numerics.Tensors`, `tenet-performance`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e9.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-01-19T05:05:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc65_PCg",
                                           "createdAt":  "2025-07-25T21:07:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "Carrying this forward to .NET 11 and tagging with https://github.com/dotnet/runtime/labels/reduce-unsafe for alignment with that effort.",
                                           "updatedAt":  "2025-07-25T21:07:36Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Vectorize TensorPrimitives operations that are currently scalar only",
        "labels":  [
                       "area-System.Numerics.Tensors",
                       "tenet-performance",
                       "reduce-unsafe"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/97318",
        "createdAt":  "2024-01-22T15:14:23Z",
        "number":  97318,
        "author":  "SteveSandersonMS",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC1VaOw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "stephentoub",
                                            "createdAt":  "2024-01-22T15:29:05Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-02-27T15:23:09Z",
        "body":  "### Background and motivation\r\n\r\nThe generic `TensorPrimitives.Dot\u003cT\u003e` is useful for float and double, but less so for integral types (`sbyte`, `short`, `int`) because there\u0027s no way to be sure it won\u0027t overflow.\r\n\r\nIn my scenario I\u0027m computing the cosine similarity of two `ReadOnlySpan\u003csbyte\u003e`, in which the entries are already scaled to the range -127..127. If the output has to be another `sbyte` it will basically always overflow.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Numerics.Tensors;\r\n\r\npublic class TensorPrimitives\r\n{\r\n    public static TResult Dot\u003cT, TResult\u003e(ReadOnlySpan\u003cT\u003e x, ReadOnlySpan\u003cT\u003e y)\r\n        where T : IAdditionOperators\u003cT, T, TResult\u003e, IAdditiveIdentity\u003cT, T\u003e, IMultiplyOperators\u003cT, T, TResult\u003e, IMultiplicativeIdentity\u003cT, T\u003e =\u003e\r\n            Aggregate\u003cT, MultiplyOperator\u003cT\u003e, AddOperator\u003cT\u003e\u003e(x, y);\r\n}\r\n```\r\n\r\nI expect there would also have to be some further generic type constraints on `TResult`.\r\n\r\n### API Usage\r\n\r\n```csharp\r\nReadOnlySpan\u003csbyte\u003e x = ComputeEmbedding(\"some text 1\");\r\nReadOnlySpan\u003csbyte\u003e y = ComputeEmbedding(\"some text 2\");\r\nfloat cosineSimilarity = TensorPrimitives.Dot\u003csbyte, float\u003e(x, y) / (TensorPrimitives.Norm(x) * TensorPrimitives.Norm(y));\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\nIf the only common reason to compute the dot product of integer-typed vectors is for cosine similarity, then a more direct alternative would be adding `float TensorPrimitives.CosineSimilarity(ReadOnlySpan\u003csbyte\u003e x, ReadOnlySpan\u003csbyte\u003e y)` (and perhaps also for `short` and `int` inputs).\r\n\r\nThis would be slightly less efficient than using `Dot` if the norms of x and y are already known/precomputed, since `CosineSimilarity` would be recalculating those on each call. But it\u0027s less for the developer to figure out. Arguably it would be nice to support both options.\r\n\r\n### Risks\r\n\r\nThe CPU might only support instructions for doing this efficiently for certain combinations of `T` and `TResult`.\r\n\r\nThe result might still overflow if `TResult` is given as an integer type.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOoDv7RA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5xgAm4",
                                           "createdAt":  "2024-01-22T15:14:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-numerics\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nThe generic `TensorPrimitives.Dot\u003cT\u003e` is useful for float and double, but usually not for integral types (`sbyte`, `short`, `int`) because there\u0027s no way to be sure it won\u0027t overflow.\r\n\r\nIn my scenario I\u0027m computing the cosine similarity of two `ReadOnlySpan\u003csbyte\u003e`, in which the entries are already scaled to the range -127..127. If the output has to be another `sbyte` it will basically always overflow.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Numerics.Tensors;\r\n\r\npublic class TensorPrimitives\r\n{\r\n    public static TResult Dot\u003cT, TResult\u003e(ReadOnlySpan\u003cT\u003e x, ReadOnlySpan\u003cT\u003e y)\r\n        where T : IAdditionOperators\u003cT, T, TResult\u003e, IAdditiveIdentity\u003cT, T\u003e, IMultiplyOperators\u003cT, T, TResult\u003e, IMultiplicativeIdentity\u003cT, T\u003e =\u003e\r\n            Aggregate\u003cT, MultiplyOperator\u003cT\u003e, AddOperator\u003cT\u003e\u003e(x, y);\r\n}\r\n```\r\n\r\nI expect there would also have to be some further generic type constraints on `TResult`.\n\n### API Usage\n\n```csharp\r\nReadOnlySpan\u003csbyte\u003e x = ComputeEmbedding(\"some text 1\");\r\nReadOnlySpan\u003csbyte\u003e y = ComputeEmbedding(\"some text 2\");\r\nfloat cosineSimilarity = TensorPrimitives.Dot\u003csbyte, float\u003e(x, y) / (TensorPrimitives.Norm(x)* TensorPrimitives.Norm(y));\r\n```\r\n\n\n### Alternative Designs\n\nIf the only common reason to compute the dot product of integer-typed vectors is for cosine similarity, then a more direct alternative would be adding `TensorPrimitives.CosineSimilarity(ReadOnlySpan\u003csbyte\u003e x, ReadOnlySpan\u003csbyte\u003e y)`.\r\n\r\nThis would be slightly less efficient than using `Dot` if the norms of x and y are already known/precomputed, since `CosineSimilarity` would be recalculating those on each call. But it\u0027s less for the developer to figure out. Arguably it would be nice to support both options.\n\n### Risks\n\nThe CPU might only support instructions for doing this efficiently for certain combinations of `T` and `TResult`.\r\n\r\nThe result might still overflow depending on the type of `TResult`.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eSteveSandersonMS\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Numerics`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-01-22T15:14:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5xgJUN",
                                           "createdAt":  "2024-01-22T15:31:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODTltGw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "SteveSandersonMS",
                                                                               "createdAt":  "2024-01-22T15:44:09Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e The result might still overflow if TResult is given as an integer type.\r\n\r\nToday, CosineSimilarity is constrained such that its T must implement IRootFunctions, which effectively means just floating-point types. I expect if the alternatively-proposed CosineSimilarly gets added, it would be such that T would be constrained similarly to how Dot is constrained today (with T just needing to support addition and multiplication) and then TResult would be constrained to IRootFunctions. (That doesn\u0027t negate the possibility of an overflow with Dot, unless we artificially constrained TResult there, but I don\u0027t think we\u0027d want to do that.)",
                                           "updatedAt":  "2024-01-22T15:32:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5xgwA1",
                                           "createdAt":  "2024-01-22T16:52:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODTmZ1Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "SteveSandersonMS",
                                                                               "createdAt":  "2024-01-22T16:58:49Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "This is one of those cases where I would like get more input and build up a case showing why this is important.\r\n\r\nTo the best of my knowledge, this kind of functionality doesn\u0027t exist for `PyTorch`, `TensorFlow`, or other common ML/AI/Tensor libraries and they all explicitly fail with something like: `RuntimeError: result dtype Float does not match input dtype Char` (this one in particular is from `PyTorch`). That is to say, they require input and output types to match.\r\n\r\nInstead, other ML/AI/Tensor libraries require you to explicitly convert using APIs like `tensor.to(torch.float32)`. This will by default incur allocations, copying, etc and you need to opt-in to get optimizations or use alternative APIs to make it more efficient.\r\n\r\nThere are many reasons that this is done, including that it is difficult to determine where the conversion should be done and that there is no singular correct answer. Different algorithms may require it at different points, such as on the inputs, as part of the intermediate computations, or even only on the final output produced. But, its also done because the core of the tensor logic is always going to just be primitive micro-kernels and you functionally need to build a single combined kernel to minimize walking of memory and operations done.\r\n\r\nGiven this, my first thought is that the complexity of supporting embedded type conversions as a built-in part of the primitive APIs is not worth it and is effectively an anti-pattern towards the long term goals/needs of such a system. Instead, I believe we need to expose some standalone primitives for doing such conversions, we need to build up and expose an easier to work with and type safe `Tensor\u003cT\u003e` type, and we need to look at ways we can help users efficiently optimize their kernels so they can avoid allocations or repeated walking of memory.\r\n\r\nThe simplest way to help with the efficiency aspect is to find a way to expose the `InvokeSpanSpanIntoSpan` and similar helper APIs + expose an `ISimdVector\u003cTSelf, T\u003e` like type. This would allow the complexities around vectorization, handling trailing elements, etc to be efficiently handled while allowing users only worry about the core operations they need to do. With the potentially better long term way would be to expose some builder pattern or potentially a source generator/interceptor, which would allow users to effectively just write their normal scalar code, bypassing any complexities involved with masking, interleaving operations, etc.\r\n\r\n-----\r\n\r\nJust to clarify here, I\u0027m not saying \"no\", just that I think we need more input/data/etc and it needs to be weighed/compared against the long term goals, API shape, expected typical use cases, and the way that other leading libraries support such functionality.",
                                           "updatedAt":  "2024-01-22T16:53:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6FayPg",
                                           "createdAt":  "2024-07-19T06:27:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-numerics-tensors\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-07-19T06:27:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6gOoV7",
                                           "createdAt":  "2025-02-27T14:50:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GGG-KILLER",
                                           "body":  "\u003e The simplest way to help with the efficiency aspect is to find a way to expose the `InvokeSpanSpanIntoSpan` and similar helper APIs + expose an `ISimdVector\u003cTSelf, T\u003e` like type. This would allow the complexities around vectorization, handling trailing elements, etc to be efficiently handled while allowing users only worry about the core operations they need to do. With the potentially better long term way would be to expose some builder pattern or potentially a source generator/interceptor, which would allow users to effectively just write their normal scalar code, bypassing any complexities involved with masking, interleaving operations, etc.\n\nUnrelated to the original post, but this would definitely be appreciated as in my own attempt at making a NN library from scratch, I had to implement my own `TensorPrimitives` version that exposes those since I have to implement derivatives of some operations like Sigmoid, SoftMax and others, and I wanted to avoid a bunch of intermediate allocations with System.Numerics.Tensors (and also wanted to try my hand at doing it initially, but now that\u0027s preventing me from switching).\n\nCould a separate issue be opened for that so that interested people can follow along the progress on that front?",
                                           "updatedAt":  "2025-02-27T14:51:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6gO_tE",
                                           "createdAt":  "2025-02-27T15:23:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Could a separate issue be opened for that so that interested people can follow along the progress on that front?\n\nAlready exists:\nhttps://github.com/dotnet/runtime/issues/93217",
                                           "updatedAt":  "2025-02-27T15:23:07Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "[API Proposal]: TensorPrimitives.Dot with specified result type",
        "labels":  [
                       "api-suggestion",
                       "area-System.Numerics.Tensors"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/98323",
        "createdAt":  "2024-02-12T20:58:07Z",
        "number":  98323,
        "author":  "ericstj",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODCLShg==",
                          "nodes":  [
                                        {
                                            "content":  "HOORAY",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-02-13T17:45:06Z"
                                        },
                                        {
                                            "content":  "ROCKET",
                                            "user":  "lewing",
                                            "createdAt":  "2024-02-13T23:58:12Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "frankbuckley",
                                            "createdAt":  "2024-02-14T18:34:08Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "asmirnov82",
                                            "createdAt":  "2024-02-15T21:38:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DL444",
                                            "createdAt":  "2024-02-18T05:32:19Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MineCake147E",
                                            "createdAt":  "2024-02-23T00:29:01Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "nietras",
                                            "createdAt":  "2024-03-03T09:17:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Jimmy-Hu",
                                            "createdAt":  "2024-03-08T11:56:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SommerEngineering",
                                            "createdAt":  "2024-05-22T05:45:06Z"
                                        },
                                        {
                                            "content":  "HOORAY",
                                            "user":  "SommerEngineering",
                                            "createdAt":  "2024-05-22T05:45:07Z"
                                        },
                                        {
                                            "content":  "ROCKET",
                                            "user":  "SommerEngineering",
                                            "createdAt":  "2024-05-22T05:45:08Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "SommerEngineering",
                                            "createdAt":  "2024-05-22T05:45:10Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "annelo-msft",
                                            "createdAt":  "2024-05-23T03:49:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "arthurvb",
                                            "createdAt":  "2024-07-23T13:26:39Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "jonas1ara",
                                            "createdAt":  "2024-09-02T22:44:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "raulsntos",
                                            "createdAt":  "2024-11-26T19:53:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "karv",
                                            "createdAt":  "2024-12-27T01:02:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sunkin351",
                                            "createdAt":  "2025-01-09T21:22:38Z"
                                        },
                                        {
                                            "content":  "ROCKET",
                                            "user":  "tjwald",
                                            "createdAt":  "2025-01-23T07:20:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "istipeti",
                                            "createdAt":  "2025-04-07T15:33:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hez2010",
                                            "createdAt":  "2025-05-08T17:56:43Z"
                                        }
                                    ],
                          "totalCount":  21
                      },
        "updatedAt":  "2025-07-26T08:06:32Z",
        "body":  "Goal: Provide a type for use as both exchange and interop that represents multi-dimensional data if a single primitive Type.  Implement arithmetic and linear algebra operations so that the type can serve as a sufficient basis for data preparation and as an input and output to neural networks.\r\n\r\n- [x] Explore memory layouts and how they play into interop\r\n- [x] Explore high-level Tensor\u003cT\u003e design\r\n  - Abstract?  Type heirarchy?  Construction patterns.\r\n  - Dense vs sparse\r\n  - Slices\r\n  - Dimension order\r\n  - Expected outcome: design document draft in dotnet/designs\r\n- [x] Explore Tensor\u003cT\u003e arithmetic design\r\n- [x] Explore Tensor\u003cT\u003e construction design\r\n- [x] Explore Tensor\u003cT\u003e loading and saving\r\n- TODO: Further break down Tensor\u003cT\u003e implementation into smaller chunks\r\n- [x] Tensor\u003cT\u003e API proposal\r\n  - Expected outcome: API review\r\n- [x] Tensor\u003cT\u003e core types implementation\r\n  - Expected outcome: PR \r\n- TODO: Further break down Tensor\u003cT\u003e implementation into smaller chunks\r\n- [ ] Performance tests\r\n- [ ] Interop with OnnxRuntime\r\n- [ ] Interop with TorchSharp\r\n- [ ] Expose in ML.NET",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOug3tUQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5zp8Zh",
                                           "createdAt":  "2024-02-13T03:42:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODYf5jw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "PaulusParssinen",
                                                                               "createdAt":  "2024-02-13T19:45:11Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "JoeTwizzle",
                                                                               "createdAt":  "2024-02-14T00:12:37Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "huoyaoyuan",
                                                                               "createdAt":  "2024-02-26T06:13:39Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "KennethHoff",
                                                                               "createdAt":  "2024-02-27T21:44:04Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "hez2010",
                                           "body":  "I hope we can take #89730 into consider together as it\u0027s critical for achieving high performance linear algebra operations on arbitrary ND tensors. Such feature has been a fundamental of libraries like the native implementation part of pytorch.",
                                           "updatedAt":  "2024-02-13T03:42:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5zwW6S",
                                           "createdAt":  "2024-02-13T17:26:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-meta\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nGoal: Provide a type for use as both exchange and interop that represents multi-dimensional data if a single primitive Type.  Implement arithmetic and linear algebra operations so that the type can serve as a sufficient basis for data preparation and as an input and output to neural networks.\r\n\r\n- [ ] Explore memory layouts and how they play into interop\r\n- [ ] Explore high-level Tensor\u003cT\u003e design\r\n  - Abstract?  Type heirarchy?  Construction patterns.\r\n  - Dense vs sparse\r\n  - Slices\r\n  - Dimension order\r\n  - Expected outcome: design document draft in dotnet/designs\r\n- [ ] Explore Tensor\u003cT\u003e arithmetic design\r\n- [ ] Explore Tensor\u003cT\u003e construction design\r\n- [ ] Explore Tensor\u003cT\u003e loading and saving\r\n- TODO: Further break down Tensor\u003cT\u003e implementation into smaller chunks\r\n- [ ] Tensor\u003cT\u003e API proposal\r\n  - Expected outcome: API review\r\n- [ ] Tensor\u003cT\u003e core types implementation\r\n  - Expected outcome: PR \r\n- TODO: Further break down Tensor\u003cT\u003e implementation into smaller chunks\r\n- [ ] Performance tests\r\n- [ ] Interop with OnnxRuntime\r\n- [ ] Interop with TorchSharp\r\n- [ ] Expose in ML.NET\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eericstj\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`Epic`, `area-Meta`, `untriaged`, `needs-area-label`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-02-13T17:26:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5zwa9n",
                                           "createdAt":  "2024-02-13T17:35:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-numerics\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nGoal: Provide a type for use as both exchange and interop that represents multi-dimensional data if a single primitive Type.  Implement arithmetic and linear algebra operations so that the type can serve as a sufficient basis for data preparation and as an input and output to neural networks.\r\n\r\n- [ ] Explore memory layouts and how they play into interop\r\n- [ ] Explore high-level Tensor\u003cT\u003e design\r\n  - Abstract?  Type heirarchy?  Construction patterns.\r\n  - Dense vs sparse\r\n  - Slices\r\n  - Dimension order\r\n  - Expected outcome: design document draft in dotnet/designs\r\n- [ ] Explore Tensor\u003cT\u003e arithmetic design\r\n- [ ] Explore Tensor\u003cT\u003e construction design\r\n- [ ] Explore Tensor\u003cT\u003e loading and saving\r\n- TODO: Further break down Tensor\u003cT\u003e implementation into smaller chunks\r\n- [ ] Tensor\u003cT\u003e API proposal\r\n  - Expected outcome: API review\r\n- [ ] Tensor\u003cT\u003e core types implementation\r\n  - Expected outcome: PR \r\n- TODO: Further break down Tensor\u003cT\u003e implementation into smaller chunks\r\n- [ ] Performance tests\r\n- [ ] Interop with OnnxRuntime\r\n- [ ] Interop with TorchSharp\r\n- [ ] Expose in ML.NET\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eericstj\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`Epic`, `area-Meta`, `area-System.Numerics`, `untriaged`, `needs-area-label`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-02-13T17:35:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5zwbDI",
                                           "createdAt":  "2024-02-13T17:35:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-numerics-tensors\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nGoal: Provide a type for use as both exchange and interop that represents multi-dimensional data if a single primitive Type.  Implement arithmetic and linear algebra operations so that the type can serve as a sufficient basis for data preparation and as an input and output to neural networks.\r\n\r\n- [ ] Explore memory layouts and how they play into interop\r\n- [ ] Explore high-level Tensor\u003cT\u003e design\r\n  - Abstract?  Type heirarchy?  Construction patterns.\r\n  - Dense vs sparse\r\n  - Slices\r\n  - Dimension order\r\n  - Expected outcome: design document draft in dotnet/designs\r\n- [ ] Explore Tensor\u003cT\u003e arithmetic design\r\n- [ ] Explore Tensor\u003cT\u003e construction design\r\n- [ ] Explore Tensor\u003cT\u003e loading and saving\r\n- TODO: Further break down Tensor\u003cT\u003e implementation into smaller chunks\r\n- [ ] Tensor\u003cT\u003e API proposal\r\n  - Expected outcome: API review\r\n- [ ] Tensor\u003cT\u003e core types implementation\r\n  - Expected outcome: PR \r\n- TODO: Further break down Tensor\u003cT\u003e implementation into smaller chunks\r\n- [ ] Performance tests\r\n- [ ] Interop with OnnxRuntime\r\n- [ ] Interop with TorchSharp\r\n- [ ] Expose in ML.NET\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eericstj\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`Epic`, `area-Meta`, `area-System.Numerics.Tensors`, `untriaged`, `needs-area-label`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-02-13T17:35:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5zz3yX",
                                           "createdAt":  "2024-02-14T02:06:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Shuenhoy",
                                           "body":  "I found my original comments somehow away from my actual intentions. The key point is not  ET, layz evaluation, or any specific techniques. It is the ability of eliminating intermediate arrays (known as _deforestation_, or _fusion_ https://en.wikipedia.org/wiki/Deforestation_(computer_science)). Users can always use lowlevel primitives to manually archive this.  But if the highlevel api can not handle this, its usages will be largely limited.\r\n\r\n- - -\r\n_original comments_\r\n\r\nFor the arithmetic and linear algebra operations, I suggest considering the \"expression template\"(ET) techniques commonly used in C++ world (eg. eigen3 and blaze), which is a kind of lazy evaluations that can reduce the allocation of temp object. This is helpful especially for a GC language.\r\n\r\nFor a quick impression, `v1 + v2` in ET will produce a `VecAdd\u003cVec, Vec\u003e` instead of a `Vec`. Similarly, `m * (v1 + v2)` will produce a `MatMul\u003cMat, VecAdd\u003cVec, Vec\u003e\u003e`. The computation is encoded in the type, and will get evaluated when assigned to a concrete `Vec` type.\r\n\r\nLast month, as part of attemp at rebasing my research from C++ to .NET, I made a  experiment with ET in .NET via generics: https://github.com/Shuenhoy/DotnetETExp . The (not sufficient but illustrative) results look promising and suggest ET may also be helpful in .NET world.\r\n\r\nHowever, there are serveral barries that prevent me further investigating:\r\n* Operator overloading does not support generic parameter (https://github.com/dotnet/csharplang/issues/813). The arithmetic in ET can happen between unlimited types, instead of finite types eg. Vector Matrix.\r\n* I then turned to F#, which supports some kinds of generic operators. However, I still cannot have generic parameter on `op_Implicit`, which means I cannot have the computation evaluated at assignment, but have to manually evaluate it like `let out = v1 + v2 |\u003e eval`\r\n* Generic constraint is not part of overload signature (https://github.com/dotnet/csharplang/discussions/2013). This preven definition of left multiple and right multiple in ET:\r\n```fsharp\r\n// ...\r\nmember (*.) (left: \u0027scalar \u0026 #INumberBase\u003c\u0027scalar\u003e, right: \u0027MatExp \u0026 #IMatExp\u003c\u0027matExp, \u0027scalar\u003e ) = // ...\r\nmember (*.) (left: \u0027matExp \u0026 #IMatExp\u003c\u0027matExp, \u0027scalar\u003e, right:  \u0027scalar \u0026 #INumberBase\u003c\u0027scalar\u003e ) = // ...\r\n```\r\nThere is an workaround to use a wrapper struct like `type MatExp\u003c\u0027inner, \u0027scalar when IMatExp\u003c\u0027inner\u003e and INumberBase\u003c\u0027scalar\u003e\u003e`. But then we have to manually do the wrap.\r\n* Lacks of const generics, as @hez2010 has mentioned (https://github.com/dotnet/runtime/issues/89730). Const generics have two benefits at least: inline allocate small matrix and prevent some potential bugs. For example, in graphics, it is common to use a `Matrix\u003cdouble, Dynamic, 3\u003e V` to store all vertices. Then `V.Row(x)` must be a expression of dimension `1*3`.\r\n* Ref struct cannot implement interface (https://github.com/dotnet/csharplang/issues/7608) .  As small matrix is allocated inline, their references need to be store in the expresstion type struct like `VecAdd` to avoid copy.\r\n* Lacks of (const) generic specialization. This can unify fix sized and dynamic sized matrix in the form `Matrix\u003cScalar, DimRow, DimCol\u003e` and simplify the API. \r\n\r\nSome other features like existential types (https://github.com/dotnet/csharplang/issues/5556) may also be useful. But I cannot provide more information for now. In case someone is interested, I have uploaded my attempts with F# here https://github.com/Shuenhoy/Furzn/  .\r\n\r\nThese feature requrests have been existed for a while and some may require changes in runtime and even metadata. I do not expect they can be all implemented any sooner. But I hope .NET foundation can take a closer look on them for a potentialy better presentation of Tensors and Linear algebra in .NET.\r\n",
                                           "updatedAt":  "2024-02-20T00:51:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5z5WCa",
                                           "createdAt":  "2024-02-14T18:54:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "Graph optimizations like that are a separate/independent concern and are not something that should be part of the default type experience.\r\n\r\nNone of the major tensor libraries force such handling. They all allow trivial direct usage and provide a separate way to do lazy evaluation over an expression tree in order to allow dynamic code generation for additional performance.",
                                           "updatedAt":  "2024-02-14T18:54:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5z8TUl",
                                           "createdAt":  "2024-02-15T00:50:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Shuenhoy",
                                           "body":  "Thanks for your reply!\r\n\r\n\u003e None of the major tensor libraries force such handling\r\n\r\nAt least almost all common used libraries in C++ world use this, Eigen3, blaze, xtensor, etc.\r\n\r\n\u003e part of the default type experience.\r\n\r\nIn most cases, the users should not experience any difference between an ET library and a \"direct usage\" library.\r\nThe following code can be both valid ET usage (but with higher perforamce without allocation of intermediate array) and direct usage, with the help of involve of implicit conversion.\r\n\r\n```csharp\r\nVectorXf x = m*(a + b + c); \r\nvar y = m*(a + b + c); // only with type inference will the expression types expose to user \r\n```\r\nIn fact, this is a major advantage of ET. It allows the users to write high performance code as natural as \"direct usage\" code.\r\nWe have examples in .NET world about the intermediate array problem that ET solves. TorchSharp has a page: https://github.com/dotnet/TorchSharp/wiki/Memory-Management .  The proposed methods are less natural (you have to write `using` for each tmp obj or use a disposing scope) and less performant (they can only offer deterministic disposing but not eliminate allocation).\r\n\r\nI propose ET because it\u0027s the most commonly used techniques to the best of my knoweldge. Though this is currently not possible in .NET, as my previous comment. I understand something may be out of the initial scope of the design goal and do not expect this can be solved in current stage. However, immediate array evaluation is definitely a fundamental problem and should be considered. Of course, techniques other than ET can be considered if they can be the same natural to write and performant (probably with the help of JIT?).",
                                           "updatedAt":  "2024-02-15T00:50:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5z839e",
                                           "createdAt":  "2024-02-15T04:19:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEBvMHQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "nietras",
                                                                               "createdAt":  "2024-03-03T09:22:05Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "saint4eva",
                                                                               "createdAt":  "2024-04-06T06:46:44Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "sunkin351",
                                                                               "createdAt":  "2025-01-09T21:36:21Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e At least almost all common used libraries in C++ world use this, Eigen3, blaze, xtensor, etc.\r\n\r\nI think we have different classifications of \"major\" here. C++ has several, but they tend to see far less usage than things like PyTorch, NumPy, TensorFlow, Jax, etc\r\n\r\nThe C++ libraries you called out are notably depending on templating very heavily here and don\u0027t really fit into the broader \"framework design guidelines\" that .NET has for it\u0027s APIs.\r\n\r\n\u003e In most cases, the users should not experience any difference between an ET library and a \"direct usage\" library.\r\n\r\nThis itself makes several assumptions including features that the consuming language supports and coding style that developers use in their codebase. Neither are things that we can rely on for something we\u0027re shipping from dotnet/runtime.\r\n\r\n-----------------\r\n\r\nA good design here is going to end up following the tried and true API design guidelines we have for .NET. It is going to consider how it integrates into the broader .NET ecosystem, how languages like C# and F# will consume it, and will be appropriately layered to correctly balance ease of use, extensibility, versioning, performance, and layering.\r\n\r\nI expect that this will ultimately come in the general shape of an `ITensor\u003cTSelf, T\u003e` interface, a `Tensor\u003cT\u003e` sealed class, and some kind of `ref struct TensorSpan\u003cT\u003e`. These will build on top of the already exposed `TensorPrimitives` APIs as a way of providing highly efficient CPU computation on a per operation basis.\r\n\r\nThis then gives a solid foundation on which it can be extended to support additional features. For example, it should be possible to design a `TensorBuilder` like type which could implement `ITensor\u003cTSelf, T\u003e` and build up an expression tree internally. It should be possible to use some level of `source generators` or potentially `interceptors` to achieve similar functionality.\r\n\r\nBy properly considering the core needs, the layering considerations, and ensuring we can have our tensor types appropriately expose the underlying memory or cheaply wrap other memory with the correct layout, we have a very robust and extensible system that follows the framework design guidelines and doesn\u0027t leave anything on the table.\r\n\r\nI\u0027m working on the general design doc currently and hope to have more to share in the coming weeks.",
                                           "updatedAt":  "2024-02-15T04:19:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5z9BEH",
                                           "createdAt":  "2024-02-15T05:01:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "RenderMichael",
                                           "body":  "A lot of the lazy-evaluation could be handled by returning an ITensor interface instance, and optimizing which lazily-evaluated version of ITensor is returned, LINQ-style. Would that be too much of a performance hit?",
                                           "updatedAt":  "2024-02-15T05:01:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5z9mN4",
                                           "createdAt":  "2024-02-15T07:51:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODpHGhQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "gaviny82",
                                                                               "createdAt":  "2024-07-10T08:11:55Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "Shuenhoy",
                                           "body":  "\u003e C++ has several, but they tend to see far less usage than things like PyTorch, NumPy, TensorFlow, Jax, etc\r\n\r\nI think it\u0027s a problem of area. I am not sure this new tensor libaray is ML-specific or tends to be more general. For ML, of course you will see a lot of PyTorch etc. But there are also physical-based simulation, geometry processing, numerical optmization, graphics etc., that also need a tensor/linear algebra libarary and may have different usages. These areas are definitely smaller than ML, so in total there are more usage of PyTorch etc. \r\n\r\nAnyway, I proposed ET here only because it\u0027s the only technique I am aware of. It will be great if there are other way better suited for .NET to handle it like the `source generator` and `interceptors` you mentioned. Looking forward to the design doc!\r\n\r\n\u003e A lot of the lazy-evaluation could be handled by returning an ITensor interface instance, and optimizing which lazily-evaluated version of ITensor is returned, LINQ-style. Would that be too much of a performance hit?\r\n\r\nFrom my experiments https://github.com/Shuenhoy/DotnetETExp , using interface seems to be slower than even eager evaluation. For LINQ, the operations themself are usually heavy enough, so the overhead of boxing and dynamic dispatch with interfaces can be ignored. But for tensor operations, 1) the dimension may be not as large as the overhead of interface can be ignored, 2) there are usually more frequent operations, it is very common for something like `(m.transpose() * (a + b * s)).dot(c.row(3)) + d.sum()`, i.e. you can easily involve more operations in even one single line.",
                                           "updatedAt":  "2024-02-15T09:43:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc55pb2H",
                                           "createdAt":  "2024-04-06T02:57:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GeorgeS2019",
                                           "body":  "\u003e Interop with TorchSharp\r\n\r\nThere are MANY hundreds of books written in python which TorchSharp can leverage\r\n\r\nWhen dealing with Tensors in .NET, only very advanced users understand what to do with them in .NET\r\n\r\nI urge more discussions using TorchSharp as context so we can see and then share where Tensors in .NET is attempting to acheive.\r\n\r\nWhat kinds of gaps and use cases that demand Tensors in .NET?\r\n\r\nThe whole concept of why we need to do this and how the goals not possible with e.g. TorchSharp is not very clear.\r\n\r\nThe .NET community is SO FAR behind compared to python.\r\n\r\nIntroducing something so that .NET community has something to play with without helping the communtiy to see **THE WHOLE is** making us nervous",
                                           "updatedAt":  "2024-04-06T02:57:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ILAAz",
                                           "createdAt":  "2024-08-12T17:43:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "Moving remaining work here to .NET 10. We made significant progress in .NET 9",
                                           "updatedAt":  "2024-08-12T17:43:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc65_Pu8",
                                           "createdAt":  "2025-07-25T21:08:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "The API surface will be stabilized in .NET 10 but the remaining items in the issue description will carry forward into .NET 11 follow-up.",
                                           "updatedAt":  "2025-07-25T21:08:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc66De1R",
                                           "createdAt":  "2025-07-26T08:04:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GeorgeS2019",
                                           "body":  "## TODO in .NET 11:\n-  Further break down Tensor implementation into smaller chunks\n\n- [ ] Performance tests\n\n- [ ] Interop with **OnnxRuntime**\n\n- [ ] Interop with **TorchSharp**\n\n- [ ] Expose in **ML.NET**",
                                           "updatedAt":  "2025-07-26T08:06:32Z"
                                       }
                                   ],
                         "totalCount":  14
                     },
        "title":  "Tensors in .NET",
        "labels":  [
                       "Epic",
                       "area-System.Numerics.Tensors"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/98862",
        "createdAt":  "2024-02-23T15:58:30Z",
        "number":  98862,
        "author":  "stephentoub",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC2tLgg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hamarb123",
                                            "createdAt":  "2024-03-22T05:04:30Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-07-16T06:33:00Z",
        "body":  "### Background and motivation\r\n\r\nThese slipped through when aiming for parity.\r\n\r\n### API Proposal\r\n\r\n```diff\r\nnamespace System.Numerics.Tensors;\r\n\r\npublic static class TensorPrimitives\r\n{\r\n    // Same surface area as Min/Max{Magnitude}, but for Min/Max{Magnitude}Number\r\n+   public static int IndexOfMaxNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x) where T : INumber\u003cT\u003e;\r\n+   public static int IndexOfMinNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x) where T : INumber\u003cT\u003e;\r\n+   public static int IndexOfMaxMagnitudeNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x) where T : INumber\u003cT\u003e;\r\n+   public static int IndexOfMinMagnitudeNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x) where T : INumber\u003cT\u003e;\r\n\r\n+   public static T MaxMagnitudeNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x) where T : INumberBase\u003cT\u003e;\r\n+   public static void MaxMagnitudeNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x, ReadOnlySpan\u003cT\u003e y, System.Span\u003cT\u003e destination) where T : INumberBase\u003cT\u003e;\r\n+   public static void MaxMagnitudeNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x, T y, Span\u003cT\u003e destination) where T : INumberBase\u003cT\u003e;\r\n\r\n+   public static T MaxNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x) where T : INumber\u003cT\u003e;\r\n+   public static void MaxNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x, ReadOnlySpan\u003cT\u003e y, Span\u003cT\u003e destination) where T : INumber\u003cT\u003e;\r\n+   public static void MaxNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x, T y, Span\u003cT\u003e destination) where T : INumber\u003cT\u003e;\r\n\r\n+   public static T MinMagnitudeNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x) where T : INumberBase\u003cT\u003e;\r\n+   public static void MinMagnitudeNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x, ReadOnlySpan\u003cT\u003e y, Span\u003cT\u003e destination) where T : INumberBase\u003cT\u003e;\r\n+   public static void MinMagnitudeNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x, T y, Span\u003cT\u003e destination) where T : INumberBase\u003cT\u003e;\r\n\r\n+   public static T MinNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x) where T : INumber\u003cT\u003e;\r\n+   public static void MinNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x, ReadOnlySpan\u003cT\u003e y, Span\u003cT\u003e destination) where T : INumber\u003cT\u003e;\r\n+   public static void MinNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x, T y, Span\u003cT\u003e destination) where T : INumber\u003cT\u003e;\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\nTensorPrimitives.MaxMagnitude(x, y, dest);\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOhEhRRg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5062cI",
                                           "createdAt":  "2024-02-23T15:58:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-numerics-tensors\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nThese slipped through when aiming for parity.\n\n### API Proposal\n\n```diff\r\nnamespace System.Numerics.Tensors;\r\n\r\npublic static class TensorPrimitives\r\n{\r\n    // Same surface area as Min/Max{Magnitude}, but for Min/Max{Magnitude}Number\r\n+   public static int IndexOfMaxNumber\u003cT\u003e(System.ReadOnlySpan\u003cT\u003e x) where T : INumber\u003cT\u003e;\r\n+   public static int IndexOfMinNumber\u003cT\u003e(System.ReadOnlySpan\u003cT\u003e x) where T : INumber\u003cT\u003e;\r\n+   public static int IndexOfMaxMagnitudeNumber\u003cT\u003e(System.ReadOnlySpan\u003cT\u003e x) where T : INumber\u003cT\u003e;\r\n+   public static int IndexOfMinMagnitudeNumber\u003cT\u003e(System.ReadOnlySpan\u003cT\u003e x) where T : INumber\u003cT\u003e;\r\n\r\n+   public static T MaxMagnitudeNumber\u003cT\u003e(System.ReadOnlySpan\u003cT\u003e x) where T : INumberBase\u003cT\u003e;\r\n+   public static void MaxMagnitudeNumber\u003cT\u003e(System.ReadOnlySpan\u003cT\u003e x, System.ReadOnlySpan\u003cT\u003e y, System.Span\u003cT\u003e destination) where T : INumberBase\u003cT\u003e;\r\n+   public static void MaxMagnitudeNumber\u003cT\u003e(System.ReadOnlySpan\u003cT\u003e x, T y, System.Span\u003cT\u003e destination) where T : INumberBase\u003cT\u003e;\r\n\r\n+   public static T MaxNumber\u003cT\u003e(System.ReadOnlySpan\u003cT\u003e x) where T : INumber\u003cT\u003e;\r\n+   public static void MaxNumber\u003cT\u003e(System.ReadOnlySpan\u003cT\u003e x, System.ReadOnlySpan\u003cT\u003e y, System.Span\u003cT\u003e destination) where T : INumber\u003cT\u003e;\r\n+   public static void MaxNumber\u003cT\u003e(System.ReadOnlySpan\u003cT\u003e x, T y, System.Span\u003cT\u003e destination) where T : INumber\u003cT\u003e;\r\n\r\n+   public static T MinMagnitudeNumber\u003cT\u003e(System.ReadOnlySpan\u003cT\u003e x) where T : INumberBase\u003cT\u003e;\r\n+   public static void MinMagnitudeNumber\u003cT\u003e(System.ReadOnlySpan\u003cT\u003e x, System.ReadOnlySpan\u003cT\u003e y, System.Span\u003cT\u003e destination) where T : INumberBase\u003cT\u003e;\r\n+   public static void MinMagnitudeNumber\u003cT\u003e(System.ReadOnlySpan\u003cT\u003e x, T y, System.Span\u003cT\u003e destination) where T : INumberBase\u003cT\u003e;\r\n\r\n+   public static T MinNumber\u003cT\u003e(System.ReadOnlySpan\u003cT\u003e x) where T : INumber\u003cT\u003e;\r\n+   public static void MinNumber\u003cT\u003e(System.ReadOnlySpan\u003cT\u003e x, System.ReadOnlySpan\u003cT\u003e y, System.Span\u003cT\u003e destination) where T : INumber\u003cT\u003e;\r\n+   public static void MinNumber\u003cT\u003e(System.ReadOnlySpan\u003cT\u003e x, T y, System.Span\u003cT\u003e destination) where T : INumber\u003cT\u003e;\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nTensorPrimitives.MaxMagnitude(x, y, dest);\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003estephentoub\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Numerics.Tensors`, `api-ready-for-review`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-02-23T15:58:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56B2se",
                                           "createdAt":  "2024-04-10T11:42:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODeHydQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "WeihanLi",
                                                                               "createdAt":  "2024-04-15T01:27:22Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "eiriktsarpalis",
                                           "body":  "The `Number` suffix feels redundant, is it intended to disambiguate from existing method groups?",
                                           "updatedAt":  "2024-04-10T11:42:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56MtHB",
                                           "createdAt":  "2024-04-11T17:16:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bartonjs",
                                           "body":  "[Video](https://www.youtube.com/watch?v=BKd3mq2XgNk\u0026t=0h0m0s)\n\n\r\n* Looks good as proposed\r\n\r\n```c#\r\nnamespace System.Numerics.Tensors;\r\n\r\npublic static class TensorPrimitives\r\n{\r\n    // Same surface area as Min/Max{Magnitude}, but for Min/Max{Magnitude}Number\r\n    public static int IndexOfMaxNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x) where T : INumber\u003cT\u003e;\r\n    public static int IndexOfMinNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x) where T : INumber\u003cT\u003e;\r\n    public static int IndexOfMaxMagnitudeNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x) where T : INumber\u003cT\u003e;\r\n    public static int IndexOfMinMagnitudeNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x) where T : INumber\u003cT\u003e;\r\n\r\n    public static T MaxMagnitudeNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x) where T : INumberBase\u003cT\u003e;\r\n    public static void MaxMagnitudeNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x, ReadOnlySpan\u003cT\u003e y, System.Span\u003cT\u003e destination) where T : INumberBase\u003cT\u003e;\r\n    public static void MaxMagnitudeNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x, T y, Span\u003cT\u003e destination) where T : INumberBase\u003cT\u003e;\r\n\r\n    public static T MaxNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x) where T : INumber\u003cT\u003e;\r\n    public static void MaxNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x, ReadOnlySpan\u003cT\u003e y, Span\u003cT\u003e destination) where T : INumber\u003cT\u003e;\r\n    public static void MaxNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x, T y, Span\u003cT\u003e destination) where T : INumber\u003cT\u003e;\r\n\r\n    public static T MinMagnitudeNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x) where T : INumberBase\u003cT\u003e;\r\n    public static void MinMagnitudeNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x, ReadOnlySpan\u003cT\u003e y, Span\u003cT\u003e destination) where T : INumberBase\u003cT\u003e;\r\n    public static void MinMagnitudeNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x, T y, Span\u003cT\u003e destination) where T : INumberBase\u003cT\u003e;\r\n\r\n    public static T MinNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x) where T : INumber\u003cT\u003e;\r\n    public static void MinNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x, ReadOnlySpan\u003cT\u003e y, Span\u003cT\u003e destination) where T : INumber\u003cT\u003e;\r\n    public static void MinNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x, T y, Span\u003cT\u003e destination) where T : INumber\u003cT\u003e;\r\n}\r\n```",
                                           "updatedAt":  "2024-04-11T19:09:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6DLofM",
                                           "createdAt":  "2024-07-01T19:23:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Remaining after https://github.com/dotnet/runtime/pull/101435\n```C#\npublic static class TensorPrimitives\n{\n    public static int IndexOfMaxNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x) where T : INumber\u003cT\u003e;\n    public static int IndexOfMinNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x) where T : INumber\u003cT\u003e;\n    public static int IndexOfMaxMagnitudeNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x) where T : INumber\u003cT\u003e;\n    public static int IndexOfMinMagnitudeNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x) where T : INumber\u003cT\u003e;\n\n    public static T MaxMagnitudeNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x) where T : INumberBase\u003cT\u003e;\n    public static void MaxMagnitudeNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x, ReadOnlySpan\u003cT\u003e y, System.Span\u003cT\u003e destination) where T : INumberBase\u003cT\u003e;\n    public static void MaxMagnitudeNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x, T y, Span\u003cT\u003e destination) where T : INumberBase\u003cT\u003e;\n\n    public static T MinMagnitudeNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x) where T : INumberBase\u003cT\u003e;\n    public static void MinMagnitudeNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x, ReadOnlySpan\u003cT\u003e y, Span\u003cT\u003e destination) where T : INumberBase\u003cT\u003e;\n    public static void MinMagnitudeNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x, T y, Span\u003cT\u003e destination) where T : INumberBase\u003cT\u003e;\n}\n```",
                                           "updatedAt":  "2024-07-01T19:23:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6DLpfb",
                                           "createdAt":  "2024-07-01T19:26:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODn8TPA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "stephentoub",
                                                                               "createdAt":  "2024-07-01T19:30:53Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "These should be a little easier to implement with https://github.com/dotnet/runtime/pull/103837 as well",
                                           "updatedAt":  "2024-07-01T19:26:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ESFFG",
                                           "createdAt":  "2024-07-10T02:00:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Remaining after https://github.com/dotnet/runtime/pull/104651\n```C#\npublic static class TensorPrimitives\n{\n    public static int IndexOfMaxNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x) where T : INumber\u003cT\u003e;\n    public static int IndexOfMinNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x) where T : INumber\u003cT\u003e;\n    public static int IndexOfMaxMagnitudeNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x) where T : INumber\u003cT\u003e;\n    public static int IndexOfMinMagnitudeNumber\u003cT\u003e(ReadOnlySpan\u003cT\u003e x) where T : INumber\u003cT\u003e;\n}\n```",
                                           "updatedAt":  "2024-07-10T02:00:26Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "[API Proposal]: Add missing Min/MaxNumber generic math APIs on TensorPrimitives",
        "labels":  [
                       "api-approved",
                       "area-System.Numerics.Tensors"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/101846",
        "createdAt":  "2024-05-03T14:20:25Z",
        "number":  101846,
        "author":  "tannergooding",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-16T05:58:26Z",
        "body":  "As per the title, the `System.Numerics.Tensors.Net8.Tests` do not appear to currently be running against .NET 8 as intended. Instead, they are compiled for .NET 8 and appear to be running on the .NET 9 runtime via the roll forward mechanism.\r\n\r\nThis can be seen in one of the CI legs for https://github.com/dotnet/runtime/pull/101800 where the `Net8.Tests` project has the following failure:\r\n```\r\nSystem.Numerics.Tensors.Tests.SingleGenericTensorPrimitives.SpanDestinationFunctions_SpecialValues(tensorPrimitivesMethod: SpanDestinationDelegate { Method = Void ReciprocalSqrtEstimate[Single](System.ReadOnlySpan`1[System.Single], System.Span`1[System.Single]), Target = null }, expectedMethod: Func`2 { Method = Single ReciprocalSqrtEstimate(Single), Target = null }, tolerance: 0.01171875) [FAIL]\r\n      Assert.All() Failure: 253 out of 256 items in the collection did not pass.\r\n      [3]:   Item:  4\r\n             Error: Assert.All() Failure: 9 out of 24 items in the collection did not pass.\r\n                    [12]: Item:  -1.40129846E-45\r\n                          Error: Assert.Equal() Failure: Values differ\r\n                                 Expected: NaN\r\n                                 Actual:   -∞\r\n```\r\n\r\nThe actual test is comparing the result of the `TensorPrimitives.ReciprocalSqrtEstimate` function against the in-box `float.ReciprocalSqrtEstimate` API. On .NET 8, the `float` version will call into `Sse.ReciprocalSqrtScalar` which treats subnormal values as `flush-to-zero` and therefore does `1 / Sqrt(-0.0f)` which returns `-∞`, however the expected value is `NaN` indicated that the `float` version isntead called into `Avx512F.Reciprocal14SqrtScalar` which handles all non-zero negatives as properly negative and thus is doing `1 / Sqrt(nonZeroNegative)` which returns `NaN`. This highlights that it is actually running against .NET 9 and not testing what we think it should be testing.\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOfpUg-A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc58woYL",
                                           "createdAt":  "2024-05-03T14:20:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-infrastructure-libraries\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-05-03T14:20:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc58wvli",
                                           "createdAt":  "2024-05-03T14:36:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ViktorHofer",
                                           "body":  "\u003e As per the title, the System.Numerics.Tensors.Net8.Tests do not appear to currently be running against .NET 8 as intended. Instead, they are compiled for .NET 8 and appear to be running on the .NET 9 runtime via the roll forward mechanism.\r\n\r\nCorrect. None of the libraries tests in dotnet/runtime run against a previous version of .NETCoreApp: https://github.com/dotnet/runtime/issues/54639\r\n\r\nWe only test the NetCoreAppCurrent and NetFrameworkCurrent/NetFrameworkMinimum TFMs via tests. That\u0027s a known gap that we never had resources to close.",
                                           "updatedAt":  "2024-05-03T14:36:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc58w3bx",
                                           "createdAt":  "2024-05-03T14:55:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e \u003e As per the title, the System.Numerics.Tensors.Net8.Tests do not appear to currently be running against .NET 8 as intended. Instead, they are compiled for .NET 8 and appear to be running on the .NET 9 runtime via the roll forward mechanism.\r\n\u003e \r\n\u003e Correct. None of the libraries tests in dotnet/runtime run against a previous version of .NETCoreApp: #54639\r\n\u003e \r\n\u003e We only test the NetCoreAppCurrent and NetFrameworkCurrent/NetFrameworkMinimum TFMs via tests. That\u0027s a known gap that we never had resources to close.\r\n\r\nOk, so this project is using the .NET 8 build of SNT (and thus exercising .NET 8 code paths in the assembly) but running on .NET 9?",
                                           "updatedAt":  "2024-05-03T14:55:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc58w6tj",
                                           "createdAt":  "2024-05-03T15:01:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODgjnTQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ViktorHofer",
                                                                               "createdAt":  "2024-05-03T18:51:00Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "That\u0027s what it looks like to me.\r\n\r\nHence the issue is that the `System.Numerics.Tensors v8.0` tests expects `ReciprocalSqrtEstimate` to behave one way (doesn\u0027t use AVX512) but `System.Private.Corelib v9` does it a different way (does use AVX512). Leading the tests to fail since they can\u0027t compare the `TensorPrimitives` results against the scalar (float) results.\r\n\r\nThe `Estimate` APIs are intentionally allowed to differ cross processes, and so changing behavior over time is expected. It\u0027s just this oddity in how our tests are written that causes this to be a problem for us since we can\u0027t guarantee the behavior is synchronized for our own out of band library.",
                                           "updatedAt":  "2024-05-03T15:03:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc592g-s",
                                           "createdAt":  "2024-05-15T01:59:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "v-wenyuxu",
                                           "body":  "**Failed in:** [runtime-coreclr libraries-jitstress 20240514.1](https://dev.azure.com/dnceng-public/public/_build/results?buildId=674625\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=16724110\u0026resultId=175546\u0026paneView=debug)\r\n\r\n**Failed tests:**\r\n```\r\nnet9.0-linux-Release-x64-jitstress2_tiered-Ubuntu.2204.Amd64.Open\r\n    - System.Numerics.Tensors.Tests.NonGenericSingleTensorPrimitivesTests.CosineSimilarity_AllLengths\r\n    - System.Numerics.Tensors.Tests.SingleGenericTensorPrimitives.CosineSimilarity_AllLengths\r\nnet9.0-linux-Release-x64-jitstress1_tiered-Ubuntu.2204.Amd64.Open\r\n    - System.Numerics.Tensors.Tests.NonGenericSingleTensorPrimitivesTests.CosineSimilarity_AllLengths\r\n    - System.Numerics.Tensors.Tests.NonGenericSingleTensorPrimitivesTests.CosineSimilarity_AllLengths\r\nnet9.0-windows-Release-x64-jitstress1_tiered-Windows.10.Amd64.Open\r\n    - System.Numerics.Tensors.Tests.NonGenericSingleTensorPrimitivesTests.CosineSimilarity_AllLengths\r\n    - System.Numerics.Tensors.Tests.NonGenericSingleTensorPrimitivesTests.CosineSimilarity_AllLengths\r\n    - System.Numerics.Tensors.Tests.SingleGenericTensorPrimitives.CosineSimilarity_AllLengths\r\n```\r\n\r\n**Error message:**\r\n```\r\n Assert.All() Failure: 4 out of 256 items in the collection did not pass.\r\n[3]: Item:  4\r\n     Error: Assert.Equal() Failure: Values differ\r\n            Expected: 0.151808769\r\n            Actual:   0.25312683\r\n[4]: Item:  5\r\n     Error: Assert.Equal() Failure: Values differ\r\n            Expected: 0.253379166\r\n            Actual:   0.138663024\r\n[5]: Item:  6\r\n     Error: Assert.Equal() Failure: Values differ\r\n            Expected: -0.344092488\r\n            Actual:   -0.0114496415\r\n[6]: Item:  7\r\n     Error: Assert.Equal() Failure: Values differ\r\n            Expected: -0.410494238\r\n            Actual:   -0.248638168\r\n```\r\n\r\n**Stack trace:**\r\n```\r\n   at System.Numerics.Tensors.Tests.TensorPrimitivesTests`1.CosineSimilarity_AllLengths() in /_/src/libraries/System.Numerics.Tensors/tests/TensorPrimitivesTests.cs:line 740\r\n   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)\r\n   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr) in /_/src/libraries/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.cs:line 57\r\n```",
                                           "updatedAt":  "2024-05-15T01:59:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc59_Q95",
                                           "createdAt":  "2024-05-16T01:26:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "@v-wenyuxu, that last failure doesn\u0027t appear to be related to this discussion. And while the one prior to that is related, it\u0027s not the same thing. Can you please open new issues for each if there\u0027s nothing else relevant open now? Thanks.",
                                           "updatedAt":  "2024-05-16T01:26:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-J2OP",
                                           "createdAt":  "2024-05-17T02:22:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "v-wenyuxu",
                                           "body":  "**Failed in:** [runtime-coreclr libraries-jitstress 20240516.4](https://dev.azure.com/dnceng-public/public/_build/results?buildId=678186\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=16810164\u0026resultId=178790\u0026paneView=debug)\r\n\r\n**Failed tests:**\r\n```\r\nnet9.0-linux-Release-x64-jitstress2_tiered-Ubuntu.2204.Amd64.Open\r\n    - System.Numerics.Tensors.Tests.SingleGenericTensorPrimitives.CosineSimilarity_AllLengths\r\nnet9.0-linux-Release-x64-jitstress1_tiered-Ubuntu.2204.Amd64.Open\r\n    - System.Numerics.Tensors.Tests.NonGenericSingleTensorPrimitivesTests.CosineSimilarity_AllLengths\r\nnet9.0-windows-Release-x64-jitstress1_tiered-Windows.10.Amd64.Open\r\n    - System.Numerics.Tensors.Tests.SingleGenericTensorPrimitives.CosineSimilarity_AllLengths\r\n    - System.Numerics.Tensors.Tests.NonGenericSingleTensorPrimitivesTests.CosineSimilarity_AllLengths\r\n    - System.Numerics.Tensors.Tests.SingleGenericTensorPrimitives.CosineSimilarity_AllLengths\r\n    - System.Numerics.Tensors.Tests.NonGenericSingleTensorPrimitivesTests.CosineSimilarity_AllLengths\r\n```\r\n\r\n**Error message:**\r\n```\r\n Assert.All() Failure: 4 out of 256 items in the collection did not pass.\r\n[3]: Item:  4\r\n     Error: Assert.Equal() Failure: Values differ\r\n            Expected: 0.151808769\r\n            Actual:   0.25312683\r\n[4]: Item:  5\r\n     Error: Assert.Equal() Failure: Values differ\r\n            Expected: 0.253379166\r\n            Actual:   0.138663024\r\n[5]: Item:  6\r\n     Error: Assert.Equal() Failure: Values differ\r\n            Expected: -0.344092488\r\n            Actual:   -0.0114496415\r\n[6]: Item:  7\r\n     Error: Assert.Equal() Failure: Values differ\r\n            Expected: -0.410494238\r\n            Actual:   -0.248638168\r\n```\r\n\r\n**Stack trace:**\r\n```\r\n   at System.Numerics.Tensors.Tests.TensorPrimitivesTests`1.CosineSimilarity_AllLengths() in /_/src/libraries/System.Numerics.Tensors/tests/TensorPrimitivesTests.cs:line 740\r\n   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)\r\n   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr) in /_/src/libraries/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.cs:line 57\r\n```\r\n",
                                           "updatedAt":  "2024-05-17T02:22:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-VUkV",
                                           "createdAt":  "2024-05-20T01:38:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "v-wenyuxu",
                                           "body":  "**Failed in:** [runtime-coreclr libraries-jitstress 20240519.1](https://dev.azure.com/dnceng-public/public/_build/results?buildId=680505\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=16879242\u0026resultId=182318\u0026paneView=debug)\r\n\r\n**Failed tests:**\r\n```\r\nnet9.0-linux-Release-x64-jitstress2_tiered-Ubuntu.2204.Amd64.Open\r\n    - System.Numerics.Tensors.Tests.NonGenericSingleTensorPrimitivesTests.CosineSimilarity_AllLengths\r\n    - System.Numerics.Tensors.Tests.NonGenericSingleTensorPrimitivesTests.CosineSimilarity_AllLengths\r\nnet9.0-linux-Release-x64-jitstress1_tiered-Ubuntu.2204.Amd64.Open\r\n    - System.Numerics.Tensors.Tests.NonGenericSingleTensorPrimitivesTests.CosineSimilarity_AllLengths\r\n    - System.Numerics.Tensors.Tests.NonGenericSingleTensorPrimitivesTests.CosineSimilarity_AllLengths\r\nnet9.0-windows-Release-x64-jitstress1_tiered-Windows.10.Amd64.Open\r\n    - System.Numerics.Tensors.Tests.NonGenericSingleTensorPrimitivesTests.CosineSimilarity_AllLengths\r\n    - System.Numerics.Tensors.Tests.NonGenericSingleTensorPrimitivesTests.CosineSimilarity_AllLengths\r\n    - System.Numerics.Tensors.Tests.SingleGenericTensorPrimitives.CosineSimilarity_AllLengths\r\n```\r\n\r\n**Error message:**\r\n```\r\n Assert.All() Failure: 4 out of 256 items in the collection did not pass.\r\n[3]: Item:  4\r\n     Error: Assert.Equal() Failure: Values differ\r\n            Expected: 0.151808769\r\n            Actual:   0.25312683\r\n[4]: Item:  5\r\n     Error: Assert.Equal() Failure: Values differ\r\n            Expected: 0.253379166\r\n            Actual:   0.138663024\r\n[5]: Item:  6\r\n     Error: Assert.Equal() Failure: Values differ\r\n            Expected: -0.344092488\r\n            Actual:   -0.0114496415\r\n[6]: Item:  7\r\n     Error: Assert.Equal() Failure: Values differ\r\n            Expected: -0.410494238\r\n            Actual:   -0.248638168\r\n```\r\n\r\n**Stack trace:**\r\n```\r\n   at System.Numerics.Tensors.Tests.TensorPrimitivesTests`1.CosineSimilarity_AllLengths() in /_/src/libraries/System.Numerics.Tensors/tests/TensorPrimitivesTests.cs:line 740\r\n   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)\r\n   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr) in /_/src/libraries/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.cs:line 57\r\n```\r\n",
                                           "updatedAt":  "2024-05-20T01:38:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-c9pW",
                                           "createdAt":  "2024-05-21T01:16:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "v-wenyuxu",
                                           "body":  "**Failed in:** [runtime-coreclr libraries-jitstress 20240520.1](https://dev.azure.com/dnceng-public/public/_build/results?buildId=681081\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=16901002\u0026resultId=188437\u0026paneView=debug)\r\n\r\n**Failed tests:**\r\n```\r\nnet9.0-linux-Release-x64-jitstress2_tiered-Ubuntu.2204.Amd64.Open\r\n    - System.Numerics.Tensors.Tests.SingleGenericTensorPrimitives.CosineSimilarity_AllLengths\r\n    - System.Numerics.Tensors.Tests.SingleGenericTensorPrimitives.CosineSimilarity_AllLengths\r\nnet9.0-linux-Release-x64-jitstress1_tiered-Ubuntu.2204.Amd64.Open\r\n    - System.Numerics.Tensors.Tests.NonGenericSingleTensorPrimitivesTests.CosineSimilarity_AllLengths\r\n    - System.Numerics.Tensors.Tests.SingleGenericTensorPrimitives.CosineSimilarity_AllLengths\r\nnet9.0-windows-Release-x64-jitstress1_tiered-Windows.10.Amd64.Open\r\n    - System.Numerics.Tensors.Tests.NonGenericSingleTensorPrimitivesTests.CosineSimilarity_AllLengths\r\n    - System.Numerics.Tensors.Tests.NonGenericSingleTensorPrimitivesTests.CosineSimilarity_AllLengths\r\n    - System.Numerics.Tensors.Tests.SingleGenericTensorPrimitives.CosineSimilarity_AllLengths\r\n```\r\n\r\n**Error message:**\r\n```\r\n Assert.All() Failure: 4 out of 256 items in the collection did not pass.\r\n[3]: Item:  4\r\n     Error: Assert.Equal() Failure: Values differ\r\n            Expected: 0.151808769\r\n            Actual:   0.25312683\r\n[4]: Item:  5\r\n     Error: Assert.Equal() Failure: Values differ\r\n            Expected: 0.253379166\r\n            Actual:   0.138663024\r\n[5]: Item:  6\r\n     Error: Assert.Equal() Failure: Values differ\r\n            Expected: -0.344092488\r\n            Actual:   -0.0114496415\r\n[6]: Item:  7\r\n     Error: Assert.Equal() Failure: Values differ\r\n            Expected: -0.410494238\r\n            Actual:   -0.248638168\r\n```\r\n\r\n**Stack trace:**\r\n```\r\n   at System.Numerics.Tensors.Tests.TensorPrimitivesTests`1.CosineSimilarity_AllLengths() in /_/src/libraries/System.Numerics.Tensors/tests/TensorPrimitivesTests.cs:line 740\r\n   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)\r\n   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr) in /_/src/libraries/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.cs:line 57\r\n```",
                                           "updatedAt":  "2024-05-21T01:16:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-k0Kz",
                                           "createdAt":  "2024-05-21T23:16:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-numerics-tensors\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-05-21T23:16:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-lSD4",
                                           "createdAt":  "2024-05-22T01:20:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "v-wenyuxu",
                                           "body":  "**Failed in:** [runtime-coreclr libraries-jitstress 20240521.1](https://dev.azure.com/dnceng-public/public/_build/results?buildId=682386\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=16934482\u0026resultId=176226\u0026paneView=debug)\r\n\r\n**Failed tests:**\r\n```\r\nnet9.0-linux-Release-x64-jitstress2_tiered-Ubuntu.2204.Amd64.Open\r\n    - System.Numerics.Tensors.Tests.SingleGenericTensorPrimitives.CosineSimilarity_AllLengths\r\n    - System.Numerics.Tensors.Tests.NonGenericSingleTensorPrimitivesTests.CosineSimilarity_AllLengths\r\nnet9.0-linux-Release-x64-jitstress1_tiered-Ubuntu.2204.Amd64.Open\r\n    - System.Numerics.Tensors.Tests.NonGenericSingleTensorPrimitivesTests.CosineSimilarity_AllLengths\r\n    - System.Numerics.Tensors.Tests.NonGenericSingleTensorPrimitivesTests.CosineSimilarity_AllLengths\r\nnet9.0-windows-Release-x64-jitstress1_tiered-Windows.10.Amd64.Open\r\n    - System.Numerics.Tensors.Tests.NonGenericSingleTensorPrimitivesTests.CosineSimilarity_AllLengths\r\n    - System.Numerics.Tensors.Tests.NonGenericSingleTensorPrimitivesTests.CosineSimilarity_AllLengths\r\n    - System.Numerics.Tensors.Tests.SingleGenericTensorPrimitives.CosineSimilarity_AllLengths\r\n```\r\n\r\n**Error message:**\r\n```\r\n Assert.All() Failure: 4 out of 256 items in the collection did not pass.\r\n[3]: Item:  4\r\n     Error: Assert.Equal() Failure: Values differ\r\n            Expected: 0.151808769\r\n            Actual:   0.25312683\r\n[4]: Item:  5\r\n     Error: Assert.Equal() Failure: Values differ\r\n            Expected: 0.253379166\r\n            Actual:   0.138663024\r\n[5]: Item:  6\r\n     Error: Assert.Equal() Failure: Values differ\r\n            Expected: -0.344092488\r\n            Actual:   -0.0114496415\r\n[6]: Item:  7\r\n     Error: Assert.Equal() Failure: Values differ\r\n            Expected: -0.410494238\r\n            Actual:   -0.248638168\r\n```\r\n\r\n**Stack trace:**\r\n```\r\n   at System.Numerics.Tensors.Tests.TensorPrimitivesTests`1.CosineSimilarity_AllLengths() in /_/src/libraries/System.Numerics.Tensors/tests/TensorPrimitivesTests.cs:line 740\r\n   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)\r\n   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr) in /_/src/libraries/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.cs:line 57\r\n```",
                                           "updatedAt":  "2024-05-22T01:20:47Z"
                                       }
                                   ],
                         "totalCount":  11
                     },
        "title":  "System.Numerics.Tensors.Net8.Tests does not appear to actually run against .NET 8",
        "labels":  [
                       "area-System.Numerics.Tensors"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/102268",
        "createdAt":  "2024-05-15T16:28:07Z",
        "number":  102268,
        "author":  "tannergooding",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC38eyQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2024-05-16T09:46:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-05-16T13:26:24Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2025-07-16T06:05:04Z",
        "body":  "Work is being done to introduce a `Tensor\u003cT\u003e` and supporting types. Due to often representing slices of multi-dimensional memory, there is quite a lot of additional data that needs to be tracked beyond what something like `Span\u003cT\u003e` needs. Correspondingly, the naive approach requires tracking multiple `nint[]` to support the potential for an arbitrary number of dimensions and therefore for an allocation to be made per slice. Doing these allocations every time a slice needs to be produced can get expensive and should ideally be optimized to allow avoiding it for common dimension counts.\r\n\r\nA simple approach would be to track a single `nint[]` where it has `rank` pieces of data tracking the length of each dimension and then `rank` more pieces of data tracking the stride of each dimension. But, this still necessitates an allocation every time. The next best thing would be to track data inline for some common dimension counts, but this quickly grows the size of the `TensorSpan` and that can itself have negative impact due to the larger copies required when passing the data by value, it can also negatively impact the CPU cache if it grows too large.\r\n\r\nAs such, the optimal setup is likely to pick a limit that is representative of commonly encountered dimension counts and which is no larger than a single cache line (typically assumed to be 64 bytes).",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOt2cNxQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc598ZEy",
                                           "createdAt":  "2024-05-15T16:28:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-numerics-tensors\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-05-15T16:28:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc598e2W",
                                           "createdAt":  "2024-05-15T16:41:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEHIcAA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tjwald",
                                                                               "createdAt":  "2025-02-21T06:25:55Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "Given the constraints described above, if we were to track the data inline using `nint` then we can track up to 3 dimensions on a 64-bit system:\r\n```csharp\r\npublic ref struct SpanND\u003cT\u003e\r\n{\r\n    private ref T _reference;       // 8 bytes\r\n    private nint[]? _metadata;         // 8 bytes\r\n\r\n    private fixed nint _lengths[3]; // 3x8 bytes (24)\r\n    private fixed nint _strides[3]; // 3x8 bytes (24)\r\n}\r\n```\r\n\r\nWhile this covers the most frequent dimension counts (1, 2, and 3), it excludes some other dimension counts (4 and 5) which are encountered, although less frequently (it depends on the domain). It also doesn\u0027t allow tracking the underlying `FlattenedLength`, which must now be computed dynamically, and doesn\u0027t allow tracking the `Rank` so some schema must be determined to allow figuring out how many dimensions exist (likely by stopping at the first `_lengths` entry that is 0).\r\n\r\n----------------------\r\n\r\nIf we were to track the `FlattenedLength` and `Rank` explicitly, we end up going down to `2` dimensions which is undesirable. However, if we say that we only need to avoid allocations for common cases and having more than `2.14b elements` in a single dimension or single tensor is uncommon, then we could define something like:\r\n```csharp\r\npublic ref struct SpanND\u003cT\u003e\r\n{\r\n    private ref T _reference;       // 8 bytes\r\n    private nint[]? _metadata;      // 8 bytes\r\n\r\n    private int _flattenedLength;   // 4 bytes\r\n    private int _rank;              // 4 bytes\r\n\r\n    private fixed int _lengths[5];  // 5x4 bytes (20)\r\n    private fixed int _strides[5];  // 5x4 bytes (20)\r\n}\r\n```\r\n\r\nThis allows tracking up to 5 dimensions and all the relevant information for the common case without allocating. Whether we use the inline data or not can be trivially checked by checking if `_metadata is null`. It is what I think to be the overall best approach and what we should likely pursue first.\r\n\r\nOne alternative layout would be to reduce this to tracking 4 dimensions so that the `_flattenedLength` can be `nint` and giving us space to track some explicit flags for any optimizations or other work that was desired (although many such flags could also exist in the prior case by using one\u0027s complement negatives like is done for `fromEnd` in `Index`):\r\n```csharp\r\npublic ref struct SpanND\u003cT\u003e\r\n{\r\n    private ref T _reference;       // 8 bytes\r\n    private nint[]? _metadata;      // 8 bytes\r\n\r\n    private nint _flattenedLength;  // 8 bytes\r\n    private int _rank;              // 4 bytes\r\n    private int _flags;             // 4 bytes\r\n\r\n    private fixed int _lengths[4];  // 4x4 bytes (16)\r\n    private fixed int _strides[4];  // 4x4 bytes (16)\r\n}\r\n```\r\n\r\n----------------------\r\n\r\nIt\u0027s worth noting that any of the approaches that involve tracking inline data to avoid allocations will push `TensorSpan\u003cT\u003e` over the FDG recommended maximum 24 byte threshold for struct types. This is expected since we\u0027re in a somewhat specialized domain where we are intentionally avoiding allocations for common scenarios. However, it will entail us passing these types via `in` to avoid implicit copy overhead for such large types",
                                           "updatedAt":  "2024-05-15T16:41:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc63Zw3F",
                                           "createdAt":  "2025-07-16T06:05:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "@tannergooding -- I\u0027m moving this to .NET 11, but please pull this back into .NET 10 if it was on your radar to still include.",
                                           "updatedAt":  "2025-07-16T06:05:00Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Optimize the layout of the Tensor types",
        "labels":  [
                       "area-System.Numerics.Tensors"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/103261",
        "createdAt":  "2024-06-11T01:59:02Z",
        "number":  103261,
        "author":  "v-wenyuxu",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-20T03:23:20Z",
        "body":  "**Failed in:** [runtime-coreclr libraries-jitstress2-jitstressregs 20240608.1](https://dev.azure.com/dnceng-public/public/_build/results?buildId=701354\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=17454672\u0026resultId=170680\u0026paneView=debug)\r\n\r\n**Failed tests:**\r\n```\r\nnet9.0-linux-Release-x64-jitstress2_jitstressregs0x1000-Ubuntu.2204.Amd64.Open\r\n    - System.Numerics.Tensors.Tests.Int16GenericTensorPrimitives.Abs_AllLengths\r\n    - System.Numerics.Tensors.Tests.Int16GenericTensorPrimitives.Abs_InPlace\r\n```\r\n\r\n**Error message:**\r\n```\r\n Assert.All() Failure: 16 out of 257 items in the collection did not pass.\r\n[17]: Item:  17\r\n      Error: Negating the minimum value of a twos complement number is invalid.\r\n[18]: Item:  18\r\n      Error: Negating the minimum value of a twos complement number is invalid.\r\n[19]: Item:  19\r\n      Error: Negating the minimum value of a twos complement number is invalid.\r\n[20]: Item:  20\r\n      Error: Negating the minimum value of a twos complement number is invalid.\r\n[21]: Item:  21\r\n      Error: Negating the minimum value of a twos complement number is invalid.\r\n[22]: Item:  22\r\n      Error: Negating the minimum value of a twos complement number is invalid.\r\n[23]: Item:  23\r\n      Error: Negating the minimum value of a twos complement number is invalid.\r\n[24]: Item:  24\r\n      Error: Negating the minimum value of a twos complement number is invalid.\r\n[25]: Item:  25\r\n      Error: Negating the minimum value of a twos complement number is invalid.\r\n[26]: Item:  26\r\n      Error: Negating the minimum value of a twos complement number is invalid.\r\n[27]: Item:  27\r\n      Error: Negating the minimum value of a twos complement number is invalid.\r\n[28]: Item:  28\r\n      Error: Negating the minimum value of a twos complement number is invalid.\r\n[29]: Item:  29\r\n      Error: Negating the minimum value of a twos complement number is invalid.\r\n[30]: Item:  30\r\n      Error: Negating the minimum value of a twos complement number is invalid.\r\n[31]: Item:  31\r\n      Error: Negating the minimum value of a twos complement number is invalid.\r\n[32]: Item:  32\r\n      Error: Negating the minimum value of a twos complement number is invalid.\r\n```\r\n\r\n**Stack trace:**\r\n```\r\n   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)\r\n   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr) in /_/src/libraries/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.cs:line 57\r\n```\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOgxAbMg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6A0BXj",
                                           "createdAt":  "2024-06-11T16:02:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-numerics-tensors\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-06-11T16:02:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6DEBsy",
                                           "createdAt":  "2024-07-01T01:27:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "v-wenyuxu",
                                           "body":  "**Failed in:** [runtime-coreclr libraries-jitstress2-jitstressregs 20240629.1](https://dev.azure.com/dnceng-public/public/_build/results?buildId=724858\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=18197646\u0026resultId=176314\u0026paneView=debug)\r\n\r\n**Failed tests:**\r\n```\r\nnet9.0-windows-Release-x86-jitstress2_jitstressregs0x80-Windows.10.Amd64.Open\r\n    - System.Numerics.Tensors.Tests.Int64GenericTensorPrimitives.SumOfMagnitudes_AllLengths\r\n```\r\n\r\n**Error message:**\r\n```\r\n Assert.All() Failure: 19 out of 256 items in the collection did not pass.\r\n[120]: Item:  121\r\n       Error: Negating the minimum value of a twos complement number is invalid.\r\n[121]: Item:  122\r\n       Error: Negating the minimum value of a twos complement number is invalid.\r\n[122]: Item:  123\r\n       Error: Negating the minimum value of a twos complement number is invalid.\r\n[123]: Item:  124\r\n       Error: Negating the minimum value of a twos complement number is invalid.\r\n[125]: Item:  126\r\n       Error: Negating the minimum value of a twos complement number is invalid.\r\n[126]: Item:  127\r\n       Error: Negating the minimum value of a twos complement number is invalid.\r\n[184]: Item:  185\r\n       Error: Negating the minimum value of a twos complement number is invalid.\r\n[186]: Item:  187\r\n       Error: Negating the minimum value of a twos complement number is invalid.\r\n[187]: Item:  188\r\n       Error: Negating the minimum value of a twos complement number is invalid.\r\n[188]: Item:  189\r\n       Error: Negating the minimum value of a twos complement number is invalid.\r\n[189]: Item:  190\r\n       Error: Negating the minimum value of a twos complement number is invalid.\r\n[190]: Item:  191\r\n       Error: Negating the minimum value of a twos complement number is invalid.\r\n[248]: Item:  249\r\n       Error: Negating the minimum value of a twos complement number is invalid.\r\n[249]: Item:  250\r\n       Error: Negating the minimum value of a twos complement number is invalid.\r\n[250]: Item:  251\r\n       Error: Negating the minimum value of a twos complement number is invalid.\r\n[251]: Item:  252\r\n       Error: Negating the minimum value of a twos complement number is invalid.\r\n[252]: Item:  253\r\n       Error: Negating the minimum value of a twos complement number is invalid.\r\n[253]: Item:  254\r\n       Error: Negating the minimum value of a twos complement number is invalid.\r\n[254]: Item:  255\r\n       Error: Negating the minimum value of a twos complement number is invalid.\r\n```\r\n\r\n**Stack trace:**\r\n```\r\n   at System.Numerics.Tensors.Tests.TensorPrimitivesTests`1.SumOfMagnitudes_AllLengths() in /_/src/libraries/System.Numerics.Tensors/tests/TensorPrimitivesTests.cs:line 3170\r\n   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)\r\n   at System.Reflection.MethodBaseInvoker.InterpretedInvoke_Method(Object obj, IntPtr* args) in /_/src/coreclr/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.CoreCLR.cs:line 36\r\n   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr) in /_/src/libraries/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.cs:line 57\r\n```",
                                           "updatedAt":  "2024-07-01T01:27:36Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Test failure: System.Numerics.Tensors.Tests.Int16GenericTensorPrimitives.Abs_AllLengths",
        "labels":  [
                       "area-System.Numerics.Tensors",
                       "os-linux",
                       "JitStress",
                       "arch-x64",
                       "blocking-clean-ci-optional"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/103756",
        "createdAt":  "2024-06-20T11:14:10Z",
        "number":  103756,
        "author":  "vpenades",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-20T03:43:10Z",
        "body":  "### Background and motivation\r\n\r\nWorking with images and tensors, it is fairly common to convert an array of bytes to an array of floats.\r\n\r\nAlso, in many cases the conversion requires some normalization or scaling, that is, byte values in the range of 0-255 are converted to float values in the range of 0-1\r\n\r\nThe usual operation is this:\r\n\r\n```c#\r\nvar src = new byte[100];\r\nvar dst = new float[100];\r\n\r\nfor(int i=0; i \u003c dst.Length; ++i)\r\n{\r\n   dst[i] = (float)src[i] / 255f;\r\n}\r\n```\r\n\r\nNow, I don\u0027t know if there\u0027s faster way of doing this using SIMD, or any other exotic, platform specific mechanism, but if it doesn\u0027t exist now, it may exist in the future, so by using a system function, any current application may benefit from future improvements on the API.\r\n\r\nAlso, I don\u0027t know if this conversion already exists somewhere else in the APIs, I\u0027ve looked for it without success. But certainly, I would expect such conversions to be available in TensorPrimitives.\r\n\r\nMy needs are limited to byte-float conversions, but certainly, other types may be included.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\n\r\nstatic class TensorPrimitives\r\n{\r\n   public static void ConvertToSingle(ReadOnlySpan\u003cbyte\u003e src, Span\u003cfloat\u003e dst);\r\n   public static void ConvertToScaledSingle(ReadOnlySpan\u003cbyte\u003e src, Span\u003cfloat\u003e dst);\r\n\r\n   public static void ConvertToByte(ReadOnlySpan\u003cfloat\u003e src, Span\u003cbyte\u003e dst);\r\n   public static void ConvertScaledToByte(ReadOnlySpan\u003cfloat\u003e src, Span\u003cbyte\u003e dst);\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\nnamespace System.Numerics.Tensors\r\n\r\nvar bytes = byte[100];\r\nvar floats = float[199];\r\n\r\nTensorPrimitives.ConvertToSingle(bytes,floats); // converts bytes to floats in the range 0-255\r\nTensorPrimitives.ConvertToScaledSingle(bytes,floats); // converts bytes to floats in the range 0-1\r\n\r\nTensorPrimitives.ConvertToByte(floats, bytes); // converts floats in the range 0-255 to bytes in the range 0-255\r\nTensorPrimitives.ConvertScaledToByte(floats,bytes); // converts floats in the range 0-1 to bytes in the range 0-255\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOgh2log==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6B97IV",
                                           "createdAt":  "2024-06-20T11:57:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-numerics-tensors\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-06-20T11:57:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6B-4_w",
                                           "createdAt":  "2024-06-20T13:45:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODumaIQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "vpenades",
                                                                               "createdAt":  "2024-06-20T13:46:26Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2024-06-20T20:30:10Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "SommerEngineering",
                                                                               "createdAt":  "2024-06-21T06:01:15Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "MitchRazga",
                                                                               "createdAt":  "2024-08-17T15:26:34Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Converting between two different types is supported via the generic TensorPrimitives.ConvertTruncating, ConvertSaturating, and ConvertChecked methods. There\u0027s no built-in operation that currently combines that with the divide, but it can be done with a second call:\n```\nReadOnlySpan\u003cbyte\u003e bytes = RandomNumberGenerator.GetBytes(100);\nSpan\u003cfloat\u003e floats = new float[bytes.Length];\n\nTensorPrimitives.ConvertTruncating(bytes, floats);\nTensorPrimitives.Divide(floats, 255.0f, floats);\n```",
                                           "updatedAt":  "2024-06-20T13:45:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6B_Pnn",
                                           "createdAt":  "2024-06-20T14:22:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vpenades",
                                           "body":  "No wonder I could not find these methods.... they\u0027re in the Net9 preview packages, is that right?\r\n\r\nAnyway, given it\u0027s in preview, I would still include a byte to float conversion with divide:  it\u0027s such a common operation that any future improvement would automatically be used by everybody, that is, imagine that some platform introduces a fast path for this exact operation...",
                                           "updatedAt":  "2024-06-20T14:23:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6B_QUp",
                                           "createdAt":  "2024-06-20T14:23:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e they\u0027re in the Net9 preview packages, is that right?\n\nYes",
                                           "updatedAt":  "2024-06-20T14:23:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6CEIiM",
                                           "createdAt":  "2024-06-21T06:53:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vpenades",
                                           "body":  "Looking at the code, I don\u0027t see that ConvertTruncating has any kind of vectorial acceleration code to convert byte to float. Right now, is there an advantage of using ConvertTruncating, over a plain loop?",
                                           "updatedAt":  "2024-06-21T06:54:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6CHaWi",
                                           "createdAt":  "2024-06-21T15:34:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Looking at the code, I don\u0027t see that ConvertTruncating has any kind of vectorial acceleration code to convert byte to float. Right now, is there an advantage of using ConvertTruncating, over a plain loop?\n\nNot in what\u0027s merged, but that\u0027s just a matter of adding an additional path for these types, e.g.\nhttps://github.com/dotnet/runtime/pull/103820",
                                           "updatedAt":  "2024-06-21T15:34:51Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "[API Proposal]: TensorPrimitives: convert Span\u003cByte\u003e to Span\u003cFloat\u003e and back",
        "labels":  [
                       "api-suggestion",
                       "area-System.Numerics.Tensors"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/105204",
        "createdAt":  "2024-07-21T17:04:30Z",
        "number":  105204,
        "author":  "huoyaoyuan",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC5qSqA==",
                          "nodes":  [
                                        {
                                            "content":  "EYES",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2024-07-24T16:16:13Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2024-07-24T16:16:19Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2025-07-16T06:39:58Z",
        "body":  "`TensorPrimitive` by default delegates simple operators to vector intrinsics. This is fine for most operations, but IDIV is an exception.\r\n\r\nFirst, most (if not all) ISAs lack support for IDIV in vector. I\u0027ve checked AVX512/Avx2 and Sve/AdvSimd but don\u0027t find it. Thus our intrinsic vector will use software simulation. On my CPU with AVX2, it\u0027s about **2.5x slower** comparing to naive for-loop on `int[1024] / int(scalar)`.\r\n\r\nWhen dividing with a common divisor, there is also the widely-used preinv algorithm to turn the division into cheaper multiplication, which is supported for vectorization on various ISAs.\r\n\r\nI\u0027m not sure if integer division is popular enough for this optimization. But we should at least disable `DivideOperator.Vectorizable` for integer types, because it ends up uses software simulation.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOt2jJow==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6FndhX",
                                           "createdAt":  "2024-07-21T17:04:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-numerics-tensors\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-07-21T17:04:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ILMVC",
                                           "createdAt":  "2024-08-12T18:14:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "@michaelgsharp / @tannergooding -- Can the two of you chat about this please and decide:\n1. Do we want to tackle this in .NET 9 since it\u0027s in `TensorPrimitives` and not `Tensor\u003cT\u003e`?\n2. Which of you can take the assignment?\n",
                                           "updatedAt":  "2024-08-12T18:14:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ILPw1",
                                           "createdAt":  "2024-08-12T18:22:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "This is optimization, not correctness, and is a fairly involved change (especially with relevant perf testing).\r\n\r\nGiven that `TensorPrimitives` is stable since .NET 8, I\u0027d leave this as is and optimize it for .NET 10 instead.\r\n\r\n",
                                           "updatedAt":  "2024-08-12T18:22:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ILT4z",
                                           "createdAt":  "2024-08-12T18:33:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "michaelgsharp",
                                           "body":  "I agree with Tanner that we should push _the majority_ of this back to .NET 10. Its trivial to disable the vectorization for int cases, and that will give us a few wins, so we should do that part in .NET 9. That will still leave many cases running un-optimally, and those we should tackle in .NET 10.",
                                           "updatedAt":  "2024-08-12T18:33:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ILUkl",
                                           "createdAt":  "2024-08-12T18:35:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "Moving to 10, have put up #106288 to avoid vectorization for types that aren\u0027t float or double. Called out cases where a manual `for` loop is likely to remain faster until .NET 10 as well (particularly for when the divisor is a constant).",
                                           "updatedAt":  "2024-08-12T18:35:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc63aGEV",
                                           "createdAt":  "2025-07-16T06:31:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "@tannergooding I\u0027m moving this to .NET 11, but if this has already been covered in the .NET 10 work, please pull it back in and close it. Thanks.",
                                           "updatedAt":  "2025-07-16T06:31:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc63aMmj",
                                           "createdAt":  "2025-07-16T06:39:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "#111505 covers improvement of this, but only for int32. The topic is also a bit different. This issue mentions vector/scalar but #111505 covers vector/vector.",
                                           "updatedAt":  "2025-07-16T06:39:58Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "TensorPrimitive: Consider to optimize integer divisions",
        "labels":  [
                       "area-System.Numerics.Tensors"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/107566",
        "createdAt":  "2024-09-09T19:17:57Z",
        "number":  107566,
        "author":  "michaelgsharp",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-16T06:37:05Z",
        "body":  "Based on the discussion in https://github.com/dotnet/runtime/pull/107266, we need to decide if we want TensorSpan/ReadOnlyTensorSpan to have a `System.Array` constructor or if we want it to be some type of `Create` method instead due to the potential pitfalls of inherent array typing.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOt2ijfQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6LaLni",
                                           "createdAt":  "2024-09-09T19:18:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-numerics-tensors\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-09-09T19:18:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc63aKN9",
                                           "createdAt":  "2025-07-16T06:37:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "@tannergooding I\u0027m moving this to .NET 11, but if it\u0027s already been addressed by chance, please pull back into .NET 10 and close it.",
                                           "updatedAt":  "2025-07-16T06:37:01Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "TensorSpan System.Array constructor",
        "labels":  [
                       "area-System.Numerics.Tensors"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/107934",
        "createdAt":  "2024-09-17T17:35:43Z",
        "number":  107934,
        "author":  "stephentoub",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-20T22:46:54Z",
        "body":  "The System.Numerics.Tensors test suite has a Helpers.IsEqualWithTolerance helper method. This is letting through as equal some values which should not be considered equal, in particular when one of the values is infinity or negative infinity. This is one of the reasons we didn\u0027t notice the bug cited by https://github.com/dotnet/runtime/issues/107838, because a value close to 0 and negative infinity were being considered equal. But when updating that helper to accomodate, other existing tests started failing. It\u0027s possible those are false positives, but it\u0027s also possible we have further edge case bugs to be fixed. We need to investigate.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOuHeB1w==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6Mdcyh",
                                           "createdAt":  "2024-09-17T17:36:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODykO8w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jeffhandley",
                                                                               "createdAt":  "2024-09-17T18:33:56Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "@jeffhandley, this is what I was referring to earlier today offline.",
                                           "updatedAt":  "2024-09-17T17:36:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Mdc0H",
                                           "createdAt":  "2024-09-17T17:36:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-numerics-tensors\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-09-17T17:36:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Md16l",
                                           "createdAt":  "2024-09-17T18:35:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "Thanks, @stephentoub. We should investigate this during the .NET 9 GA milestone and verify correctness of test cases that were slipping through coverage before.",
                                           "updatedAt":  "2024-09-17T18:35:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6NLeN0",
                                           "createdAt":  "2024-09-23T15:11:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "A valid implementation would be https://github.com/dotnet/runtime/blob/main/src/libraries/Common/tests/TestUtilities/System/AssertExtensions.cs#L818-L1037\r\n\r\nThis ensures that values such as `inf` and `nan` are checked exactly, while finite values are within an expected variance amount. It does so in a way that minimizes additional error and which can account for per input result differences.",
                                           "updatedAt":  "2024-09-23T15:11:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6O-w9I",
                                           "createdAt":  "2024-10-08T04:39:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "@tannergooding -- I\u0027m punting this to 10.0.0. When we address it, if we find there were lurking correctness bugs, we can consider backporting the fixes to .NET 9 in servicing.",
                                           "updatedAt":  "2024-10-08T04:39:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc64d4HX",
                                           "createdAt":  "2025-07-20T22:46:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "@tannergooding I\u0027m moving this out to 11.0.0 since it hasn\u0027t been blocking. Please pull back into 10.0.0 if it gets addressed before GA.",
                                           "updatedAt":  "2025-07-20T22:46:44Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "Investigate Tensor\u0027s Helpers.IsEqualWithTolerance helper",
        "labels":  [
                       "area-System.Numerics.Tensors",
                       "test-bug"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/111141",
        "createdAt":  "2025-01-07T02:06:18Z",
        "number":  111141,
        "author":  "dellamonica",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-14T20:34:50Z",
        "body":  "### Background and motivation\n\nA common operation initializes a Span/Array with sequential values, e.g. `arr[i] == i`.\nThis is something that can be easily vectorized and seems useful even if perf is not critical for the consumer (e.g. it will be a correct implementation of something trivial, but even trivial code sometimes has bugs).\n\n### API Proposal\n\n```csharp\n\npublic static void Sequential(Span\u003cint\u003e x, int startValue = 0);\n\n```\n\n\n### API Usage\n\n```csharp\n\nvar indices = new int[data.Length]\nvar values = data.Select(x =\u003e x.SortKey).ToArray();\nTensorPrimitives.Sequential(indices, 0);\nMemoryExtensions.Sort(values, indices);\nConsole.WriteLine($\"The first sorted entry has index {indices[0]}\");\n\n```\n\n\n### Alternative Designs\n\n`Enumerable.Range()` already exists, but it is not very performant/can\u0027t work with an already allocated array or span\n\nThe method itself could be called `Range` instead of `Sequential`.\n\n### Risks\n\nAnyone can write a for loop to initialize these spans/arrays or use `Enumerable.Range(...).ToArray()`. The vectorization gain might be small depending on the context (e.g, sorting in the example above would most likely take a lot more time than what you save on the initialization.  ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOtwoubg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6ZcDSX",
                                           "createdAt":  "2025-01-07T02:22:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Enumerable.Range() already exists, but it is not very performant\n\u003e The vectorization gain might be small depending on the context\n\nNote that Enumerable.Range is already vectorized; if you do Enumerable.Range.ToArray(...), internally it does the operation you\u0027re asking for, just allocating the int[] first. Same goes for Enumerable.Range.ToList(...). And if you do `someList.AddRange(Enumerable.Range(...))`, it\u0027ll similarly write the sequence directly into the List. You pay for the small enumerable allocation, but other than that it\u0027s an efficient operation.\n\nSo in your example, instead of:\n```C#\nvar indices = new int[data.Length]\nTensorPrimitives.Sequential(indices, 0);\n```\nif you do:\n```C#\nvar indices = Enumerable.Range(0, data.Length).ToArray();\n```\nother than the few additional allocated bytes for the range iterator, it\u0027d be effectively the same thing.",
                                           "updatedAt":  "2025-01-07T02:24:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ZcFgc",
                                           "createdAt":  "2025-01-07T02:32:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dellamonica",
                                           "body":  "\u003e \u003e Enumerable.Range() already exists, but it is not very performant\n\u003e \u003e The vectorization gain might be small depending on the context\n\u003e \n\u003e Note that Enumerable.Range is already vectorized; if you do Enumerable.Range.ToArray(...), internally it does the operation you\u0027re asking for, just allocating the int[] first. Same goes for Enumerable.Range.ToList(...). And if you do `someList.AddRange(Enumerable.Range(...))`, it\u0027ll similarly write the sequence directly into the List. You pay for the small enumerable allocation, but other than that it\u0027s an efficient operation.\n\nThanks for the information. It is nice to know that it is vectorized already, but it is not flexible enough to use with Spans, unfortunately, which is the nice feature of this API proposal.\n\nBTW, this means that one could probably just make https://github.com/dotnet/runtime/blob/c5df73f30cb55ab9b0281cb915d6f51d8580a67f/src/libraries/System.Linq/src/System/Linq/Range.cs#L79 the implementation of this proposed API.\n\n\u003e \n\u003e So in your example, instead of:\n\u003e \n\u003e var indices = new int[data.Length]\n\u003e TensorPrimitives.Sequential(indices, 0);\n\u003e if you do:\n\u003e \n\u003e var indices = Enumerable.Range(0, data.Length).ToArray();\n\u003e other than the few additional allocated bytes for the range iterator, it\u0027d be effectively the same thing.\n\nI tried to keep the example simple enough, but in practice I would apply the API to a Span (e.g. something I get by slicing a pooled array, OR maybe something stackalloc\u0027ed which is not very large, in which case the convenience factor is more relevant than perf).\n",
                                           "updatedAt":  "2025-01-07T02:37:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ZfNNp",
                                           "createdAt":  "2025-01-07T11:51:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "alrz",
                                           "body":  "Is there a scalar variation of this API? e.g \"AllEqualTo\"",
                                           "updatedAt":  "2025-01-07T11:51:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ZgAWF",
                                           "createdAt":  "2025-01-07T13:31:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dellamonica",
                                           "body":  "\u003e Is there a scalar variation of this API? e.g \"AllEqualTo\"\n\nThere is `Span.Fill`, is that what you are asking?",
                                           "updatedAt":  "2025-01-07T13:31:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ZhBIg",
                                           "createdAt":  "2025-01-07T15:24:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "\u003e other than the few additional allocated bytes for the range iterator, it\u0027d be effectively the same thing.\n\nMight still be nice to expose it here though to be able to fill the data into an already existing buffer.",
                                           "updatedAt":  "2025-01-07T15:24:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ZhN1x",
                                           "createdAt":  "2025-01-07T15:46:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "alrz",
                                           "body":  "\u003e \u003e Is there a scalar variation of this API? e.g \"AllEqualTo\"\n\u003e \n\u003e There is `Span.Fill`, is that what you are asking?\n\nSorry I\u0027ve mistaken this with sequence equals. Probably not the best name but I mean `bool AllEqualTo(ROSpan\u003cT\u003e,T)`",
                                           "updatedAt":  "2025-01-07T15:46:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ZhT-2",
                                           "createdAt":  "2025-01-07T15:56:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEBXBqQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "alrz",
                                                                               "createdAt":  "2025-01-07T16:00:07Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Probably not the best name but I mean bool AllEqualTo(ROSpan\u003cT\u003e,T)\n\nThat exists as MemoryExtensions.ContainsAnyExcept (AllEqualTo == !ContainsAnyExcept)",
                                           "updatedAt":  "2025-01-07T15:56:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6apFBA",
                                           "createdAt":  "2025-01-16T04:34:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "Assigned to @tannergooding to finish triage on this.",
                                           "updatedAt":  "2025-01-16T04:34:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc63CEga",
                                           "createdAt":  "2025-07-14T19:52:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "I could see this being useful as a `Fill` or `Create` API, much as we have `Vector128.CreateSequence`\n\nThe proposed API likely needs work and should be updated to consider the existing `Enumerable.Range`, `Enumerable.Sequence`, and `Vector128.CreateSequence` API shapes.",
                                           "updatedAt":  "2025-07-14T19:52:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc63Ci5u",
                                           "createdAt":  "2025-07-14T20:34:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dellamonica",
                                           "body":  "\u003e I could see this being useful as a `Fill` or `Create` API, much as we have `Vector128.CreateSequence`\n\u003e \n\u003e The proposed API likely needs work and should be updated to consider the existing `Enumerable.Range`, `Enumerable.Sequence`, and `Vector128.CreateSequence` API shapes.\n\nFeel free to suggest changes to the name of the method. I think the arguments are just the Span and the start value (with default value 0).",
                                           "updatedAt":  "2025-07-14T20:34:36Z"
                                       }
                                   ],
                         "totalCount":  10
                     },
        "title":  "[API Proposal]: TensorPrimitives.Sequential",
        "labels":  [
                       "api-suggestion",
                       "area-System.Numerics.Tensors",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/112784",
        "createdAt":  "2025-02-21T13:33:03Z",
        "number":  112784,
        "author":  "KungFuryKeyboard",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-26T09:22:10Z",
        "body":  "### Background and motivation\n\nWith the new Tensor api we now have \n\n[HammingBitDistance](https://learn.microsoft.com/en-us/dotnet/api/system.numerics.tensors.tensorprimitives.hammingbitdistance?view=net-9.0-pp#system-numerics-tensors-tensorprimitives-hammingbitdistance-1(system-readonlyspan((-0))-system-readonlyspan((-0))))\n\n[HammingDistance\u003cT\u003e(ReadOnlySpan\u003cT\u003e, ReadOnlySpan\u003cT\u003e)](https://learn.microsoft.com/en-us/dotnet/api/system.numerics.tensors.tensorprimitives.hammingdistance?view=net-9.0-pp#system-numerics-tensors-tensorprimitives-hammingdistance-1(system-readonlyspan((-0))-system-readonlyspan((-0))))\n\n\nThis solves distance between 2 equal-length tensors of values. \n\n\nHowever what about unequal lengths ? \n\nOther languages which i don\u0027t want to write in implement such as rust implement \u0027Edit Distance\u0027 using [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\n\nWould it be possible to implement edit distance into the TensorPimatives api ?  to support calculating edit distance in .net with unequal length strings or whatever \u003ct\u003e  ? \n\nI work at a large financial institution, these methods are required for a lot of things.\nwe are primarily a dotnet shop.\n\n\nfor reference https://docs.rs/edit-distance/latest/edit_distance/\n\n\n\n\n### API Proposal\n\n```csharp\nnamespace System.Numerics.Tensor;\n\n\nEnum DistanceAlgorithm {\n  Levenshtein,\n  DamerauLevenshtein,\n // ETC\n}\n\nPublic static class TensorPrimitives {\n\n    public static int EditDistance\u003cT\u003e(DistanceAlgorithm , ReadOnlySpan\u003cT\u003e x, ReadOnlySpan\u003cT\u003e y);\n}\n```\n\n\n### API Usage\n\n```csharp\n\nusing System.Numerics.Tensor;\n\nvar  result = TensorPrimitives.EditDistance(DistanceAlgorithm.Levenshtein, SomeStringSpanA,SomeStringSpanb)\n\n```\n```\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOn43neA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6fayDP",
                                           "createdAt":  "2025-02-21T13:47:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-numerics-tensors\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-02-21T13:47:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6fa2pp",
                                           "createdAt":  "2025-02-21T13:55:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "`TensorPrimitive` is not the correct place for Levenshtein Distance. It requires different element of the input to be processed equally, which isn\u0027t applicable to Levenshtein Distance. It doesn\u0027t aim to provide edit distance either. Hamming Distance is there because its algorithm meets the requirement, and is low-level enough.",
                                           "updatedAt":  "2025-02-21T13:55:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6fjed4",
                                           "createdAt":  "2025-02-23T13:59:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEHTO2Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "KungFuryKeyboard",
                                                                               "createdAt":  "2025-02-23T16:07:34Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e It requires different element of the input to be processed equally\n\nWhile that\u0027s true for most if not all of what we\u0027ve added thus far, I\u0027m not sure it\u0027s a requirement. I agree having one or more edit distance metrics somewhere would be valuable, and I\u0027m not sure we have a better place than TP.",
                                           "updatedAt":  "2025-02-23T13:59:49Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "[API Proposal]: Add EditDistance (Levenshtein) to  TensorPrimitives for unEqual length \u003cT\u003e comparision.",
        "labels":  [
                       "api-suggestion",
                       "area-System.Numerics.Tensors"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/114089",
        "createdAt":  "2025-03-31T22:52:21Z",
        "number":  114089,
        "author":  "michaelgsharp",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODAt6CA==",
                          "nodes":  [
                                        {
                                            "content":  "HEART",
                                            "user":  "asmirnov82",
                                            "createdAt":  "2025-04-01T11:48:09Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-07-23T09:00:18Z",
        "body":  "### Background and motivation\n\nCurrently we have `Tensor\u003cT\u003e` which is backed by managed memory. This gives us all the goodness we get from managed memory and will satisfy most of our needs. There will be times, however, that we need a tensor type that is backed by native memory. This can occur if we need to store more data than we can in our managed array, if we need to point to native memory that already exists, or if we are creating a tensor around tensor\u0027s from other frameworks.\n\n### API Proposal\n\n```csharp\npublic static partial class NativeTensor\n{\n        // Allocate native memory based on the specified lengths and fill it with a Gaussian normal distribution.\n        // The tensor will own the underlying memory, so it will be responsible for freeing it. \n        public static System.Numerics.Tensors.NativeTensor\u003cT\u003e AllocateAndFillGaussianNormalDistribution\u003cT\u003e(System.Random random, params scoped System.ReadOnlySpan\u003cnint\u003e lengths) where T : System.Numerics.IFloatingPoint\u003cT\u003e;\n        public static System.Numerics.Tensors.NativeTensor\u003cT\u003e AllocateAndFillGaussianNormalDistribution\u003cT\u003e(params scoped System.ReadOnlySpan\u003cnint\u003e lengths) where T : System.Numerics.IFloatingPoint\u003cT\u003e;\n\n        // Allocate native memory based on the specified lengths and fill it with a uniform distribution.\n        // The tensor will own the underlying memory, so it will be responsible for freeing it. \n        public static System.Numerics.Tensors.NativeTensor\u003cT\u003e AllocateAndFillUniformDistribution\u003cT\u003e(System.Random random, params scoped System.ReadOnlySpan\u003cnint\u003e lengths) where T : System.Numerics.IFloatingPoint\u003cT\u003e;\n        public static System.Numerics.Tensors.NativeTensor\u003cT\u003e AllocateAndFillUniformDistribution\u003cT\u003e(params scoped System.ReadOnlySpan\u003cnint\u003e lengths) where T : System.Numerics.IFloatingPoint\u003cT\u003e;\n\n        // Allocate native memory based on the specified lengths. does nothing to fill the memory.\n        // The tensor will own the underlying memory, so it will be responsible for freeing it. \n        public static System.Numerics.Tensors.NativeTensor\u003cT\u003e AllocateUninitialized\u003cT\u003e(scoped System.ReadOnlySpan\u003cnint\u003e lengths);\n        public static System.Numerics.Tensors.NativeTensor\u003cT\u003e AllocateUninitialized\u003cT\u003e(scoped System.ReadOnlySpan\u003cnint\u003e lengths, scoped System.ReadOnlySpan\u003cnint\u003e strides);\n\n        // Do we want to keep the IEnumerable\u003cT\u003e here? It would copy the data over to the native tensor and essentially allow you to initialize a native tensor with an array of values.\n        // The tensor will own the underlying memory, so it will be responsible for freeing it. \n        public static System.Numerics.Tensors.NativeTensor\u003cT\u003e Allocate\u003cT\u003e(System.Collections.Generic.IEnumerable\u003cT\u003e values, scoped System.ReadOnlySpan\u003cnint\u003e lengths);\n        public static System.Numerics.Tensors.NativeTensor\u003cT\u003e Allocate\u003cT\u003e(System.Collections.Generic.IEnumerable\u003cT\u003e values, scoped System.ReadOnlySpan\u003cnint\u003e lengths, scoped System.ReadOnlySpan\u003cnint\u003e strides);\n\n        // Allocate native memory based on the specified lengths. 0 filled.\n        // The tensor will own the underlying memory, so it will be responsible for freeing it. \n        public static System.Numerics.Tensors.NativeTensor\u003cT\u003e Allocate\u003cT\u003e(scoped System.ReadOnlySpan\u003cnint\u003e lengths);\n        public static System.Numerics.Tensors.NativeTensor\u003cT\u003e Allocate\u003cT\u003e(scoped System.ReadOnlySpan\u003cnint\u003e lengths, scoped System.ReadOnlySpan\u003cnint\u003e strides);\n\n        // Do we want to keep the T[] here? It would copy the data over to the native tensor and essentially allow you to initialize a native tensor with an array of values.\n        // The tensor will own the underlying memory, so it will be responsible for freeing it. \n        public static System.Numerics.Tensors.NativeTensor\u003cT\u003e Allocate\u003cT\u003e(T[] values, scoped System.ReadOnlySpan\u003cnint\u003e lengths);\n        public static System.Numerics.Tensors.NativeTensor\u003cT\u003e Allocate\u003cT\u003e(T[] values, scoped System.ReadOnlySpan\u003cnint\u003e lengths, scoped System.ReadOnlySpan\u003cnint\u003e strides);\n\n\n        // Create a native tensor using the provided T* location and fill it with a Gaussian normal distribution.\n        // The tensor won\u0027t own the underlying memory, so it won\u0027t be responsible for freeing it.\n        public static unsafe System.Numerics.Tensors.NativeTensor\u003cT\u003e CreateAndFillGaussianNormalDistribution\u003cT\u003e(System.Random random, T* data, nint dataLength, params scoped System.ReadOnlySpan\u003cnint\u003e lengths) where T : System.Numerics.IFloatingPoint\u003cT\u003e;\n        public static unsafe System.Numerics.Tensors.NativeTensor\u003cT\u003e CreateAndFillGaussianNormalDistribution\u003cT\u003e(T* data, nint dataLength, params scoped System.ReadOnlySpan\u003cnint\u003e lengths) where T : System.Numerics.IFloatingPoint\u003cT\u003e;\n\n        // Create a native tensor using the provided T* location and fill it with a uniform distribution.\n        // The tensor won\u0027t own the underlying memory, so it won\u0027t be responsible for freeing it.\n        public static unsafe System.Numerics.Tensors.NativeTensor\u003cT\u003e CreateAndFillUniformDistribution\u003cT\u003e(System.Random random, T* data, nint dataLength, params scoped System.ReadOnlySpan\u003cnint\u003e lengths) where T : System.Numerics.IFloatingPoint\u003cT\u003e;\n        public static unsafe System.Numerics.Tensors.NativeTensor\u003cT\u003e CreateAndFillUniformDistribution\u003cT\u003e(T* data, nint dataLength, params scoped System.ReadOnlySpan\u003cnint\u003e lengths) where T : System.Numerics.IFloatingPoint\u003cT\u003e;\n\n        // Create a native tensor using the provided T* location. does nothing to fill the memory.\n        // The tensor won\u0027t own the underlying memory, so it won\u0027t be responsible for freeing it.\n        public static unsafe System.Numerics.Tensors.NativeTensor\u003cT\u003e CreateUninitialized\u003cT\u003e(T* data, nint dataLength, scoped System.ReadOnlySpan\u003cnint\u003e lengths);\n        public static unsafe System.Numerics.Tensors.NativeTensor\u003cT\u003e CreateUninitialized\u003cT\u003e(T* data, nint dataLength, scoped System.ReadOnlySpan\u003cnint\u003e lengths, scoped System.ReadOnlySpan\u003cnint\u003e strides);\n\n        // Create a native tensor using the provided T* location. Do we want to keep the IEnumerable\u003cT\u003e here? It would copy the data over to the native tensor and essentially allow you to initialize a native tensor with an array of values.\n        // The tensor won\u0027t own the underlying memory, so it won\u0027t be responsible for freeing it.\n        public static unsafe System.Numerics.Tensors.NativeTensor\u003cT\u003e Create\u003cT\u003e(T* data, nint dataLength, System.Collections.Generic.IEnumerable\u003cT\u003e values, scoped System.ReadOnlySpan\u003cnint\u003e lengths);\n        public static unsafe System.Numerics.Tensors.NativeTensor\u003cT\u003e Create\u003cT\u003e(T* data, nint dataLength, System.Collections.Generic.IEnumerable\u003cT\u003e values, scoped System.ReadOnlySpan\u003cnint\u003e lengths, scoped System.ReadOnlySpan\u003cnint\u003e strides);\n\n        // Create a native tensor using the provided T* location. 0 filled.\n        // The tensor won\u0027t own the underlying memory, so it won\u0027t be responsible for freeing it.\n        public static unsafe System.Numerics.Tensors.NativeTensor\u003cT\u003e Create\u003cT\u003e(T* data, nint dataLength, scoped System.ReadOnlySpan\u003cnint\u003e lengths);\n        public static unsafe System.Numerics.Tensors.NativeTensor\u003cT\u003e Create\u003cT\u003e(T* data, nint dataLength, scoped System.ReadOnlySpan\u003cnint\u003e lengths, scoped System.ReadOnlySpan\u003cnint\u003e strides);\n\n        // Create a native tensor using the provided T* location. Do we want to keep the T[] here? It would copy the data over to the native tensor and essentially allow you to initialize a native tensor with an array of values.\n        // The tensor won\u0027t own the underlying memory, so it won\u0027t be responsible for freeing it.\n        public static unsafe System.Numerics.Tensors.NativeTensor\u003cT\u003e Create\u003cT\u003e(T* data, nint dataLength, T[] values, scoped System.ReadOnlySpan\u003cnint\u003e lengths);\n        public static unsafe System.Numerics.Tensors.NativeTensor\u003cT\u003e Create\u003cT\u003e(T* data, nint dataLength, T[] values, scoped System.ReadOnlySpan\u003cnint\u003e lengths, scoped System.ReadOnlySpan\u003cnint\u003e strides);\n}\n\n\npublic sealed class NativeTensor\u003cT\u003e : System.Collections.Generic.IEnumerable\u003cT\u003e, System.Numerics.Tensors.IReadOnlyTensor\u003cSystem.Numerics.Tensors.NativeTensor\u003cT\u003e, T\u003e, System.Numerics.Tensors.ITensor\u003cSystem.Numerics.Tensors.NativeTensor\u003cT\u003e, T\u003e, IDisposable\n{\n        internal NativeTensor() { }\n        // THis would let us create a NativeTensor from a parent NativeTensor so that we can share the underlying memory, but still have lifetimes tracked correctly.\n        internal NativeTensor(NativeTensor\u003cT\u003e parent, nint start, scoped System.ReadOnlySpan\u003cnint\u003e lengths, scoped System.ReadOnlySpan\u003cnint\u003e strides) { }\n\n        // Everything below is exactly the same as the normal Tensor\u003cT\u003e \n        public static System.Numerics.Tensors.NativeTensor\u003cT\u003e Empty { get; }\n        public nint FlattenedLength { get; }\n        public bool IsEmpty { get; }\n        public bool IsPinned { get; }\n        public System.Numerics.Tensors.NativeTensor\u003cT\u003e this[System.Numerics.Tensors.Tensor\u003cbool\u003e filter] { get; }\n        public ref T this[params scoped System.ReadOnlySpan\u003cSystem.Buffers.NIndex\u003e indexes] { get; }\n        public System.Numerics.Tensors.NativeTensor\u003cT\u003e this[params scoped System.ReadOnlySpan\u003cSystem.Buffers.NRange\u003e ranges] { get; set { } }\n        public ref T this[params scoped System.ReadOnlySpan\u003cnint\u003e indexes] { get; }\n        public System.ReadOnlySpan\u003cnint\u003e Lengths { get; }\n        public int Rank { get; }\n        public System.ReadOnlySpan\u003cnint\u003e Strides { get; }\n        object System.Numerics.Tensors.IReadOnlyTensor.this[params scoped System.ReadOnlySpan\u003cSystem.Buffers.NIndex\u003e indexes] { get; }\n        object System.Numerics.Tensors.IReadOnlyTensor.this[params scoped System.ReadOnlySpan\u003cnint\u003e indexes] { get; }\n        System.ReadOnlySpan\u003cnint\u003e System.Numerics.Tensors.IReadOnlyTensor.Lengths { get; }\n        System.ReadOnlySpan\u003cnint\u003e System.Numerics.Tensors.IReadOnlyTensor.Strides { get; }\n        T System.Numerics.Tensors.IReadOnlyTensor\u003cSystem.Numerics.Tensors.NativeTensor\u003cT\u003e, T\u003e.this[params scoped System.ReadOnlySpan\u003cSystem.Buffers.NIndex\u003e indexes] { get; }\n        System.Numerics.Tensors.NativeTensor\u003cT\u003e System.Numerics.Tensors.IReadOnlyTensor\u003cSystem.Numerics.Tensors.NativeTensor\u003cT\u003e, T\u003e.this[params scoped System.ReadOnlySpan\u003cSystem.Buffers.NRange\u003e ranges] { get; }\n        T System.Numerics.Tensors.IReadOnlyTensor\u003cSystem.Numerics.Tensors.NativeTensor\u003cT\u003e, T\u003e.this[params scoped System.ReadOnlySpan\u003cnint\u003e indexes] { get; }\n        bool System.Numerics.Tensors.ITensor.IsReadOnly { get; }\n        object System.Numerics.Tensors.ITensor.this[params scoped System.ReadOnlySpan\u003cSystem.Buffers.NIndex\u003e indexes] { get; set { } }\n        object System.Numerics.Tensors.ITensor.this[params scoped System.ReadOnlySpan\u003cnint\u003e indexes] { get; set { } }\n        T System.Numerics.Tensors.ITensor\u003cSystem.Numerics.Tensors.NativeTensor\u003cT\u003e, T\u003e.this[params scoped System.ReadOnlySpan\u003cSystem.Buffers.NIndex\u003e indexes] { get; set { } }\n        T System.Numerics.Tensors.ITensor\u003cSystem.Numerics.Tensors.NativeTensor\u003cT\u003e, T\u003e.this[params scoped System.ReadOnlySpan\u003cnint\u003e indexes] { get; set { } }\n        public System.Numerics.Tensors.ReadOnlyTensorSpan\u003cT\u003e AsReadOnlyTensorSpan();\n        public System.Numerics.Tensors.ReadOnlyTensorSpan\u003cT\u003e AsReadOnlyTensorSpan(params scoped System.ReadOnlySpan\u003cSystem.Buffers.NIndex\u003e startIndex);\n        public System.Numerics.Tensors.ReadOnlyTensorSpan\u003cT\u003e AsReadOnlyTensorSpan(params scoped System.ReadOnlySpan\u003cSystem.Buffers.NRange\u003e start);\n        public System.Numerics.Tensors.ReadOnlyTensorSpan\u003cT\u003e AsReadOnlyTensorSpan(params scoped System.ReadOnlySpan\u003cnint\u003e start);\n        public System.Numerics.Tensors.TensorSpan\u003cT\u003e AsTensorSpan();\n        public System.Numerics.Tensors.TensorSpan\u003cT\u003e AsTensorSpan(params scoped System.ReadOnlySpan\u003cSystem.Buffers.NIndex\u003e startIndex);\n        public System.Numerics.Tensors.TensorSpan\u003cT\u003e AsTensorSpan(params scoped System.ReadOnlySpan\u003cSystem.Buffers.NRange\u003e start);\n        public System.Numerics.Tensors.TensorSpan\u003cT\u003e AsTensorSpan(params scoped System.ReadOnlySpan\u003cnint\u003e start);\n        public void Clear() { }\n        public void CopyTo(scoped System.Numerics.Tensors.TensorSpan\u003cT\u003e destination) { }\n        public void Fill(object value) { }\n        public void Fill(T value) { }\n        public void FlattenTo(scoped System.Span\u003cT\u003e destination) { }\n        public System.Collections.Generic.IEnumerator\u003cT\u003e GetEnumerator();\n        public override int GetHashCode();\n        public ref T GetPinnableReference();\n        public System.Buffers.MemoryHandle GetPinnedHandle();\n        public static implicit operator System.Numerics.Tensors.ReadOnlyTensorSpan\u003cT\u003e (System.Numerics.Tensors.NativeTensor\u003cT\u003e value);\n        public static implicit operator System.Numerics.Tensors.TensorSpan\u003cT\u003e (System.Numerics.Tensors.NativeTensor\u003cT\u003e value);\n        public static implicit operator System.Numerics.Tensors.NativeTensor\u003cT\u003e (T[] array);\n        public System.Numerics.Tensors.NativeTensor\u003cT\u003e Slice(params scoped System.ReadOnlySpan\u003cSystem.Buffers.NIndex\u003e startIndex);\n        public System.Numerics.Tensors.NativeTensor\u003cT\u003e Slice(params scoped System.ReadOnlySpan\u003cSystem.Buffers.NRange\u003e start);\n        public System.Numerics.Tensors.NativeTensor\u003cT\u003e Slice(params scoped System.ReadOnlySpan\u003cnint\u003e start);\n        System.Collections.Generic.IEnumerator\u003cT\u003e System.Collections.Generic.IEnumerable\u003cT\u003e.GetEnumerator();\n        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();\n        ref readonly T System.Numerics.Tensors.IReadOnlyTensor\u003cSystem.Numerics.Tensors.NativeTensor\u003cT\u003e, T\u003e.GetPinnableReference();\n        static System.Numerics.Tensors.NativeTensor\u003cT\u003e System.Numerics.Tensors.ITensor\u003cSystem.Numerics.Tensors.NativeTensor\u003cT\u003e, T\u003e.Create(scoped System.ReadOnlySpan\u003cnint\u003e lengths, bool pinned);\n        static System.Numerics.Tensors.NativeTensor\u003cT\u003e System.Numerics.Tensors.ITensor\u003cSystem.Numerics.Tensors.NativeTensor\u003cT\u003e, T\u003e.Create(scoped System.ReadOnlySpan\u003cnint\u003e lengths, scoped System.ReadOnlySpan\u003cnint\u003e strides, bool pinned);\n        static System.Numerics.Tensors.NativeTensor\u003cT\u003e System.Numerics.Tensors.ITensor\u003cSystem.Numerics.Tensors.NativeTensor\u003cT\u003e, T\u003e.CreateUninitialized(scoped System.ReadOnlySpan\u003cnint\u003e lengths, bool pinned);\n        static System.Numerics.Tensors.NativeTensor\u003cT\u003e System.Numerics.Tensors.ITensor\u003cSystem.Numerics.Tensors.NativeTensor\u003cT\u003e, T\u003e.CreateUninitialized(scoped System.ReadOnlySpan\u003cnint\u003e lengths, scoped System.ReadOnlySpan\u003cnint\u003e strides, bool pinned);\n        public string ToString(params scoped System.ReadOnlySpan\u003cnint\u003e maximumLengths);\n        public bool TryCopyTo(scoped System.Numerics.Tensors.TensorSpan\u003cT\u003e destination);\n        public bool TryFlattenTo(scoped System.Span\u003cT\u003e destination);\n        public void Dispose();\n}\n```\n\n\n### API Usage\n\nSame as normal Tensor\u003cT\u003e.\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOuSs7lQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6k9jfk",
                                           "createdAt":  "2025-03-31T22:52:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "michaelgsharp",
                                           "body":  "@tannergooding ",
                                           "updatedAt":  "2025-03-31T22:52:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6k9ji9",
                                           "createdAt":  "2025-03-31T22:52:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-numerics\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-03-31T22:52:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6k9jpe",
                                           "createdAt":  "2025-03-31T22:53:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-numerics-tensors\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-03-31T22:53:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6lFpKH",
                                           "createdAt":  "2025-04-01T15:15:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "colejohnson66",
                                           "body":  "If the idea is that `NativeTensor\u003cT\u003e` would own native (unmanaged memory), why is it allocating it? Shouldn\u0027t it just take a `T*`? Or is your idea that `NativeTensor` would use the managed wrapper `NativeMemory.Alloc`?",
                                           "updatedAt":  "2025-04-01T15:16:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6laB7_",
                                           "createdAt":  "2025-04-03T09:28:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tjwald",
                                           "body":  "@michaelgsharp I want to be able to pool the underlying memory using the ArrayPool, but the size of the tensor varies but the arrays that are being pooled are not necessary the same size. \nWill using this NativeTensor help? How can I achieve this?",
                                           "updatedAt":  "2025-04-03T09:28:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6laEsy",
                                           "createdAt":  "2025-04-03T09:31:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tjwald",
                                           "body":  "\u003e // Do we want to keep the T[] here? It would copy the data over to the native tensor and essentially allow you to initialize a native tensor with an array of values.\n        // The tensor will own the underlying memory, so it will be responsible for freeing it. \n        public static System.Numerics.Tensors.NativeTensor\u003cT\u003e Allocate\u003cT\u003e(T[] values, scoped System.ReadOnlySpan\u003cnint\u003e lengths);\n        public static System.Numerics.Tensors.NativeTensor\u003cT\u003e Allocate\u003cT\u003e(T[] values, scoped System.ReadOnlySpan\u003cnint\u003e lengths, scoped System.ReadOnlySpan\u003cnint\u003e strides);\n\nWhy not accept `Memory\u003cT\u003e` instead of the `T[]`?",
                                           "updatedAt":  "2025-04-03T09:31:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6xiw6K",
                                           "createdAt":  "2025-06-17T01:58:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "xela-trawets",
                                           "body":  "A pattern I am familiar with is: Span, Memory and IMemoryOwner.\n\nSo wrapping a native/pinned TensorSpan with \"TensorMemory\" and \"TensorMemoryOwner\" looks like the way to go for me.  \n\nThis needs me to tag a pointer/reference with a TensorShape, and some way to alert myself to the inevitable clean-up-on-aisle-four mess when I forget to free, dispose or whatever. - Possibly by keeping a little object around and letting the GC track that as a surrogate (perhaps the TensorMemoryOwner).\n\nI only ever want value types (IBinaryNumber) in my tensors and I am happy with native or pinned memory for large tensors.\n\nWe can wrap native memory in a TensorSpan e.g. something like this:\n`                void* p = NativeMemory.Alloc((nuint)length, (nuint)sizeof(float));\n                float* pf = (float*)p;\n                tensor = new TensorSpan\u003cfloat\u003e(pf, length, [length]);`\n\n\n(While Tensor\u003cT\u003e uses nint dimensions and looks like it is most of the way to the promised land of wide open spaces, it does rely on the GC to allocate, which is limiting, (but can be worked around using jumbo elements (e.g. SIMD types) which have more numbers per element)).\n\nI explicitly dont want to mix my old array code with these tensor types because I used 32 bit ints for indexing... \n",
                                           "updatedAt":  "2025-06-17T01:58:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc65KzuV",
                                           "createdAt":  "2025-07-23T09:00:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "@tannergooding I put this in Future, but please confirm this should remain open.",
                                           "updatedAt":  "2025-07-23T09:00:18Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "[API Proposal]: NativeTensor\u003cT\u003e",
        "labels":  [
                       "api-suggestion",
                       "area-System.Numerics.Tensors"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/115201",
        "createdAt":  "2025-04-30T17:23:30Z",
        "number":  115201,
        "author":  "tjwald",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-23T07:44:26Z",
        "body":  "### Background and motivation\n\nDue to the nature of the usage of tensors they tend to be really big. \nIn addition, due to usage patterns creating copies with different operations applied to them, many of which can\u0027t be in place, applications using Tensors create many temporaries which are large.\n\nIn my [ML application](https://github.com/tjwald/high-perf-ML/tree/develop/Example/SentimentInference/Example.SentimentInference.Console), there are fixed number of threads running operations on batches of sentences, so there are a constant number of tensors active at each moment. \nI am spending ~1% of my time in the GC, mostly on the large 500KB Tensors I am tokenizing and processing.\nI have not measured the overhead of the allocations and GC pauses in my server example, but I assume it will be larger since I do not have all of the requests ahead of time and so have to create more tensors.\n\nBucketing the tensors by size and pooling instances will reduce the allocations done by the server, reduce the GC time, and increase throughput.\n\nThis is almost exactly like `ArrayPool\u003cT\u003e`, and should probably be a wrapper of it.\n\nThis is something I discussed with @tannergooding but I didn\u0027t see any API proposals.\nI will state, that like `ArrayPool\u003cT\u003e`, this pool might in some situations be overkill and cause more harm than benefit, as the GC is doing an amazing job.\n\n### API Proposal\n\n```csharp\nnamespace System.Numeric.Tensors.Buffers;\n\npublic class TensorPool\u003cTTensor, T\u003e where TTensor: ITensor\u003cTTensor, T\u003e\n{\n    public TensorPool();\n    public TensorPool(int maxFlattenedLength, int maxTensorsPerBucket);  // Configuration Params.\n\n    public TTensor Rent(scoped ReadOnlySpan\u003cnint\u003e lengths);\n    public TTensor Rent(scoped ReadOnlySpan\u003cnint\u003e lengths, scoped ReadOnlySpan\u003cnint\u003e strides);\n\n    public void Return(TTensor tensor, bool clearTensor = true);  // should it default to false? \n}\n```\n\n\n### API Usage\n\n```csharp\nint maxFlattenedLength = 1000;\nint maxTensorsPerBucket = 10;\nint exampleCount = 10000;\nvar tensorPool = new TensorPool\u003cTensor\u003cfloat\u003e, float\u003e(maxFlattenedLength, maxTensorsPerBucket);\n\nvar lengths = new nint[] { 100, 100 };\nfloat[] averages = new float[10000];\nParallel.For(0, 10000, i =\u003e\n{\n    Tensor\u003cfloat\u003e tensor1 = tensorPool.Rent(lengths);\n    Tensor\u003cfloat\u003e tensor2 = tensorPool.Rent(lengths);\n    Tensor\u003cfloat\u003e tensor3 = tensorPool.Rent(lengths);\n\n    Tensor.FillGaussianNormalDistribution(tensor1.AsTensorSpan());\n    tensor2.Fill(i * i);\n    Tensor.Add(tensor1.AsReadOnlyTensorSpan(), tensor2, tensor3);\n    Tensor.Multiply(tensor1.AsReadOnlyTensorSpan(), tensor3, tensor2);\n\n    averages[i] = Tensor.Average\u003cfloat\u003e(tensor2.AsTensorSpan());\n\n    tensorPool.Return(tensor1, clearTensor: true);\n    tensorPool.Return(tensor2, clearTensor: true);\n    tensorPool.Return(tensor3, clearTensor: true);\n});\n\nforeach (float average in averages) Console.WriteLine(average);\n```\n\n### Alternative Designs\n\n* Each consumer wanting to pool Tensors will have to write their own wrapper around ArrayPool\u003cT\u003e and deal with converting the lengths and strides to the correct size of backing array.\n* Not pooling Tensors - relying on the GC to do a good job on big chunks of memory.\n* Should the default for TensorPool be to clear the Tensor on return? Usually they are used for calculations, and so will most likely not want leftovers from the previous calculation. \n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOuSabIA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6pcOJJ",
                                           "createdAt":  "2025-04-30T17:24:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-numerics-tensors\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-04-30T17:24:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc65Jpsg",
                                           "createdAt":  "2025-07-23T07:44:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEbz5NA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "ROCKET",
                                                                               "user":  "tjwald",
                                                                               "createdAt":  "2025-07-24T16:23:09Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "Penciling this in for _consideration_ during .NET 11. /cc @tannergooding ",
                                           "updatedAt":  "2025-07-23T07:44:26Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[API Proposal]: Add TensorPool\u003cT\u003e",
        "labels":  [
                       "api-suggestion",
                       "area-System.Numerics.Tensors"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/119632",
        "createdAt":  "2025-09-12T08:48:09Z",
        "number":  119632,
        "author":  "ManickaP",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-12T12:25:07Z",
        "body":  "For example:\n```\nAssert.All() Failure: 239 out of 257 items in the collection did not pass.\n[5]:   Item:  5\nError: Assert.Equal() Failure: Values differ\nExpected: -0.38118276\nActual:   -0.38118273\n[6]:   Item:  6\nError: Assert.Equal() Failure: Values differ\nExpected: 0.5835795\nActual:   0.58357954\n[8]:   Item:  8\n...\n```\nIn https://dev.azure.com/dnceng-public/public/_build/results?buildId=1146192\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=31628618\u0026resultId=103457\u0026paneView=debug",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOw853WA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc7DzndY",
                                           "createdAt":  "2025-09-12T12:25:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-numerics-tensors\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-09-12T12:25:07Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Mutliple System.Numerics.Tensors tests failing in outerloop",
        "labels":  [
                       "area-System.Numerics.Tensors",
                       "untriaged"
                   ]
    }
]
